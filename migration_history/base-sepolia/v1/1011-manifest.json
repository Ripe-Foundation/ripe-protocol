{
  "contracts": {
    "GreenToken": {
      "address": "0xB2d9B97fd379a91f4ba4457BB2dcD162D9676576",
      "abi": [
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeInitiated",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeConfirmed",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeCancelled",
          "inputs": [
            {
              "name": "cancelledHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "InitialRipeHqSet",
          "inputs": [
            {
              "name": "hq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqChange",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewRipeHq",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHq",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_initialSupply",
              "type": "uint256"
            },
            {
              "name": "_initialSupplyRecipient",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/tokens/modules/Erc20Token.vy": {
            "content": "# @version 0.4.1\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface RipeHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintGreen(_addr: address) -> bool: view\n    def canMintRipe(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def greenToken() -> address: view\n    def governance() -> address: view\n    def ripeToken() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nstruct PendingHq:\n    newHq: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# ripe \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent HqChangeInitiated:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    confirmBlock: uint256\n\nevent HqChangeConfirmed:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqChangeCancelled:\n    cancelledHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent TokenPauseModified:\n    isPaused: bool\n\nevent InitialRipeHqSet:\n    hq: indexed(address)\n    timeLock: uint256\n\nevent HqChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\n# ripe hq\nripeHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\npendingHq: public(PendingHq)\nhqChangeTimeLock: public(uint256)\ntempGov: address\n\nMIN_HQ_TIME_LOCK: immutable(uint256)\nMAX_HQ_TIME_LOCK: immutable(uint256)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    MIN_HQ_TIME_LOCK = _minHqTimeLock\n    MAX_HQ_TIME_LOCK = _maxHqTimeLock\n\n    # set initial gov (green / ripe tokens)\n    if _initialGov != empty(address):\n        assert _ripeHq == empty(address) # dev: cannot set initial gov and ripe hq\n        self.tempGov = _initialGov\n\n    # set ripe hq\n    if _ripeHq != empty(address):\n        assert self._isValidNewRipeHq(_ripeHq, empty(address)) # dev: invalid ripe hq\n        assert _initialGov == empty(address) # dev: cannot set initial gov and ripe hq\n        self.ripeHq = _ripeHq\n\n    # initial supply\n    if _initialSupply != 0 and _initialSupplyRecipient not in [empty(address), self]:\n        self.balanceOf[_initialSupplyRecipient] = _initialSupply\n        self.totalSupply = _initialSupply\n        log Transfer(sender=empty(address), recipient=_initialSupplyRecipient, amount=_initialSupply)\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall RipeHq(self.ripeHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n###################\n# Ripe Hq Changes #\n###################\n\n\n@view\n@external\ndef hasPendingHqChange() -> bool:\n    return self.pendingHq.confirmBlock != 0\n\n\n# initiate hq change\n\n\n@external\ndef initiateHqChange(_newHq: address):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    # validate new hq\n    prevHq: address = self.ripeHq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid new hq\n\n    confirmBlock: uint256 = block.number + self.hqChangeTimeLock\n    self.pendingHq = PendingHq(\n        newHq= _newHq,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqChangeInitiated(prevHq=prevHq, newHq=_newHq, confirmBlock=confirmBlock)\n\n\n# confirm hq change\n\n\n@external\ndef confirmHqChange() -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # validate new hq one more time\n    prevHq: address = self.ripeHq\n    if not self._isValidNewRipeHq(data.newHq, prevHq):\n        self.pendingHq = empty(PendingHq)\n        return False\n\n    # set new ripe hq\n    self.ripeHq = data.newHq\n    self.pendingHq = empty(PendingHq)\n    log HqChangeConfirmed(prevHq=prevHq, newHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n    return True\n\n\n# cancel hq change\n\n\n@external\ndef cancelHqChange():\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingHq = empty(PendingHq)\n    log HqChangeCancelled(cancelledHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewRipeHq(_newHq: address) -> bool:\n    return self._isValidNewRipeHq(_newHq, self.ripeHq)\n\n\n@view\n@internal\ndef _isValidNewRipeHq(_newHq: address, _prevHq: address) -> bool:\n\n    # same hq, or invalid new hq\n    if _newHq == _prevHq or _newHq == empty(address) or not _newHq.is_contract:\n        return False\n\n    # if current hq has pending gov change, cannot change ripe hq now\n    if _prevHq != empty(address) and staticcall RipeHq(_prevHq).hasPendingGovChange():\n        return False\n\n    # if new hq has pending gov change, or is not set, cannot change ripe hq now\n    if staticcall RipeHq(_newHq).hasPendingGovChange() or staticcall RipeHq(_newHq).governance() == empty(address):\n        return False\n\n    # tokens must be set\n    if staticcall RipeHq(_newHq).greenToken() == empty(address) or staticcall RipeHq(_newHq).ripeToken() == empty(address):\n        return False\n\n    # make sure it has the necessary interfaces\n    assert not staticcall RipeHq(_newHq).canSetTokenBlacklist(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintGreen(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintRipe(empty(address)) # dev: invalid interface\n\n    return True\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    ripeHq: address = self.ripeHq\n    assert msg.sender == staticcall RipeHq(ripeHq).governance() # dev: no perms\n    assert not staticcall RipeHq(ripeHq).hasPendingGovChange() # dev: pending gov change\n    return self._setHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@internal\ndef _setHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidHqChangeTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.hqChangeTimeLock = _newTimeLock\n    log HqChangeTimeLockModified(prevTimeLock=_prevTimeLock, newTimeLock=_newTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_HQ_TIME_LOCK and _newTimeLock <= MAX_HQ_TIME_LOCK\n\n\n# views\n\n\n@view\n@external\ndef minHqTimeLock() -> uint256:\n    return MIN_HQ_TIME_LOCK\n\n\n@view\n@external\ndef maxHqTimeLock() -> uint256:\n    return MAX_HQ_TIME_LOCK\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n\n\n###############\n# Token Setup #\n###############\n\n\n@external\ndef finishTokenSetup(_newHq: address, _timeLock: uint256 = 0) -> bool:\n    assert msg.sender == self.tempGov # dev: no perms\n\n    prevHq: address = self.ripeHq\n    assert prevHq == empty(address) # dev: already set\n\n    # set hq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid ripe hq\n    self.ripeHq = _newHq\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_HQ_TIME_LOCK\n    prevTimeLock: uint256 = self.hqChangeTimeLock\n    if timeLock != prevTimeLock:\n        assert self._setHqChangeTimeLock(timeLock, prevTimeLock) # dev: invalid time lock\n\n    self.tempGov = empty(address)\n    log InitialRipeHqSet(hq=_newHq, timeLock=timeLock)\n    return True\n",
            "sha256sum": "66c2e657d9faa162b27fbb89751938175d9271c75685964781cfe37863b7806a"
          },
          "contracts/tokens/GreenToken.vy": {
            "content": "# @version 0.4.1\n\nexports: token.__interface__\ninitializes: token\n\nfrom contracts.tokens.modules import Erc20Token as token\n\ninterface RipeHq:\n    def canMintGreen(_addr: address) -> bool: view\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    token.__init__(\"Green USD Stablecoin\", \"GREEN\", 18, _ripeHq, _initialGov, _minHqTimeLock, _maxHqTimeLock, _initialSupply, _initialSupplyRecipient)\n\n\n###########\n# Minting #\n###########\n\n\n@external\ndef mint(_recipient: address, _amount: uint256) -> bool:\n    assert staticcall RipeHq(token.ripeHq).canMintGreen(msg.sender) # dev: cannot mint\n    return token._mint(_recipient, _amount)\n",
            "sha256sum": "d4f598449ad69fd6709748f7cf59d92631ff9a8a2ccf38bb137d7630b9a93005"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/tokens/GreenToken.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "df96d3ab4d7098847b91ca3a00a9259dae60db0827875969d8b9f935192ef555"
      },
      "args": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7"
    },
    "RipeToken": {
      "address": "0x7563dE9626990658111Ed4AC21fA0149e49C6AAe",
      "abi": [
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeInitiated",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeConfirmed",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeCancelled",
          "inputs": [
            {
              "name": "cancelledHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "InitialRipeHqSet",
          "inputs": [
            {
              "name": "hq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqChange",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewRipeHq",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHq",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_initialSupply",
              "type": "uint256"
            },
            {
              "name": "_initialSupplyRecipient",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/tokens/modules/Erc20Token.vy": {
            "content": "# @version 0.4.1\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface RipeHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintGreen(_addr: address) -> bool: view\n    def canMintRipe(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def greenToken() -> address: view\n    def governance() -> address: view\n    def ripeToken() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nstruct PendingHq:\n    newHq: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# ripe \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent HqChangeInitiated:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    confirmBlock: uint256\n\nevent HqChangeConfirmed:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqChangeCancelled:\n    cancelledHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent TokenPauseModified:\n    isPaused: bool\n\nevent InitialRipeHqSet:\n    hq: indexed(address)\n    timeLock: uint256\n\nevent HqChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\n# ripe hq\nripeHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\npendingHq: public(PendingHq)\nhqChangeTimeLock: public(uint256)\ntempGov: address\n\nMIN_HQ_TIME_LOCK: immutable(uint256)\nMAX_HQ_TIME_LOCK: immutable(uint256)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    MIN_HQ_TIME_LOCK = _minHqTimeLock\n    MAX_HQ_TIME_LOCK = _maxHqTimeLock\n\n    # set initial gov (green / ripe tokens)\n    if _initialGov != empty(address):\n        assert _ripeHq == empty(address) # dev: cannot set initial gov and ripe hq\n        self.tempGov = _initialGov\n\n    # set ripe hq\n    if _ripeHq != empty(address):\n        assert self._isValidNewRipeHq(_ripeHq, empty(address)) # dev: invalid ripe hq\n        assert _initialGov == empty(address) # dev: cannot set initial gov and ripe hq\n        self.ripeHq = _ripeHq\n\n    # initial supply\n    if _initialSupply != 0 and _initialSupplyRecipient not in [empty(address), self]:\n        self.balanceOf[_initialSupplyRecipient] = _initialSupply\n        self.totalSupply = _initialSupply\n        log Transfer(sender=empty(address), recipient=_initialSupplyRecipient, amount=_initialSupply)\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall RipeHq(self.ripeHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n###################\n# Ripe Hq Changes #\n###################\n\n\n@view\n@external\ndef hasPendingHqChange() -> bool:\n    return self.pendingHq.confirmBlock != 0\n\n\n# initiate hq change\n\n\n@external\ndef initiateHqChange(_newHq: address):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    # validate new hq\n    prevHq: address = self.ripeHq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid new hq\n\n    confirmBlock: uint256 = block.number + self.hqChangeTimeLock\n    self.pendingHq = PendingHq(\n        newHq= _newHq,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqChangeInitiated(prevHq=prevHq, newHq=_newHq, confirmBlock=confirmBlock)\n\n\n# confirm hq change\n\n\n@external\ndef confirmHqChange() -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # validate new hq one more time\n    prevHq: address = self.ripeHq\n    if not self._isValidNewRipeHq(data.newHq, prevHq):\n        self.pendingHq = empty(PendingHq)\n        return False\n\n    # set new ripe hq\n    self.ripeHq = data.newHq\n    self.pendingHq = empty(PendingHq)\n    log HqChangeConfirmed(prevHq=prevHq, newHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n    return True\n\n\n# cancel hq change\n\n\n@external\ndef cancelHqChange():\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingHq = empty(PendingHq)\n    log HqChangeCancelled(cancelledHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewRipeHq(_newHq: address) -> bool:\n    return self._isValidNewRipeHq(_newHq, self.ripeHq)\n\n\n@view\n@internal\ndef _isValidNewRipeHq(_newHq: address, _prevHq: address) -> bool:\n\n    # same hq, or invalid new hq\n    if _newHq == _prevHq or _newHq == empty(address) or not _newHq.is_contract:\n        return False\n\n    # if current hq has pending gov change, cannot change ripe hq now\n    if _prevHq != empty(address) and staticcall RipeHq(_prevHq).hasPendingGovChange():\n        return False\n\n    # if new hq has pending gov change, or is not set, cannot change ripe hq now\n    if staticcall RipeHq(_newHq).hasPendingGovChange() or staticcall RipeHq(_newHq).governance() == empty(address):\n        return False\n\n    # tokens must be set\n    if staticcall RipeHq(_newHq).greenToken() == empty(address) or staticcall RipeHq(_newHq).ripeToken() == empty(address):\n        return False\n\n    # make sure it has the necessary interfaces\n    assert not staticcall RipeHq(_newHq).canSetTokenBlacklist(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintGreen(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintRipe(empty(address)) # dev: invalid interface\n\n    return True\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    ripeHq: address = self.ripeHq\n    assert msg.sender == staticcall RipeHq(ripeHq).governance() # dev: no perms\n    assert not staticcall RipeHq(ripeHq).hasPendingGovChange() # dev: pending gov change\n    return self._setHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@internal\ndef _setHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidHqChangeTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.hqChangeTimeLock = _newTimeLock\n    log HqChangeTimeLockModified(prevTimeLock=_prevTimeLock, newTimeLock=_newTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_HQ_TIME_LOCK and _newTimeLock <= MAX_HQ_TIME_LOCK\n\n\n# views\n\n\n@view\n@external\ndef minHqTimeLock() -> uint256:\n    return MIN_HQ_TIME_LOCK\n\n\n@view\n@external\ndef maxHqTimeLock() -> uint256:\n    return MAX_HQ_TIME_LOCK\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n\n\n###############\n# Token Setup #\n###############\n\n\n@external\ndef finishTokenSetup(_newHq: address, _timeLock: uint256 = 0) -> bool:\n    assert msg.sender == self.tempGov # dev: no perms\n\n    prevHq: address = self.ripeHq\n    assert prevHq == empty(address) # dev: already set\n\n    # set hq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid ripe hq\n    self.ripeHq = _newHq\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_HQ_TIME_LOCK\n    prevTimeLock: uint256 = self.hqChangeTimeLock\n    if timeLock != prevTimeLock:\n        assert self._setHqChangeTimeLock(timeLock, prevTimeLock) # dev: invalid time lock\n\n    self.tempGov = empty(address)\n    log InitialRipeHqSet(hq=_newHq, timeLock=timeLock)\n    return True\n",
            "sha256sum": "66c2e657d9faa162b27fbb89751938175d9271c75685964781cfe37863b7806a"
          },
          "contracts/tokens/RipeToken.vy": {
            "content": "# @version 0.4.1\n\nexports: token.__interface__\ninitializes: token\n\nfrom contracts.tokens.modules import Erc20Token as token\n\ninterface RipeHq:\n    def canMintRipe(_addr: address) -> bool: view\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    token.__init__(\"Ripe DAO Governance Token\", \"RIPE\", 18, _ripeHq, _initialGov, _minHqTimeLock, _maxHqTimeLock, _initialSupply, _initialSupplyRecipient)\n\n\n###########\n# Minting #\n###########\n\n\n@external\ndef mint(_recipient: address, _amount: uint256) -> bool:\n    assert staticcall RipeHq(token.ripeHq).canMintRipe(msg.sender) # dev: cannot mint\n    return token._mint(_recipient, _amount)\n",
            "sha256sum": "5c9cae6aba9e5c6d49ef51801cfc614d384f7b79164cde1ce48ec33fc323c7dc"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/tokens/RipeToken.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "ba4ace1cf21b6b0be7e9384eaf102aa54e83efc82c5a35b529071281f6333e1a"
      },
      "args": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000d3c21bcecceda10000000000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7"
    },
    "SavingsGreen": {
      "address": "0x39A976A0Eb2094F20078E8AD352f6cd18b532fF8",
      "abi": [
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeInitiated",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeConfirmed",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeCancelled",
          "inputs": [
            {
              "name": "cancelledHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "InitialRipeHqSet",
          "inputs": [
            {
              "name": "hq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Withdraw",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "receiver",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqChange",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewRipeHq",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHq",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "asset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxDeposit",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewDeposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxMint",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewMint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxWithdraw",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewWithdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRedeem",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRedeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToShares",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssets",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastUnderlying",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pricePerShare",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastPricePerShare",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_initialSupply",
              "type": "uint256"
            },
            {
              "name": "_initialSupplyRecipient",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/tokens/modules/Erc20Token.vy": {
            "content": "# @version 0.4.1\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface RipeHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintGreen(_addr: address) -> bool: view\n    def canMintRipe(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def greenToken() -> address: view\n    def governance() -> address: view\n    def ripeToken() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nstruct PendingHq:\n    newHq: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# ripe \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent HqChangeInitiated:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    confirmBlock: uint256\n\nevent HqChangeConfirmed:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqChangeCancelled:\n    cancelledHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent TokenPauseModified:\n    isPaused: bool\n\nevent InitialRipeHqSet:\n    hq: indexed(address)\n    timeLock: uint256\n\nevent HqChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\n# ripe hq\nripeHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\npendingHq: public(PendingHq)\nhqChangeTimeLock: public(uint256)\ntempGov: address\n\nMIN_HQ_TIME_LOCK: immutable(uint256)\nMAX_HQ_TIME_LOCK: immutable(uint256)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    MIN_HQ_TIME_LOCK = _minHqTimeLock\n    MAX_HQ_TIME_LOCK = _maxHqTimeLock\n\n    # set initial gov (green / ripe tokens)\n    if _initialGov != empty(address):\n        assert _ripeHq == empty(address) # dev: cannot set initial gov and ripe hq\n        self.tempGov = _initialGov\n\n    # set ripe hq\n    if _ripeHq != empty(address):\n        assert self._isValidNewRipeHq(_ripeHq, empty(address)) # dev: invalid ripe hq\n        assert _initialGov == empty(address) # dev: cannot set initial gov and ripe hq\n        self.ripeHq = _ripeHq\n\n    # initial supply\n    if _initialSupply != 0 and _initialSupplyRecipient not in [empty(address), self]:\n        self.balanceOf[_initialSupplyRecipient] = _initialSupply\n        self.totalSupply = _initialSupply\n        log Transfer(sender=empty(address), recipient=_initialSupplyRecipient, amount=_initialSupply)\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall RipeHq(self.ripeHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n###################\n# Ripe Hq Changes #\n###################\n\n\n@view\n@external\ndef hasPendingHqChange() -> bool:\n    return self.pendingHq.confirmBlock != 0\n\n\n# initiate hq change\n\n\n@external\ndef initiateHqChange(_newHq: address):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    # validate new hq\n    prevHq: address = self.ripeHq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid new hq\n\n    confirmBlock: uint256 = block.number + self.hqChangeTimeLock\n    self.pendingHq = PendingHq(\n        newHq= _newHq,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqChangeInitiated(prevHq=prevHq, newHq=_newHq, confirmBlock=confirmBlock)\n\n\n# confirm hq change\n\n\n@external\ndef confirmHqChange() -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # validate new hq one more time\n    prevHq: address = self.ripeHq\n    if not self._isValidNewRipeHq(data.newHq, prevHq):\n        self.pendingHq = empty(PendingHq)\n        return False\n\n    # set new ripe hq\n    self.ripeHq = data.newHq\n    self.pendingHq = empty(PendingHq)\n    log HqChangeConfirmed(prevHq=prevHq, newHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n    return True\n\n\n# cancel hq change\n\n\n@external\ndef cancelHqChange():\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingHq = empty(PendingHq)\n    log HqChangeCancelled(cancelledHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewRipeHq(_newHq: address) -> bool:\n    return self._isValidNewRipeHq(_newHq, self.ripeHq)\n\n\n@view\n@internal\ndef _isValidNewRipeHq(_newHq: address, _prevHq: address) -> bool:\n\n    # same hq, or invalid new hq\n    if _newHq == _prevHq or _newHq == empty(address) or not _newHq.is_contract:\n        return False\n\n    # if current hq has pending gov change, cannot change ripe hq now\n    if _prevHq != empty(address) and staticcall RipeHq(_prevHq).hasPendingGovChange():\n        return False\n\n    # if new hq has pending gov change, or is not set, cannot change ripe hq now\n    if staticcall RipeHq(_newHq).hasPendingGovChange() or staticcall RipeHq(_newHq).governance() == empty(address):\n        return False\n\n    # tokens must be set\n    if staticcall RipeHq(_newHq).greenToken() == empty(address) or staticcall RipeHq(_newHq).ripeToken() == empty(address):\n        return False\n\n    # make sure it has the necessary interfaces\n    assert not staticcall RipeHq(_newHq).canSetTokenBlacklist(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintGreen(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintRipe(empty(address)) # dev: invalid interface\n\n    return True\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    ripeHq: address = self.ripeHq\n    assert msg.sender == staticcall RipeHq(ripeHq).governance() # dev: no perms\n    assert not staticcall RipeHq(ripeHq).hasPendingGovChange() # dev: pending gov change\n    return self._setHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@internal\ndef _setHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidHqChangeTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.hqChangeTimeLock = _newTimeLock\n    log HqChangeTimeLockModified(prevTimeLock=_prevTimeLock, newTimeLock=_newTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_HQ_TIME_LOCK and _newTimeLock <= MAX_HQ_TIME_LOCK\n\n\n# views\n\n\n@view\n@external\ndef minHqTimeLock() -> uint256:\n    return MIN_HQ_TIME_LOCK\n\n\n@view\n@external\ndef maxHqTimeLock() -> uint256:\n    return MAX_HQ_TIME_LOCK\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n\n\n###############\n# Token Setup #\n###############\n\n\n@external\ndef finishTokenSetup(_newHq: address, _timeLock: uint256 = 0) -> bool:\n    assert msg.sender == self.tempGov # dev: no perms\n\n    prevHq: address = self.ripeHq\n    assert prevHq == empty(address) # dev: already set\n\n    # set hq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid ripe hq\n    self.ripeHq = _newHq\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_HQ_TIME_LOCK\n    prevTimeLock: uint256 = self.hqChangeTimeLock\n    if timeLock != prevTimeLock:\n        assert self._setHqChangeTimeLock(timeLock, prevTimeLock) # dev: invalid time lock\n\n    self.tempGov = empty(address)\n    log InitialRipeHqSet(hq=_newHq, timeLock=timeLock)\n    return True\n",
            "sha256sum": "66c2e657d9faa162b27fbb89751938175d9271c75685964781cfe37863b7806a"
          },
          "contracts/tokens/modules/Erc4626Token.vy": {
            "content": "# @version 0.4.1\n\nimplements: IERC4626\nfrom ethereum.ercs import IERC4626\n\nuses: token\nfrom contracts.tokens.modules import Erc20Token as token\nfrom ethereum.ercs import IERC20\n\nevent Deposit:\n    sender: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nevent Withdraw:\n    sender: indexed(address)\n    receiver: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nlastPricePerShare: public(uint256)\n\nASSET: immutable(address)\nDECIMAL_OFFSET: constant(uint256) = 10 ** 8\n\n\n@deploy\ndef __init__(_asset: address):\n    assert _asset != empty(address) # dev: invalid asset\n    ASSET = _asset\n\n\n@view\n@external\ndef asset() -> address:\n    return ASSET\n\n\n@view\n@external\ndef totalAssets() -> uint256:\n    return staticcall IERC20(ASSET).balanceOf(self)\n\n\n############\n# Deposits #\n############\n\n\n@view\n@external\ndef maxDeposit(_receiver: address) -> uint256:\n    return max_value(uint256)\n\n\n@view\n@external\ndef previewDeposit(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)\n\n\n@nonreentrant\n@external\ndef deposit(_assets: uint256, _receiver: address = msg.sender) -> uint256:\n    asset: address = ASSET\n\n    amount: uint256 = _assets\n    if amount == max_value(uint256):\n        amount = staticcall IERC20(asset).balanceOf(msg.sender)\n\n    shares: uint256 = self._amountToShares(amount, token.totalSupply, staticcall IERC20(asset).balanceOf(self), False)\n    self._deposit(asset, amount, shares, _receiver)\n    return shares\n\n\n# mint\n\n\n@view\n@external\ndef maxMint(_receiver: address) -> uint256:\n    return max_value(uint256)\n\n\n@view\n@external\ndef previewMint(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), True)\n\n\n@nonreentrant\n@external\ndef mint(_shares: uint256, _receiver: address = msg.sender) -> uint256:\n    asset: address = ASSET\n    amount: uint256 = self._sharesToAmount(_shares, token.totalSupply, staticcall IERC20(asset).balanceOf(self), True)\n    self._deposit(asset, amount, _shares, _receiver)\n    return amount\n\n\n# shared deposit logic\n\n\n@internal\ndef _deposit(_asset: address, _amount: uint256, _shares: uint256, _recipient: address):\n    assert _amount != 0 # dev: cannot deposit 0 amount\n    assert _shares != 0 # dev: cannot receive 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True) # dev: deposit failed\n    token._mint(_recipient, _shares)\n\n    # update last price per share\n    self._updateLastPricePerShare(_asset)\n\n    log Deposit(sender=msg.sender, owner=_recipient, assets=_amount, shares=_shares)\n\n\n###############\n# Withdrawals #\n###############\n\n\n@view\n@external\ndef maxWithdraw(_owner: address) -> uint256:\n    return staticcall IERC20(ASSET).balanceOf(self)\n\n\n@view\n@external\ndef previewWithdraw(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), True)\n\n\n@external\ndef withdraw(_assets: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    asset: address = ASSET\n    shares: uint256 = self._amountToShares(_assets, token.totalSupply, staticcall IERC20(asset).balanceOf(self), True)\n    self._redeem(asset, _assets, shares, msg.sender, _receiver, _owner)\n    return shares\n\n\n# redeem\n\n\n@view\n@external\ndef maxRedeem(_owner: address) -> uint256:\n    return token.balanceOf[_owner]\n\n\n@view\n@external\ndef previewRedeem(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)\n\n\n@external\ndef redeem(_shares: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    asset: address = ASSET\n\n    shares: uint256 = _shares\n    if shares == max_value(uint256):\n        shares = token.balanceOf[_owner]\n\n    amount: uint256 = self._sharesToAmount(shares, token.totalSupply, staticcall IERC20(asset).balanceOf(self), False)\n    return self._redeem(asset, amount, shares, msg.sender, _receiver, _owner)\n\n\n# shared redeem logic\n\n\n@internal\ndef _redeem(\n    _asset: address,\n    _amount: uint256,\n    _shares: uint256, \n    _sender: address, \n    _recipient: address, \n    _owner: address,\n) -> uint256:\n    assert _amount != 0 # dev: cannot withdraw 0 amount\n    assert _shares != 0 # dev: cannot redeem 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    assert token.balanceOf[_owner] >= _shares # dev: insufficient shares\n\n    if _sender != _owner:\n        token._spendAllowance(_owner, _sender, _shares)\n\n    token._burn(_owner, _shares)\n    assert extcall IERC20(_asset).transfer(_recipient, _amount, default_return_value=True) # dev: withdrawal failed\n\n    # update last price per share\n    self._updateLastPricePerShare(_asset)\n\n    log Withdraw(sender=_sender, receiver=_recipient, owner=_owner, assets=_amount, shares=_shares)\n    return _amount\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@external\ndef convertToShares(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)\n\n\n@view\n@external\ndef convertToAssets(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)\n\n\n# amount -> shares\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalBalance: uint256 = _totalBalance\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalBalance += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc shares\n    numerator: uint256 = _amount * totalShares\n    shares: uint256 = numerator // totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalBalance: uint256 = _totalBalance\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalBalance += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc amount\n    numerator: uint256 = _shares * totalBalance\n    amount: uint256 = numerator // totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalShares != 0):\n        amount += 1\n\n    return amount\n\n\n# price per share\n\n\n@internal\ndef _updateLastPricePerShare(_asset: address):\n    newLastPricePerShare: uint256 = self._sharesToAmount(10 ** convert(token.TOKEN_DECIMALS, uint256), token.totalSupply, staticcall IERC20(_asset).balanceOf(self), False)\n    self.lastPricePerShare = newLastPricePerShare\n\n\n@view\n@external\ndef getLastUnderlying(_shares: uint256) -> uint256:\n    return self.lastPricePerShare * _shares // (10 ** convert(token.TOKEN_DECIMALS, uint256))\n\n\n@view\n@external\ndef pricePerShare() -> uint256:\n    return self._sharesToAmount(10 ** convert(token.TOKEN_DECIMALS, uint256), token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)",
            "sha256sum": "e927afad6e165faf4b77d79ff24323f20166f8eb153275dd1c4edda0ff3deab5"
          },
          "contracts/tokens/SavingsGreen.vy": {
            "content": "# @version 0.4.1\n\nexports: token.__interface__\nexports: erc4626.__interface__\n\ninitializes: token\ninitializes: erc4626[token := token]\n\nfrom contracts.tokens.modules import Erc20Token as token\nimport contracts.tokens.modules.Erc4626Token as erc4626\n\nfrom ethereum.ercs import IERC20Detailed\n\n\n@deploy\ndef __init__(\n    _asset: address,\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    token.__init__(\"Savings Green USD\", \"sGREEN\", staticcall IERC20Detailed(_asset).decimals(), _ripeHq, _initialGov, _minHqTimeLock, _maxHqTimeLock, _initialSupply, _initialSupplyRecipient)\n    erc4626.__init__(_asset)\n",
            "sha256sum": "9eefef3f84e6a2de2ec6b7f17d77df8f78607ff12d99d5b751735556af352f53"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/tokens/SavingsGreen.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "7fb8ece2c6259f6929a4cfa9b76761cdc968993ffb302d69f365789c1771369c"
      },
      "args": "000000000000000000000000b2d9b97fd379a91f4ba4457bb2dcd162d967657600000000000000000000000000000000000000000000000000000000000000000000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    },
    "RipeHq": {
      "address": "0xA14bceB2C0086Acdee1b01e47C7EF3dE49ed996E",
      "abi": [
        {
          "name": "HqConfigChangeInitiated",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canMintRipe",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canModifyMissionControl",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqConfigChangeConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canMintRipe",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canModifyMissionControl",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqConfigChangeCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canMintRipe",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canModifyMissionControl",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_canMintGreen",
              "type": "bool"
            },
            {
              "name": "_canMintRipe",
              "type": "bool"
            },
            {
              "name": "_canSetTokenBlacklist",
              "type": "bool"
            },
            {
              "name": "_canModifyMissionControl",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "isValidHqConfig",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_canMintGreen",
              "type": "bool"
            },
            {
              "name": "_canMintRipe",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "greenToken",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "savingsGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeToken",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canSetTokenBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canModifyMissionControl",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "canMintGreen",
                  "type": "bool"
                },
                {
                  "name": "canMintRipe",
                  "type": "bool"
                },
                {
                  "name": "canSetTokenBlacklist",
                  "type": "bool"
                },
                {
                  "name": "canModifyMissionControl",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHqConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHqConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "description",
                      "type": "string"
                    },
                    {
                      "name": "canMintGreen",
                      "type": "bool"
                    },
                    {
                      "name": "canMintRipe",
                      "type": "bool"
                    },
                    {
                      "name": "canSetTokenBlacklist",
                      "type": "bool"
                    },
                    {
                      "name": "canModifyMissionControl",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_greenToken",
              "type": "address"
            },
            {
              "name": "_savingsGreen",
              "type": "address"
            },
            {
              "name": "_ripeToken",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minGovTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxGovTimeLock",
              "type": "uint256"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/registries/modules/AddressRegistry.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "45a6786be62ebfcd266d4b9f321aa22bfc8d125d6ce75ffcf4d895ad011ff661"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/registries/RipeHq.vy": {
            "content": "# @version 0.4.1\n\nexports: gov.__interface__\nexports: registry.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.registries.modules.AddressRegistry as registry\n\nfrom interfaces import Department\nfrom ethereum.ercs import IERC20\n\nstruct HqConfig:\n    description: String[64]\n    canMintGreen: bool\n    canMintRipe: bool\n    canSetTokenBlacklist: bool\n    canModifyMissionControl: bool\n\nstruct PendingHqConfig:\n    newHqConfig: HqConfig\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqConfigChangeInitiated:\n    regId: uint256\n    description: String[64]\n    canMintGreen: bool\n    canMintRipe: bool\n    canSetTokenBlacklist: bool\n    canModifyMissionControl: bool\n    confirmBlock: uint256\n\nevent HqConfigChangeConfirmed:\n    regId: uint256\n    description: String[64]\n    canMintGreen: bool\n    canMintRipe: bool\n    canSetTokenBlacklist: bool\n    canModifyMissionControl: bool\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqConfigChangeCancelled:\n    regId: uint256\n    description: String[64]\n    canMintGreen: bool\n    canMintRipe: bool\n    canSetTokenBlacklist: bool\n    canModifyMissionControl: bool\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent RipeHqFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# hq config\nhqConfig: public(HashMap[uint256, HqConfig]) # reg id -> hq config\npendingHqConfig: public(HashMap[uint256, PendingHqConfig]) # reg id -> pending hq config\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(\n    _greenToken: address,\n    _savingsGreen: address,\n    _ripeToken: address,\n    _initialGov: address,\n    _minGovTimeLock: uint256,\n    _maxGovTimeLock: uint256,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(empty(address), _initialGov, _minGovTimeLock, _maxGovTimeLock, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"RipeHq.vy\")\n\n    # green token\n    assert registry._startAddNewAddressToRegistry(_greenToken, \"Green Token\") # dev: failed to register green token\n    assert registry._confirmNewAddressToRegistry(_greenToken) == 1 # dev: failed to confirm green token\n\n    # savings green\n    assert registry._startAddNewAddressToRegistry(_savingsGreen, \"Savings Green\") # dev: failed to register savings green\n    assert registry._confirmNewAddressToRegistry(_savingsGreen) == 2 # dev: failed to confirm savings green\n\n    # ripe token\n    assert registry._startAddNewAddressToRegistry(_ripeToken, \"Ripe Token\") # dev: failed to register ripe token\n    assert registry._confirmNewAddressToRegistry(_ripeToken) == 3 # dev: failed to confirm ripe token\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert not self._isTokenId(_regId) # dev: cannot disable token\n\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n#############\n# Hq Config #\n#############\n\n\n@view\n@external\ndef hasPendingHqConfigChange(_regId: uint256) -> bool:\n    return self.pendingHqConfig[_regId].confirmBlock != 0\n\n\n# start hq config change\n\n\n@external\ndef initiateHqConfigChange(\n    _regId: uint256,\n    _canMintGreen: bool,\n    _canMintRipe: bool,\n    _canSetTokenBlacklist: bool,\n    _canModifyMissionControl: bool,\n):\n    assert msg.sender == gov.governance # dev: no perms\n\n    assert self._isValidHqConfig(_regId, _canMintGreen, _canMintRipe) # dev: invalid hq config\n    hqConfig: HqConfig = HqConfig(\n        description= registry._getAddrDescription(_regId),\n        canMintGreen= _canMintGreen,\n        canMintRipe= _canMintRipe,\n        canSetTokenBlacklist= _canSetTokenBlacklist,\n        canModifyMissionControl= _canModifyMissionControl,\n    )\n\n    # set pending hq config\n    confirmBlock: uint256 = block.number + registry.registryChangeTimeLock\n    self.pendingHqConfig[_regId] = PendingHqConfig(\n        newHqConfig= hqConfig,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqConfigChangeInitiated(\n        regId=_regId,\n        description=hqConfig.description,\n        canMintGreen=_canMintGreen,\n        canMintRipe=_canMintRipe,\n        canSetTokenBlacklist=_canSetTokenBlacklist,\n        canModifyMissionControl=_canModifyMissionControl,\n        confirmBlock=confirmBlock,\n    )\n\n\n# confirm hq config change\n\n\n@external\ndef confirmHqConfigChange(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n\n    data: PendingHqConfig = self.pendingHqConfig[_regId]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # invalid hq config\n    newConfig: HqConfig = data.newHqConfig\n    if not self._isValidHqConfig(_regId, newConfig.canMintGreen, newConfig.canMintRipe):\n        self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n        return False\n\n    # set hq config\n    self.hqConfig[_regId] = newConfig\n    self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n\n    log HqConfigChangeConfirmed(\n        regId=_regId,\n        description=newConfig.description,\n        canMintGreen=newConfig.canMintGreen,\n        canMintRipe=newConfig.canMintRipe,\n        canSetTokenBlacklist=newConfig.canSetTokenBlacklist,\n        canModifyMissionControl=newConfig.canModifyMissionControl,\n        initiatedBlock=data.initiatedBlock,\n        confirmBlock=data.confirmBlock,\n    )\n    return True\n\n\n# cancel hq config change\n\n\n@external\ndef cancelHqConfigChange(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n\n    data: PendingHqConfig = self.pendingHqConfig[_regId]\n    assert data.confirmBlock != 0 # dev: no pending change\n\n    self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n    log HqConfigChangeCancelled(\n        regId=_regId,\n        description=data.newHqConfig.description,\n        canMintGreen=data.newHqConfig.canMintGreen,\n        canMintRipe=data.newHqConfig.canMintRipe,\n        canSetTokenBlacklist=data.newHqConfig.canSetTokenBlacklist,\n        canModifyMissionControl=data.newHqConfig.canModifyMissionControl,\n        initiatedBlock=data.initiatedBlock,\n        confirmBlock=data.confirmBlock\n    )\n    return True\n\n\n# validation\n\n\n@external\ndef isValidHqConfig(\n    _regId: uint256,\n    _canMintGreen: bool,\n    _canMintRipe: bool,\n) -> bool:\n    return self._isValidHqConfig(_regId, _canMintGreen, _canMintRipe)\n\n\n@internal\ndef _isValidHqConfig(\n    _regId: uint256,\n    _canMintGreen: bool,\n    _canMintRipe: bool,\n) -> bool:\n\n    # tokens cannot mint, cannot set their own blacklist, cannot modify mission control\n    if self._isTokenId(_regId):\n        return False\n\n    # invalid reg id\n    if not registry._isValidRegId(_regId):\n        return False\n\n    # no addr\n    addr: address = registry._getAddr(_regId)\n    if addr == empty(address):\n        return False\n\n    # two-factor auth on minting\n    if _canMintGreen and not staticcall Department(addr).canMintGreen():\n        return False\n\n    if _canMintRipe and not staticcall Department(addr).canMintRipe():\n        return False\n\n    return True\n\n\n@view\n@internal\ndef _isTokenId(_regId: uint256) -> bool:\n    return _regId in [1, 2, 3]\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@external\ndef greenToken() -> address:\n    return registry._getAddr(1)\n\n\n@view\n@external\ndef savingsGreen() -> address:\n    return registry._getAddr(2)\n\n\n@view\n@external\ndef ripeToken() -> address:\n    return registry._getAddr(3)\n\n\n@view\n@external\ndef canMintGreen(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0 or not self.hqConfig[regId].canMintGreen:\n        return False\n    return staticcall Department(_addr).canMintGreen()\n\n\n@view\n@external\ndef canMintRipe(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0 or not self.hqConfig[regId].canMintRipe:\n        return False\n    return staticcall Department(_addr).canMintRipe()\n\n\n@view\n@external\ndef canSetTokenBlacklist(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0:\n        return False\n    return self.hqConfig[regId].canSetTokenBlacklist\n\n\n@view\n@external\ndef canModifyMissionControl(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0:\n        return False\n    return self.hqConfig[regId].canModifyMissionControl\n\n\n############\n# Recovery #\n############\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert msg.sender == gov.governance # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert msg.sender == gov.governance # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log RipeHqFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "f92b8cf8f35d5b37a9d93b7520f0816fe9ecfc74298485cf6b5431bc218cc58a"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/RipeHq.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "b5cfac580c32186e165b0787c148f5f94279f29f3ac8207c515c126cfa617a71"
      },
      "args": "000000000000000000000000b2d9b97fd379a91f4ba4457bb2dcd162d967657600000000000000000000000039a976a0eb2094f20078e8ad352f6cd18b532ff80000000000000000000000007563de9626990658111ed4ac21fa0149e49c6aae0000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "Ledger": {
      "address": "0x9D3c008b105c3E0897612dF5FC41bcCf297040C8",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isParticipatingInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserVaults",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addVaultToUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeVaultFromUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositLedgerData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "isParticipatingInVault",
                  "type": "bool"
                },
                {
                  "name": "numUserVaults",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDebt",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_newYield",
              "type": "uint256"
            },
            {
              "name": "_interval",
              "type": "tuple",
              "components": [
                {
                  "name": "start",
                  "type": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "flushUnrealizedYield",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasDebt",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumBorrowers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBorrowDataBundle",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "userDebt",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "name": "principal",
                      "type": "uint256"
                    },
                    {
                      "name": "debtTerms",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "ltv",
                          "type": "uint256"
                        },
                        {
                          "name": "redemptionThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqFee",
                          "type": "uint256"
                        },
                        {
                          "name": "borrowRate",
                          "type": "uint256"
                        },
                        {
                          "name": "daowry",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "lastTimestamp",
                      "type": "uint256"
                    },
                    {
                      "name": "inLiquidation",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "userBorrowInterval",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "start",
                      "type": "uint256"
                    },
                    {
                      "name": "amount",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "isUserBorrower",
                  "type": "bool"
                },
                {
                  "name": "numUserVaults",
                  "type": "uint256"
                },
                {
                  "name": "totalDebt",
                  "type": "uint256"
                },
                {
                  "name": "numBorrowers",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRepayDataBundle",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "userDebt",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "name": "principal",
                      "type": "uint256"
                    },
                    {
                      "name": "debtTerms",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "ltv",
                          "type": "uint256"
                        },
                        {
                          "name": "redemptionThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqFee",
                          "type": "uint256"
                        },
                        {
                          "name": "borrowRate",
                          "type": "uint256"
                        },
                        {
                          "name": "daowry",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "lastTimestamp",
                      "type": "uint256"
                    },
                    {
                      "name": "inLiquidation",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "numUserVaults",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isBorrower",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInLiquidation",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewards",
          "inputs": [
            {
              "name": "_ripeRewards",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeAvailForRewards",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDepositPointsAndRipeRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_userPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_assetPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                },
                {
                  "name": "precision",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_globalPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_ripeRewards",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBorrowPointsAndRipeRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_userPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "lastPrincipal",
                  "type": "uint256"
                },
                {
                  "name": "points",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_globalPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "lastPrincipal",
                  "type": "uint256"
                },
                {
                  "name": "points",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_ripeRewards",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeRewardsBundle",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ripeRewards",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "borrowers",
                      "type": "uint256"
                    },
                    {
                      "name": "stakers",
                      "type": "uint256"
                    },
                    {
                      "name": "voters",
                      "type": "uint256"
                    },
                    {
                      "name": "genDepositors",
                      "type": "uint256"
                    },
                    {
                      "name": "newRipeRewards",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ripeAvailForRewards",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBorrowPointsBundle",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "userPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "lastPrincipal",
                      "type": "uint256"
                    },
                    {
                      "name": "points",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "globalPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "lastPrincipal",
                      "type": "uint256"
                    },
                    {
                      "name": "points",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "userDebtPrincipal",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositPointsBundle",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "userPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "balancePoints",
                      "type": "uint256"
                    },
                    {
                      "name": "lastBalance",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "assetPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "balancePoints",
                      "type": "uint256"
                    },
                    {
                      "name": "lastBalance",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUsdValue",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeStakerPoints",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeVotePoints",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeGenPoints",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    },
                    {
                      "name": "precision",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "globalPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "lastUsdValue",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeStakerPoints",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeVotePoints",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeGenPoints",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasFungibleAuctions",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createNewFungibleAuction",
          "inputs": [
            {
              "name": "_auc",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_auc",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAllFungibleAuctions",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getFungibleAuctionDuringPurchase",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfVault",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userDebt",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalDebt",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "borrowers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfBorrower",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numBorrowers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "borrowIntervals",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "start",
                  "type": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "unrealizedYield",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeAvailForRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalDepositPoints",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetDepositPoints",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                },
                {
                  "name": "precision",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userDepositPoints",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            },
            {
              "name": "arg2",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBorrowPoints",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastPrincipal",
                  "type": "uint256"
                },
                {
                  "name": "points",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalBorrowPoints",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastPrincipal",
                  "type": "uint256"
                },
                {
                  "name": "points",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fungibleAuctions",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fungibleAuctionIndex",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            },
            {
              "name": "arg2",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numFungibleAuctions",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fungLiqUsers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfFungLiqUser",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numFungLiqUsers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_ripeAvailForRewards",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "cdcbc1c83a0ffa09166c89d2698097b5dee00d2ebebf714134ab8faa6e9ff685"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/data/Ledger.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\n# deposit / withdrawals\n\nstruct DepositLedgerData:\n    isParticipatingInVault: bool\n    numUserVaults: uint256\n\n# points / rewards\n\nstruct RipeRewards:\n    borrowers: uint256\n    stakers: uint256\n    voters: uint256\n    genDepositors: uint256\n    newRipeRewards: uint256\n    lastUpdate: uint256\n\nstruct GlobalDepositPoints:\n    lastUsdValue: uint256\n    ripeStakerPoints: uint256\n    ripeVotePoints: uint256\n    ripeGenPoints: uint256\n    lastUpdate: uint256\n\nstruct AssetDepositPoints:\n    balancePoints: uint256\n    lastBalance: uint256\n    lastUsdValue: uint256\n    ripeStakerPoints: uint256\n    ripeVotePoints: uint256\n    ripeGenPoints: uint256\n    lastUpdate: uint256\n    precision: uint256\n\nstruct UserDepositPoints:\n    balancePoints: uint256\n    lastBalance: uint256\n    lastUpdate: uint256\n\nstruct BorrowPoints:\n    lastPrincipal: uint256\n    points: uint256\n    lastUpdate: uint256\n\nstruct BorrowPointsBundle:\n    userPoints: BorrowPoints\n    globalPoints: BorrowPoints\n    userDebtPrincipal: uint256\n\nstruct DepositPointsBundle:\n    userPoints: UserDepositPoints\n    assetPoints: AssetDepositPoints\n    globalPoints: GlobalDepositPoints\n\nstruct RipeRewardsBundle:\n    ripeRewards: RipeRewards\n    ripeAvailForRewards: uint256\n\n# debt\n\nstruct BorrowDataBundle:\n    userDebt: UserDebt\n    userBorrowInterval: IntervalBorrow\n    isUserBorrower: bool\n    numUserVaults: uint256\n    totalDebt: uint256\n    numBorrowers: uint256\n\nstruct RepayDataBundle:\n    userDebt: UserDebt\n    numUserVaults: uint256\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserDebt:\n    amount: uint256\n    principal: uint256\n    debtTerms: DebtTerms\n    lastTimestamp: uint256\n    inLiquidation: bool\n\nstruct IntervalBorrow:\n    start: uint256\n    amount: uint256\n\n# auctions\n\nstruct FungibleAuction:\n    liqUser: address\n    vaultId: uint256\n    asset: address \n    startDiscount: uint256\n    maxDiscount: uint256\n    startBlock: uint256\n    endBlock: uint256\n    isActive: bool\n\n# user vault participation\nuserVaults: public(HashMap[address, HashMap[uint256, uint256]]) # user -> index -> vault id\nindexOfVault: public(HashMap[address, HashMap[uint256, uint256]]) # user -> vault id -> index\nnumUserVaults: public(HashMap[address, uint256]) # user -> num vaults\n\n# borrow data\nuserDebt: public(HashMap[address, UserDebt]) # user -> user debt\ntotalDebt: public(uint256) # total debt\nborrowers: public(HashMap[uint256, address]) # index -> borrower\nindexOfBorrower: public(HashMap[address, uint256]) # borrower -> index\nnumBorrowers: public(uint256) # num borrowers\nborrowIntervals: public(HashMap[address, IntervalBorrow]) # user -> borrow interval\nunrealizedYield: public(uint256) # unrealized yield\n\n# ripe rewards\nripeRewards: public(RipeRewards)\nripeAvailForRewards: public(uint256)\n\n# points\nglobalDepositPoints: public(GlobalDepositPoints)\nassetDepositPoints: public(HashMap[uint256, HashMap[address, AssetDepositPoints]]) # vault id -> asset -> points\nuserDepositPoints: public(HashMap[address, HashMap[uint256, HashMap[address, UserDepositPoints]]]) # user -> vault id -> asset -> points\nuserBorrowPoints:  public(HashMap[address, BorrowPoints]) # user -> BorrowPoints\nglobalBorrowPoints: public(BorrowPoints)\n\n# auctions\nfungibleAuctions: public(HashMap[address, HashMap[uint256, FungibleAuction]]) # liq user -> auction index -> FungibleAuction\nfungibleAuctionIndex: public(HashMap[address, HashMap[uint256, HashMap[address, uint256]]]) # liq user -> vault id -> asset -> auction index\nnumFungibleAuctions: public(HashMap[address, uint256]) # liq user -> num fungible auctions\n\nfungLiqUsers: public(HashMap[uint256, address]) # index -> liq user\nindexOfFungLiqUser: public(HashMap[address, uint256]) # liq user -> index\nnumFungLiqUsers: public(uint256) # num liq users\n\n\n@deploy\ndef __init__(_ripeHq: address, _ripeAvailForRewards: uint256):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n    if _ripeAvailForRewards != 0:\n        self.ripeAvailForRewards = _ripeAvailForRewards\n\n\n###############\n# User Vaults #\n###############\n\n\n@view\n@external\ndef isParticipatingInVault(_user: address, _vaultId: uint256) -> bool:\n    return self.indexOfVault[_user][_vaultId] != 0\n\n\n@view\n@external\ndef getNumUserVaults(_user: address) -> uint256:\n    return self._getNumUserVaults(_user)\n\n\n@view\n@internal\ndef _getNumUserVaults(_user: address) -> uint256:\n    numVaults: uint256 = self.numUserVaults[_user]\n    if numVaults == 0:\n        return 0\n    return numVaults - 1\n\n\n@external\ndef addVaultToUser(_user: address, _vaultId: uint256):\n    assert msg.sender in [addys._getTellerAddr(), addys._getCreditEngineAddr(), addys._getAuctionHouseAddr()] # dev: not allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    # already participating - fail gracefully\n    if self.indexOfVault[_user][_vaultId] != 0:\n        return\n\n    # register vault\n    vid: uint256 = self.numUserVaults[_user]\n    if vid == 0:\n        vid = 1 # not using 0 index\n\n    self.userVaults[_user][vid] = _vaultId\n    self.indexOfVault[_user][_vaultId] = vid\n    self.numUserVaults[_user] = vid + 1\n\n\n@external\ndef removeVaultFromUser(_user: address, _vaultId: uint256):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    numUserVaults: uint256 = self.numUserVaults[_user]\n    if numUserVaults == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfVault[_user][_vaultId]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numUserVaults - 1\n    self.numUserVaults[_user] = lastIndex\n    self.indexOfVault[_user][_vaultId] = 0\n\n    # have last vault replace the target vault\n    if targetIndex != lastIndex:\n        lastVaultId: uint256 = self.userVaults[_user][lastIndex]\n        self.userVaults[_user][targetIndex] = lastVaultId\n        self.indexOfVault[_user][lastVaultId] = targetIndex\n\n\n# utils\n\n\n@view\n@external\ndef getDepositLedgerData(_user: address, _vaultId: uint256) -> DepositLedgerData:\n    return DepositLedgerData(\n        isParticipatingInVault=self.indexOfVault[_user][_vaultId] != 0,\n        numUserVaults=self._getNumUserVaults(_user),\n    )\n\n\n########\n# Debt #\n########\n\n\n@external\ndef setUserDebt(_user: address, _userDebt: UserDebt, _newYield: uint256, _interval: IntervalBorrow):\n    assert msg.sender == addys._getCreditEngineAddr() # dev: only CreditEngine allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    # reduce prev user debt\n    totalDebt: uint256 = self.totalDebt\n    prevUserDebt: UserDebt = self.userDebt[_user]\n    if prevUserDebt.amount != 0:\n        totalDebt -= prevUserDebt.amount\n\n    # save new user debt\n    self.userDebt[_user] = _userDebt\n    if _userDebt.amount != 0:\n        totalDebt += _userDebt.amount\n    self.totalDebt = totalDebt\n\n    # update intervals -- during repay, we pass in empty interval\n    if _interval.start != 0:\n        self.borrowIntervals[_user] = _interval\n\n    # update unrealized yield\n    if _newYield != 0:\n        self.unrealizedYield += _newYield\n\n    # update fung auctions (if they exist)\n    if prevUserDebt.inLiquidation and not _userDebt.inLiquidation:\n        self._removeAllFungibleAuctions(_user)\n\n    # remove borrower\n    if _userDebt.amount == 0:\n        self._removeBorrower(_user)\n\n    # add borrower (if necessary)\n    elif self.indexOfBorrower[_user] == 0:\n        self._addNewBorrower(_user)\n\n\n# realize yield\n\n\n@external\ndef flushUnrealizedYield() -> uint256:\n    assert msg.sender == addys._getCreditEngineAddr() # dev: only CreditEngine allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    unrealizedYield: uint256 = self.unrealizedYield\n    self.unrealizedYield = 0\n    return unrealizedYield\n\n\n# registration\n\n\n@internal\ndef _addNewBorrower(_user: address):\n    bid: uint256 = self.numBorrowers\n    if bid == 0:\n        bid = 1 # not using 0 index\n    self.borrowers[bid] = _user\n    self.indexOfBorrower[_user] = bid\n    self.numBorrowers = bid + 1\n\n\n@internal\ndef _removeBorrower(_user: address):\n    numBorrowers: uint256 = self.numBorrowers\n    if numBorrowers == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfBorrower[_user]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numBorrowers - 1\n    self.numBorrowers = lastIndex\n    self.indexOfBorrower[_user] = 0\n\n    # shift users to replace the removed one\n    if targetIndex != lastIndex:\n        lastUser: address = self.borrowers[lastIndex]\n        self.borrowers[targetIndex] = lastUser\n        self.indexOfBorrower[lastUser] = targetIndex\n\n\n# utils\n\n\n@view\n@external\ndef hasDebt(_user: address) -> bool:\n    return self.userDebt[_user].amount != 0\n\n\n@view\n@external\ndef getNumBorrowers() -> uint256:\n    return self._getNumBorrowers()\n\n\n@view\n@internal\ndef _getNumBorrowers() -> uint256:\n    numBorrowers: uint256 = self.numBorrowers\n    if numBorrowers == 0:\n        return 0\n    return numBorrowers - 1\n\n\n@view\n@external\ndef getBorrowDataBundle(_user: address) -> BorrowDataBundle:\n    return BorrowDataBundle(\n        userDebt=self.userDebt[_user],\n        userBorrowInterval=self.borrowIntervals[_user],\n        isUserBorrower=self.indexOfBorrower[_user] != 0,\n        numUserVaults=self.numUserVaults[_user],\n        totalDebt=self.totalDebt,\n        numBorrowers=self._getNumBorrowers(),\n    )\n\n\n@view\n@external\ndef getRepayDataBundle(_user: address) -> RepayDataBundle:\n    return RepayDataBundle(\n        userDebt=self.userDebt[_user],\n        numUserVaults=self.numUserVaults[_user],\n    )\n\n\n@view\n@external\ndef isBorrower(_user: address) -> bool:\n    return self.indexOfBorrower[_user] != 0\n\n\n@view\n@external\ndef isUserInLiquidation(_user: address) -> bool:\n    return self.userDebt[_user].inLiquidation\n\n\n####################\n# Rewards / Points #\n####################\n\n\n# ripe rewards\n\n\n@external\ndef setRipeRewards(_ripeRewards: RipeRewards):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n    self._setRipeRewards(_ripeRewards)\n\n\n@internal\ndef _setRipeRewards(_ripeRewards: RipeRewards):\n    self.ripeRewards = _ripeRewards\n    if _ripeRewards.newRipeRewards != 0:\n        self.ripeAvailForRewards -= min(self.ripeAvailForRewards, _ripeRewards.newRipeRewards)\n\n\n@external\ndef setRipeAvailForRewards(_amount: uint256):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n    self.ripeAvailForRewards = _amount\n\n\n# deposit points\n\n\n@external\ndef setDepositPointsAndRipeRewards(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _userPoints: UserDepositPoints,\n    _assetPoints: AssetDepositPoints,\n    _globalPoints: GlobalDepositPoints,\n    _ripeRewards: RipeRewards,\n):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    if _user != empty(address):\n        self.userDepositPoints[_user][_vaultId][_asset] = _userPoints\n    self.assetDepositPoints[_vaultId][_asset] = _assetPoints\n    self.globalDepositPoints = _globalPoints\n    self._setRipeRewards(_ripeRewards)\n\n\n# borrow points\n\n\n@external\ndef setBorrowPointsAndRipeRewards(\n    _user: address,\n    _userPoints: BorrowPoints,\n    _globalPoints: BorrowPoints,\n    _ripeRewards: RipeRewards,\n):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    self.globalBorrowPoints = _globalPoints\n    if _user != empty(address):\n        self.userBorrowPoints[_user] = _userPoints\n    self._setRipeRewards(_ripeRewards)\n\n\n# utils\n\n\n@view\n@external\ndef getRipeRewardsBundle() -> RipeRewardsBundle:\n    return RipeRewardsBundle(\n        ripeRewards=self.ripeRewards,\n        ripeAvailForRewards=self.ripeAvailForRewards,\n    )\n\n\n@view\n@external\ndef getBorrowPointsBundle(_user: address) -> BorrowPointsBundle:\n    return BorrowPointsBundle(\n        userPoints=self.userBorrowPoints[_user],\n        globalPoints=self.globalBorrowPoints,\n        userDebtPrincipal=self.userDebt[_user].principal,\n    )\n\n\n@view\n@external\ndef getDepositPointsBundle(_user: address, _vaultId: uint256, _asset: address) -> DepositPointsBundle:\n    userPoints: UserDepositPoints = empty(UserDepositPoints)\n    if _user != empty(address):\n        userPoints = self.userDepositPoints[_user][_vaultId][_asset]\n    return DepositPointsBundle(\n        userPoints=userPoints,\n        assetPoints=self.assetDepositPoints[_vaultId][_asset],\n        globalPoints=self.globalDepositPoints,\n    )\n\n\n############\n# Auctions #\n############\n\n\n@view\n@external\ndef hasFungibleAuctions(_liqUser: address) -> bool:\n    return self.numFungibleAuctions[_liqUser] != 0\n\n\n# create new auction\n\n\n@external\ndef createNewFungibleAuction(_auc: FungibleAuction) -> uint256:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    # fail gracefully if auction already exists\n    if self.fungibleAuctionIndex[_auc.liqUser][_auc.vaultId][_auc.asset] != 0:\n        return 0\n\n    # create new auction\n    aid: uint256 = self.numFungibleAuctions[_auc.liqUser]\n    if aid == 0:\n        aid = 1\n    self.fungibleAuctions[_auc.liqUser][aid] = _auc\n    self.fungibleAuctionIndex[_auc.liqUser][_auc.vaultId][_auc.asset] = aid\n    self.numFungibleAuctions[_auc.liqUser] = aid + 1\n\n    # register fungible liq user (if applicable)\n    if self.indexOfFungLiqUser[_auc.liqUser] == 0:\n        self._registerFungibleLiqUser(_auc.liqUser)\n\n    return aid\n\n\n# register fungible liq user\n\n\n@internal\ndef _registerFungibleLiqUser(_liqUser: address):\n    uid: uint256 = self.numFungLiqUsers\n    if uid == 0:\n        uid = 1\n    self.fungLiqUsers[uid] = _liqUser\n    self.indexOfFungLiqUser[_liqUser] = uid\n    self.numFungLiqUsers = uid + 1\n\n\n# removal fungible auction\n\n\n@external\ndef removeFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address):\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    numAuctions: uint256 = self.numFungibleAuctions[_liqUser]\n    if numAuctions == 0:\n        return\n\n    targetIndex: uint256 = self.fungibleAuctionIndex[_liqUser][_vaultId][_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAuctions - 1\n    self.numFungibleAuctions[_liqUser] = lastIndex\n    self.fungibleAuctionIndex[_liqUser][_vaultId][_asset] = 0\n\n    # have last auction replace the target auction\n    if targetIndex != lastIndex:\n        lastItem: FungibleAuction = self.fungibleAuctions[_liqUser][lastIndex]\n        self.fungibleAuctions[_liqUser][targetIndex] = lastItem\n        self.fungibleAuctionIndex[_liqUser][lastItem.vaultId][lastItem.asset] = targetIndex\n\n    # no more fungible auctions\n    if lastIndex <= 1:\n        self.numFungibleAuctions[_liqUser] = 0\n        self._removeFungLiqUser(_liqUser)\n\n\n# update auction\n\n\n@external\ndef setFungibleAuction(\n    _liqUser: address,\n    _vaultId: uint256,\n    _asset: address,\n    _auc: FungibleAuction,\n) -> bool:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    aid: uint256 = self.fungibleAuctionIndex[_liqUser][_vaultId][_asset]\n    if aid == 0:\n        return False # this does not yet exist\n\n    self.fungibleAuctions[_liqUser][aid] = _auc\n    return True\n\n\n# remove liq user\n\n\n@internal\ndef _removeFungLiqUser(_liqUser: address):\n    numUsers: uint256 = self.numFungLiqUsers\n    if numUsers == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfFungLiqUser[_liqUser]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numUsers - 1\n    self.numFungLiqUsers = lastIndex\n    self.indexOfFungLiqUser[_liqUser] = 0\n\n    # have last liq user replace the target liq user\n    if targetIndex != lastIndex:\n        lastUser: address = self.fungLiqUsers[lastIndex]\n        self.fungLiqUsers[targetIndex] = lastUser\n        self.indexOfFungLiqUser[lastUser] = targetIndex\n\n\n# remove all fungible auctions\n\n\n@external\ndef removeAllFungibleAuctions(_liqUser: address):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: only AuctionHouse or CreditEngine allowed\n    assert not deptBasics.isPaused # dev: not activated\n    self._removeAllFungibleAuctions(_liqUser)\n\n\n@internal\ndef _removeAllFungibleAuctions(_liqUser: address):\n    self._removeFungLiqUser(_liqUser)\n\n    numAuctions: uint256 = self.numFungibleAuctions[_liqUser]\n    if numAuctions == 0:\n        return\n\n    # zero out the auction indexes\n    for i: uint256 in range(1, numAuctions, bound=max_value(uint256)):\n        auc: FungibleAuction = self.fungibleAuctions[_liqUser][i]\n        self.fungibleAuctionIndex[_liqUser][auc.vaultId][auc.asset] = 0\n\n    # zero out total num\n    self.numFungibleAuctions[_liqUser] = 0\n\n\n# utils\n\n\n@view\n@external\ndef getFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address) -> FungibleAuction:\n    aid: uint256 = self.fungibleAuctionIndex[_liqUser][_vaultId][_asset]\n    return self.fungibleAuctions[_liqUser][aid]\n\n\n@view\n@external\ndef getFungibleAuctionDuringPurchase(_liqUser: address, _vaultId: uint256, _asset: address) -> FungibleAuction:\n    if not self.userDebt[_liqUser].inLiquidation:\n        return empty(FungibleAuction)\n    aid: uint256 = self.fungibleAuctionIndex[_liqUser][_vaultId][_asset]\n    return self.fungibleAuctions[_liqUser][aid]\n\n\n@view\n@external\ndef hasFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address) -> bool:\n    return self.fungibleAuctionIndex[_liqUser][_vaultId][_asset] != 0\n",
            "sha256sum": "c4c70c0c6bc44487a424c6c8698cd4872540e88d99b6513faaa62ad679c9e247"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/data/Ledger.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "dd7250ddb71a5c273b27537a820446eba86cd4f93938d22d39c5ffa5bbe432aa"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e00000000000000000000000000000000000000000052b7d2dcc80cd2e4000000"
    },
    "MissionControl": {
      "address": "0x179202Af28127775E44229688eA49DE73e6f11a3",
      "abi": [
        {
          "name": "UserConfigSet",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canAnyoneDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canAnyoneRepayDebt",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserDelegationSet",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "delegate",
              "type": "address",
              "indexed": true
            },
            {
              "name": "setter",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canBorrow",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimFromStabPool",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimLoot",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGeneralConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserMaxVaults",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxAssetsPerVault",
                  "type": "uint256"
                },
                {
                  "name": "priceStaleTime",
                  "type": "uint256"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                },
                {
                  "name": "canLiquidate",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGeneralDebtConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDebtAmount",
                  "type": "uint256"
                },
                {
                  "name": "numAllowedBorrowers",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "keeperFeeRatio",
                  "type": "uint256"
                },
                {
                  "name": "minKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "isDaowryEnabled",
                  "type": "bool"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "genAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewardsConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "arePointsEnabled",
                  "type": "bool"
                },
                {
                  "name": "ripePerBlock",
                  "type": "uint256"
                },
                {
                  "name": "borrowersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "votersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "genDepositorsAlloc",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultIds",
                  "type": "uint256[]"
                },
                {
                  "name": "stakersPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "perUserDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "shouldBurnAsPayment",
                  "type": "bool"
                },
                {
                  "name": "shouldTransferToEndaoment",
                  "type": "bool"
                },
                {
                  "name": "shouldSwapInStabPools",
                  "type": "bool"
                },
                {
                  "name": "shouldAuctionInstantly",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                },
                {
                  "name": "specialStabPoolId",
                  "type": "uint256"
                },
                {
                  "name": "customAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "whitelist",
                  "type": "address"
                },
                {
                  "name": "isNft",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedAssetInVault",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityPriceSourceIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityPriceSourceIds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256[]"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityLiqAssetVaults",
          "inputs": [
            {
              "name": "_priorityLiqAssetVaults",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityLiqAssetVaults",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityStabVaults",
          "inputs": [
            {
              "name": "_priorityStabVaults",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityStabVaults",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUnderscoreRegistry",
          "inputs": [
            {
              "name": "_underscoreRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPerformLiteAction",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canDo",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxLtvDeviation",
          "inputs": [
            {
              "name": "_maxLtvDeviation",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceStaleTime",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [
            {
              "name": "_canAnyoneDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [
            {
              "name": "_canAnyoneDeposit",
              "type": "bool"
            },
            {
              "name": "_canAnyoneRepayDebt",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_delegate",
              "type": "address"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canBorrow",
              "type": "bool"
            },
            {
              "name": "_canClaimFromStabPool",
              "type": "bool"
            },
            {
              "name": "_canClaimLoot",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_delegate",
              "type": "address"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canBorrow",
              "type": "bool"
            },
            {
              "name": "_canClaimFromStabPool",
              "type": "bool"
            },
            {
              "name": "_canClaimLoot",
              "type": "bool"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTellerDepositConfig",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canDepositGeneral",
                  "type": "bool"
                },
                {
                  "name": "canDepositAsset",
                  "type": "bool"
                },
                {
                  "name": "doesVaultSupportAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "perUserDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxAssetsPerVault",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxVaults",
                  "type": "uint256"
                },
                {
                  "name": "canAnyoneDeposit",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTellerWithdrawConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canWithdrawGeneral",
                  "type": "bool"
                },
                {
                  "name": "canWithdrawAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "canWithdrawForUser",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDebtTerms",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBorrowConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canBorrowForUser",
                  "type": "bool"
                },
                {
                  "name": "numAllowedBorrowers",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "perUserDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDebtAmount",
                  "type": "uint256"
                },
                {
                  "name": "isDaowryEnabled",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRepayConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canRepay",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneRepayDebt",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRedeemCollateralConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_redeemer",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canRedeemCollateralGeneral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateralAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLtvPaybackBuffer",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAuctionBuyConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_buyer",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canBuyInAuctionGeneral",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuctionAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGenLiqConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canLiquidate",
                  "type": "bool"
                },
                {
                  "name": "keeperFeeRatio",
                  "type": "uint256"
                },
                {
                  "name": "minKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "genAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "priorityLiqAssetVaults",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "vaultId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultAddr",
                      "type": "address"
                    },
                    {
                      "name": "asset",
                      "type": "address"
                    }
                  ]
                },
                {
                  "name": "priorityStabVaults",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "vaultId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultAddr",
                      "type": "address"
                    },
                    {
                      "name": "asset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGenAuctionParams",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasParams",
                  "type": "bool"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "delay",
                  "type": "uint256"
                },
                {
                  "name": "duration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetLiqConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasConfig",
                  "type": "bool"
                },
                {
                  "name": "shouldBurnAsPayment",
                  "type": "bool"
                },
                {
                  "name": "shouldTransferToEndaoment",
                  "type": "bool"
                },
                {
                  "name": "shouldSwapInStabPools",
                  "type": "bool"
                },
                {
                  "name": "shouldAuctionInstantly",
                  "type": "bool"
                },
                {
                  "name": "customAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "specialStabPool",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "vaultId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultAddr",
                      "type": "address"
                    },
                    {
                      "name": "asset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getStabPoolClaimsConfig",
          "inputs": [
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canClaimInStabPoolGeneral",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPoolAsset",
                  "type": "bool"
                },
                {
                  "name": "canClaimFromStabPoolForUser",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getStabPoolRedemptionsConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_redeemer",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canRedeemInStabPoolGeneral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPoolAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimLootConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                },
                {
                  "name": "canClaimLootForUser",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "arePointsEnabled",
                  "type": "bool"
                },
                {
                  "name": "ripePerBlock",
                  "type": "uint256"
                },
                {
                  "name": "borrowersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "votersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "genDepositorsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersPointsAllocTotal",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAllocTotal",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositPointsConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "stakersPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "isNft",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "staleTime",
                  "type": "uint256"
                },
                {
                  "name": "priorityPriceSourceIds",
                  "type": "uint256[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "genConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserMaxVaults",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxAssetsPerVault",
                  "type": "uint256"
                },
                {
                  "name": "priceStaleTime",
                  "type": "uint256"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                },
                {
                  "name": "canLiquidate",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "genDebtConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDebtAmount",
                  "type": "uint256"
                },
                {
                  "name": "numAllowedBorrowers",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "keeperFeeRatio",
                  "type": "uint256"
                },
                {
                  "name": "minKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "isDaowryEnabled",
                  "type": "bool"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "genAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultIds",
                  "type": "uint256[]"
                },
                {
                  "name": "stakersPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "perUserDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "shouldBurnAsPayment",
                  "type": "bool"
                },
                {
                  "name": "shouldTransferToEndaoment",
                  "type": "bool"
                },
                {
                  "name": "shouldSwapInStabPools",
                  "type": "bool"
                },
                {
                  "name": "shouldAuctionInstantly",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                },
                {
                  "name": "specialStabPoolId",
                  "type": "uint256"
                },
                {
                  "name": "customAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "whitelist",
                  "type": "address"
                },
                {
                  "name": "isNft",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canAnyoneDeposit",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneRepayDebt",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userDelegation",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canClaimFromStabPool",
                  "type": "bool"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "rewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "arePointsEnabled",
                  "type": "bool"
                },
                {
                  "name": "ripePerBlock",
                  "type": "uint256"
                },
                {
                  "name": "borrowersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "votersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "genDepositorsAlloc",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalPointsAllocs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "stakersPointsAllocTotal",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAllocTotal",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityPriceSourceIds",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityLiqAssetVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityStabVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "underscoreRegistry",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canPerformLiteAction",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxLtvDeviation",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "cdcbc1c83a0ffa09166c89d2698097b5dee00d2ebebf714134ab8faa6e9ff685"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/data/MissionControl.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\ninterface Whitelist:\n    def isUserAllowed(_user: address, _asset: address) -> bool: view\n\ninterface Vault:\n    def vaultAssets(_index: uint256) -> address: view\n\ninterface UnderscoreAgentFactory:\n    def isUserWallet(_addr: address) -> bool: view\n\ninterface UnderscoreRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface VaultBook:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface UnderscoreWallet:\n    def walletConfig() -> address: view\n\ninterface UnderscoreWalletConfig:\n    def owner() -> address: view\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct TotalPointsAllocs:\n    stakersPointsAllocTotal: uint256\n    voterPointsAllocTotal: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address\n\nstruct VaultData:\n    vaultId: uint256\n    vaultAddr: address\n    asset: address\n\n# helpers\n\nstruct TellerDepositConfig:\n    canDepositGeneral: bool\n    canDepositAsset: bool\n    doesVaultSupportAsset: bool\n    isUserAllowed: bool\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    perUserMaxAssetsPerVault: uint256\n    perUserMaxVaults: uint256\n    canAnyoneDeposit: bool\n\nstruct TellerWithdrawConfig:\n    canWithdrawGeneral: bool\n    canWithdrawAsset: bool\n    isUserAllowed: bool\n    canWithdrawForUser: bool\n\nstruct BorrowConfig:\n    canBorrow: bool\n    canBorrowForUser: bool\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    isDaowryEnabled: bool\n\nstruct RepayConfig:\n    canRepay: bool\n    canAnyoneRepayDebt: bool\n\nstruct RedeemCollateralConfig:\n    canRedeemCollateralGeneral: bool\n    canRedeemCollateralAsset: bool\n    isUserAllowed: bool\n    ltvPaybackBuffer: uint256\n\nstruct AuctionBuyConfig:\n    canBuyInAuctionGeneral: bool\n    canBuyInAuctionAsset: bool\n    isUserAllowed: bool\n\nstruct GenLiqConfig:\n    canLiquidate: bool\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n    priorityLiqAssetVaults: DynArray[VaultData, PRIORITY_VAULT_DATA]\n    priorityStabVaults: DynArray[VaultData, PRIORITY_VAULT_DATA]\n\nstruct AssetLiqConfig:\n    hasConfig: bool\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    customAuctionParams: AuctionParams\n    specialStabPool: VaultData\n\nstruct StabPoolClaimsConfig:\n    canClaimInStabPoolGeneral: bool\n    canClaimInStabPoolAsset: bool\n    canClaimFromStabPoolForUser: bool\n    isUserAllowed: bool\n\nstruct StabPoolRedemptionsConfig:\n    canRedeemInStabPoolGeneral: bool\n    canRedeemInStabPoolAsset: bool\n    isUserAllowed: bool\n\nstruct ClaimLootConfig:\n    canClaimLoot: bool\n    canClaimLootForUser: bool\n\nstruct RewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    stakersPointsAllocTotal: uint256\n    voterPointsAllocTotal: uint256\n\nstruct DepositPointsConfig:\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    isNft: bool\n\nstruct PriceConfig:\n    staleTime: uint256\n    priorityPriceSourceIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]\n\n# events\n\nevent UserConfigSet:\n    user: indexed(address)\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n\nevent UserDelegationSet:\n    user: indexed(address)\n    delegate: indexed(address)\n    setter: indexed(address)\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\n# global config\ngenConfig: public(GenConfig)\ngenDebtConfig: public(GenDebtConfig)\n\n# asset config\nassetConfig: public(HashMap[address, AssetConfig]) # asset -> config\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# user config\nuserConfig: public(HashMap[address, UserConfig]) # user -> config\nuserDelegation: public(HashMap[address, HashMap[address, ActionDelegation]]) # user -> caller -> config\n\n# ripe rewards\nrewardsConfig: public(RipeRewardsConfig)\ntotalPointsAllocs: public(TotalPointsAllocs)\n\n# priority data\npriorityPriceSourceIds: public(DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES])\npriorityLiqAssetVaults: public(DynArray[VaultLite, PRIORITY_VAULT_DATA])\npriorityStabVaults: public(DynArray[VaultLite, PRIORITY_VAULT_DATA])\n\n# other\nunderscoreRegistry: public(address)\ncanPerformLiteAction: public(HashMap[address, bool]) # user -> canPerformLiteAction\nmaxLtvDeviation: public(uint256)\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\nMAX_PRIORITY_PRICE_SOURCES: constant(uint256) = 10\nPRIORITY_VAULT_DATA: constant(uint256) = 20\nUNDERSCORE_AGENT_FACTORY_ID: constant(uint256) = 1\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n    self.numAssets = 1 # not using 0 index\n    self.maxLtvDeviation = 10_00 # 10% default\n\n\n#################\n# Global Config #\n#################\n\n\n# general\n\n\n@external\ndef setGeneralConfig(_config: GenConfig):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.genConfig = _config\n\n\n# debt\n\n\n@external\ndef setGeneralDebtConfig(_config: GenDebtConfig):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.genDebtConfig = _config\n\n\n# rewards\n\n\n@external\ndef setRipeRewardsConfig(_config: RipeRewardsConfig):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.rewardsConfig = _config\n\n\n################\n# Asset Config #\n################\n\n\n@external\ndef setAssetConfig(_asset: address, _config: AssetConfig):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._updatePointsAllocs(_asset, _config.stakersPointsAlloc, _config.voterPointsAlloc) # do first!\n    self.assetConfig[_asset] = _config\n\n    # register asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerAsset(_asset)\n\n\n# points allocs\n\n\n@internal\ndef _updatePointsAllocs(_asset: address, _newStakersPointsAlloc: uint256, _newVoterPointsAlloc: uint256):\n    totalPointsAllocs: TotalPointsAllocs = self.totalPointsAllocs\n\n    # remove old allocs\n    prevConfig: AssetConfig = self.assetConfig[_asset]\n    totalPointsAllocs.stakersPointsAllocTotal -= prevConfig.stakersPointsAlloc\n    totalPointsAllocs.voterPointsAllocTotal -= prevConfig.voterPointsAlloc\n\n    # add new allocs\n    totalPointsAllocs.stakersPointsAllocTotal += _newStakersPointsAlloc\n    totalPointsAllocs.voterPointsAllocTotal += _newVoterPointsAlloc\n    self.totalPointsAllocs = totalPointsAllocs\n\n\n# asset registration\n\n\n@internal\ndef _registerAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterAsset(_asset: address) -> bool:\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n# utils\n\n\n@view\n@external\ndef isSupportedAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@view\n@external\ndef isSupportedAssetInVault(_vaultId: uint256, _asset: address) -> bool:\n    return _vaultId in self.assetConfig[_asset].vaultIds\n\n\n@view\n@external\ndef getNumAssets() -> uint256:\n    return self._getNumAssets()\n\n\n@view\n@internal\ndef _getNumAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n#################\n# Priority Data #\n#################\n\n\n# price sources\n\n\n@external\ndef setPriorityPriceSourceIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.priorityPriceSourceIds = _priorityIds\n\n\n@view \n@external \ndef getPriorityPriceSourceIds() -> DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]:\n    return self.priorityPriceSourceIds\n\n\n# priority liq asset vaults\n\n\n@external\ndef setPriorityLiqAssetVaults(_priorityLiqAssetVaults: DynArray[VaultLite, PRIORITY_VAULT_DATA]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.priorityLiqAssetVaults = _priorityLiqAssetVaults\n\n\n@view \n@external \ndef getPriorityLiqAssetVaults() -> DynArray[VaultLite, PRIORITY_VAULT_DATA]:\n    return self.priorityLiqAssetVaults\n\n\n# stability pool vaults\n\n\n@external\ndef setPriorityStabVaults(_priorityStabVaults: DynArray[VaultLite, PRIORITY_VAULT_DATA]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.priorityStabVaults = _priorityStabVaults\n\n\n@view \n@external \ndef getPriorityStabVaults() -> DynArray[VaultLite, PRIORITY_VAULT_DATA]:\n    return self.priorityStabVaults\n\n\n#########\n# Other #\n#########\n\n\n# underscore registry\n\n\n@external\ndef setUnderscoreRegistry(_underscoreRegistry: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.underscoreRegistry = _underscoreRegistry\n\n\n# can perform lite action\n\n\n@external\ndef setCanPerformLiteAction(_user: address, _canDo: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.canPerformLiteAction[_user] = _canDo\n\n\n# max ltv deviation\n\n\n@external\ndef setMaxLtvDeviation(_maxLtvDeviation: uint256):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self.maxLtvDeviation = _maxLtvDeviation\n\n\n# stale price time\n\n\n@view\n@external\ndef getPriceStaleTime() -> uint256:\n    # used by Chainlink.vy\n    return self.genConfig.priceStaleTime\n\n\n###############\n# User Config #\n###############\n\n\n@external\ndef setUserConfig(\n    _canAnyoneDeposit: bool = True,\n    _canAnyoneRepayDebt: bool = True,\n) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    userConfig: UserConfig = UserConfig(\n        canAnyoneDeposit=_canAnyoneDeposit,\n        canAnyoneRepayDebt=_canAnyoneRepayDebt,\n    )\n    self.userConfig[msg.sender] = userConfig\n    log UserConfigSet(user=msg.sender, canAnyoneDeposit=_canAnyoneDeposit, canAnyoneRepayDebt=_canAnyoneRepayDebt)\n    return True\n\n\n# delegation\n\n\n@external\ndef setUserDelegation(\n    _delegate: address,\n    _canWithdraw: bool,\n    _canBorrow: bool,\n    _canClaimFromStabPool: bool,\n    _canClaimLoot: bool,\n    _user: address = msg.sender,\n) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert _delegate != empty(address) # dev: invalid delegate\n\n    # validate underscore wallet\n    if _user != msg.sender:\n        assert self._isUnderscoreWalletOwner(_user, msg.sender) # dev: not owner of underscore wallet\n\n    config: ActionDelegation = ActionDelegation(\n        canWithdraw=_canWithdraw,\n        canBorrow=_canBorrow,\n        canClaimFromStabPool=_canClaimFromStabPool,\n        canClaimLoot=_canClaimLoot,\n    )\n    self.userDelegation[_user][_delegate] = config\n    log UserDelegationSet(user=_user, delegate=_delegate, setter=msg.sender, canWithdraw=_canWithdraw, canBorrow=_canBorrow, canClaimFromStabPool=_canClaimFromStabPool, canClaimLoot=_canClaimLoot)\n    return True\n\n\n# underscore ownership check\n\n\n@view\n@internal\ndef _isUnderscoreWalletOwner(_user: address, _caller: address) -> bool:\n    underscore: address = self.underscoreRegistry\n    if underscore == empty(address):\n        return False\n\n    agentFactory: address = staticcall UnderscoreRegistry(underscore).getAddy(UNDERSCORE_AGENT_FACTORY_ID)\n    if agentFactory == empty(address):\n        return False\n\n    # must be underscore wallet\n    if not staticcall UnderscoreAgentFactory(agentFactory).isUserWallet(_user):\n        return False\n\n    walletConfig: address = staticcall UnderscoreWallet(_user).walletConfig()\n    if walletConfig == empty(address):\n        return False\n\n    # caller must be owner!\n    return staticcall UnderscoreWalletConfig(walletConfig).owner() == _caller\n\n\n###################\n# Helpers / Views #\n###################\n\n\n# is user allowed\n\n\n@view\n@internal\ndef _isUserAllowed(_whitelist: address, _user: address, _asset: address) -> bool:\n    isUserAllowed: bool = True \n    if _whitelist != empty(address):\n        isUserAllowed = staticcall Whitelist(_whitelist).isUserAllowed(_user, _asset)\n    return isUserAllowed\n\n\n# deposits\n\n\n@view\n@external\ndef getTellerDepositConfig(_vaultId: uint256, _asset: address, _user: address) -> TellerDepositConfig:\n    assetConfig: AssetConfig = self.assetConfig[_asset]\n    genConfig: GenConfig = self.genConfig\n    return TellerDepositConfig(\n        canDepositGeneral=genConfig.canDeposit,\n        canDepositAsset=assetConfig.canDeposit,\n        doesVaultSupportAsset=_vaultId in assetConfig.vaultIds,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _user, _asset),\n        perUserDepositLimit=assetConfig.perUserDepositLimit,\n        globalDepositLimit=assetConfig.globalDepositLimit,\n        perUserMaxAssetsPerVault=genConfig.perUserMaxAssetsPerVault,\n        perUserMaxVaults=genConfig.perUserMaxVaults,\n        canAnyoneDeposit=self.userConfig[_user].canAnyoneDeposit,\n    )\n\n\n# withdrawals\n\n\n@view\n@external\ndef getTellerWithdrawConfig(_asset: address, _user: address, _caller: address) -> TellerWithdrawConfig:\n    assetConfig: AssetConfig = self.assetConfig[_asset]\n\n    canWithdrawForUser: bool = True\n    if _user != _caller:\n        delegation: ActionDelegation = self.userDelegation[_user][_caller]\n        canWithdrawForUser = delegation.canWithdraw\n\n    return TellerWithdrawConfig(\n        canWithdrawGeneral=self.genConfig.canWithdraw,\n        canWithdrawAsset=assetConfig.canWithdraw,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _user, _asset),\n        canWithdrawForUser=canWithdrawForUser,\n    )\n\n\n# borrow\n\n\n@view\n@external\ndef getDebtTerms(_asset: address) -> DebtTerms:\n    return self.assetConfig[_asset].debtTerms\n\n\n@view\n@external\ndef getBorrowConfig(_user: address, _caller: address) -> BorrowConfig:\n    genDebtConfig: GenDebtConfig = self.genDebtConfig\n\n    canBorrowForUser: bool = True\n    if _user != _caller:\n        delegation: ActionDelegation = self.userDelegation[_user][_caller]\n        canBorrowForUser = delegation.canBorrow\n\n    return BorrowConfig(\n        canBorrow=self.genConfig.canBorrow,\n        canBorrowForUser=canBorrowForUser,\n        numAllowedBorrowers=genDebtConfig.numAllowedBorrowers,\n        maxBorrowPerInterval=genDebtConfig.maxBorrowPerInterval,\n        numBlocksPerInterval=genDebtConfig.numBlocksPerInterval,\n        perUserDebtLimit=genDebtConfig.perUserDebtLimit,\n        globalDebtLimit=genDebtConfig.globalDebtLimit,\n        minDebtAmount=genDebtConfig.minDebtAmount,\n        isDaowryEnabled=genDebtConfig.isDaowryEnabled,\n    )\n\n\n# repay\n\n\n@view\n@external\ndef getRepayConfig(_user: address) -> RepayConfig:\n    return RepayConfig(\n        canRepay=self.genConfig.canRepay,\n        canAnyoneRepayDebt=self.userConfig[_user].canAnyoneRepayDebt,\n    )\n\n\n# redeem collateral\n\n\n@view\n@external\ndef getRedeemCollateralConfig(_asset: address, _redeemer: address) -> RedeemCollateralConfig:\n    assetConfig: AssetConfig = self.assetConfig[_asset]\n    return RedeemCollateralConfig(\n        canRedeemCollateralGeneral=self.genConfig.canRedeemCollateral,\n        canRedeemCollateralAsset=assetConfig.canRedeemCollateral,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _redeemer, _asset),\n        ltvPaybackBuffer=self.genDebtConfig.ltvPaybackBuffer,\n    )\n\n\n@view\n@external\ndef getLtvPaybackBuffer() -> uint256:\n    return self.genDebtConfig.ltvPaybackBuffer\n\n\n# auction purchases\n\n\n@view\n@external\ndef getAuctionBuyConfig(_asset: address, _buyer: address) -> AuctionBuyConfig:\n    assetConfig: AssetConfig = self.assetConfig[_asset]\n    return AuctionBuyConfig(\n        canBuyInAuctionGeneral=self.genConfig.canBuyInAuction,\n        canBuyInAuctionAsset=assetConfig.canBuyInAuction,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _buyer, _asset),\n    )\n\n\n# general liquidation config\n\n\n@view\n@external\ndef getGenLiqConfig() -> GenLiqConfig:\n    genDebtConfig: GenDebtConfig = self.genDebtConfig\n    vaultBook: address = addys._getVaultBookAddr()\n\n    # priority liq asset vault data\n    priorityLiqAssetVaults: DynArray[VaultData, PRIORITY_VAULT_DATA] = []\n    for pData: VaultLite in self.priorityLiqAssetVaults:\n        vaultAddr: address = staticcall VaultBook(vaultBook).getAddr(pData.vaultId)\n        priorityLiqAssetVaults.append(VaultData(vaultId=pData.vaultId, vaultAddr=vaultAddr, asset=pData.asset))\n\n    # stability pool vault data\n    priorityStabVaults: DynArray[VaultData, PRIORITY_VAULT_DATA] = []\n    for pData: VaultLite in self.priorityStabVaults:\n        vaultAddr: address = staticcall VaultBook(vaultBook).getAddr(pData.vaultId)\n        priorityStabVaults.append(VaultData(vaultId=pData.vaultId, vaultAddr=vaultAddr, asset=pData.asset))\n\n    return GenLiqConfig(\n        canLiquidate=self.genConfig.canLiquidate,\n        keeperFeeRatio=genDebtConfig.keeperFeeRatio,\n        minKeeperFee=genDebtConfig.minKeeperFee,\n        ltvPaybackBuffer=genDebtConfig.ltvPaybackBuffer,\n        genAuctionParams=genDebtConfig.genAuctionParams,\n        priorityLiqAssetVaults=priorityLiqAssetVaults,\n        priorityStabVaults=priorityStabVaults,\n    )\n\n\n@view\n@external\ndef getGenAuctionParams() -> AuctionParams:\n    return self.genDebtConfig.genAuctionParams\n\n\n# asset liquidation config\n\n\n@view\n@external\ndef getAssetLiqConfig(_asset: address) -> AssetLiqConfig:\n    assetConfig: AssetConfig = self.assetConfig[_asset]\n    vaultBook: address = addys._getVaultBookAddr()\n\n    # handle special stab pool\n    specialStabPool: VaultData = empty(VaultData)\n    if assetConfig.specialStabPoolId != 0:\n        specialVaultAddr: address = staticcall VaultBook(vaultBook).getAddr(assetConfig.specialStabPoolId)\n        if specialVaultAddr != empty(address):\n            firstAsset: address = staticcall Vault(specialVaultAddr).vaultAssets(1) # get first asset\n            if firstAsset != empty(address):\n                specialStabPool = VaultData(\n                    vaultId=assetConfig.specialStabPoolId,\n                    vaultAddr=specialVaultAddr,\n                    asset=firstAsset\n                )\n\n    return AssetLiqConfig(\n        hasConfig=True,\n        shouldBurnAsPayment=assetConfig.shouldBurnAsPayment,\n        shouldTransferToEndaoment=assetConfig.shouldTransferToEndaoment,\n        shouldSwapInStabPools=assetConfig.shouldSwapInStabPools,\n        shouldAuctionInstantly=assetConfig.shouldAuctionInstantly,\n        customAuctionParams=assetConfig.customAuctionParams,\n        specialStabPool=specialStabPool,\n    )\n\n\n# stability pool claims\n\n\n@view\n@external\ndef getStabPoolClaimsConfig(_claimAsset: address, _claimer: address, _caller: address) -> StabPoolClaimsConfig:\n    assetConfig: AssetConfig = self.assetConfig[_claimAsset]\n\n    canClaimFromStabPoolForUser: bool = True\n    if _claimer != _caller:\n        delegation: ActionDelegation = self.userDelegation[_claimer][_caller]\n        canClaimFromStabPoolForUser = delegation.canClaimFromStabPool\n\n    return StabPoolClaimsConfig(\n        canClaimInStabPoolGeneral=self.genConfig.canClaimInStabPool,\n        canClaimInStabPoolAsset=assetConfig.canClaimInStabPool,\n        canClaimFromStabPoolForUser=canClaimFromStabPoolForUser,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _claimer, _claimAsset),\n    )\n\n\n# stability pool redemptions\n\n\n@view\n@external\ndef getStabPoolRedemptionsConfig(_asset: address, _redeemer: address) -> StabPoolRedemptionsConfig:\n    assetConfig: AssetConfig = self.assetConfig[_asset]\n    return StabPoolRedemptionsConfig(\n        canRedeemInStabPoolGeneral=self.genConfig.canRedeemInStabPool,\n        canRedeemInStabPoolAsset=assetConfig.canRedeemInStabPool,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _redeemer, _asset),\n    )\n\n\n# loot claims\n\n\n@view\n@external\ndef getClaimLootConfig(_user: address, _caller: address) -> ClaimLootConfig:\n    canClaimLootForUser: bool = True\n    if _user != _caller:\n        delegation: ActionDelegation = self.userDelegation[_user][_caller]\n        canClaimLootForUser = delegation.canClaimLoot\n    return ClaimLootConfig(\n        canClaimLoot=self.genConfig.canClaimLoot,\n        canClaimLootForUser=canClaimLootForUser,\n    )\n\n\n# rewards config\n\n\n@view\n@external\ndef getRewardsConfig() -> RewardsConfig:\n    rewardsConfig: RipeRewardsConfig = self.rewardsConfig\n    totalPointsAllocs: TotalPointsAllocs = self.totalPointsAllocs\n    return RewardsConfig(\n        arePointsEnabled=rewardsConfig.arePointsEnabled,\n        ripePerBlock=rewardsConfig.ripePerBlock,\n        borrowersAlloc=rewardsConfig.borrowersAlloc,\n        stakersAlloc=rewardsConfig.stakersAlloc,\n        votersAlloc=rewardsConfig.votersAlloc,\n        genDepositorsAlloc=rewardsConfig.genDepositorsAlloc,\n        stakersPointsAllocTotal=totalPointsAllocs.stakersPointsAllocTotal,\n        voterPointsAllocTotal=totalPointsAllocs.voterPointsAllocTotal,\n    )\n\n\n# deposit points\n\n\n@view\n@external\ndef getDepositPointsConfig(_asset: address) -> DepositPointsConfig:\n    assetConfig: AssetConfig = self.assetConfig[_asset]\n    return DepositPointsConfig(\n        stakersPointsAlloc=assetConfig.stakersPointsAlloc,\n        voterPointsAlloc=assetConfig.voterPointsAlloc,\n        isNft=assetConfig.isNft,\n    )\n\n\n# price config\n\n\n@view\n@external\ndef getPriceConfig() -> PriceConfig:\n    return PriceConfig(\n        staleTime=self.genConfig.priceStaleTime,\n        priorityPriceSourceIds=self.priorityPriceSourceIds,\n    )\n",
            "sha256sum": "21f6fb2f4852a9c1b33c1866521812a5a12c1c576f84036c81e8782ae6dbda9d"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/data/MissionControl.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "e7ae7204afe8c3b2b7a26233e355f8e33f26eac753072e3d4156208558585ecb"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e"
    },
    "PriceDesk": {
      "address": "0x13a7b15401f16Ae4b957F4505e9e2E90311Cc5A2",
      "abi": [
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/registries/modules/AddressRegistry.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "45a6786be62ebfcd266d4b9f321aa22bfc8d125d6ce75ffcf4d895ad011ff661"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "cdcbc1c83a0ffa09166c89d2698097b5dee00d2ebebf714134ab8faa6e9ff685"
          },
          "interfaces/PriceSource.vyi": {
            "content": "# @version 0.4.1\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, 50]:\n    ...\n\n\n################\n# Feed Changes #\n################\n\n\n# new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    ...\n\n\n# update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n# disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n#############\n# Time Lock #\n#############\n\n\n@view\n@external\ndef actionTimeLock() -> uint256:\n    ...\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    ...\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    ...\n\n\n@external\ndef setActionTimeLock(_numBlocks: uint256) -> bool:\n    ...\n\n\n@external\ndef setActionTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "289828f43691dc382bce6ee0caf4cbdf0a49db41bae788bfcf7e23056b5a5d25"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/registries/PriceDesk.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.registries.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import PriceSource\nfrom interfaces import Department\nfrom ethereum.ercs import IERC20Detailed\n\ninterface MissionControl:\n    def getPriceConfig() -> PriceConfig: view\n\nstruct PriceConfig:\n    staleTime: uint256\n    priorityPriceSourceIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]\n\nETH: public(immutable(address))\nMAX_PRIORITY_PRICE_SOURCES: constant(uint256) = 10\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _ethAddr: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    assert _ethAddr != empty(address) # dev: invalid eth addr\n    ETH = _ethAddr\n\n    # modules\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"PriceDesk.vy\")\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n\n#############################\n# Asset Amount -> USD Value #\n#############################\n\n\n@view\n@external\ndef getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256:\n    if _amount == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return price * _amount // (10 ** decimals)\n\n\n#############################\n# USD Value -> Asset Amount #\n#############################\n\n\n@view\n@external\ndef getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    if _usdValue == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return _usdValue * (10 ** decimals) // price\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    if _asset == empty(address):\n        return 0\n    return self._getPrice(_asset, _shouldRaise)\n\n\n@view\n@internal\ndef _getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    price: uint256 = 0\n    hasFeedConfig: bool = False\n    alreadyLooked: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES] = []\n\n    # config\n    config: PriceConfig = staticcall MissionControl(addys._getMissionControlAddr()).getPriceConfig()\n\n    # go thru priority partners first\n    for pid: uint256 in config.priorityPriceSourceIds:\n        hasFeed: bool = False\n        price, hasFeed = self._getPriceFromPriceSource(pid, _asset, config.staleTime)\n        if price != 0:\n            break\n        if hasFeed:\n            hasFeedConfig = True\n        alreadyLooked.append(pid)\n\n    # go thru rest of price sources\n    if price == 0:\n        numSources: uint256 = registry.numAddrs\n        if numSources != 0:\n            for pid: uint256 in range(1, numSources, bound=max_value(uint256)):\n                if pid in alreadyLooked:\n                    continue\n                hasFeed: bool = False\n                price, hasFeed = self._getPriceFromPriceSource(pid, _asset, config.staleTime)\n                if price != 0:\n                    break\n                if hasFeed:\n                    hasFeedConfig = True\n\n    # raise exception if feed exists but no price\n    if price == 0 and hasFeedConfig and _shouldRaise:\n        raise \"has price config, no price\"\n\n    return price\n\n\n@view\n@internal\ndef _getPriceFromPriceSource(_pid: uint256, _asset: address, _staleTime: uint256) -> (uint256, bool):\n    priceSource: address = registry._getAddr(_pid)\n    if priceSource == empty(address):\n        return 0, False\n    return staticcall PriceSource(priceSource).getPriceAndHasFeed(_asset, _staleTime, self)\n\n\n###############\n# Other Utils #\n###############\n\n\n# ETH\n\n\n@view\n@external\ndef getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256:\n    if _amount == 0:\n        return 0\n    return self._getPrice(ETH, _shouldRaise) * _amount // (10 ** 18)\n\n\n@view\n@external\ndef getEthAmount(_usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    if _usdValue == 0:\n        return 0\n    price: uint256 = self._getPrice(ETH, _shouldRaise)\n    if price == 0:\n        return 0\n    return _usdValue * (10 ** 18) // price\n\n\n# has feed\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    numSources: uint256 = registry.numAddrs\n    for pid: uint256 in range(1, numSources, bound=max_value(uint256)):\n        priceSource: address = registry._getAddr(pid)\n        if priceSource == empty(address):\n            continue\n        if staticcall PriceSource(priceSource).hasPriceFeed(_asset):\n            return True\n    return False\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n",
            "sha256sum": "dde7786b28d9ab83f28791331a5cd343b2565b61373bdb59f6c570a42ef41aae"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/PriceDesk.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "155fc39ad4a9142a0a5dbaa42c9a2a30deed3d356a9674cf6d829c39e8f2a513"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "MockUsdcFeed": {
      "address": "0x93C1B5e9063773d6E8EcDEEDc2658305e53F5B43",
      "abi": [
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernance",
          "inputs": [
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "latestRoundData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "roundId",
                  "type": "uint80"
                },
                {
                  "name": "answer",
                  "type": "int256"
                },
                {
                  "name": "startedAt",
                  "type": "uint256"
                },
                {
                  "name": "updatedAt",
                  "type": "uint256"
                },
                {
                  "name": "answeredInRound",
                  "type": "uint80"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDecimals",
          "inputs": [
            {
              "name": "_decimals",
              "type": "uint8"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            },
            {
              "name": "_updatedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_localPrice",
              "type": "uint256"
            },
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/mock/MockChainlinkFeed.vy": {
            "content": "# @version 0.4.1\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nmockData: ChainlinkRound\n_decimals: uint8\n\n\ngovernance: public(address)\n\n@deploy\ndef __init__(_localPrice: uint256, _governance: address): # should be 18 decimals\n    self.governance = _governance\n    self._decimals = 8\n    if _localPrice != 0:\n        self.mockData = ChainlinkRound(\n            roundId=1,\n            answer=convert(_localPrice // (10 ** 10), int256),\n            startedAt=block.timestamp,\n            updatedAt=block.timestamp,\n            answeredInRound=1,\n        )\n\n    # set governance\n    self.governance = _governance\n\n@external\ndef setGovernance(\n    _governance: address,\n):\n    assert msg.sender == self.governance\n    self.governance = _governance\n\n@view \n@external \ndef latestRoundData() -> ChainlinkRound:\n    return self.mockData\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return self._decimals\n\n\n@external\ndef setDecimals(\n    _decimals: uint8,\n):\n    self._decimals = _decimals\n\n\n@external\ndef setMockData(\n    _price: int256, # 8 decimals\n    _roundId: uint80 = 1,\n    _answeredInRound: uint80 = 1,\n    _startedAt: uint256 = block.timestamp,\n    _updatedAt: uint256 = block.timestamp,\n):\n    assert msg.sender == self.governance\n    self.mockData = ChainlinkRound(\n        roundId=_roundId,\n        answer=_price,\n        startedAt=_startedAt,\n        updatedAt=_updatedAt,\n        answeredInRound=_answeredInRound,\n    )",
            "sha256sum": "8e162121c8d47bcffbbda16175bee3e50dee2728b27efc631cf5454c1cc9f4a7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/MockChainlinkFeed.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "cd94a10aedb3a0d0a09db7c4d017483c8a53cbc51df3f58e3b03e659c6a0dede"
      },
      "args": "0000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7"
    },
    "MockBtcFeed": {
      "address": "0xa3E216FDf96D7e7c7AfAEdfc1d99bc3F1aB5ab3d",
      "abi": [
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernance",
          "inputs": [
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "latestRoundData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "roundId",
                  "type": "uint80"
                },
                {
                  "name": "answer",
                  "type": "int256"
                },
                {
                  "name": "startedAt",
                  "type": "uint256"
                },
                {
                  "name": "updatedAt",
                  "type": "uint256"
                },
                {
                  "name": "answeredInRound",
                  "type": "uint80"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDecimals",
          "inputs": [
            {
              "name": "_decimals",
              "type": "uint8"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            },
            {
              "name": "_updatedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_localPrice",
              "type": "uint256"
            },
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/mock/MockChainlinkFeed.vy": {
            "content": "# @version 0.4.1\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nmockData: ChainlinkRound\n_decimals: uint8\n\n\ngovernance: public(address)\n\n@deploy\ndef __init__(_localPrice: uint256, _governance: address): # should be 18 decimals\n    self.governance = _governance\n    self._decimals = 8\n    if _localPrice != 0:\n        self.mockData = ChainlinkRound(\n            roundId=1,\n            answer=convert(_localPrice // (10 ** 10), int256),\n            startedAt=block.timestamp,\n            updatedAt=block.timestamp,\n            answeredInRound=1,\n        )\n\n    # set governance\n    self.governance = _governance\n\n@external\ndef setGovernance(\n    _governance: address,\n):\n    assert msg.sender == self.governance\n    self.governance = _governance\n\n@view \n@external \ndef latestRoundData() -> ChainlinkRound:\n    return self.mockData\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return self._decimals\n\n\n@external\ndef setDecimals(\n    _decimals: uint8,\n):\n    self._decimals = _decimals\n\n\n@external\ndef setMockData(\n    _price: int256, # 8 decimals\n    _roundId: uint80 = 1,\n    _answeredInRound: uint80 = 1,\n    _startedAt: uint256 = block.timestamp,\n    _updatedAt: uint256 = block.timestamp,\n):\n    assert msg.sender == self.governance\n    self.mockData = ChainlinkRound(\n        roundId=_roundId,\n        answer=_price,\n        startedAt=_startedAt,\n        updatedAt=_updatedAt,\n        answeredInRound=_answeredInRound,\n    )",
            "sha256sum": "8e162121c8d47bcffbbda16175bee3e50dee2728b27efc631cf5454c1cc9f4a7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/MockChainlinkFeed.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "cd94a10aedb3a0d0a09db7c4d017483c8a53cbc51df3f58e3b03e659c6a0dede"
      },
      "args": "00000000000000000000000000000000000000000000152d02c7e14af68000000000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7"
    },
    "MockEthFeed": {
      "address": "0x12FB9866F8889ba91e63083617ed197489687472",
      "abi": [
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernance",
          "inputs": [
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "latestRoundData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "roundId",
                  "type": "uint80"
                },
                {
                  "name": "answer",
                  "type": "int256"
                },
                {
                  "name": "startedAt",
                  "type": "uint256"
                },
                {
                  "name": "updatedAt",
                  "type": "uint256"
                },
                {
                  "name": "answeredInRound",
                  "type": "uint80"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDecimals",
          "inputs": [
            {
              "name": "_decimals",
              "type": "uint8"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            },
            {
              "name": "_updatedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_localPrice",
              "type": "uint256"
            },
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/mock/MockChainlinkFeed.vy": {
            "content": "# @version 0.4.1\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nmockData: ChainlinkRound\n_decimals: uint8\n\n\ngovernance: public(address)\n\n@deploy\ndef __init__(_localPrice: uint256, _governance: address): # should be 18 decimals\n    self.governance = _governance\n    self._decimals = 8\n    if _localPrice != 0:\n        self.mockData = ChainlinkRound(\n            roundId=1,\n            answer=convert(_localPrice // (10 ** 10), int256),\n            startedAt=block.timestamp,\n            updatedAt=block.timestamp,\n            answeredInRound=1,\n        )\n\n    # set governance\n    self.governance = _governance\n\n@external\ndef setGovernance(\n    _governance: address,\n):\n    assert msg.sender == self.governance\n    self.governance = _governance\n\n@view \n@external \ndef latestRoundData() -> ChainlinkRound:\n    return self.mockData\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return self._decimals\n\n\n@external\ndef setDecimals(\n    _decimals: uint8,\n):\n    self._decimals = _decimals\n\n\n@external\ndef setMockData(\n    _price: int256, # 8 decimals\n    _roundId: uint80 = 1,\n    _answeredInRound: uint80 = 1,\n    _startedAt: uint256 = block.timestamp,\n    _updatedAt: uint256 = block.timestamp,\n):\n    assert msg.sender == self.governance\n    self.mockData = ChainlinkRound(\n        roundId=_roundId,\n        answer=_price,\n        startedAt=_startedAt,\n        updatedAt=_updatedAt,\n        answeredInRound=_answeredInRound,\n    )",
            "sha256sum": "8e162121c8d47bcffbbda16175bee3e50dee2728b27efc631cf5454c1cc9f4a7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/MockChainlinkFeed.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "cd94a10aedb3a0d0a09db7c4d017483c8a53cbc51df3f58e3b03e659c6a0dede"
      },
      "args": "0000000000000000000000000000000000000000000000878678326eac9000000000000000000000000000003fbe79100d2b637d577f1d2d8d14c9825f869db7"
    },
    "Chainlink": {
      "address": "0x9fB69F873d24078935E1678BD61Db7675b8B6Ef4",
      "abi": [
        {
          "name": "NewChainlinkFeedPending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewChainlinkFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewChainlinkFeedCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedUpdatePending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "oldFeed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedUpdated",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "oldFeed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedUpdateCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "oldFeed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisableChainlinkFeedPending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisableChainlinkFeedCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourcePauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourceFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricedAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_ACTION_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_ACTION_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewPendingPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUpdateFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "feed",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "needsEthToUsd",
                  "type": "bool"
                },
                {
                  "name": "needsBtcToUsd",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUpdates",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "actionId",
                  "type": "uint256"
                },
                {
                  "name": "config",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "feed",
                      "type": "address"
                    },
                    {
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "name": "needsEthToUsd",
                      "type": "bool"
                    },
                    {
                      "name": "needsBtcToUsd",
                      "type": "bool"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "BTC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minPriceChangeTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxPriceChangeTimeLock",
              "type": "uint256"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_btcAddr",
              "type": "address"
            },
            {
              "name": "_ethUsdFeed",
              "type": "address"
            },
            {
              "name": "_btcUsdFeed",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/priceSources/modules/PriceSourceData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent PriceSourcePauseModified:\n    isPaused: bool\n\nevent PriceSourceFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# priced assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n##############\n# Asset Data #\n##############\n\n\n# add priced asset\n\n\n@internal\ndef _addPricedAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove priced asset\n\n\n@internal\ndef _removePricedAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n\n# get priced assets\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log PriceSourcePauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log PriceSourceFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "51688ce305f327581c761294d11a45d4d2bfa3a09fb3b76edd5501b0323ad860"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: public(immutable(uint256))\nMAX_ACTION_TIMELOCK: public(immutable(uint256))\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "a46b5a99a1f326aaa7280f656bd284c654cfd5afb2dd208b79e701f9028ee605"
          },
          "interfaces/PriceSource.vyi": {
            "content": "# @version 0.4.1\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, 50]:\n    ...\n\n\n################\n# Feed Changes #\n################\n\n\n# new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    ...\n\n\n# update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n# disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n#############\n# Time Lock #\n#############\n\n\n@view\n@external\ndef actionTimeLock() -> uint256:\n    ...\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    ...\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    ...\n\n\n@external\ndef setActionTimeLock(_numBlocks: uint256) -> bool:\n    ...\n\n\n@external\ndef setActionTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "289828f43691dc382bce6ee0caf4cbdf0a49db41bae788bfcf7e23056b5a5d25"
          },
          "contracts/priceSources/Chainlink.vy": {
            "content": "# @version 0.4.1\n\nimplements: PriceSource\n\nexports: gov.__interface__\nexports: addys.__interface__\nexports: priceData.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: addys\ninitializes: priceData[addys := addys]\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Addys as addys\nimport contracts.priceSources.modules.PriceSourceData as priceData\nimport contracts.modules.TimeLock as timeLock\n\nimport interfaces.PriceSource as PriceSource\n\ninterface ChainlinkFeed:\n    def latestRoundData() -> ChainlinkRound: view\n    def decimals() -> uint8: view \n\ninterface MissionControl:\n    def getPriceStaleTime() -> uint256: view\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nstruct ChainlinkConfig:\n    feed: address\n    decimals: uint256\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nstruct PendingChainlinkConfig:\n    actionId: uint256\n    config: ChainlinkConfig\n\nevent NewChainlinkFeedPending:\n    asset: indexed(address)\n    feed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent NewChainlinkFeedAdded:\n    asset: indexed(address)\n    feed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nevent NewChainlinkFeedCancelled:\n    asset: indexed(address)\n    feed: indexed(address)\n\nevent ChainlinkFeedUpdatePending:\n    asset: indexed(address)\n    feed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n    confirmationBlock: uint256\n    oldFeed: indexed(address)\n    actionId: uint256\n\nevent ChainlinkFeedUpdated:\n    asset: indexed(address)\n    feed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n    oldFeed: indexed(address)\n\nevent ChainlinkFeedUpdateCancelled:\n    asset: indexed(address)\n    feed: indexed(address)\n    oldFeed: indexed(address)\n\nevent DisableChainlinkFeedPending:\n    asset: indexed(address)\n    feed: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent ChainlinkFeedDisabled:\n    asset: indexed(address)\n    feed: indexed(address)\n\nevent DisableChainlinkFeedCancelled:\n    asset: indexed(address)\n    feed: indexed(address)\n\n# core config\nfeedConfig: public(HashMap[address, ChainlinkConfig]) # asset -> config\n\n# pending changes\npendingUpdates: public(HashMap[address, PendingChainlinkConfig]) # asset -> config\n\n# default assets\nWETH: public(immutable(address))\nETH: public(immutable(address))\nBTC: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minPriceChangeTimeLock: uint256,\n    _maxPriceChangeTimeLock: uint256,\n    _wethAddr: address,\n    _ethAddr: address,\n    _btcAddr: address,\n    _ethUsdFeed: address,\n    _btcUsdFeed: address,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    addys.__init__(_ripeHq)\n    priceData.__init__(False)\n    timeLock.__init__(_minPriceChangeTimeLock, _maxPriceChangeTimeLock, 0, _maxPriceChangeTimeLock)\n\n    # set default assets\n    assert empty(address) not in [_wethAddr, _ethAddr, _btcAddr] # dev: invalid asset addrs\n    WETH = _wethAddr\n    ETH = _ethAddr\n    BTC = _btcAddr\n\n    # set default feeds\n    if _ethUsdFeed != empty(address):\n        assert self._setDefaultFeedOnDeploy(_ethAddr, _ethUsdFeed) # dev: invalid feed\n        assert self._setDefaultFeedOnDeploy(_wethAddr, _ethUsdFeed) # dev: invalid feed\n    if _btcUsdFeed != empty(address):\n        assert self._setDefaultFeedOnDeploy(_btcAddr, _btcUsdFeed) # dev: invalid feed\n\n\n# set default feeds\n\n\n@internal\ndef _setDefaultFeedOnDeploy(_asset: address, _newFeed: address) -> bool:\n    decimals: uint256 = convert(staticcall ChainlinkFeed(_newFeed).decimals(), uint256)\n    if not self._isValidNewFeed(_asset, _newFeed, decimals, False, False):\n        return False\n    self.feedConfig[_asset] = ChainlinkConfig(\n        feed=_newFeed,\n        decimals=decimals,\n        needsEthToUsd=False,\n        needsBtcToUsd=False,\n    )\n    priceData._addPricedAsset(_asset)\n    return True\n\n\n###############\n# Core Prices #\n###############\n\n\n# get price\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> uint256:\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> (uint256, bool):\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0, False\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(\n    _feed: address, \n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n    _staleTime: uint256,\n) -> uint256:\n    price: uint256 = self._getChainlinkData(_feed, _decimals, _staleTime)\n    if price == 0:\n        return 0\n\n    # if price needs ETH -> USD conversion\n    if _needsEthToUsd:\n        ethConfig: ChainlinkConfig = self.feedConfig[ETH]\n        ethUsdPrice: uint256 = self._getChainlinkData(ethConfig.feed, ethConfig.decimals, _staleTime)\n        price = price * ethUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    # if price needs BTC -> USD conversion\n    elif _needsBtcToUsd:\n        btcConfig: ChainlinkConfig = self.feedConfig[BTC]\n        btcUsdPrice: uint256 = self._getChainlinkData(btcConfig.feed, btcConfig.decimals, _staleTime)\n        price = price * btcUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    return price\n\n\n# utilities\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset].feed != empty(address)\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    return timeLock._hasPendingAction(self.pendingUpdates[_asset].actionId)\n\n\n##################\n# Chainlink Data #\n##################\n\n\n@view\n@external\ndef getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256 = 0) -> uint256:\n    return self._getChainlinkData(_feed, _decimals, _staleTime)\n\n\n@view\n@internal\ndef _getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256) -> uint256:\n    oracle: ChainlinkRound = staticcall ChainlinkFeed(_feed).latestRoundData()\n\n    # oracle has no price\n    if oracle.answer <= 0:\n        return 0\n\n    # bad decimals\n    if _decimals > NORMALIZED_DECIMALS:\n        return 0\n\n    # cannot have future timestamp\n    if oracle.updatedAt > block.timestamp:\n        return 0\n\n    # validate round ID\n    if oracle.roundId == 0:\n        return 0\n    if oracle.answeredInRound < oracle.roundId:\n        return 0\n\n    # price is too stale\n    if _staleTime != 0 and block.timestamp - oracle.updatedAt > _staleTime:\n        return 0\n\n    # handle decimal normalization\n    price: uint256 = convert(oracle.answer, uint256)\n    decimals: uint256 = _decimals\n    if decimals < NORMALIZED_DECIMALS:\n        decimals = NORMALIZED_DECIMALS - decimals\n        price = price * (10 ** decimals)\n\n    return price\n\n\n################\n# Add New Feed #\n################\n\n\n# initiate new feed\n\n\n@external\ndef addNewPriceFeed(\n    _asset: address, \n    _newFeed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    decimals: uint256 = 0\n    if _newFeed != empty(address):\n        decimals = convert(staticcall ChainlinkFeed(_newFeed).decimals(), uint256)\n    assert self._isValidNewFeed(_asset, _newFeed, decimals, _needsEthToUsd, _needsBtcToUsd) # dev: invalid feed\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingChainlinkConfig(\n        actionId=aid,\n        config=ChainlinkConfig(\n            feed=_newFeed,\n            decimals=decimals,\n            needsEthToUsd=_needsEthToUsd,\n            needsBtcToUsd=_needsBtcToUsd,\n        ),\n    )\n\n    log NewChainlinkFeedPending(asset=_asset, feed=_newFeed, needsEthToUsd=_needsEthToUsd, needsBtcToUsd=_needsBtcToUsd, confirmationBlock=timeLock._getActionConfirmationBlock(aid), actionId=aid)\n    return True\n\n\n# confirm new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    assert d.config.feed != empty(address) # dev: no pending new feed\n    if not self._isValidNewFeed(_asset, d.config.feed, d.config.decimals, d.config.needsEthToUsd, d.config.needsBtcToUsd):\n        self._cancelNewPendingPriceFeed(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # save new feed config\n    self.feedConfig[_asset] = d.config\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n    priceData._addPricedAsset(_asset)\n\n    log NewChainlinkFeedAdded(asset=_asset, feed=d.config.feed, needsEthToUsd=d.config.needsEthToUsd, needsBtcToUsd=d.config.needsBtcToUsd)\n    return True\n\n\n# cancel new feed\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    self._cancelNewPendingPriceFeed(_asset, d.actionId)\n    log NewChainlinkFeedCancelled(asset=_asset, feed=d.config.feed)\n    return True\n\n\n@internal\ndef _cancelNewPendingPriceFeed(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewFeed(_asset: address, _newFeed: address, _decimals: uint256, _needsEthToUsd: bool, _needsBtcToUsd: bool) -> bool:\n    return self._isValidNewFeed(_asset, _newFeed, _decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidNewFeed(_asset: address, _newFeed: address, _decimals: uint256, _needsEthToUsd: bool, _needsBtcToUsd: bool) -> bool:\n    if priceData.indexOfAsset[_asset] != 0 or self.feedConfig[_asset].feed != empty(address): # use the `updatePriceFeed` function instead\n        return False\n    return self._isValidFeedConfig(_asset, _newFeed, _decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n###############\n# Update Feed #\n###############\n\n\n# initiate update feed\n\n\n@external\ndef updatePriceFeed(\n    _asset: address, \n    _newFeed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    decimals: uint256 = 0\n    if _newFeed != empty(address):\n        decimals = convert(staticcall ChainlinkFeed(_newFeed).decimals(), uint256)\n    oldFeed: address = self.feedConfig[_asset].feed\n    assert self._isValidUpdateFeed(_asset, _newFeed, oldFeed, decimals, _needsEthToUsd, _needsBtcToUsd) # dev: invalid feed\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingChainlinkConfig(\n        actionId=aid,\n        config=ChainlinkConfig(\n            feed=_newFeed,\n            decimals=decimals,\n            needsEthToUsd=_needsEthToUsd,\n            needsBtcToUsd=_needsBtcToUsd,\n        ),\n    )\n    log ChainlinkFeedUpdatePending(asset=_asset, feed=_newFeed, needsEthToUsd=_needsEthToUsd, needsBtcToUsd=_needsBtcToUsd, confirmationBlock=timeLock._getActionConfirmationBlock(aid), oldFeed=oldFeed, actionId=aid)\n    return True\n\n\n# confirm update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    assert d.config.feed != empty(address) # dev: no pending update feed\n    oldFeed: address = self.feedConfig[_asset].feed\n    if not self._isValidUpdateFeed(_asset, d.config.feed, oldFeed, d.config.decimals, d.config.needsEthToUsd, d.config.needsBtcToUsd):\n        self._cancelPriceFeedUpdate(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # save new feed config\n    self.feedConfig[_asset] = d.config\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n\n    log ChainlinkFeedUpdated(asset=_asset, feed=d.config.feed, needsEthToUsd=d.config.needsEthToUsd, needsBtcToUsd=d.config.needsBtcToUsd, oldFeed=oldFeed)\n    return True\n\n\n# cancel update feed\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    self._cancelPriceFeedUpdate(_asset, d.actionId)\n    log ChainlinkFeedUpdateCancelled(asset=_asset, feed=d.config.feed, oldFeed=self.feedConfig[_asset].feed)\n    return True\n\n\n@internal\ndef _cancelPriceFeedUpdate(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidUpdateFeed(_asset: address, _newFeed: address, _decimals: uint256, _needsEthToUsd: bool, _needsBtcToUsd: bool) -> bool:\n    return self._isValidUpdateFeed(_asset, _newFeed, self.feedConfig[_asset].feed, _decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidUpdateFeed(_asset: address, _newFeed: address, _oldFeed: address, _decimals: uint256, _needsEthToUsd: bool, _needsBtcToUsd: bool) -> bool:\n    if _newFeed == _oldFeed:\n        return False\n    if priceData.indexOfAsset[_asset] == 0 or _oldFeed == empty(address): # use the `addNewPriceFeed` function instead\n        return False\n    return self._isValidFeedConfig(_asset, _newFeed, _decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidFeedConfig(\n    _asset: address, \n    _feed: address,\n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n) -> bool:\n    if empty(address) in [_asset, _feed]:\n        return False\n    if _needsEthToUsd and _needsBtcToUsd:\n        return False\n\n    staleTime: uint256 = 0\n    missionControl: address = addys._getMissionControlAddr()\n    if missionControl != empty(address):\n        staleTime = staticcall MissionControl(missionControl).getPriceStaleTime()\n\n    return self._getPrice(_feed, _decimals, _needsEthToUsd, _needsBtcToUsd, staleTime) != 0\n\n\n################\n# Disable Feed #\n################\n\n\n# initiate disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    oldFeed: address = self.feedConfig[_asset].feed\n    assert self._isValidDisablePriceFeed(_asset, oldFeed) # dev: invalid asset\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingChainlinkConfig(\n        actionId=aid,\n        config=empty(ChainlinkConfig),\n    )\n\n    log DisableChainlinkFeedPending(asset=_asset, feed=oldFeed, confirmationBlock=timeLock._getActionConfirmationBlock(aid), actionId=aid)\n    return True\n\n\n# confirm disable feed\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    oldFeed: address = self.feedConfig[_asset].feed\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    assert d.actionId != 0 # dev: no pending disable feed\n    if not self._isValidDisablePriceFeed(_asset, oldFeed):\n        self._cancelDisablePriceFeed(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # disable feed\n    self.feedConfig[_asset] = empty(ChainlinkConfig)\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n    priceData._removePricedAsset(_asset)\n\n    log ChainlinkFeedDisabled(asset=_asset, feed=oldFeed)\n    return True\n\n\n# cancel disable feed\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    self._cancelDisablePriceFeed(_asset, self.pendingUpdates[_asset].actionId)\n    log DisableChainlinkFeedCancelled(asset=_asset, feed=self.feedConfig[_asset].feed)\n    return True\n\n\n@internal\ndef _cancelDisablePriceFeed(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidDisablePriceFeed(_asset: address) -> bool:\n    return self._isValidDisablePriceFeed(_asset, self.feedConfig[_asset].feed)\n\n\n@view\n@internal\ndef _isValidDisablePriceFeed(_asset: address, _oldFeed: address) -> bool:\n    if priceData.indexOfAsset[_asset] == 0:\n        return False\n    if _oldFeed == empty(address):\n        return False\n    return _asset not in [ETH, WETH, BTC]\n",
            "sha256sum": "0de2220caa6a97884153e04017220c0d9ac22da26196bbf114b56d824fc2a4ca"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/priceSources/Chainlink.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "b780cbd6f71aee1f4237a08b8eacd0fd932d12494583326866f172ad35203649"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d400000000000000000000000004200000000000000000000000000000000000006000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb00000000000000000000000012fb9866f8889ba91e63083617ed197489687472000000000000000000000000a3e216fdf96d7e7c7afaedfc1d99bc3f1ab5ab3d"
    },
    "MockPriceSource": {
      "address": "0xfBbA972f3693360AE48B61268aD3cA2e373895bc",
      "abi": [
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourcePauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourceFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricedAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_ACTION_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_ACTION_TIMELOCK",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_price",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewPendingPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "price",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minPriceChangeTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxPriceChangeTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/priceSources/modules/PriceSourceData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent PriceSourcePauseModified:\n    isPaused: bool\n\nevent PriceSourceFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# priced assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n##############\n# Asset Data #\n##############\n\n\n# add priced asset\n\n\n@internal\ndef _addPricedAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove priced asset\n\n\n@internal\ndef _removePricedAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n\n# get priced assets\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log PriceSourcePauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log PriceSourceFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "51688ce305f327581c761294d11a45d4d2bfa3a09fb3b76edd5501b0323ad860"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: public(immutable(uint256))\nMAX_ACTION_TIMELOCK: public(immutable(uint256))\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "a46b5a99a1f326aaa7280f656bd284c654cfd5afb2dd208b79e701f9028ee605"
          },
          "interfaces/PriceSource.vyi": {
            "content": "# @version 0.4.1\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, 50]:\n    ...\n\n\n################\n# Feed Changes #\n################\n\n\n# new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    ...\n\n\n# update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n# disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n#############\n# Time Lock #\n#############\n\n\n@view\n@external\ndef actionTimeLock() -> uint256:\n    ...\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    ...\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    ...\n\n\n@external\ndef setActionTimeLock(_numBlocks: uint256) -> bool:\n    ...\n\n\n@external\ndef setActionTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "289828f43691dc382bce6ee0caf4cbdf0a49db41bae788bfcf7e23056b5a5d25"
          },
          "contracts/mock/MockPriceSource.vy": {
            "content": "# @version 0.4.1\n\nimplements: PriceSource\n\nexports: gov.__interface__\nexports: addys.__interface__\nexports: priceData.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: addys\ninitializes: priceData[addys := addys]\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Addys as addys\nimport contracts.priceSources.modules.PriceSourceData as priceData\nimport contracts.modules.TimeLock as timeLock\n\nimport interfaces.PriceSource as PriceSource\n\nprice: public(HashMap[address, uint256])\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minPriceChangeTimeLock: uint256,\n    _maxPriceChangeTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    addys.__init__(_ripeHq)\n    priceData.__init__(False)\n    timeLock.__init__(_minPriceChangeTimeLock, _maxPriceChangeTimeLock, 0, _maxPriceChangeTimeLock)\n\n\n# MOCK CONFIG\n\n\n@external\ndef setPrice(_asset: address, _price: uint256):\n    self.price[_asset] = _price\n\n    if priceData.indexOfAsset[_asset] == 0:\n        priceData._addPricedAsset(_asset)\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    self.price[_asset] = 0\n\n    if priceData.indexOfAsset[_asset] != 0:\n        priceData._removePricedAsset(_asset)\n\n    return True\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> uint256:\n    return self.price[_asset]\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> (uint256, bool):\n    price: uint256 = self.price[_asset]\n    return price, price != 0\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self.price[_asset] != 0\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    return False\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    return True\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    return True\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    return True\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    return True\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    return True\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    return True\n",
            "sha256sum": "3102a1cc4ebb1752b100400eac36c3740481a95a703489c0c1722f3a91ba569b"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/MockPriceSource.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "0b1399674cef8ddd5480d6b9dde4b22db4c444e60ebc98d3ce2dc389d767a25a"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "VaultBook": {
      "address": "0xEcA75a91a7e1Af188cC0C7506fCc35bF0C877F77",
      "abi": [
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/registries/modules/AddressRegistry.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "45a6786be62ebfcd266d4b9f321aa22bfc8d125d6ce75ffcf4d895ad011ff661"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "cdcbc1c83a0ffa09166c89d2698097b5dee00d2ebebf714134ab8faa6e9ff685"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/registries/VaultBook.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.registries.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Vault\nfrom interfaces import Department\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"VaultBook.vy\")\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert not self._doesVaultIdHaveAnyFunds(_regId) # dev: vault has funds\n\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert not self._doesVaultIdHaveAnyFunds(_regId) # dev: vault has funds\n\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n# check if vault has funds\n\n\n@view\n@internal\ndef _doesVaultIdHaveAnyFunds(_vaultId: uint256) -> bool:\n    vaultAddr: address = registry._getAddr(_vaultId)\n    return staticcall Vault(vaultAddr).doesVaultHaveAnyFunds()\n",
            "sha256sum": "0c42f31baa92e8c2ef5a72fef3d5f48bd6d3c5292bc97dee2dd8b5df6f0457b2"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/VaultBook.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "4e11db0417366f98a1d8c0791740c68e8a85c5792c3dd7d1b212d7a28b14e1ab"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40"
    },
    "SimpleErc20": {
      "address": "0x59FB519D45cE535A8c683Be252581AA980ae409a",
      "abi": [
        {
          "name": "SimpleErc20VaultDeposit",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SimpleErc20VaultWithdrawal",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SimpleErc20VaultTransfer",
          "inputs": [
            {
              "name": "fromUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "toUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "transferAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isFromUserDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInVaultAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesUserHaveBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterUserAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesVaultHaveAnyFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumVaultAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfUserAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultDataOnDeposit",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasPosition",
                  "type": "bool"
                },
                {
                  "name": "numAssets",
                  "type": "uint256"
                },
                {
                  "name": "userBalance",
                  "type": "uint256"
                },
                {
                  "name": "totalBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserLootBoxShare",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAndAmountAtIndex",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAtIndexAndHasBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/vaults/modules/VaultData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent VaultPauseModified:\n    isPaused: bool\n\nevent VaultFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# balances (may be shares or actual balance)\nuserBalances: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> balance\ntotalBalances: public(HashMap[address, uint256]) # asset -> balance\n\n# user assets (iterable)\nuserAssets: public(HashMap[address, HashMap[uint256, address]]) # user -> index -> asset\nindexOfUserAsset: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> index\nnumUserAssets: public(HashMap[address, uint256]) # user -> num assets\n\n# vault assets (iterable)\nvaultAssets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###################\n# Balance Changes #\n###################\n\n\n# deposit\n\n\n@internal\ndef _addBalanceOnDeposit(\n    _user: address,\n    _asset: address,\n    _depositBal: uint256,\n    _shouldUpdateTotal: bool,\n):\n    # update balances\n    self.userBalances[_user][_asset] += _depositBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] += _depositBal\n\n    # register user asset (if necessary)\n    if self.indexOfUserAsset[_user][_asset] == 0:\n        self._registerUserAsset(_user, _asset)\n\n    # register vault asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerVaultAsset(_asset)\n\n\n# withdrawal\n\n\n@internal\ndef _reduceBalanceOnWithdrawal(\n    _user: address,\n    _asset: address,\n    _withdrawBal: uint256,\n    _shouldUpdateTotal: bool,\n) -> (uint256, bool):\n    assert self.indexOfUserAsset[_user][_asset] != 0 # dev: user does not have this asset\n\n    currentBal: uint256 = self.userBalances[_user][_asset]\n    withdrawBal: uint256 = min(_withdrawBal, currentBal)\n    assert withdrawBal != 0 # dev: nothing to withdraw\n\n    # update balances\n    currentBal -= withdrawBal\n    self.userBalances[_user][_asset] = currentBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] -= withdrawBal\n\n    return withdrawBal, currentBal == 0\n\n\n###############\n# User Assets #\n###############\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    return self.indexOfUserAsset[_user][_asset] != 0\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    return self.userBalances[_user][_asset] != 0\n\n\n@internal\ndef _registerUserAsset(_user: address, _asset: address):\n    aid: uint256 = self.numUserAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.userAssets[_user][aid] = _asset\n    self.indexOfUserAsset[_user][_asset] = aid\n    self.numUserAssets[_user] = aid + 1\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n\n    if self.userBalances[_user][_asset] != 0:\n        return True\n\n    numUserAssets: uint256 = self.numUserAssets[_user]\n    if numUserAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfUserAsset[_user][_asset]\n    if targetIndex == 0:\n        return numUserAssets > 1\n\n    # update data\n    lastIndex: uint256 = numUserAssets - 1\n    self.numUserAssets[_user] = lastIndex\n    self.indexOfUserAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.userAssets[_user][lastIndex]\n        self.userAssets[_user][targetIndex] = lastItem\n        self.indexOfUserAsset[_user][lastItem] = targetIndex\n\n    return lastIndex > 1\n\n\n################\n# Vault Assets #\n################\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@internal\ndef _registerVaultAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.vaultAssets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n\n    if self.totalBalances[_asset] != 0:\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.vaultAssets[lastIndex]\n        self.vaultAssets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n##############\n# Data Utils #\n##############\n\n\n# any vault funds\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.vaultAssets[i]\n        if self.totalBalances[asset] != 0:\n            return True\n    return False\n\n\n# num user assets\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    return self._getNumUserAssets(_user)\n\n\n@view\n@internal\ndef _getNumUserAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numUserAssets[_user]\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n# num vault assets\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    return self._getNumVaultAssets()\n\n\n@view\n@internal\ndef _getNumVaultAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log VaultPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    # cannot recover funds from a registered asset with a balance\n    assert self.indexOfAsset[_asset] == 0 and self.totalBalances[_asset] == 0 # dev: invalid recovery\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log VaultFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "7337a862786825b6f405aa72491f6603765f554ad933fb7a53c1039acc572ec1"
          },
          "contracts/vaults/modules/BasicVault.vy": {
            "content": "# @version 0.4.1\n\nuses: vaultData\nimport contracts.vaults.modules.VaultData as vaultData\n\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC20\n\n\n@deploy\ndef __init__():\n    pass\n\n\n########\n# Core #\n########\n\n\n@internal\ndef _depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n) -> uint256:\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset] # dev: invalid user or asset\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(self))\n    assert depositAmount != 0 # dev: invalid deposit amount\n\n    # add balance on deposit\n    vaultData._addBalanceOnDeposit(_user, _asset, depositAmount, True)\n\n    return depositAmount\n\n\n@internal\ndef _withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n) -> (uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset, _recipient] # dev: invalid user, asset, or recipient\n    assert _amount != 0 # dev: invalid withdrawal amount\n\n    # reduce balance on withdrawal\n    withdrawalAmount: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, isDepleted = vaultData._reduceBalanceOnWithdrawal(_user, _asset, _amount, True)\n\n    # move tokens to recipient\n    withdrawalAmount = min(withdrawalAmount, staticcall IERC20(_asset).balanceOf(self))\n    assert withdrawalAmount != 0 # dev: no withdrawal amount\n    assert extcall IERC20(_asset).transfer(_recipient, withdrawalAmount, default_return_value=True) # dev: token transfer failed\n\n    return withdrawalAmount, isDepleted\n\n\n@internal\ndef _transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n) -> (uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_fromUser, _toUser, _asset] # dev: invalid users or asset\n    assert _transferAmount != 0 # dev: invalid transfer amount\n\n    # transfer balances\n    transferAmount: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, isFromUserDepleted = vaultData._reduceBalanceOnWithdrawal(_fromUser, _asset, _transferAmount, False)\n    vaultData._addBalanceOnDeposit(_toUser, _asset, transferAmount, False)\n\n    return transferAmount, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@internal\ndef _getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return Vault.VaultDataOnDeposit(\n        hasPosition=vaultData.indexOfUserAsset[_user][_asset] != 0,\n        numAssets=vaultData._getNumUserAssets(_user),\n        userBalance=vaultData.userBalances[_user][_asset],\n        totalBalance=vaultData.totalBalances[_asset],\n    )\n\n\n@view\n@internal\ndef _getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return vaultData.userBalances[_user][_asset]\n\n\n@view\n@internal\ndef _getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), 0\n    return asset, vaultData.userBalances[_user][asset]\n\n\n@view\n@internal\ndef _getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), False\n    return asset, vaultData.userBalances[_user][asset] != 0\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@internal\ndef _getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return vaultData.userBalances[_user][_asset]\n\n\n@view\n@internal\ndef _getTotalAmountForVault(_asset: address) -> uint256:\n    return vaultData.totalBalances[_asset]\n",
            "sha256sum": "330fca9b966f89bcc7a8583a6bdae810a3e524abce8e49e43dd88d3046df5e0a"
          },
          "contracts/vaults/SimpleErc20.vy": {
            "content": "# @version 0.4.1\n\nimplements: Vault\n\nexports: addys.__interface__\nexports: vaultData.__interface__\n\ninitializes: addys\ninitializes: vaultData[addys := addys]\ninitializes: basicVault[vaultData := vaultData]\n\nfrom interfaces import Vault\nimport contracts.modules.Addys as addys\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.vaults.modules.BasicVault as basicVault\nfrom ethereum.ercs import IERC20\n\nevent SimpleErc20VaultDeposit:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n\nevent SimpleErc20VaultWithdrawal:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    isDepleted: bool\n\nevent SimpleErc20VaultTransfer:\n    fromUser: indexed(address)\n    toUser: indexed(address)\n    asset: indexed(address)\n    transferAmount: uint256\n    isFromUserDepleted: bool\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    vaultData.__init__(False)\n    basicVault.__init__()\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n\n    depositAmount: uint256 = basicVault._depositTokensInVault(_user, _asset, _amount)\n    log SimpleErc20VaultDeposit(user=_user, asset=_asset, amount=depositAmount)\n    return depositAmount\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getTellerAddr(), addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n\n    withdrawalAmount: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, isDepleted = basicVault._withdrawTokensFromVault(_user, _asset, _amount, _recipient)\n    log SimpleErc20VaultWithdrawal(user=_user, asset=_asset, amount=withdrawalAmount, isDepleted=isDepleted)\n    return withdrawalAmount, isDepleted\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n\n    transferAmount: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, isFromUserDepleted = basicVault._transferBalanceWithinVault(_asset, _fromUser, _toUser, _transferAmount)\n    log SimpleErc20VaultTransfer(fromUser=_fromUser, toUser=_toUser, asset=_asset, transferAmount=transferAmount, isFromUserDepleted=isFromUserDepleted)\n    return transferAmount, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return basicVault._getVaultDataOnDeposit(_user, _asset)\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return basicVault._getUserLootBoxShare(_user, _asset)\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    return basicVault._getUserAssetAndAmountAtIndex(_user, _index)\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    return basicVault._getUserAssetAtIndexAndHasBalance(_user, _index)\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return basicVault._getTotalAmountForUser(_user, _asset)\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    return basicVault._getTotalAmountForVault(_asset)\n",
            "sha256sum": "8b5e477349aa0034e1a22a3d292eb90adda5a5b8a595373cdac869a897f8c99e"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/SimpleErc20.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5ce96dd69e0b10b315f35d6cb1bd1903b634c5ccd3e2f8068954376dc687e67b"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e"
    },
    "RebaseErc20": {
      "address": "0x625aE93941249634C54BB6ce372638bc116D541b",
      "abi": [
        {
          "name": "RebaseErc20VaultDeposit",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RebaseErc20VaultWithdrawal",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RebaseErc20VaultTransfer",
          "inputs": [
            {
              "name": "fromUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "toUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "transferAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isFromUserDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "transferShares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInVaultAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesUserHaveBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterUserAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesVaultHaveAnyFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumVaultAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfUserAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "amountToShares",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sharesToAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultDataOnDeposit",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasPosition",
                  "type": "bool"
                },
                {
                  "name": "numAssets",
                  "type": "uint256"
                },
                {
                  "name": "userBalance",
                  "type": "uint256"
                },
                {
                  "name": "totalBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserLootBoxShare",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAndAmountAtIndex",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAtIndexAndHasBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/vaults/modules/VaultData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent VaultPauseModified:\n    isPaused: bool\n\nevent VaultFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# balances (may be shares or actual balance)\nuserBalances: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> balance\ntotalBalances: public(HashMap[address, uint256]) # asset -> balance\n\n# user assets (iterable)\nuserAssets: public(HashMap[address, HashMap[uint256, address]]) # user -> index -> asset\nindexOfUserAsset: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> index\nnumUserAssets: public(HashMap[address, uint256]) # user -> num assets\n\n# vault assets (iterable)\nvaultAssets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###################\n# Balance Changes #\n###################\n\n\n# deposit\n\n\n@internal\ndef _addBalanceOnDeposit(\n    _user: address,\n    _asset: address,\n    _depositBal: uint256,\n    _shouldUpdateTotal: bool,\n):\n    # update balances\n    self.userBalances[_user][_asset] += _depositBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] += _depositBal\n\n    # register user asset (if necessary)\n    if self.indexOfUserAsset[_user][_asset] == 0:\n        self._registerUserAsset(_user, _asset)\n\n    # register vault asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerVaultAsset(_asset)\n\n\n# withdrawal\n\n\n@internal\ndef _reduceBalanceOnWithdrawal(\n    _user: address,\n    _asset: address,\n    _withdrawBal: uint256,\n    _shouldUpdateTotal: bool,\n) -> (uint256, bool):\n    assert self.indexOfUserAsset[_user][_asset] != 0 # dev: user does not have this asset\n\n    currentBal: uint256 = self.userBalances[_user][_asset]\n    withdrawBal: uint256 = min(_withdrawBal, currentBal)\n    assert withdrawBal != 0 # dev: nothing to withdraw\n\n    # update balances\n    currentBal -= withdrawBal\n    self.userBalances[_user][_asset] = currentBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] -= withdrawBal\n\n    return withdrawBal, currentBal == 0\n\n\n###############\n# User Assets #\n###############\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    return self.indexOfUserAsset[_user][_asset] != 0\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    return self.userBalances[_user][_asset] != 0\n\n\n@internal\ndef _registerUserAsset(_user: address, _asset: address):\n    aid: uint256 = self.numUserAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.userAssets[_user][aid] = _asset\n    self.indexOfUserAsset[_user][_asset] = aid\n    self.numUserAssets[_user] = aid + 1\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n\n    if self.userBalances[_user][_asset] != 0:\n        return True\n\n    numUserAssets: uint256 = self.numUserAssets[_user]\n    if numUserAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfUserAsset[_user][_asset]\n    if targetIndex == 0:\n        return numUserAssets > 1\n\n    # update data\n    lastIndex: uint256 = numUserAssets - 1\n    self.numUserAssets[_user] = lastIndex\n    self.indexOfUserAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.userAssets[_user][lastIndex]\n        self.userAssets[_user][targetIndex] = lastItem\n        self.indexOfUserAsset[_user][lastItem] = targetIndex\n\n    return lastIndex > 1\n\n\n################\n# Vault Assets #\n################\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@internal\ndef _registerVaultAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.vaultAssets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n\n    if self.totalBalances[_asset] != 0:\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.vaultAssets[lastIndex]\n        self.vaultAssets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n##############\n# Data Utils #\n##############\n\n\n# any vault funds\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.vaultAssets[i]\n        if self.totalBalances[asset] != 0:\n            return True\n    return False\n\n\n# num user assets\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    return self._getNumUserAssets(_user)\n\n\n@view\n@internal\ndef _getNumUserAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numUserAssets[_user]\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n# num vault assets\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    return self._getNumVaultAssets()\n\n\n@view\n@internal\ndef _getNumVaultAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log VaultPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    # cannot recover funds from a registered asset with a balance\n    assert self.indexOfAsset[_asset] == 0 and self.totalBalances[_asset] == 0 # dev: invalid recovery\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log VaultFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "7337a862786825b6f405aa72491f6603765f554ad933fb7a53c1039acc572ec1"
          },
          "contracts/vaults/modules/SharesVault.vy": {
            "content": "# @version 0.4.1\n\nuses: vaultData\nimport contracts.vaults.modules.VaultData as vaultData\n\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC20\n\nDECIMAL_OFFSET: constant(uint256) = 10 ** 8\n\n\n@deploy\ndef __init__():\n    pass\n\n\n########\n# Core #\n########\n\n\n@internal\ndef _depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n) -> (uint256, uint256):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset] # dev: invalid user or asset\n    totalAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    depositAmount: uint256 = min(_amount, totalAssetBalance)\n    assert depositAmount != 0 # dev: invalid deposit amount\n\n    # calc shares\n    prevTotalBalance: uint256 = totalAssetBalance - depositAmount # remove the deposited amount to calc shares accurately\n    newShares: uint256 = self._amountToShares(depositAmount, vaultData.totalBalances[_asset], prevTotalBalance, False)\n\n    # add balance on deposit\n    vaultData._addBalanceOnDeposit(_user, _asset, newShares, True)\n\n    return depositAmount, newShares\n\n\n@internal\ndef _withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_user, _asset, _recipient] # dev: invalid user, asset, or recipient\n\n    # calc shares + amount to withdraw\n    withdrawalShares: uint256 = 0\n    withdrawalAmount: uint256 = 0\n    withdrawalShares, withdrawalAmount = self._calcWithdrawalSharesAndAmount(_user, _asset, _amount)\n\n    # reduce balance on withdrawal\n    isDepleted: bool = False\n    withdrawalShares, isDepleted = vaultData._reduceBalanceOnWithdrawal(_user, _asset, withdrawalShares, True)\n\n    # move tokens to recipient\n    assert extcall IERC20(_asset).transfer(_recipient, withdrawalAmount, default_return_value=True) # dev: token transfer failed\n    return withdrawalAmount, withdrawalShares, isDepleted\n\n\n@internal\ndef _transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_fromUser, _toUser, _asset] # dev: invalid users or asset\n\n    # calc shares + amount to transfer\n    transferShares: uint256 = 0\n    transferAmount: uint256 = 0\n    transferShares, transferAmount = self._calcWithdrawalSharesAndAmount(_fromUser, _asset, _transferAmount)\n\n    # transfer shares\n    isFromUserDepleted: bool = False\n    transferShares, isFromUserDepleted = vaultData._reduceBalanceOnWithdrawal(_fromUser, _asset, transferShares, False)\n    vaultData._addBalanceOnDeposit(_toUser, _asset, transferShares, False)\n\n    return transferAmount, transferShares, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@internal\ndef _getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return Vault.VaultDataOnDeposit(\n        hasPosition=vaultData.indexOfUserAsset[_user][_asset] != 0,\n        numAssets=vaultData._getNumUserAssets(_user),\n        userBalance=self._getTotalAmountForUserWithTotalBal(_user, _asset, totalBalance),\n        totalBalance=totalBalance,\n    )\n\n\n@view\n@internal\ndef _getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return vaultData.userBalances[_user][_asset] // DECIMAL_OFFSET\n\n\n@view\n@internal\ndef _getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), 0\n    userShares: uint256 = vaultData.userBalances[_user][asset]\n    if userShares == 0:\n        return empty(address), 0\n    return asset, self._sharesToAmount(userShares, vaultData.totalBalances[asset], staticcall IERC20(asset).balanceOf(self), False)\n\n\n@view\n@internal\ndef _getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), False\n    return asset, vaultData.userBalances[_user][asset] != 0\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@internal\ndef _getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return self._getTotalAmountForUserWithTotalBal(_user, _asset, staticcall IERC20(_asset).balanceOf(self))\n\n\n@view\n@internal\ndef _getTotalAmountForUserWithTotalBal(_user: address, _asset: address, _totalBalance: uint256) -> uint256:\n    userShares: uint256 = vaultData.userBalances[_user][_asset]\n    return self._sharesToAmount(userShares, vaultData.totalBalances[_asset], _totalBalance, False)\n\n\n@view\n@internal\ndef _getTotalAmountForVault(_asset: address) -> uint256:\n    return staticcall IERC20(_asset).balanceOf(self)\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@internal\ndef _calcWithdrawalSharesAndAmount(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n) -> (uint256, uint256):\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert totalBalance != 0 # dev: no asset to withdraw\n\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n\n    # user shares\n    withdrawalShares: uint256 = vaultData.userBalances[_user][_asset]\n    assert withdrawalShares != 0 # dev: user has no shares\n\n    # calc amount + shares to withdraw\n    withdrawalAmount: uint256 = min(totalBalance, self._sharesToAmount(withdrawalShares, totalShares, totalBalance, False))\n    if _amount < withdrawalAmount:\n        withdrawalShares = min(withdrawalShares, self._amountToShares(_amount, totalShares, totalBalance, True))\n        withdrawalAmount = _amount\n\n    assert withdrawalAmount != 0 # dev: no withdrawal amount\n    return withdrawalShares, withdrawalAmount\n\n\n# amount -> shares\n\n\n@view\n@external\ndef amountToShares(_asset: address, _amount: uint256, _shouldRoundUp: bool) -> uint256:\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return self._amountToShares(_amount, totalShares, totalBalance, _shouldRoundUp)\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalBalance: uint256 = _totalBalance\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalBalance += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc shares\n    numerator: uint256 = _amount * totalShares\n    shares: uint256 = numerator // totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@external\ndef sharesToAmount(_asset: address, _shares: uint256, _shouldRoundUp: bool) -> uint256:\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return self._sharesToAmount(_shares, totalShares, totalBalance, _shouldRoundUp)\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalBalance: uint256 = _totalBalance\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalBalance += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc amount\n    numerator: uint256 = _shares * totalBalance\n    amount: uint256 = numerator // totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalShares != 0):\n        amount += 1\n\n    return amount\n",
            "sha256sum": "e5950f837a378ea674587140082327b4113dcd19b9f77b9c86bbedc6ee329860"
          },
          "contracts/vaults/RebaseErc20.vy": {
            "content": "# @version 0.4.1\n\nimplements: Vault\n\nexports: addys.__interface__\nexports: vaultData.__interface__\nexports: sharesVault.__interface__\n\ninitializes: addys\ninitializes: vaultData[addys := addys]\ninitializes: sharesVault[vaultData := vaultData]\n\nfrom interfaces import Vault\nimport contracts.modules.Addys as addys\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.vaults.modules.SharesVault as sharesVault\nfrom ethereum.ercs import IERC20\n\nevent RebaseErc20VaultDeposit:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    shares: uint256\n\nevent RebaseErc20VaultWithdrawal:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    isDepleted: bool\n    shares: uint256\n\nevent RebaseErc20VaultTransfer:\n    fromUser: indexed(address)\n    toUser: indexed(address)\n    asset: indexed(address)\n    transferAmount: uint256\n    isFromUserDepleted: bool\n    transferShares: uint256\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    vaultData.__init__(False)\n    sharesVault.__init__()\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n\n    depositAmount: uint256 = 0\n    newShares: uint256 = 0\n    depositAmount, newShares = sharesVault._depositTokensInVault(_user, _asset, _amount)\n    log RebaseErc20VaultDeposit(user=_user, asset=_asset, amount=depositAmount, shares=newShares)\n    return depositAmount\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getTellerAddr(), addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n\n    withdrawalAmount: uint256 = 0\n    withdrawalShares: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, withdrawalShares, isDepleted = sharesVault._withdrawTokensFromVault(_user, _asset, _amount, _recipient)\n    log RebaseErc20VaultWithdrawal(user=_user, asset=_asset, amount=withdrawalAmount, isDepleted=isDepleted, shares=withdrawalShares)\n    return withdrawalAmount, isDepleted\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n\n    transferAmount: uint256 = 0\n    transferShares: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, transferShares, isFromUserDepleted = sharesVault._transferBalanceWithinVault(_asset, _fromUser, _toUser, _transferAmount)\n    log RebaseErc20VaultTransfer(fromUser=_fromUser, toUser=_toUser, asset=_asset, transferAmount=transferAmount, isFromUserDepleted=isFromUserDepleted, transferShares=transferShares)\n    return transferAmount, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return sharesVault._getVaultDataOnDeposit(_user, _asset)\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return sharesVault._getUserLootBoxShare(_user, _asset)\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    return sharesVault._getUserAssetAndAmountAtIndex(_user, _index)\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    return sharesVault._getUserAssetAtIndexAndHasBalance(_user, _index)\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return sharesVault._getTotalAmountForUser(_user, _asset)\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    return sharesVault._getTotalAmountForVault(_asset)\n",
            "sha256sum": "8fc1fd85e0bd5b7c9a019f86a90b920f02d8c5cc0bf7cd9e0c8045d7b35678c7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/RebaseErc20.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "6a1ab0299c70b6acd1f14c8593f056a4bf478c45e1f11b9a6345b814e71484a5"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e"
    },
    "StabilityPool": {
      "address": "0x4a926e530ec127c5a308c5657611Bf4AafEAaE38",
      "abi": [
        {
          "name": "StabilityPoolDeposit",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabilityPoolWithdrawal",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabilityPoolTransfer",
          "inputs": [
            {
              "name": "fromUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "toUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "transferAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isFromUserDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "transferShares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetClaimedInStabilityPool",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "stabAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "claimAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "claimAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimUsdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimShares",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInVaultAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesUserHaveBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterUserAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesVaultHaveAnyFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumVaultAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfUserAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "valueToShares",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sharesToValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapForLiquidatedCollateral",
          "inputs": [
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_stabAssetAmount",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            },
            {
              "name": "_liqAmountSent",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_greenToken",
              "type": "address"
            },
            {
              "name": "_savingsGreenToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapWithClaimableGreen",
          "inputs": [
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            },
            {
              "name": "_liqAmountSent",
              "type": "uint256"
            },
            {
              "name": "_greenToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalUserValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimFromStabilityPool",
          "inputs": [
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_maxUsdValue",
              "type": "uint256"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimFromStabilityPool",
          "inputs": [
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_maxUsdValue",
              "type": "uint256"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimManyFromStabilityPool",
          "inputs": [
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_claims",
              "type": "tuple[]",
              "components": [
                {
                  "name": "stabAsset",
                  "type": "address"
                },
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxUsdValue",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimManyFromStabilityPool",
          "inputs": [
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_claims",
              "type": "tuple[]",
              "components": [
                {
                  "name": "stabAsset",
                  "type": "address"
                },
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxUsdValue",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_redeemer",
              "type": "address"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_redeemer",
              "type": "address"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_redeemer",
              "type": "address"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_redeemer",
              "type": "address"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "claimableBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalClaimableBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "claimableAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfClaimableAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numClaimableAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultDataOnDeposit",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasPosition",
                  "type": "bool"
                },
                {
                  "name": "numAssets",
                  "type": "uint256"
                },
                {
                  "name": "userBalance",
                  "type": "uint256"
                },
                {
                  "name": "totalBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserLootBoxShare",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAndAmountAtIndex",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAtIndexAndHasBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/vaults/modules/VaultData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent VaultPauseModified:\n    isPaused: bool\n\nevent VaultFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# balances (may be shares or actual balance)\nuserBalances: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> balance\ntotalBalances: public(HashMap[address, uint256]) # asset -> balance\n\n# user assets (iterable)\nuserAssets: public(HashMap[address, HashMap[uint256, address]]) # user -> index -> asset\nindexOfUserAsset: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> index\nnumUserAssets: public(HashMap[address, uint256]) # user -> num assets\n\n# vault assets (iterable)\nvaultAssets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###################\n# Balance Changes #\n###################\n\n\n# deposit\n\n\n@internal\ndef _addBalanceOnDeposit(\n    _user: address,\n    _asset: address,\n    _depositBal: uint256,\n    _shouldUpdateTotal: bool,\n):\n    # update balances\n    self.userBalances[_user][_asset] += _depositBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] += _depositBal\n\n    # register user asset (if necessary)\n    if self.indexOfUserAsset[_user][_asset] == 0:\n        self._registerUserAsset(_user, _asset)\n\n    # register vault asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerVaultAsset(_asset)\n\n\n# withdrawal\n\n\n@internal\ndef _reduceBalanceOnWithdrawal(\n    _user: address,\n    _asset: address,\n    _withdrawBal: uint256,\n    _shouldUpdateTotal: bool,\n) -> (uint256, bool):\n    assert self.indexOfUserAsset[_user][_asset] != 0 # dev: user does not have this asset\n\n    currentBal: uint256 = self.userBalances[_user][_asset]\n    withdrawBal: uint256 = min(_withdrawBal, currentBal)\n    assert withdrawBal != 0 # dev: nothing to withdraw\n\n    # update balances\n    currentBal -= withdrawBal\n    self.userBalances[_user][_asset] = currentBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] -= withdrawBal\n\n    return withdrawBal, currentBal == 0\n\n\n###############\n# User Assets #\n###############\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    return self.indexOfUserAsset[_user][_asset] != 0\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    return self.userBalances[_user][_asset] != 0\n\n\n@internal\ndef _registerUserAsset(_user: address, _asset: address):\n    aid: uint256 = self.numUserAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.userAssets[_user][aid] = _asset\n    self.indexOfUserAsset[_user][_asset] = aid\n    self.numUserAssets[_user] = aid + 1\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n\n    if self.userBalances[_user][_asset] != 0:\n        return True\n\n    numUserAssets: uint256 = self.numUserAssets[_user]\n    if numUserAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfUserAsset[_user][_asset]\n    if targetIndex == 0:\n        return numUserAssets > 1\n\n    # update data\n    lastIndex: uint256 = numUserAssets - 1\n    self.numUserAssets[_user] = lastIndex\n    self.indexOfUserAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.userAssets[_user][lastIndex]\n        self.userAssets[_user][targetIndex] = lastItem\n        self.indexOfUserAsset[_user][lastItem] = targetIndex\n\n    return lastIndex > 1\n\n\n################\n# Vault Assets #\n################\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@internal\ndef _registerVaultAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.vaultAssets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n\n    if self.totalBalances[_asset] != 0:\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.vaultAssets[lastIndex]\n        self.vaultAssets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n##############\n# Data Utils #\n##############\n\n\n# any vault funds\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.vaultAssets[i]\n        if self.totalBalances[asset] != 0:\n            return True\n    return False\n\n\n# num user assets\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    return self._getNumUserAssets(_user)\n\n\n@view\n@internal\ndef _getNumUserAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numUserAssets[_user]\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n# num vault assets\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    return self._getNumVaultAssets()\n\n\n@view\n@internal\ndef _getNumVaultAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log VaultPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    # cannot recover funds from a registered asset with a balance\n    assert self.indexOfAsset[_asset] == 0 and self.totalBalances[_asset] == 0 # dev: invalid recovery\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log VaultFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "7337a862786825b6f405aa72491f6603765f554ad933fb7a53c1039acc572ec1"
          },
          "contracts/vaults/modules/StabVault.vy": {
            "content": "# @version 0.4.1\n\nuses: vaultData\nuses: addys\n\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.modules.Addys as addys\n\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\ninterface MissionControl:\n    def getStabPoolClaimsConfig(_claimAsset: address, _claimer: address, _caller: address) -> StabPoolClaimsConfig: view\n    def getStabPoolRedemptionsConfig(_asset: address, _redeemer: address) -> StabPoolRedemptionsConfig: view\n\ninterface PriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface GreenToken:\n    def burn(_amount: uint256) -> bool: nonpayable\n\nstruct StabPoolClaim:\n    stabAsset: address\n    claimAsset: address\n    maxUsdValue: uint256\n\nstruct StabPoolRedemption:\n    claimAsset: address\n    maxGreenAmount: uint256\n\nstruct StabPoolClaimsConfig:\n    canClaimInStabPoolGeneral: bool\n    canClaimInStabPoolAsset: bool\n    canClaimFromStabPoolForUser: bool\n    isUserAllowed: bool\n\nstruct StabPoolRedemptionsConfig:\n    canRedeemInStabPoolGeneral: bool\n    canRedeemInStabPoolAsset: bool\n    isUserAllowed: bool\n\nevent AssetClaimedInStabilityPool:\n    user: indexed(address)\n    stabAsset: indexed(address)\n    claimAsset: indexed(address)\n    claimAmount: uint256\n    claimUsdValue: uint256\n    claimShares: uint256\n    isDepleted: bool\n\n# claimable balances\nclaimableBalances: public(HashMap[address, HashMap[address, uint256]]) # stab asset -> claimable asset -> balance\ntotalClaimableBalances: public(HashMap[address, uint256]) # claimable asset -> balance\n\n# claimable assets (iterable)\nclaimableAssets: public(HashMap[address, HashMap[uint256, address]]) # stab asset -> index -> claimable asset\nindexOfClaimableAsset: public(HashMap[address, HashMap[address, uint256]]) # stab asset -> claimable asset -> index\nnumClaimableAssets: public(HashMap[address, uint256]) # stab asset -> num claimable assets\n\nMAX_STAB_CLAIMS: constant(uint256) = 15\nMAX_STAB_REDEMPTIONS: constant(uint256) = 15\nDECIMAL_OFFSET: constant(uint256) = 10 ** 8\n\n\n@deploy\ndef __init__():\n    pass\n\n\n########\n# Core #\n########\n\n\n@internal\ndef _depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _priceDesk: address,\n) -> (uint256, uint256):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset] # dev: invalid user or asset\n    totalAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    depositAmount: uint256 = min(_amount, totalAssetBalance)\n    assert depositAmount != 0 # dev: invalid deposit amount\n\n    # calc usd values\n    totalStabValue: uint256 = staticcall PriceDesk(_priceDesk).getUsdValue(_asset, totalAssetBalance, True)\n    assert totalStabValue != 0 # dev: no price for stab asset\n\n    newUserValue: uint256 = totalStabValue\n    prevStabValue: uint256 = 0\n    if depositAmount != totalAssetBalance:\n        newUserValue = depositAmount * totalStabValue // totalAssetBalance\n        prevStabValue = (totalAssetBalance - depositAmount) * totalStabValue // totalAssetBalance # remove the deposited amount to calc shares accurately\n\n    # calc shares\n    claimableValue: uint256 = self._getValueOfClaimableAssets(_asset, _priceDesk)\n    newShares: uint256 = self._valueToShares(newUserValue, vaultData.totalBalances[_asset], prevStabValue + claimableValue, False)\n\n    # add balance on deposit\n    vaultData._addBalanceOnDeposit(_user, _asset, newShares, True)\n\n    return depositAmount, newShares\n\n\n@internal\ndef _withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _priceDesk: address,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_user, _asset, _recipient] # dev: invalid user, asset, or recipient\n\n    # calc shares + amount to withdraw\n    withdrawalShares: uint256 = 0\n    withdrawalAmount: uint256 = 0\n    withdrawalShares, withdrawalAmount = self._calcWithdrawalSharesAndAmount(_user, _asset, _amount, _priceDesk)\n\n    # reduce balance on withdrawal\n    isDepleted: bool = False\n    withdrawalShares, isDepleted = vaultData._reduceBalanceOnWithdrawal(_user, _asset, withdrawalShares, True)\n\n    assert extcall IERC20(_asset).transfer(_recipient, withdrawalAmount, default_return_value=True) # dev: token transfer failed\n    return withdrawalAmount, withdrawalShares, isDepleted\n\n\n@internal\ndef _transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _priceDesk: address,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_fromUser, _toUser, _asset] # dev: invalid users or asset\n\n    # calc shares + amount to transfer\n    transferShares: uint256 = 0\n    transferAmount: uint256 = 0\n    transferShares, transferAmount = self._calcWithdrawalSharesAndAmount(_fromUser, _asset, _transferAmount, _priceDesk)\n\n    # transfer shares\n    isFromUserDepleted: bool = False\n    transferShares, isFromUserDepleted = vaultData._reduceBalanceOnWithdrawal(_fromUser, _asset, transferShares, False)\n    vaultData._addBalanceOnDeposit(_toUser, _asset, transferShares, False)\n\n    return transferAmount, transferShares, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@internal\ndef _getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    totalAmount: uint256 = self._getTotalAmountForVault(_asset)\n    return Vault.VaultDataOnDeposit(\n        hasPosition=vaultData.indexOfUserAsset[_user][_asset] != 0,\n        numAssets=vaultData._getNumUserAssets(_user),\n        userBalance=self._getTotalAmountForUserWithTotalBal(_user, _asset, totalAmount),\n        totalBalance=totalAmount,\n    )\n\n\n@view\n@internal\ndef _getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return vaultData.userBalances[_user][_asset] // DECIMAL_OFFSET\n\n\n@view\n@internal\ndef _getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    # NOTE: cannot borrow against stability pool positions, returning empty/0 to ensure this\n    return empty(address), 0\n\n\n@view\n@internal\ndef _getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), False\n    return asset, vaultData.userBalances[_user][asset] != 0\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@internal\ndef _getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    totalAmount: uint256 = self._getTotalAmountForVault(_asset)\n    return self._getTotalAmountForUserWithTotalBal(_user, _asset, totalAmount)\n\n\n@view\n@internal\ndef _getTotalAmountForUserWithTotalBal(_user: address, _asset: address, _totalAmount: uint256) -> uint256:\n    # NOTE: converting usd value to amount, even though vault may not actually have this asset balance!!\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    if totalShares == 0:\n        return 0\n    return vaultData.userBalances[_user][_asset] * _totalAmount // totalShares\n\n\n@view\n@internal\ndef _getTotalAmountForVault(_asset: address) -> uint256:\n    # NOTE: converting usd value to amount, even though vault may not actually have this asset balance!!\n\n    # get total value of asset\n    priceDesk: address = addys._getPriceDeskAddr()\n    stabAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    totalStabValue: uint256 = staticcall PriceDesk(priceDesk).getUsdValue(_asset, stabAssetBalance, True)\n    claimableValue: uint256 = self._getValueOfClaimableAssets(_asset, priceDesk)\n\n    # return amount if there is claimable value\n    if claimableValue != 0:\n        return staticcall PriceDesk(priceDesk).getAssetAmount(_asset, totalStabValue + claimableValue, True)\n    return stabAssetBalance\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@internal\ndef _calcWithdrawalSharesAndAmount(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _priceDesk: address,\n) -> (uint256, uint256):\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    totalStabAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert totalStabAssetBalance != 0 # dev: no stab asset to withdraw\n\n    # user shares\n    withdrawalShares: uint256 = vaultData.userBalances[_user][_asset]\n    assert withdrawalShares != 0 # dev: user has no shares\n\n    # calc usd values\n    totalStabValue: uint256 = staticcall PriceDesk(_priceDesk).getUsdValue(_asset, totalStabAssetBalance, True)\n    assert totalStabValue != 0 # dev: no price for stab asset\n    claimableValue: uint256 = self._getValueOfClaimableAssets(_asset, _priceDesk)\n    totalValue: uint256 = totalStabValue + claimableValue\n\n    # max withdraw usd value\n    maxWithdrawUsdValue: uint256 = self._sharesToValue(withdrawalShares, totalShares, totalValue, False)\n    maxWithdrawStabAmount: uint256 = maxWithdrawUsdValue * totalStabAssetBalance // totalStabValue\n    assert maxWithdrawStabAmount != 0 # dev: max withdraw stab amount is 0\n\n    # max amount available to withdraw\n    if _amount >= maxWithdrawStabAmount and maxWithdrawStabAmount <= totalStabAssetBalance:\n        return withdrawalShares, maxWithdrawStabAmount\n\n    # finalize withdrawal amount / shares\n    maxAvailStabAmount: uint256 = min(maxWithdrawStabAmount, totalStabAssetBalance)\n    withdrawalAmount: uint256 = min(_amount, maxAvailStabAmount)\n    assert withdrawalAmount != 0 # dev: no withdrawal amount\n\n    withdrawalUsdValue: uint256 = withdrawalAmount * totalStabValue // totalStabAssetBalance\n    withdrawalShares = min(withdrawalShares, self._valueToShares(withdrawalUsdValue, totalShares, totalValue, True))\n    return withdrawalShares, withdrawalAmount\n\n\n# usd value -> shares\n\n\n@view\n@external\ndef valueToShares(_asset: address, _usdValue: uint256, _shouldRoundUp: bool) -> uint256:\n    totalValue: uint256 = self._getTotalValue(_asset)\n    return self._valueToShares(_usdValue, vaultData.totalBalances[_asset], totalValue, _shouldRoundUp)\n\n\n@view\n@internal\ndef _valueToShares(\n    _usdValue: uint256,\n    _totalShares: uint256,\n    _totalUsdValue: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalUsdValue: uint256 = _totalUsdValue\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalUsdValue += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc shares\n    numerator: uint256 = _usdValue * totalShares\n    shares: uint256 = numerator // totalUsdValue\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalUsdValue != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> usd value\n\n\n@view\n@external\ndef sharesToValue(_asset: address, _shares: uint256, _shouldRoundUp: bool) -> uint256:\n    totalValue: uint256 = self._getTotalValue(_asset)\n    return self._sharesToValue(_shares, vaultData.totalBalances[_asset], totalValue, _shouldRoundUp)\n\n\n@view\n@internal\ndef _sharesToValue(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalUsdValue: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalUsdValue: uint256 = _totalUsdValue\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalUsdValue += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc usd value\n    numerator: uint256 = _shares * totalUsdValue\n    usdValue: uint256 = numerator // totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalShares != 0):\n        usdValue += 1\n\n    return usdValue\n\n\n##################\n# Stability Pool #\n##################\n\n\n@external\ndef swapForLiquidatedCollateral(\n    _stabAsset: address,\n    _stabAssetAmount: uint256,\n    _liqAsset: address,\n    _liqAmountSent: uint256,\n    _recipient: address,\n    _greenToken: address,\n    _savingsGreenToken: address,\n) -> uint256:\n    assert not vaultData.isPaused # dev: contract paused\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n\n    assert vaultData.indexOfAsset[_stabAsset] != 0 # dev: stab asset not supported\n    assert vaultData.indexOfAsset[_liqAsset] == 0 # dev: liq asset cannot be vault asset\n    assert _liqAsset != empty(address) # dev: invalid liq asset\n\n    # add claimable balance\n    self._addClaimableBalance(_stabAsset, _liqAsset, _liqAmountSent)\n\n    # finalize amount\n    amount: uint256 = min(_stabAssetAmount, staticcall IERC20(_stabAsset).balanceOf(self))\n    assert amount != 0 # dev: nothing to transfer\n\n    # burn green token\n    if _recipient == empty(address):\n        assert _stabAsset in [_greenToken, _savingsGreenToken] # dev: must be green token or savings green token\n        assert extcall GreenToken(_greenToken).burn(amount) # dev: burn failed\n\n    else:\n        assert extcall IERC20(_stabAsset).transfer(_recipient, amount, default_return_value=True) # dev: transfer failed\n\n    return amount\n\n\n@external\ndef swapWithClaimableGreen(\n    _stabAsset: address,\n    _greenAmount: uint256,\n    _liqAsset: address,\n    _liqAmountSent: uint256,\n    _greenToken: address,\n) -> uint256:\n    assert not vaultData.isPaused # dev: contract paused\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n\n    assert vaultData.indexOfAsset[_stabAsset] != 0 # dev: stab asset not supported\n    assert vaultData.indexOfAsset[_liqAsset] == 0 # dev: liq asset cannot be vault asset\n    assert _liqAsset != empty(address) # dev: invalid liq asset\n\n    # add claimable balance\n    self._addClaimableBalance(_stabAsset, _liqAsset, _liqAmountSent)\n\n    # finalize amount\n    maxClaimableGreen: uint256 = self.claimableBalances[_stabAsset][_greenToken]\n    greenAvailable: uint256 = min(maxClaimableGreen, staticcall IERC20(_greenToken).balanceOf(self))\n    amount: uint256 = min(_greenAmount, greenAvailable)\n    assert amount != 0 # dev: no green\n\n    # reduce green from claimable, and burn\n    self._reduceClaimableBalances(_stabAsset, _greenToken, amount, maxClaimableGreen)\n    assert extcall GreenToken(_greenToken).burn(amount) # dev: burn failed\n\n    return amount\n\n\n# utilities\n\n\n@view\n@external\ndef getTotalValue(_asset: address) -> uint256:\n    return self._getTotalValue(_asset)\n\n\n@view\n@external\ndef getTotalUserValue(_user: address, _asset: address) -> uint256:\n    totalValue: uint256 = self._getTotalValue(_asset)\n    return self._sharesToValue(vaultData.userBalances[_user][_asset], vaultData.totalBalances[_asset], totalValue, False)\n\n\n@view\n@internal\ndef _getTotalValue(_asset: address, _priceDesk: address = empty(address)) -> uint256:\n    priceDesk: address = _priceDesk\n    if priceDesk == empty(address):\n        priceDesk = addys._getPriceDeskAddr()\n    totalStabValue: uint256 = 0\n    stabAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if stabAssetBalance != 0:\n        totalStabValue = staticcall PriceDesk(priceDesk).getUsdValue(_asset, stabAssetBalance, True)\n    claimableValue: uint256 = self._getValueOfClaimableAssets(_asset, priceDesk)\n    return totalStabValue + claimableValue\n\n\n@view\n@internal\ndef _getValueOfClaimableAssets(_stabAsset: address, _priceDesk: address) -> uint256:\n    totalValue: uint256 = 0\n    numClaimableAssets: uint256 = self.numClaimableAssets[_stabAsset]\n    if numClaimableAssets == 0:\n        return 0\n\n    for i: uint256 in range(1, numClaimableAssets, bound=max_value(uint256)):\n        asset: address = self.claimableAssets[_stabAsset][i]\n        if asset == empty(address):\n            continue\n        balance: uint256 = self.claimableBalances[_stabAsset][asset]\n        if balance == 0:\n            continue\n\n        claimValue: uint256 = staticcall PriceDesk(_priceDesk).getUsdValue(asset, balance, True)\n        assert claimValue != 0 # dev: claimable asset has no value\n        totalValue += claimValue\n\n    return totalValue\n\n\n############################\n# Claims (already in pool) #\n############################\n\n\n@external\ndef claimFromStabilityPool(\n    _claimer: address,\n    _stabAsset: address,\n    _claimAsset: address,\n    _maxUsdValue: uint256,\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not vaultData.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    claimUsdValue: uint256 = self._claimFromStabilityPool(_claimer, _stabAsset, _claimAsset, _maxUsdValue, _caller, a.priceDesk, a.missionControl)\n    assert claimUsdValue != 0 # dev: nothing claimed\n    return claimUsdValue\n\n\n@external\ndef claimManyFromStabilityPool(\n    _claimer: address,\n    _claims: DynArray[StabPoolClaim, MAX_STAB_CLAIMS],\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not vaultData.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    totalUsdValue: uint256 = 0\n    for c: StabPoolClaim in _claims:\n        totalUsdValue += self._claimFromStabilityPool(_claimer, c.stabAsset, c.claimAsset, c.maxUsdValue, _caller, a.priceDesk, a.missionControl)\n    assert totalUsdValue != 0 # dev: nothing claimed\n\n    return totalUsdValue\n\n\n@internal\ndef _claimFromStabilityPool(\n    _claimer: address,\n    _stabAsset: address,\n    _claimAsset: address,\n    _maxUsdValue: uint256,\n    _caller: address,\n    _priceDesk: address,\n    _missionControl: address,\n) -> uint256:\n    if empty(address) in [_claimer, _stabAsset, _claimAsset] or _maxUsdValue == 0:\n        return 0\n\n    # check claims config\n    config: StabPoolClaimsConfig = staticcall MissionControl(_missionControl).getStabPoolClaimsConfig(_claimAsset, _claimer, _caller)\n    if not config.canClaimInStabPoolGeneral or not config.canClaimInStabPoolAsset or not config.isUserAllowed:\n        return 0\n\n    if _claimer != _caller:\n        assert config.canClaimFromStabPoolForUser # dev: cannot claim for user\n\n    # max claimable asset\n    maxClaimableAsset: uint256 = self.claimableBalances[_stabAsset][_claimAsset]\n    if maxClaimableAsset == 0:\n        return 0\n\n    # calc shares + amount to withdraw\n    claimShares: uint256 = 0\n    claimAmount: uint256 = 0\n    claimUsdValue: uint256 = 0\n    claimShares, claimAmount, claimUsdValue = self._calcClaimSharesAndAmount(_claimer, _stabAsset, _claimAsset, _maxUsdValue, maxClaimableAsset, _priceDesk)\n    if claimShares == 0:\n        return 0\n\n    # reduce balance on withdrawal\n    isDepleted: bool = False\n    claimShares, isDepleted = vaultData._reduceBalanceOnWithdrawal(_claimer, _stabAsset, claimShares, True)\n\n    # reduce claimable balances\n    self._reduceClaimableBalances(_stabAsset, _claimAsset, claimAmount, maxClaimableAsset)\n\n    # move tokens to recipient\n    assert extcall IERC20(_claimAsset).transfer(_claimer, claimAmount, default_return_value=True) # dev: token transfer failed\n\n    log AssetClaimedInStabilityPool(user=_claimer, stabAsset=_stabAsset, claimAsset=_claimAsset, claimAmount=claimAmount, claimUsdValue=claimUsdValue, claimShares=claimShares, isDepleted=isDepleted)\n    return claimUsdValue\n\n\n@view\n@internal\ndef _calcClaimSharesAndAmount(\n    _claimer: address,\n    _stabAsset: address,\n    _claimAsset: address,\n    _maxUsdValue: uint256,\n    _maxClaimableAsset: uint256,\n    _priceDesk: address,\n) -> (uint256, uint256, uint256):\n\n    # NOTE: failing gracefully here, in case of many claims at same time\n\n    # total claimable asset\n    totalClaimAsset: uint256 = min(_maxClaimableAsset, staticcall IERC20(_claimAsset).balanceOf(self))\n    if totalClaimAsset == 0:\n        return 0, 0, 0 # no claimable asset\n\n    # user shares\n    maxUserShares: uint256 = vaultData.userBalances[_claimer][_stabAsset]\n    if maxUserShares == 0:\n        return 0, 0, 0 # no user shares\n\n    # totals\n    totalShares: uint256 = vaultData.totalBalances[_stabAsset]\n    totalValue: uint256 = self._getTotalValue(_stabAsset)\n\n    # max claim values for user\n    maxClaimUsdValue: uint256 = self._sharesToValue(maxUserShares, totalShares, totalValue, False)\n    maxClaimAmount: uint256 = staticcall PriceDesk(_priceDesk).getAssetAmount(_claimAsset, maxClaimUsdValue, True)\n    if maxClaimAmount == 0:\n        return 0, 0, 0 # not getting price for claim asset\n\n    # max amount available to withdraw\n    if _maxUsdValue >= maxClaimUsdValue and maxClaimAmount <= totalClaimAsset:\n        return maxUserShares, maxClaimAmount, maxClaimUsdValue\n\n    # finalize withdrawal amount / shares\n    claimAmount: uint256 = min(maxClaimAmount, totalClaimAsset)\n    if _maxUsdValue != max_value(uint256):\n        claimAmount = min(claimAmount, _maxUsdValue * maxClaimAmount // maxClaimUsdValue)\n\n    # finalize values\n    claimUsdValue: uint256 = claimAmount * maxClaimUsdValue // maxClaimAmount\n    claimShares: uint256 = min(maxUserShares, self._valueToShares(claimUsdValue, totalShares, totalValue, True))\n    return claimShares, claimAmount, claimUsdValue\n\n\n###############\n# Redemptions #\n###############\n\n\n@external\ndef redeemFromStabilityPool(\n    _asset: address,\n    _greenAmount: uint256,\n    _redeemer: address,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not vaultData.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    assert self._canRedeemInThisVault(a.greenToken) # dev: redemptions not allowed\n\n    greenAmount: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert greenAmount != 0 # dev: no green to redeem\n    greenSpent: uint256 = self._redeemFromStabilityPool(_redeemer, _asset, max_value(uint256), greenAmount, a.greenToken, a.priceDesk, a.missionControl)\n    assert greenSpent != 0 # dev: no redemptions occurred\n\n    # handle leftover green\n    if greenAmount > greenSpent:\n        self._handleGreenForUser(_redeemer, greenAmount - greenSpent, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return greenSpent\n\n\n@external\ndef redeemManyFromStabilityPool(\n    _redemptions: DynArray[StabPoolRedemption, MAX_STAB_REDEMPTIONS],\n    _greenAmount: uint256,\n    _redeemer: address,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not vaultData.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    assert self._canRedeemInThisVault(a.greenToken) # dev: redemptions not allowed\n\n    totalGreenSpent: uint256 = 0\n    totalGreenRemaining: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert totalGreenRemaining != 0 # dev: no green to redeem\n\n    for r: StabPoolRedemption in _redemptions:\n        if totalGreenRemaining == 0:\n            break\n        greenSpent: uint256 = self._redeemFromStabilityPool(_redeemer, r.claimAsset, r.maxGreenAmount, totalGreenRemaining, a.greenToken, a.priceDesk, a.missionControl)\n        totalGreenRemaining -= greenSpent\n        totalGreenSpent += greenSpent\n\n    assert totalGreenSpent != 0 # dev: no redemptions occurred\n\n    # handle leftover green\n    if totalGreenRemaining != 0:\n        self._handleGreenForUser(_redeemer, totalGreenRemaining, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return totalGreenSpent\n\n\n@view\n@internal\ndef _canRedeemInThisVault(_greenToken: address) -> bool:\n    # if green is a stab asset, then it must be the ONLY asset in the vault\n    if vaultData.indexOfAsset[_greenToken] != 0:\n        return vaultData._getNumVaultAssets() == 1\n    return True\n\n\n@internal\ndef _redeemFromStabilityPool(\n    _redeemer: address,\n    _asset: address,\n    _maxGreenForAsset: uint256,\n    _totalGreenRemaining: uint256,\n    _greenToken: address,\n    _priceDesk: address,\n    _missionControl: address,\n) -> uint256:\n\n    # NOTE: failing gracefully here, in case of many redemptions at same time\n\n    # invalid inputs\n    if empty(address) in [_redeemer, _asset] or 0 in [_maxGreenForAsset, _totalGreenRemaining]:\n        return 0\n\n    # check redemption config\n    config: StabPoolRedemptionsConfig = staticcall MissionControl(_missionControl).getStabPoolRedemptionsConfig(_asset, _redeemer)\n    if not config.canRedeemInStabPoolGeneral or not config.canRedeemInStabPoolAsset or not config.isUserAllowed:\n        return 0\n\n    # cannot redeem green token\n    if _asset == _greenToken:\n        return 0\n\n    # treating green as $1\n    maxGreenAvailable: uint256 = min(_totalGreenRemaining, staticcall IERC20(_greenToken).balanceOf(self))\n    maxRedeemValue: uint256 = min(_maxGreenForAsset, maxGreenAvailable)\n    if maxRedeemValue == 0:\n        return 0\n\n    # max claimable amount\n    maxClaimableAmount: uint256 = staticcall PriceDesk(_priceDesk).getAssetAmount(_asset, maxRedeemValue, True)\n    if maxClaimableAmount == 0:\n        return 0\n\n    # total claimable asset\n    actualClaimableAmount: uint256 = min(self.totalClaimableBalances[_asset], staticcall IERC20(_asset).balanceOf(self))\n    if actualClaimableAmount == 0:\n        return 0\n\n    # finalize amounts\n    remainingRedeemValue: uint256 = maxRedeemValue\n    remainingClaimAmount: uint256 = maxClaimableAmount\n    if maxClaimableAmount > actualClaimableAmount:\n        remainingRedeemValue = min(actualClaimableAmount * maxRedeemValue // maxClaimableAmount, maxRedeemValue)\n        remainingClaimAmount = actualClaimableAmount\n\n    greenSpent: uint256 = 0\n    numStabAssets: uint256 = vaultData.numAssets\n    if numStabAssets == 0:\n        return 0\n\n    # iterate thru stab assets\n    for i: uint256 in range(1, numStabAssets, bound=max_value(uint256)):\n        if remainingClaimAmount == 0 or remainingRedeemValue == 0:\n            break\n\n        stabAsset: address = vaultData.vaultAssets[i]\n        if stabAsset == empty(address):\n            continue\n\n        # claimable balance\n        claimableBalance: uint256 = self.claimableBalances[stabAsset][_asset]\n        if claimableBalance == 0:\n            continue\n\n        # reduce claimable balances\n        claimAmount: uint256 = min(remainingClaimAmount, claimableBalance)\n        self._reduceClaimableBalances(stabAsset, _asset, claimAmount, claimableBalance)\n        assert extcall IERC20(_asset).transfer(_redeemer, claimAmount, default_return_value=True) # dev: transfer failed\n        remainingClaimAmount -= claimAmount\n\n        # add green to claimable\n        redeemAmount: uint256 = min(claimAmount * maxRedeemValue // maxClaimableAmount, remainingRedeemValue)\n        self._addClaimableBalance(stabAsset, _greenToken, redeemAmount)\n        remainingRedeemValue -= redeemAmount\n        greenSpent += redeemAmount\n\n    return greenSpent\n\n\n##################\n# Green Handling #\n##################\n\n\n@internal\ndef _handleGreenForUser(\n    _recipient: address,\n    _greenAmount: uint256,\n    _wantsSavingsGreen: bool,\n    _greenToken: address,\n    _savingsGreen: address,\n):\n    amount: uint256 = min(_greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n    if amount == 0:\n        return\n\n    if _wantsSavingsGreen:\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, amount, default_return_value=True) # dev: green approval failed\n        extcall IERC4626(_savingsGreen).deposit(amount, _recipient)\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n    else:\n        assert extcall IERC20(_greenToken).transfer(_recipient, amount, default_return_value=True) # dev: green transfer failed\n\n\n##################\n# Claimable Data #\n##################\n\n\n# add claimable\n\n\n@internal\ndef _addClaimableBalance(\n    _stabAsset: address,\n    _claimAsset: address,\n    _claimAmount: uint256,\n):\n    claimAmount: uint256 = min(_claimAmount, staticcall IERC20(_claimAsset).balanceOf(self))\n    assert claimAmount != 0 # dev: nothing received\n\n    # update balances\n    self.claimableBalances[_stabAsset][_claimAsset] += claimAmount\n    self.totalClaimableBalances[_claimAsset] += claimAmount\n\n    # register claimable asset if not already registered\n    if self.indexOfClaimableAsset[_stabAsset][_claimAsset] == 0:\n        self._registerClaimableAsset(_stabAsset, _claimAsset)\n\n\n# register claimable asset\n\n\n@internal\ndef _registerClaimableAsset(_stabAsset: address, _assetReceived: address):\n    cid: uint256 = self.numClaimableAssets[_stabAsset]\n    if cid == 0:\n        cid = 1 # not using 0 index\n    self.claimableAssets[_stabAsset][cid] = _assetReceived\n    self.indexOfClaimableAsset[_stabAsset][_assetReceived] = cid\n    self.numClaimableAssets[_stabAsset] = cid + 1\n\n\n# reduce claimable\n\n\n@internal\ndef _reduceClaimableBalances(\n    _stabAsset: address,\n    _claimAsset: address,\n    _claimAmount: uint256,\n    _prevClaimableBalance: uint256,\n):\n    newClaimableBalance: uint256 = _prevClaimableBalance - _claimAmount\n    self.claimableBalances[_stabAsset][_claimAsset] = newClaimableBalance\n    self.totalClaimableBalances[_claimAsset] -= _claimAmount\n\n    # remove claimable asset if depleted\n    if newClaimableBalance == 0:\n        self._removeClaimableAsset(_stabAsset, _claimAsset)\n\n\n# deregister claimable asset\n\n\n@internal\ndef _removeClaimableAsset(_stabAsset: address, _asset: address):\n    numAssets: uint256 = self.numClaimableAssets[_stabAsset]\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfClaimableAsset[_stabAsset][_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numClaimableAssets[_stabAsset] = lastIndex\n    self.indexOfClaimableAsset[_stabAsset][_asset] = 0\n\n    # shift to replace the one being removed\n    if targetIndex != lastIndex:\n        lastAsset: address = self.claimableAssets[_stabAsset][lastIndex]\n        self.claimableAssets[_stabAsset][targetIndex] = lastAsset\n        self.indexOfClaimableAsset[_stabAsset][lastAsset] = targetIndex",
            "sha256sum": "a4af45f83d207314181279133d436d9bcc6fb62e356f5791e1e01d954e4b3f14"
          },
          "contracts/vaults/StabilityPool.vy": {
            "content": "# @version 0.4.1\n\nimplements: Vault\n\nexports: addys.__interface__\nexports: vaultData.__interface__\nexports: stabVault.__interface__\n\ninitializes: addys\ninitializes: vaultData[addys := addys]\ninitializes: stabVault[addys := addys, vaultData := vaultData]\n\nfrom interfaces import Vault\nimport contracts.modules.Addys as addys\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.vaults.modules.StabVault as stabVault\nfrom ethereum.ercs import IERC20\n\nevent StabilityPoolDeposit:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    shares: uint256\n\nevent StabilityPoolWithdrawal:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    isDepleted: bool\n    shares: uint256\n\nevent StabilityPoolTransfer:\n    fromUser: indexed(address)\n    toUser: indexed(address)\n    asset: indexed(address)\n    transferAmount: uint256\n    isFromUserDepleted: bool\n    transferShares: uint256\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    vaultData.__init__(False)\n    stabVault.__init__()\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    a: addys.Addys = addys._getAddys(_a)\n\n    depositAmount: uint256 = 0\n    newShares: uint256 = 0\n    depositAmount, newShares = stabVault._depositTokensInVault(_user, _asset, _amount, a.priceDesk)\n    log StabilityPoolDeposit(user=_user, asset=_asset, amount=depositAmount, shares=newShares)\n    return depositAmount\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getTellerAddr(), addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n    a: addys.Addys = addys._getAddys(_a)\n\n    withdrawalAmount: uint256 = 0\n    withdrawalShares: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, withdrawalShares, isDepleted = stabVault._withdrawTokensFromVault(_user, _asset, _amount, _recipient, a.priceDesk)\n    log StabilityPoolWithdrawal(user=_user, asset=_asset, amount=withdrawalAmount, isDepleted=isDepleted, shares=withdrawalShares)\n    return withdrawalAmount, isDepleted\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n    a: addys.Addys = addys._getAddys(_a)\n\n    transferAmount: uint256 = 0\n    transferShares: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, transferShares, isFromUserDepleted = stabVault._transferBalanceWithinVault(_asset, _fromUser, _toUser, _transferAmount, a.priceDesk)\n    log StabilityPoolTransfer(fromUser=_fromUser, toUser=_toUser, asset=_asset, transferAmount=transferAmount, isFromUserDepleted=isFromUserDepleted, transferShares=transferShares)\n    return transferAmount, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return stabVault._getVaultDataOnDeposit(_user, _asset)\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return stabVault._getUserLootBoxShare(_user, _asset)\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    return stabVault._getUserAssetAndAmountAtIndex(_user, _index)\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    return stabVault._getUserAssetAtIndexAndHasBalance(_user, _index)\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return stabVault._getTotalAmountForUser(_user, _asset)\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    return stabVault._getTotalAmountForVault(_asset)\n",
            "sha256sum": "aa5ae2265033b37ce8d3a4c59ef90fe3a171c69ae45989ee2faf59b64c042f83"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/StabilityPool.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "627778936fa20631552ffc72c7f58c0c8b470078c19e4b793f83111b94597486"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e"
    },
    "AuctionHouse": {
      "address": "0xE5D77B63c751AE3284cba39a98fb2ec80C926640",
      "abi": [
        {
          "name": "LiquidateUser",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalLiqFees",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "targetRepayAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "didRestoreDebtHealth",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "collateralValueOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqFeesUnpaid",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numAuctionsStarted",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "keeperFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CollateralSentToEndaoment",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountSent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabAssetBurntAsRepayment",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqStabAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CollateralSwappedWithStabPool",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqVaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "collateralAmountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "collateralValueOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabVaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetSwapped",
              "type": "address",
              "indexed": false
            },
            {
              "name": "amountSwapped",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "valueSwapped",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FungibleAuctionUpdated",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "startDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "startBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "endBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isNewAuction",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FungibleAuctionPaused",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FungAuctionPurchased",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqVaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "greenSpent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "buyer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "collateralAmountSent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "collateralUsdValueSent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isPositionDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateUser",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_keeper",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateUser",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_keeper",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateManyUsers",
          "inputs": [
            {
              "name": "_liqUsers",
              "type": "address[]"
            },
            {
              "name": "_keeper",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateManyUsers",
          "inputs": [
            {
              "name": "_liqUsers",
              "type": "address[]"
            },
            {
              "name": "_keeper",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canStartAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_buyer",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_buyer",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_buyer",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_buyer",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "calcAmountOfDebtToRepayDuringLiq",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "cdcbc1c83a0ffa09166c89d2698097b5dee00d2ebebf714134ab8faa6e9ff685"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/core/AuctionHouse.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\ninterface Ledger:\n    def setFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address, _auc: FungibleAuction) -> bool: nonpayable\n    def getFungibleAuctionDuringPurchase(_liqUser: address, _vaultId: uint256, _asset: address) -> FungibleAuction: view\n    def removeFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address): nonpayable\n    def hasFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address) -> bool: view\n    def isParticipatingInVault(_user: address, _vaultId: uint256) -> bool: view\n    def createNewFungibleAuction(_auc: FungibleAuction) -> uint256: nonpayable\n    def addVaultToUser(_user: address, _vaultId: uint256): nonpayable\n    def userVaults(_user: address, _index: uint256) -> uint256: view\n    def isUserInLiquidation(_user: address) -> bool: view\n    def numUserVaults(_user: address) -> uint256: view\n\ninterface MissionControl:\n    def getAuctionBuyConfig(_asset: address, _buyer: address) -> AuctionBuyConfig: view\n    def getAssetLiqConfig(_asset: address) -> AssetLiqConfig: view\n    def getGenAuctionParams() -> AuctionParams: view\n    def getGenLiqConfig() -> GenLiqConfig: view\n\ninterface StabilityPool:\n    def swapForLiquidatedCollateral(_stabAsset: address, _stabAmountToRemove: uint256, _liqAsset: address, _liqAmountSent: uint256, _recipient: address, _greenToken: address, _savingsGreenToken: address) -> uint256: nonpayable\n    def swapWithClaimableGreen(_stabAsset: address, _greenAmount: uint256, _liqAsset: address, _liqAmountSent: uint256, _greenToken: address) -> uint256: nonpayable\n    def claimableBalances(_stabAsset: address, _greenToken: address) -> uint256: view\n\ninterface CreditEngine:\n    def repayDuringLiquidation(_liqUser: address, _userDebt: UserDebt, _repayAmount: uint256, _newInterest: uint256, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n    def getLatestUserDebtAndTerms(_user: address, _shouldRaise: bool, _a: addys.Addys = empty(addys.Addys)) -> (UserDebt, UserBorrowTerms, uint256): view\n    def repayDuringAuctionPurchase(_liqUser: address, _repayAmount: uint256, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n\ninterface PriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface GreenToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n    def burn(_amount: uint256): nonpayable\n\ninterface LootBox:\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface VaultBook:\n    def getAddr(_vaultId: uint256) -> address: view\n\ninterface StabAsset:\n    def burn(_amount: uint256) -> bool: nonpayable\n\nstruct AuctionBuyConfig:\n    canBuyInAuctionGeneral: bool\n    canBuyInAuctionAsset: bool\n    isUserAllowed: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserBorrowTerms:\n    collateralVal: uint256\n    totalMaxDebt: uint256\n    debtTerms: DebtTerms\n\nstruct UserDebt:\n    amount: uint256\n    principal: uint256\n    debtTerms: DebtTerms\n    lastTimestamp: uint256\n    inLiquidation: bool\n\nstruct VaultData:\n    vaultId: uint256\n    vaultAddr: address\n    asset: address\n\nstruct GenLiqConfig:\n    canLiquidate: bool\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n    priorityLiqAssetVaults: DynArray[VaultData, PRIORITY_LIQ_VAULT_DATA]\n    priorityStabVaults: DynArray[VaultData, MAX_STAB_VAULT_DATA]\n\nstruct AssetLiqConfig:\n    hasConfig: bool\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    customAuctionParams: AuctionParams\n    specialStabPool: VaultData\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct FungibleAuction:\n    liqUser: address\n    vaultId: uint256\n    asset: address \n    startDiscount: uint256\n    maxDiscount: uint256\n    startBlock: uint256\n    endBlock: uint256\n    isActive: bool\n\nstruct FungAuctionPurchase:\n    liqUser: address\n    vaultId: uint256\n    asset: address\n    maxGreenAmount: uint256\n\nstruct FungAuctionConfig:\n    liqUser: address\n    vaultId: uint256\n    asset: address\n\nevent LiquidateUser:\n    user: indexed(address)\n    totalLiqFees: uint256\n    targetRepayAmount: uint256\n    repayAmount: uint256\n    didRestoreDebtHealth: bool\n    collateralValueOut: uint256\n    liqFeesUnpaid: uint256\n    numAuctionsStarted: uint256\n    keeperFee: uint256\n\nevent CollateralSentToEndaoment:\n    liqUser: indexed(address)\n    vaultId: uint256\n    liqAsset: indexed(address)\n    amountSent: uint256\n    usdValue: uint256\n    isDepleted: bool\n\nevent StabAssetBurntAsRepayment:\n    liqUser: indexed(address)\n    vaultId: uint256\n    liqStabAsset: indexed(address)\n    amountBurned: uint256\n    usdValue: uint256\n    isDepleted: bool\n\nevent CollateralSwappedWithStabPool:\n    liqUser: indexed(address)\n    liqVaultId: uint256\n    liqAsset: indexed(address)\n    collateralAmountOut: uint256\n    collateralValueOut: uint256\n    stabVaultId: uint256\n    stabAsset: indexed(address)\n    assetSwapped: address\n    amountSwapped: uint256\n    valueSwapped: uint256\n\nevent FungibleAuctionUpdated:\n    liqUser: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    startDiscount: uint256\n    maxDiscount: uint256\n    startBlock: uint256\n    endBlock: uint256\n    isNewAuction: bool\n\nevent FungibleAuctionPaused:\n    liqUser: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n\nevent FungAuctionPurchased:\n    liqUser: indexed(address)\n    liqVaultId: uint256\n    liqAsset: indexed(address)\n    greenSpent: uint256\n    buyer: indexed(address)\n    collateralAmountSent: uint256\n    collateralUsdValueSent: uint256\n    isPositionDepleted: bool\n    hasGoodDebtHealth: bool\n\n# cache\nvaultAddrs: transient(HashMap[uint256, address]) # vaultId -> vaultAddr\nassetLiqConfig: transient(HashMap[address, AssetLiqConfig]) # asset -> config\ndidHandleLiqAsset: transient(HashMap[address, HashMap[uint256, HashMap[address, bool]]]) # user -> vaultId -> asset -> did handle\ndidHandleVaultId: transient(HashMap[address, HashMap[uint256, bool]]) # user -> vaultId -> did handle\nnumUserAssetsForAuction: transient(HashMap[address, uint256]) # user -> num assets\nuserAssetForAuction: transient(HashMap[address, HashMap[uint256, VaultData]]) # user -> index -> asset\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nONE_PERCENT: constant(uint256) = 1_00 # 1%\nMAX_STAB_VAULT_DATA: constant(uint256) = 10\nPRIORITY_LIQ_VAULT_DATA: constant(uint256) = 20\nMAX_LIQ_USERS: constant(uint256) = 50\nMAX_AUCTIONS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, True, False) # can mint green (keeper rewards)\n\n\n###############\n# Liquidation #\n###############\n\n\n@external\ndef liquidateUser(\n    _liqUser: address,\n    _keeper: address,\n    _wantsSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n    assert config.canLiquidate # dev: cannot liquidate\n\n    # liquidate user\n    keeperRewards: uint256 = self._liquidateUser(_liqUser, config, a)\n\n    # handle keeper rewards\n    if keeperRewards != 0:\n        self._handleGreenForUser(_keeper, keeperRewards, True, _wantsSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return keeperRewards\n\n\n@external\ndef liquidateManyUsers(\n    _liqUsers: DynArray[address, MAX_LIQ_USERS],\n    _keeper: address,\n    _wantsSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n    assert config.canLiquidate # dev: cannot liquidate\n\n    totalKeeperRewards: uint256 = 0\n    for liqUser: address in _liqUsers:\n        totalKeeperRewards += self._liquidateUser(liqUser, config, a)\n\n    # handle keeper rewards\n    if totalKeeperRewards != 0:\n        self._handleGreenForUser(_keeper, totalKeeperRewards, True, _wantsSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return totalKeeperRewards\n\n\n@internal\ndef _liquidateUser(\n    _liqUser: address,\n    _config: GenLiqConfig,\n    _a: addys.Addys,\n) -> uint256:\n    if _liqUser == empty(address):\n        return 0\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    newInterest: uint256 = 0\n    userDebt, bt, newInterest = staticcall CreditEngine(_a.creditEngine).getLatestUserDebtAndTerms(_liqUser, True, _a)\n\n    # no debt\n    if userDebt.amount == 0:\n        return 0\n\n    # already in liquidation\n    if userDebt.inLiquidation:\n        return 0\n\n    # not reached liquidation threshold\n    collateralLiqThreshold: uint256 = userDebt.amount * HUNDRED_PERCENT // bt.debtTerms.liqThreshold\n    if bt.collateralVal > collateralLiqThreshold:\n        return 0\n\n    # set liquidation mode\n    userDebt.inLiquidation = True\n\n    # liquidation fees\n    totalLiqFees: uint256 = userDebt.amount * bt.debtTerms.liqFee // HUNDRED_PERCENT\n    liqFeeRatio: uint256 = bt.debtTerms.liqFee\n\n    # keeper fee (for liquidator)\n    keeperFee: uint256 = max(_config.minKeeperFee, userDebt.amount * _config.keeperFeeRatio // HUNDRED_PERCENT)\n    if keeperFee != 0:\n        totalLiqFees += keeperFee\n        liqFeeRatio = totalLiqFees * HUNDRED_PERCENT // userDebt.amount\n\n    # how much to achieve safe LTV -- won't be exact because depends on which collateral is liquidated (LTV changes)\n    targetLtv: uint256 = bt.debtTerms.ltv * (HUNDRED_PERCENT - _config.ltvPaybackBuffer) // HUNDRED_PERCENT\n    targetRepayAmount: uint256 = self._calcAmountOfDebtToRepay(userDebt.amount, bt.collateralVal, targetLtv, liqFeeRatio, totalLiqFees)\n\n    # perform liquidation phases\n    repayValueIn: uint256 = 0\n    collateralValueOut: uint256 = 0\n    repayValueIn, collateralValueOut = self._performLiquidationPhases(_liqUser, targetRepayAmount, liqFeeRatio, _config, _a)\n\n    # check if liq fees were already covered (stability pool swaps)\n    liqFeesUnpaid: uint256 = totalLiqFees\n    if collateralValueOut > repayValueIn:\n        paidLiqFees: uint256 = collateralValueOut - repayValueIn\n        liqFeesUnpaid -= min(paidLiqFees, liqFeesUnpaid)\n\n    # repayValueIn may be zero, but need to update debt\n    userDebt.amount += liqFeesUnpaid\n    repayValueIn = min(repayValueIn, userDebt.amount)\n    didRestoreDebtHealth: bool = extcall CreditEngine(_a.creditEngine).repayDuringLiquidation(_liqUser, userDebt, repayValueIn, newInterest, _a)\n\n    # start auctions (if necessary)\n    numAuctionsStarted: uint256 = 0\n    if not didRestoreDebtHealth:\n        numAuctionsStarted = self._startAuctionsDuringLiq(_liqUser, _config.genAuctionParams, _a.missionControl, _a.ledger)\n\n    log LiquidateUser(\n        user=_liqUser,\n        totalLiqFees=totalLiqFees,\n        targetRepayAmount=targetRepayAmount,\n        repayAmount=repayValueIn,\n        didRestoreDebtHealth=didRestoreDebtHealth,\n        collateralValueOut=collateralValueOut,\n        liqFeesUnpaid=liqFeesUnpaid,\n        numAuctionsStarted=numAuctionsStarted,\n        keeperFee=keeperFee,\n    )\n    return keeperFee\n\n\n########################\n# Liquidation - Phases #\n########################\n\n\n@internal\ndef _performLiquidationPhases(\n    _liqUser: address,\n    _targetRepayAmount: uint256,\n    _liqFeeRatio: uint256,\n    _config: GenLiqConfig,\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    remainingToRepay: uint256 = _targetRepayAmount\n    collateralValueOut: uint256 = 0\n\n    # PHASE 1 -- If liq user is in stability pool, use those assets first to pay off debt\n\n    for stabPool: VaultData in _config.priorityStabVaults:\n        if remainingToRepay == 0:\n            break\n\n        if not staticcall Ledger(_a.ledger).isParticipatingInVault(_liqUser, stabPool.vaultId):\n            continue\n\n        remainingToRepay, collateralValueOut = self._iterateThruAssetsWithinVault(_liqUser, stabPool.vaultId, stabPool.vaultAddr, remainingToRepay, collateralValueOut, _liqFeeRatio, [], _a)\n        if self.vaultAddrs[stabPool.vaultId] == empty(address):\n            self.vaultAddrs[stabPool.vaultId] = stabPool.vaultAddr # cache\n\n    # PHASE 2 -- Go thru priority liq assets (set in mission control)\n\n    if remainingToRepay != 0:\n        for pData: VaultData in _config.priorityLiqAssetVaults:\n            if remainingToRepay == 0:\n                break\n\n            if not staticcall Vault(pData.vaultAddr).doesUserHaveBalance(_liqUser, pData.asset):\n                continue\n\n            remainingToRepay, collateralValueOut = self._handleSpecificLiqAsset(_liqUser, pData.vaultId, pData.vaultAddr, pData.asset, remainingToRepay, collateralValueOut, _liqFeeRatio, _config.priorityStabVaults, _a)\n            if self.vaultAddrs[pData.vaultId] == empty(address):\n                self.vaultAddrs[pData.vaultId] = pData.vaultAddr # cache\n\n    # PHASE 3 -- Go thru user's vaults (top to bottom as saved in ledger / vaults)\n\n    if remainingToRepay != 0:\n        remainingToRepay, collateralValueOut = self._iterateThruAllUserVaults(_liqUser, remainingToRepay, collateralValueOut, _liqFeeRatio, _config.priorityStabVaults, _a)\n\n    return _targetRepayAmount - remainingToRepay, collateralValueOut\n\n\n#################################\n# Liquidation - All User Vaults #\n#################################\n\n\n@internal\ndef _iterateThruAllUserVaults(\n    _liqUser: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _liqFeeRatio: uint256,\n    _genStabPools: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # iterate thru each user vault\n    numUserVaults: uint256 = staticcall Ledger(_a.ledger).numUserVaults(_liqUser)\n    for i: uint256 in range(1, numUserVaults, bound=max_value(uint256)):\n        if remainingToRepay == 0:\n            break\n\n        vaultId: uint256 = staticcall Ledger(_a.ledger).userVaults(_liqUser, i)\n\n        # get vault address\n        vaultAddr: address = empty(address)\n        isVaultAddrCached: bool = False\n        vaultAddr, isVaultAddrCached = self._getVaultAddr(vaultId, _a.vaultBook)\n        if vaultAddr == empty(address):\n            continue\n\n        # cache vault addr\n        if not isVaultAddrCached:\n            self.vaultAddrs[vaultId] = vaultAddr\n\n        remainingToRepay, collateralValueOut = self._iterateThruAssetsWithinVault(_liqUser, vaultId, vaultAddr, remainingToRepay, collateralValueOut, _liqFeeRatio, _genStabPools, _a)\n\n    return remainingToRepay, collateralValueOut\n\n\n#####################################\n# Liquidation - Assets Within Vault #\n#####################################\n\n\n@internal\ndef _iterateThruAssetsWithinVault(\n    _liqUser: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _liqFeeRatio: uint256,\n    _genStabPools: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _a: addys.Addys,\n) -> (uint256, uint256):\n\n    # check if we've already handled this vault\n    if self.didHandleVaultId[_liqUser][_vaultId]:\n        return _remainingToRepay, _collateralValueOut\n    self.didHandleVaultId[_liqUser][_vaultId] = True\n\n    # no assets in vault, skip\n    numUserAssets: uint256 = staticcall Vault(_vaultAddr).numUserAssets(_liqUser)\n    if numUserAssets == 0:\n        return _remainingToRepay, _collateralValueOut\n\n    # totals\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n    for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n        if remainingToRepay == 0:\n            break\n\n        # check if user still has balance in this asset\n        liqAsset: address = empty(address)\n        hasBalance: bool = False\n        liqAsset, hasBalance = staticcall Vault(_vaultAddr).getUserAssetAtIndexAndHasBalance(_liqUser, y)\n        if liqAsset == empty(address) or not hasBalance:\n            continue\n\n        # handle specific liq asset\n        remainingToRepay, collateralValueOut = self._handleSpecificLiqAsset(_liqUser, _vaultId, _vaultAddr, liqAsset, remainingToRepay, collateralValueOut, _liqFeeRatio, _genStabPools, _a)\n\n    return remainingToRepay, collateralValueOut\n\n\n################################\n# Liquidation - Specific Asset #\n################################\n\n\n@internal\ndef _handleSpecificLiqAsset(\n    _liqUser: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _liqAsset: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _liqFeeRatio: uint256,\n    _genStabPools: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _a: addys.Addys,\n) -> (uint256, uint256):\n\n    # check if we've already handled this liq asset (cache for next time)\n    if self.didHandleLiqAsset[_liqUser][_vaultId][_liqAsset]:\n        return _remainingToRepay, _collateralValueOut\n    self.didHandleLiqAsset[_liqUser][_vaultId][_liqAsset] = True\n\n    # asset liq config\n    config: AssetLiqConfig = empty(AssetLiqConfig)\n    isConfigCached: bool = False\n    config, isConfigCached = self._getAssetLiqConfig(_liqAsset, _a.missionControl)\n    if not isConfigCached:\n        self.assetLiqConfig[_liqAsset] = config\n\n    # totals\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # burn as payment (GREEN, sGREEN)\n    if config.shouldBurnAsPayment:\n        remainingToRepay, collateralValueOut = self._burnLiqUserStabAsset(_liqUser, _vaultId, _vaultAddr, _liqAsset, remainingToRepay, collateralValueOut, _a)\n        return remainingToRepay, collateralValueOut\n\n    # endaoment wants this asset (other stablecoins)\n    if config.shouldTransferToEndaoment:\n        remainingToRepay, collateralValueOut = self._transferToEndaoment(_liqUser, _vaultId, _vaultAddr, _liqAsset, remainingToRepay, collateralValueOut, _a)\n        return remainingToRepay, collateralValueOut\n\n    # stability pool swaps (eth, btc, etc)\n    isPositionDepleted: bool = False\n    if config.shouldSwapInStabPools:\n        remainingToRepay, collateralValueOut, isPositionDepleted = self._swapWithStabPools(_liqUser, _vaultId, _vaultAddr, _liqAsset, _liqFeeRatio, remainingToRepay, collateralValueOut, config.specialStabPool, _genStabPools, _a)\n\n    # add to auction list if not depleted\n    if config.shouldAuctionInstantly and not isPositionDepleted:\n        self._saveLiqAssetForAuction(_liqUser, _vaultId, _vaultAddr, _liqAsset)\n\n    return remainingToRepay, collateralValueOut\n\n\n####################################\n# Liquidation - Endaoment Transfer #\n####################################\n\n\n@internal\ndef _transferToEndaoment(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    collateralUsdValueSent: uint256 = 0\n    collateralAmountSent: uint256 = 0\n    isPositionDepleted: bool = False\n    na: bool = False\n    collateralUsdValueSent, collateralAmountSent, isPositionDepleted, na = self._transferCollateral(_liqUser, _a.endaoment, _liqVaultId, _liqVaultAddr, _liqAsset, False, remainingToRepay, _a)\n    if collateralUsdValueSent == 0:\n        return remainingToRepay, collateralValueOut\n\n    # update totals\n    remainingToRepay -= min(collateralUsdValueSent, remainingToRepay)\n    collateralValueOut += collateralUsdValueSent\n\n    log CollateralSentToEndaoment(\n        liqUser=_liqUser,\n        vaultId=_liqVaultId,\n        liqAsset=_liqAsset,\n        amountSent=collateralAmountSent,\n        usdValue=collateralUsdValueSent,\n        isDepleted=isPositionDepleted,\n    )\n    return remainingToRepay, collateralValueOut\n\n\n#################################\n# Liquidation - Burn Stab Asset #\n#################################\n\n\n@internal\ndef _burnLiqUserStabAsset(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqStabAsset: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    usdValue: uint256 = 0\n    amountReceived: uint256 = 0\n    isPositionDepleted: bool = False\n    na: bool = False\n    usdValue, amountReceived, isPositionDepleted, na = self._transferCollateral(_liqUser, self, _liqVaultId, _liqVaultAddr, _liqStabAsset, False, remainingToRepay, _a)\n    if usdValue == 0:\n        return remainingToRepay, collateralValueOut\n\n    # burn stab asset\n    assert extcall StabAsset(_liqStabAsset).burn(amountReceived) # dev: failed to burn stab asset\n\n    # update totals\n    remainingToRepay -= min(usdValue, remainingToRepay)\n    collateralValueOut += usdValue\n\n    log StabAssetBurntAsRepayment(\n        liqUser=_liqUser,\n        vaultId=_liqVaultId,\n        liqStabAsset=_liqStabAsset,\n        amountBurned=amountReceived,\n        usdValue=usdValue,\n        isDepleted=isPositionDepleted,\n    )\n    return remainingToRepay, collateralValueOut\n\n\n######################################\n# Liquidation - Stability Pool Swaps #\n######################################\n\n\n# iterate thru stab pools\n\n\n@internal\ndef _swapWithStabPools(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _liqFeeRatio: uint256,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _specialStabPool: VaultData,\n    _genStabPools: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _a: addys.Addys,\n) -> (uint256, uint256, bool):\n\n    # stability pools to use\n    stabPoolsToUse: DynArray[VaultData, MAX_STAB_VAULT_DATA] = _genStabPools\n    if _specialStabPool.vaultAddr != empty(address):\n        stabPoolsToUse = [_specialStabPool]\n\n    # nothing to do here\n    if len(stabPoolsToUse) == 0:\n        return _remainingToRepay, _collateralValueOut, False\n\n    # totals\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # iterate thru each stab pool\n    isPositionDepleted: bool = False\n    for stabPool: VaultData in stabPoolsToUse:\n        if remainingToRepay == 0:\n            break\n\n        # swap with stability pool\n        shouldGoToNextAsset: bool = False\n        remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset = self._swapWithSpecificStabPool(stabPool, _liqUser, _liqVaultId, _liqVaultAddr, _liqAsset, _liqFeeRatio, remainingToRepay, collateralValueOut, _a)\n\n        # nothing else to do here\n        if isPositionDepleted or shouldGoToNextAsset:\n            break\n\n    return remainingToRepay, collateralValueOut, isPositionDepleted\n\n\n# individual stability pool swap\n\n\n@internal\ndef _swapWithSpecificStabPool(\n    _stabPool: VaultData,\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _liqFeeRatio: uint256,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool, bool):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # cannot liquidate asset that is also a stability pool asset in that vault\n    if staticcall Vault(_stabPool.vaultAddr).isSupportedVaultAsset(_liqAsset):\n        return remainingToRepay, collateralValueOut, False, False\n\n    # check for green redemptions for this stab asset\n    isPositionDepleted: bool = False\n    shouldGoToNextAsset: bool = False\n    remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset = self._swapWithGreenRedemptions(_stabPool, _liqUser, _liqVaultId, _liqVaultAddr, _liqAsset, _liqFeeRatio, remainingToRepay, collateralValueOut, _a)\n    if remainingToRepay == 0 or isPositionDepleted or shouldGoToNextAsset:\n        return remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset\n\n    # no balance in stability pool, skip\n    maxAmountInStabPool: uint256 = staticcall IERC20(_stabPool.asset).balanceOf(_stabPool.vaultAddr)\n    if maxAmountInStabPool == 0:\n        return remainingToRepay, collateralValueOut, False, False\n\n    # max usd value in stability pool\n    maxUsdValueInStabPool: uint256 = staticcall PriceDesk(_a.priceDesk).getUsdValue(_stabPool.asset, maxAmountInStabPool, True)     \n    if maxUsdValueInStabPool == 0:\n        return remainingToRepay, collateralValueOut, False, False # can't get price of stab asset, skip      \n\n    # where to move stab asset\n    stabProceedsAddr: address = _a.endaoment # non-green assets, move to Endaoment\n    if _stabPool.asset in [_a.greenToken, _a.savingsGreen]:\n        stabProceedsAddr = empty(address)\n\n    # swap with stability pool\n    return self._swapAssetsWithStabPool(True, _liqUser, _liqVaultId, _liqVaultAddr, _liqAsset, _liqFeeRatio, maxAmountInStabPool, maxUsdValueInStabPool, remainingToRepay, collateralValueOut, _stabPool, stabProceedsAddr, _a)\n\n\n@internal\ndef _swapWithGreenRedemptions(\n    _stabPool: VaultData,\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _liqFeeRatio: uint256,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool, bool):\n    maxClaimableGreen: uint256 = staticcall StabilityPool(_stabPool.vaultAddr).claimableBalances(_stabPool.asset, _a.greenToken)\n    if maxClaimableGreen == 0:\n        return _remainingToRepay, _collateralValueOut, False, False\n    return self._swapAssetsWithStabPool(False, _liqUser, _liqVaultId, _liqVaultAddr, _liqAsset, _liqFeeRatio, maxClaimableGreen, maxClaimableGreen, _remainingToRepay, _collateralValueOut, _stabPool, empty(address), _a)\n\n\n@internal\ndef _swapAssetsWithStabPool(\n    _isNormalStabSwap: bool,\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _liqFeeRatio: uint256,\n    _maxAmountInStabPool: uint256,\n    _maxUsdValueInStabPool: uint256,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _stabPool: VaultData,\n    _stabProceedsAddr: address,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool, bool):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # max collateral usd value (to take from liq user)\n    maxCollateralUsdValue: uint256 = min(_maxUsdValueInStabPool, remainingToRepay) * HUNDRED_PERCENT // (HUNDRED_PERCENT - _liqFeeRatio)\n\n    # transfer collateral to stability pool\n    collateralUsdValueSent: uint256 = 0\n    collateralAmountSent: uint256 = 0\n    isPositionDepleted: bool = False\n    shouldGoToNextAsset: bool = False\n    collateralUsdValueSent, collateralAmountSent, isPositionDepleted, shouldGoToNextAsset = self._transferCollateral(_liqUser, _stabPool.vaultAddr, _liqVaultId, _liqVaultAddr, _liqAsset, False, maxCollateralUsdValue, _a)\n    if collateralUsdValueSent == 0 or collateralAmountSent == 0:\n        return remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset\n\n    # calc target stab pool values\n    targetStabPoolUsdValue: uint256 = collateralUsdValueSent * (HUNDRED_PERCENT - _liqFeeRatio) // HUNDRED_PERCENT\n    targetStabPoolAmount: uint256 = targetStabPoolUsdValue * _maxAmountInStabPool // _maxUsdValueInStabPool\n\n    # take asset out of stability pool\n    stabPoolAmount: uint256 = 0\n    assetSwapped: address = empty(address)\n    if _isNormalStabSwap:\n        stabPoolAmount = extcall StabilityPool(_stabPool.vaultAddr).swapForLiquidatedCollateral(_stabPool.asset, targetStabPoolAmount, _liqAsset, collateralAmountSent, _stabProceedsAddr, _a.greenToken, _a.savingsGreen)\n        assetSwapped = _stabPool.asset\n    else:\n        stabPoolAmount = extcall StabilityPool(_stabPool.vaultAddr).swapWithClaimableGreen(_stabPool.asset, targetStabPoolAmount, _liqAsset, collateralAmountSent, _a.greenToken)\n        assetSwapped = _a.greenToken\n\n    # verify it's a fair swap\n    assert self._isPaymentCloseEnough(targetStabPoolAmount, stabPoolAmount) # dev: invalid stability pool swap\n\n    # update overall values\n    stabValueSwapped: uint256 = _maxUsdValueInStabPool * stabPoolAmount // _maxAmountInStabPool\n    remainingToRepay -= min(stabValueSwapped, remainingToRepay)\n    collateralValueOut += collateralUsdValueSent\n\n    log CollateralSwappedWithStabPool(\n        liqUser=_liqUser,\n        liqVaultId=_liqVaultId,\n        liqAsset=_liqAsset,\n        collateralAmountOut=collateralAmountSent,\n        collateralValueOut=collateralUsdValueSent,\n        stabVaultId=_stabPool.vaultId,\n        stabAsset=_stabPool.asset,\n        assetSwapped=assetSwapped,\n        amountSwapped=stabPoolAmount,\n        valueSwapped=stabValueSwapped,\n    )\n    return remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset\n\n\n######################\n# Auction Initiation #\n######################\n\n\n# start during liquidation\n\n\n@internal\ndef _startAuctionsDuringLiq(\n    _liqUser: address,\n    _genAuctionParams: AuctionParams,\n    _missionControl: address,\n    _ledger: address,\n) -> uint256:\n    numAssets: uint256 = self.numUserAssetsForAuction[_liqUser]\n    if numAssets == 0:\n        return 0\n\n    numAuctionsStarted: uint256 = 0\n    for i: uint256 in range(numAssets, bound=max_value(uint256)):\n        d: VaultData = self.userAssetForAuction[_liqUser][i]\n        didCreateAuction: bool = self._createOrUpdateFungAuction(_liqUser, d.vaultId, d.asset, False, _genAuctionParams, _missionControl, _ledger)\n        if didCreateAuction:\n            numAuctionsStarted += 1\n\n    return numAuctionsStarted\n\n\n# start / restart (via mission control)\n\n\n@external\ndef startAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    genParams: AuctionParams = staticcall MissionControl(a.missionControl).getGenAuctionParams()\n    return self._startAuction(_liqUser, _liqVaultId, _liqAsset, genParams, a)\n\n\n@external\ndef startManyAuctions(\n    _auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS],\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    genParams: AuctionParams = staticcall MissionControl(a.missionControl).getGenAuctionParams()\n    numAuctionsStarted: uint256 = 0\n    for auc: FungAuctionConfig in _auctions:\n        didStart: bool = self._startAuction(auc.liqUser, auc.vaultId, auc.asset, genParams, a)\n        if didStart:\n            numAuctionsStarted += 1\n\n    return numAuctionsStarted\n\n\n@internal\ndef _startAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _genParams: AuctionParams,\n    _a: addys.Addys,\n) -> bool:\n    if not self._canStartAuction(_liqUser, _liqVaultId, _liqAsset, _a.vaultBook, _a.ledger):\n        return False\n    hasAuction: bool = staticcall Ledger(_a.ledger).hasFungibleAuction(_liqUser, _liqVaultId, _liqAsset)\n    return self._createOrUpdateFungAuction(_liqUser, _liqVaultId, _liqAsset, hasAuction, _genParams, _a.missionControl, _a.ledger)\n\n\n# validation\n\n\n@view\n@external\ndef canStartAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n) -> bool:\n    a: addys.Addys = addys._getAddys()\n    return self._canStartAuction(_liqUser, _liqVaultId, _liqAsset, a.vaultBook, a.ledger)\n\n\n@view\n@internal\ndef _canStartAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _vaultBook: address,\n    _ledger: address,\n) -> bool:\n    vaultAddr: address = staticcall VaultBook(_vaultBook).getAddr(_liqVaultId)\n    if vaultAddr == empty(address):\n        return False\n    if not staticcall Vault(vaultAddr).doesUserHaveBalance(_liqUser, _liqAsset):\n        return False\n    return staticcall Ledger(_ledger).isUserInLiquidation(_liqUser)\n\n\n# create auction\n\n\n@internal\ndef _createOrUpdateFungAuction(\n    _liqUser: address,\n    _vaultId: uint256,\n    _asset: address,\n    _alreadyExists: bool,\n    _genAuctionParams: AuctionParams,\n    _missionControl: address,\n    _ledger: address,\n) -> bool:\n\n    # get asset liq config\n    config: AssetLiqConfig = empty(AssetLiqConfig)\n    isConfigCached: bool = False\n    config, isConfigCached = self._getAssetLiqConfig(_asset, _missionControl)\n    if not isConfigCached:\n        self.assetLiqConfig[_asset] = config # cache\n\n    # finalize auction params\n    params: AuctionParams = _genAuctionParams\n    if config.customAuctionParams.hasParams:\n        params = config.customAuctionParams\n\n    startBlock: uint256 = block.number + params.delay\n    endBlock: uint256 = startBlock + params.duration\n    auctionData: FungibleAuction = FungibleAuction(\n        liqUser=_liqUser,\n        vaultId=_vaultId,\n        asset=_asset,\n        startDiscount=params.startDiscount,\n        maxDiscount=params.maxDiscount,\n        startBlock=startBlock,\n        endBlock=endBlock,\n        isActive=True,\n    )\n\n    # update existing auction data\n    if _alreadyExists:\n        assert extcall Ledger(_ledger).setFungibleAuction(_liqUser, _vaultId, _asset, auctionData) # dev: failed to set auction\n\n    # create new auction\n    else:\n        aid: uint256 = extcall Ledger(_ledger).createNewFungibleAuction(auctionData)\n        if aid == 0:\n            return False # fail gracefully, though this should never happen\n\n    log FungibleAuctionUpdated(\n        liqUser=_liqUser,\n        vaultId=_vaultId,\n        asset=_asset,\n        startDiscount=params.startDiscount,\n        maxDiscount=params.maxDiscount,\n        startBlock=startBlock,\n        endBlock=endBlock,\n        isNewAuction=not _alreadyExists,\n    )\n    return True\n\n\n# pause\n\n\n@external\ndef pauseAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    return self._pauseAuction(_liqUser, _liqVaultId, _liqAsset, a.ledger)\n\n\n@external\ndef pauseManyAuctions(\n    _auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS],\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    numAuctionsPaused: uint256 = 0\n    for auc: FungAuctionConfig in _auctions:\n        didPause: bool = self._pauseAuction(auc.liqUser, auc.vaultId, auc.asset, a.ledger)\n        if didPause:\n            numAuctionsPaused += 1\n\n    return numAuctionsPaused\n\n\n@internal\ndef _pauseAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _ledger: address,\n) -> bool:\n    auc: FungibleAuction = staticcall Ledger(_ledger).getFungibleAuctionDuringPurchase(_liqUser, _liqVaultId, _liqAsset)\n    if not auc.isActive:\n        return False\n\n    auc.isActive = False\n    assert extcall Ledger(_ledger).setFungibleAuction(_liqUser, _liqVaultId, _liqAsset, auc) # dev: failed to set auction\n    log FungibleAuctionPaused(\n        liqUser=_liqUser,\n        vaultId=_liqVaultId,\n        asset=_liqAsset,\n    )\n    return True\n\n\n################\n# Buy Auctions #\n################\n\n\n@external\ndef buyFungibleAuction(\n    _liqUser: address,\n    _vaultId: uint256,\n    _asset: address,\n    _greenAmount: uint256,\n    _buyer: address,\n    _shouldTransferBalance: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    greenAmount: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert greenAmount != 0 # dev: no green to spend\n    greenSpent: uint256 = self._buyFungibleAuction(_liqUser, _vaultId, _asset, max_value(uint256), greenAmount, _buyer, _shouldTransferBalance, a)\n    assert greenSpent != 0 # dev: no green spent\n\n    # handle leftover green\n    if greenAmount > greenSpent:\n        self._handleGreenForUser(_buyer, greenAmount - greenSpent, False, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return greenSpent\n\n\n@external\ndef buyManyFungibleAuctions(\n    _purchases: DynArray[FungAuctionPurchase, MAX_AUCTIONS],\n    _greenAmount: uint256,\n    _buyer: address,\n    _shouldTransferBalance: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    totalGreenSpent: uint256 = 0\n    totalGreenRemaining: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert totalGreenRemaining != 0 # dev: no green to spend\n\n    for p: FungAuctionPurchase in _purchases:\n        if totalGreenRemaining == 0:\n            break\n        greenSpent: uint256 = self._buyFungibleAuction(p.liqUser, p.vaultId, p.asset, p.maxGreenAmount, totalGreenRemaining, _buyer, _shouldTransferBalance, a)\n        totalGreenRemaining -= greenSpent\n        totalGreenSpent += greenSpent\n\n    assert totalGreenSpent != 0 # dev: no green spent\n\n    # handle leftover green\n    if totalGreenRemaining != 0:\n        self._handleGreenForUser(_buyer, totalGreenRemaining, False, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return totalGreenSpent\n\n\n@internal\ndef _buyFungibleAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _maxGreenForAsset: uint256,\n    _totalGreenRemaining: uint256,\n    _buyer: address,\n    _shouldTransferBalance: bool,\n    _a: addys.Addys,\n) -> uint256:\n\n    # NOTE: faililng gracefully in case there are many purchases at same time\n\n    # this also verifies that user is in liquidation\n    auc: FungibleAuction = staticcall Ledger(_a.ledger).getFungibleAuctionDuringPurchase(_liqUser, _liqVaultId, _liqAsset)\n    if not auc.isActive:\n        return 0\n\n    # not within time boundaries, skip\n    if block.number < auc.startBlock or block.number >= auc.endBlock:\n        return 0\n\n    # check auction config\n    config: AuctionBuyConfig = staticcall MissionControl(_a.missionControl).getAuctionBuyConfig(_liqAsset, _buyer)\n    if not config.canBuyInAuctionGeneral or not config.canBuyInAuctionAsset or not config.isUserAllowed:\n        return 0\n\n    # finalize green amount\n    availGreen: uint256 = min(_totalGreenRemaining, staticcall IERC20(_a.greenToken).balanceOf(self))\n    greenAmount: uint256 = min(_maxGreenForAsset, availGreen)\n    if greenAmount == 0:\n        return 0\n\n    # calculate discount\n    auctionProgress: uint256 = (block.number - auc.startBlock) * HUNDRED_PERCENT // (auc.endBlock - auc.startBlock)\n    discount: uint256 = self._calculateAuctionDiscount(auctionProgress, auc.startDiscount, auc.maxDiscount)\n\n    # get vault addr\n    liqVaultAddr: address = staticcall VaultBook(_a.vaultBook).getAddr(_liqVaultId)\n    if liqVaultAddr == empty(address):\n        return 0\n\n    # max collateral usd value (to take from liq user)\n    maxCollateralUsdValue: uint256 = greenAmount * HUNDRED_PERCENT // (HUNDRED_PERCENT - discount)\n\n    # transfer collateral to buyer\n    collateralUsdValueSent: uint256 = 0\n    collateralAmountSent: uint256 = 0\n    isPositionDepleted: bool = False\n    shouldGoToNextAsset: bool = False\n    collateralUsdValueSent, collateralAmountSent, isPositionDepleted, shouldGoToNextAsset = self._transferCollateral(_liqUser, _buyer, _liqVaultId, liqVaultAddr, _liqAsset, _shouldTransferBalance, maxCollateralUsdValue, _a)\n    if collateralUsdValueSent == 0 or collateralAmountSent == 0:\n        return 0\n\n    # pay green amount, pay back debt\n    greenRequired: uint256 = collateralUsdValueSent * (HUNDRED_PERCENT - discount) // HUNDRED_PERCENT\n    greenSpent: uint256 = min(greenRequired, greenAmount)\n    assert extcall IERC20(_a.greenToken).transfer(_a.creditEngine, greenSpent, default_return_value=True) # dev: could not transfer\n    assert self._isPaymentCloseEnough(greenRequired, greenSpent) # dev: amounts do not match up\n    hasGoodDebtHealth: bool = extcall CreditEngine(_a.creditEngine).repayDuringAuctionPurchase(_liqUser, greenSpent, _a)\n\n    # disable auction (if depleted)\n    if isPositionDepleted and staticcall Ledger(_a.ledger).hasFungibleAuction(_liqUser, _liqVaultId, _liqAsset):\n        extcall Ledger(_a.ledger).removeFungibleAuction(_liqUser, _liqVaultId, _liqAsset)\n\n    log FungAuctionPurchased(\n        liqUser=_liqUser,\n        liqVaultId=_liqVaultId,\n        liqAsset=_liqAsset,\n        greenSpent=greenSpent,\n        buyer=_buyer,\n        collateralAmountSent=collateralAmountSent,\n        collateralUsdValueSent=collateralUsdValueSent,\n        isPositionDepleted=isPositionDepleted,\n        hasGoodDebtHealth=hasGoodDebtHealth,\n    )\n    return greenSpent\n\n\n@pure\n@internal\ndef _calculateAuctionDiscount(_progress: uint256, _startDiscount: uint256, _maxDiscount: uint256) -> uint256:\n    if _progress == 0 or _startDiscount == _maxDiscount:\n        return _startDiscount\n    discountRange: uint256 = _maxDiscount - _startDiscount\n    adjustment: uint256 =  _progress * discountRange // HUNDRED_PERCENT\n    return _startDiscount + adjustment\n\n\n#############\n# Utilities #\n#############\n\n\n# transfer collateral\n\n\n@internal\ndef _transferCollateral(\n    _fromUser: address,\n    _toUser: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _shouldTransferBalance: bool,\n    _targetUsdValue: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool, bool):\n    maxAssetAmount: uint256 = staticcall PriceDesk(_a.priceDesk).getAssetAmount(_asset, _targetUsdValue, True)\n    if maxAssetAmount == 0:\n        return 0, 0, False, True # skip if cannot get price for this asset\n\n    amountSent: uint256 = 0\n    isPositionDepleted: bool = False\n\n    # transfer balance within vault\n    if _shouldTransferBalance:\n        amountSent, isPositionDepleted = extcall Vault(_vaultAddr).transferBalanceWithinVault(_asset, _fromUser, _toUser, maxAssetAmount, _a)\n        extcall Ledger(_a.ledger).addVaultToUser(_toUser, _vaultId)\n        extcall LootBox(_a.lootbox).updateDepositPoints(_toUser, _vaultId, _vaultAddr, _asset, _a)\n\n    # withdraw and transfer to recipient\n    else:\n        amountSent, isPositionDepleted = extcall Vault(_vaultAddr).withdrawTokensFromVault(_fromUser, _asset, maxAssetAmount, _toUser, _a)\n\n    usdValue: uint256 = amountSent * _targetUsdValue // maxAssetAmount\n    return usdValue, amountSent, isPositionDepleted, isPositionDepleted\n\n\n# green handling\n\n\n@internal\ndef _handleGreenForUser(\n    _recipient: address,\n    _greenAmount: uint256,\n    _needsMint: bool,\n    _wantsSavingsGreen: bool,\n    _greenToken: address,\n    _savingsGreen: address,\n):\n    # mint green\n    if _needsMint:\n        if not _wantsSavingsGreen:\n            extcall GreenToken(_greenToken).mint(_recipient, _greenAmount) # directly to recipient, exit\n            return\n        extcall GreenToken(_greenToken).mint(self, _greenAmount)\n\n    # finalize amount\n    amount: uint256 = min(_greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n    if amount == 0:\n        return\n\n    if _wantsSavingsGreen:\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, amount, default_return_value=True) # dev: green approval failed\n        extcall IERC4626(_savingsGreen).deposit(amount, _recipient)\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n    else:\n        assert extcall IERC20(_greenToken).transfer(_recipient, amount, default_return_value=True) # dev: green transfer failed\n\n\n# is payment close enough\n\n\n@pure\n@internal\ndef _isPaymentCloseEnough(_requestedAmount: uint256, _actualAmount: uint256) -> bool:\n    # An extra safety check to make sure what was paid was actually close-ish to what was requested\n    buffer: uint256 = _requestedAmount * ONE_PERCENT // HUNDRED_PERCENT\n    upperBound: uint256 = _requestedAmount + buffer\n    lowerBound: uint256 = _requestedAmount - buffer\n    return upperBound >= _actualAmount and _actualAmount >= lowerBound\n\n\n# calc amount of debt to repay\n\n\n@view\n@external\ndef calcAmountOfDebtToRepayDuringLiq(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n\n    # user debt\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = staticcall CreditEngine(a.creditEngine).getLatestUserDebtAndTerms(_user, True, a)\n\n    # No debt to repay\n    if userDebt.amount == 0:\n        return 0\n\n    # liquidation fees\n    totalLiqFees: uint256 = userDebt.amount * bt.debtTerms.liqFee // HUNDRED_PERCENT\n    totalLiqFees += max(config.minKeeperFee, userDebt.amount * config.keeperFeeRatio // HUNDRED_PERCENT)\n    liqFeeRatio: uint256 = totalLiqFees * HUNDRED_PERCENT // userDebt.amount\n\n    # calc amount of debt to repay\n    targetLtv: uint256 = bt.debtTerms.ltv * (HUNDRED_PERCENT - config.ltvPaybackBuffer) // HUNDRED_PERCENT\n    return self._calcAmountOfDebtToRepay(userDebt.amount, bt.collateralVal, targetLtv, liqFeeRatio, totalLiqFees)\n\n\n@pure\n@internal\ndef _calcAmountOfDebtToRepay(\n    _debtAmount: uint256,\n    _collateralValue: uint256,\n    _targetLtv: uint256,\n    _liqFeeRatio: uint256,\n    _totalLiqFees: uint256,\n) -> uint256:\n    # goal here is to only reduce the debt necessary to get LTV back to safe position\n    # it will never be perfectly precise because depending on what assets are taken, the LTV might slightly change\n\n    effectiveDebt: uint256 = _debtAmount + _totalLiqFees\n    if _targetLtv == 0:\n        return effectiveDebt # repay everything to achieve 0% LTV\n\n    # calculate the coefficient for repay amount\n    oneMinusLiqFeeRatio: uint256 = HUNDRED_PERCENT - _liqFeeRatio\n    if oneMinusLiqFeeRatio == 0:\n        return effectiveDebt # edge case: 100% liquidation fee\n\n    # check if user is already in safe position (prevent underflow)\n    targetDebtValue: uint256 = _targetLtv * _collateralValue\n    effectiveDebtValue: uint256 = effectiveDebt * HUNDRED_PERCENT\n    if effectiveDebtValue <= targetDebtValue:\n        return 0 # User is already safe, no repayment needed\n\n    numerator: uint256 = effectiveDebtValue - targetDebtValue\n    denominator: uint256 = HUNDRED_PERCENT - _targetLtv\n    if denominator == 0:\n        return effectiveDebt # edge case: 100% target LTV\n\n    X: uint256 = numerator // denominator\n    return X * oneMinusLiqFeeRatio // HUNDRED_PERCENT\n\n\n#########\n# Cache #\n#########\n\n\n@view\n@internal\ndef _getAssetLiqConfig(_asset: address, _missionControl: address) -> (AssetLiqConfig, bool):\n    config: AssetLiqConfig = self.assetLiqConfig[_asset]\n    if config.hasConfig:\n        return config, True\n    return staticcall MissionControl(_missionControl).getAssetLiqConfig(_asset), False\n\n\n@view\n@internal\ndef _getVaultAddr(_vaultId: uint256, _vaultBook: address) -> (address, bool):\n    vaultAddr: address = self.vaultAddrs[_vaultId]\n    if vaultAddr != empty(address):\n        return vaultAddr, True\n    return staticcall VaultBook(_vaultBook).getAddr(_vaultId), False\n\n\n@internal\ndef _saveLiqAssetForAuction(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address):\n    nextId: uint256 = self.numUserAssetsForAuction[_user]\n    self.userAssetForAuction[_user][nextId] = VaultData(vaultId=_vaultId, vaultAddr=_vaultAddr, asset=_asset)\n    self.numUserAssetsForAuction[_user] = nextId + 1\n",
            "sha256sum": "482ddf2e9a8ad5d5187fb6fac4e35c65bef4bb05873a6ff45a223c58c04e7000"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AuctionHouse.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "eadbb2f403876a3a4e44303c6c8efae7b1b3232087de3b57a1668362b2ab8a88"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e"
    },
    "AuctionHouseNFT": {
      "address": "0xd87d6e29513bCf542DFfd19fF45b8a1c295a698c",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "cdcbc1c83a0ffa09166c89d2698097b5dee00d2ebebf714134ab8faa6e9ff685"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/core/AuctionHouseNFT.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n    # NOTE: This is a temporary AuctionHouseNFT contract. Real one coming soon.\n",
            "sha256sum": "ee8c6c80aa2922719a1ce80756a69e1b0e38b1496e521ba7a2e63b95e7da2160"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AuctionHouseNFT.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "93c7a1b539462b5f6d99c2d461de4c472a8c19fc2fbf66fee4e92ea3cd1bbec1"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e"
    },
    "BondRoom": {
      "address": "0xF8F3eA34d29De9658b402b86D4F10B18CaBF86a0",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "cdcbc1c83a0ffa09166c89d2698097b5dee00d2ebebf714134ab8faa6e9ff685"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/core/BondRoom.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n    # NOTE: This is a temporary BondRoom contract. Real one coming soon.\n",
            "sha256sum": "1f3fe67f7579c604eb5181f472a01dd7b8356d8e389304139653bdec281822a0"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/BondRoom.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "8ee672e3bb240e2423f70b4a6b631dd81d3975ff32a1a8fc934d7447e58f59c5"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e"
    },
    "CreditEngine": {
      "address": "0x3143A289C81C4313CeF3E8f61aD407d961C5DaAf",
      "abi": [
        {
          "name": "NewBorrow",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newLoan",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "daowry",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "didReceiveSavingsGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "outstandingUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "userCollateralVal",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "globalYieldRealized",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RepayDebt",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "repayValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayType",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundWasSavingsGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "outstandingUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "userCollateralVal",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CollateralRedeemed",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "redeemer",
              "type": "address",
              "indexed": true
            },
            {
              "name": "repayValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrowForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrowForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxBorrowAmount",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringLiquidation",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_newInterest",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringLiquidation",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_newInterest",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringAuctionPurchase",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringAuctionPurchase",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_redeemer",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_redeemer",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_redeemer",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_redeemer",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxRedeemValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCollateralValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            },
            {
              "name": "_skipAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            },
            {
              "name": "_skipAsset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestUserDebtAndTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestUserDebtAndTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasGoodDebtHealth",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasGoodDebtHealth",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canLiquidateUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canLiquidateUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRedeemUserCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRedeemUserCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLiquidationThreshold",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRedemptionThreshold",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                },
                {
                  "name": "switchboardOne",
                  "type": "address"
                },
                {
                  "name": "switchboardTwo",
                  "type": "address"
                },
                {
                  "name": "switchboardThree",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    lootbox: address\n    teller: address\n    switchboardOne: address\n    switchboardTwo: address\n    switchboardThree: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 7\nAUCTION_HOUSE_ID: constant(uint256) = 8\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 9\nBOND_ROOM_ID: constant(uint256) = 10\nCREDIT_ENGINE_ID: constant(uint256) = 11\nENDAOMENT_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 13\nTELLER_ID: constant(uint256) = 14\nSWITCHBOARD_ONE_ID: constant(uint256) = 15\nSWITCHBOARD_TWO_ID: constant(uint256) = 16\nSWITCHBOARD_THREE_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n        switchboardOne=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ONE_ID),\n        switchboardTwo=staticcall RipeHq(hq).getAddr(SWITCHBOARD_TWO_ID),\n        switchboardThree=staticcall RipeHq(hq).getAddr(SWITCHBOARD_THREE_ID),\n    )\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _canModifyMissionControl(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).canModifyMissionControl(_addr)\n\n\n@view\n@internal\ndef _isValidRipeHqAddr(_addr: address) -> bool:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).isValidAddr(_addr)\n\n\n# tokens\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# switchboard one\n\n\n@view\n@internal\ndef _getSwitchboardOneId() -> uint256:\n    return SWITCHBOARD_ONE_ID\n\n\n@view\n@internal\ndef _getSwitchboardOneAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ONE_ID)\n\n\n# switchboard two\n\n\n@view\n@internal\ndef _getSwitchboardTwoId() -> uint256:\n    return SWITCHBOARD_TWO_ID\n\n\n@view\n@internal\ndef _getSwitchboardTwoAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_TWO_ID)\n\n\n# switchboard three\n\n\n@view\n@internal\ndef _getSwitchboardThreeId() -> uint256:\n    return SWITCHBOARD_THREE_ID\n\n\n@view\n@internal\ndef _getSwitchboardThreeAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_THREE_ID)\n",
            "sha256sum": "f90b1e0a6881703b428fb7091514cf2f6559d80f97be1dfc1e321ca8ab9d4581"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._canModifyMissionControl(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "cdcbc1c83a0ffa09166c89d2698097b5dee00d2ebebf714134ab8faa6e9ff685"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/core/CreditEngine.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\ninterface Ledger:\n    def setUserDebt(_user: address, _userDebt: UserDebt, _newInterest: uint256, _interval: IntervalBorrow): nonpayable\n    def getBorrowDataBundle(_user: address) -> BorrowDataBundle: view\n    def addVaultToUser(_user: address, _vaultId: uint256): nonpayable\n    def userVaults(_user: address, _index: uint256) -> uint256: view\n    def getRepayDataBundle(_user: address) -> RepayDataBundle: view\n    def numUserVaults(_user: address) -> uint256: view\n    def flushUnrealizedYield() -> uint256: nonpayable\n\ninterface MissionControl:\n    def getRedeemCollateralConfig(_asset: address, _redeemer: address) -> RedeemCollateralConfig: view\n    def getBorrowConfig(_user: address, _caller: address) -> BorrowConfig: view\n    def getRepayConfig(_user: address) -> RepayConfig: view\n    def getDebtTerms(_asset: address) -> DebtTerms: view\n    def getLtvPaybackBuffer() -> uint256: view\n\ninterface LootBox:\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n    def updateBorrowPoints(_user: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface PriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool) -> uint256: view\n\ninterface GreenToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n    def burn(_amount: uint256): nonpayable\n\ninterface VaultBook:\n    def getAddr(_vaultId: uint256) -> address: view\n\nflag RepayType:\n    STANDARD\n    LIQUIDATION\n    AUCTION\n    REDEMPTION\n\nstruct BorrowDataBundle:\n    userDebt: UserDebt\n    userBorrowInterval: IntervalBorrow\n    isUserBorrower: bool\n    numUserVaults: uint256\n    totalDebt: uint256\n    numBorrowers: uint256\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserBorrowTerms:\n    collateralVal: uint256\n    totalMaxDebt: uint256\n    debtTerms: DebtTerms\n\nstruct UserDebt:\n    amount: uint256\n    principal: uint256\n    debtTerms: DebtTerms\n    lastTimestamp: uint256\n    inLiquidation: bool\n\nstruct IntervalBorrow:\n    start: uint256\n    amount: uint256\n\nstruct RepayDataBundle:\n    userDebt: UserDebt\n    numUserVaults: uint256\n\nstruct BorrowConfig:\n    canBorrow: bool\n    canBorrowForUser: bool\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    isDaowryEnabled: bool\n\nstruct RepayConfig:\n    canRepay: bool\n    canAnyoneRepayDebt: bool\n\nstruct RedeemCollateralConfig:\n    canRedeemCollateralGeneral: bool\n    canRedeemCollateralAsset: bool\n    isUserAllowed: bool\n    ltvPaybackBuffer: uint256\n\nstruct CollateralRedemption:\n    user: address\n    vaultId: uint256\n    asset: address\n    maxGreenAmount: uint256\n\nevent NewBorrow:\n    user: indexed(address)\n    newLoan: uint256\n    daowry: uint256\n    didReceiveSavingsGreen: bool\n    outstandingUserDebt: uint256\n    userCollateralVal: uint256\n    maxUserDebt: uint256\n    globalYieldRealized: uint256\n\nevent RepayDebt:\n    user: indexed(address)\n    repayValue: uint256\n    repayType: RepayType\n    refundAmount: uint256\n    refundWasSavingsGreen: bool\n    outstandingUserDebt: uint256\n    userCollateralVal: uint256\n    maxUserDebt: uint256\n    hasGoodDebtHealth: bool\n\nevent CollateralRedeemed:\n    user: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    amount: uint256\n    redeemer: indexed(address)\n    repayValue: uint256\n    hasGoodDebtHealth: bool\n\nONE_YEAR: constant(uint256) = 60 * 60 * 24 * 365\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nONE_PERCENT: constant(uint256) = 1_00 # 1.00%\nMAX_DEBT_UPDATES: constant(uint256) = 25\nMAX_COLLATERAL_REDEMPTIONS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, True, False) # can mint green only\n\n\n##########\n# Borrow #\n##########\n\n\n@external\ndef borrowForUser(\n    _user: address,\n    _greenAmount: uint256,\n    _wantsSavingsGreen: bool,\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    assert _user != empty(address) # dev: cannot borrow for 0x0\n\n    # get borrow data\n    d: BorrowDataBundle = staticcall Ledger(a.ledger).getBorrowDataBundle(_user)\n\n    # get latest user debt\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # get borrow data (debt terms for user)\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, True, 0, empty(address), a)\n\n    # get config\n    config: BorrowConfig = staticcall MissionControl(a.missionControl).getBorrowConfig(_user, _caller)\n\n    # validation\n    newBorrowAmount: uint256 = 0\n    isFreshInterval: bool = False\n    newBorrowAmount, isFreshInterval = self._validateOnBorrow(_greenAmount, userDebt, bt.totalMaxDebt, d, config)\n    assert newBorrowAmount != 0 # dev: cannot borrow\n\n    # update borrow interval\n    userBorrowInterval: IntervalBorrow = d.userBorrowInterval\n    if isFreshInterval:\n        userBorrowInterval.start = block.number\n        userBorrowInterval.amount = newBorrowAmount\n    else:\n        userBorrowInterval.amount += newBorrowAmount\n\n    # update user debt\n    userDebt.amount += newBorrowAmount\n    userDebt.principal += newBorrowAmount\n    userDebt.debtTerms = bt.debtTerms\n\n    # check debt health\n    hasGoodDebtHealth: bool = self._hasGoodDebtHealth(userDebt.amount, bt.collateralVal, bt.debtTerms.ltv)\n    assert hasGoodDebtHealth # dev: bad debt health\n    userDebt.inLiquidation = False\n\n    # save debt\n    extcall Ledger(a.ledger).setUserDebt(_user, userDebt, newInterest, userBorrowInterval)\n\n    # update borrow points\n    extcall LootBox(a.lootbox).updateBorrowPoints(_user, a)\n\n    # mint green - piggy back on borrow to flush unrealized yield\n    unrealizedYield: uint256 = extcall Ledger(a.ledger).flushUnrealizedYield()\n    totalGreenMint: uint256 = newBorrowAmount + unrealizedYield\n    extcall GreenToken(a.greenToken).mint(self, totalGreenMint)\n\n    # origination fee\n    daowry: uint256 = self._getDaowryAmount(newBorrowAmount, bt.debtTerms.daowry, config.isDaowryEnabled)\n\n    # dao revenue\n    forDao: uint256 = daowry + unrealizedYield\n    if forDao != 0:\n        assert extcall IERC20(a.greenToken).transfer(a.savingsGreen, forDao, default_return_value=True) # dev: could not transfer\n\n    # borrower gets their green now -- do this AFTER sending green to stakers\n    forBorrower: uint256 = newBorrowAmount - daowry\n    self._handleGreenForUser(_user, forBorrower, _wantsSavingsGreen, a.greenToken, a.savingsGreen)\n\n    log NewBorrow(user=_user, newLoan=forBorrower, daowry=daowry, didReceiveSavingsGreen=_wantsSavingsGreen, outstandingUserDebt=userDebt.amount, userCollateralVal=bt.collateralVal, maxUserDebt=bt.totalMaxDebt, globalYieldRealized=unrealizedYield)\n    return forBorrower\n\n\n# borrow validation\n\n\n@view\n@internal\ndef _validateOnBorrow(\n    _greenAmount: uint256,\n    _userDebt: UserDebt,\n    _maxUserDebt: uint256,\n    _d: BorrowDataBundle,\n    _config: BorrowConfig,\n) -> (uint256, bool):\n    assert not _userDebt.inLiquidation # dev: cannot borrow in liquidation\n    assert _greenAmount != 0 # dev: cannot borrow 0 amount\n\n    # get borrow config\n    assert _config.canBorrow # dev: borrow not enabled\n    assert _config.canBorrowForUser # dev: cannot borrow for user\n\n    # check num allowed borrowers\n    if not _d.isUserBorrower:\n        numAvailBorrowers: uint256 = self._getAvailNumBorrowers(_d.numBorrowers, _config.numAllowedBorrowers)\n        assert numAvailBorrowers != 0 # dev: max num borrowers reached\n\n    # main var\n    newBorrowAmount: uint256 = _greenAmount\n\n    # avail debt based on collateral value / ltv\n    availDebtPerLtv: uint256 = self._getAvailBasedOnLtv(_userDebt.amount, _maxUserDebt)\n    assert availDebtPerLtv != 0 # dev: no debt available\n    newBorrowAmount = min(newBorrowAmount, availDebtPerLtv)\n\n    # check borrow interval\n    availInInterval: uint256 = 0\n    isFreshInterval: bool = False\n    availInInterval, isFreshInterval = self._getAvailDebtInInterval(_d.userBorrowInterval, _config.maxBorrowPerInterval, _config.numBlocksPerInterval)\n    assert availInInterval != 0 # dev: interval borrow limit reached\n    newBorrowAmount = min(newBorrowAmount, availInInterval)\n\n    # check per user debt limit\n    availPerUser: uint256 = self._getAvailPerUserDebt(_userDebt.amount, _config.perUserDebtLimit)\n    assert availPerUser != 0 # dev: per user debt limit reached\n    newBorrowAmount = min(newBorrowAmount, availPerUser)\n\n    # check global debt limit\n    availGlobal: uint256 = self._getAvailGlobalDebt(_d.totalDebt, _config.globalDebtLimit)\n    assert availGlobal != 0 # dev: global debt limit reached\n    newBorrowAmount = min(newBorrowAmount, availGlobal)\n\n    # must reach minimum debt threshold\n    assert _userDebt.amount + newBorrowAmount >= _config.minDebtAmount # dev: debt too small\n\n    return newBorrowAmount, isFreshInterval\n\n\n# max available borrow (mostly for front-ends, no exceptions raised)\n\n\n@view\n@external\ndef getMaxBorrowAmount(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt\n    d: BorrowDataBundle = staticcall Ledger(a.ledger).getBorrowDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    na1: uint256 = 0\n    userDebt, na1 = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # cannot borrow in liquidation\n    if userDebt.inLiquidation:\n        return 0\n\n    # get borrow config\n    config: BorrowConfig = staticcall MissionControl(a.missionControl).getBorrowConfig(_user, _user)\n    if not config.canBorrow:\n        return 0\n\n    # check num allowed borrowers\n    if not d.isUserBorrower:\n        numAvailBorrowers: uint256 = self._getAvailNumBorrowers(d.numBorrowers, config.numAllowedBorrowers)\n        if numAvailBorrowers == 0:\n            return 0\n\n    # main var\n    newBorrowAmount: uint256 = max_value(uint256)\n\n    # avail debt based on collateral value / ltv\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, False, 0, empty(address), a)\n    availDebtPerLtv: uint256 = self._getAvailBasedOnLtv(userDebt.amount, bt.totalMaxDebt)\n    if availDebtPerLtv == 0:\n        return 0\n    newBorrowAmount = min(newBorrowAmount, availDebtPerLtv)\n\n    # check borrow interval\n    availInInterval: uint256 = 0\n    na2: bool = False\n    availInInterval, na2 = self._getAvailDebtInInterval(d.userBorrowInterval, config.maxBorrowPerInterval, config.numBlocksPerInterval)\n    if availInInterval == 0:\n        return 0\n    newBorrowAmount = min(newBorrowAmount, availInInterval)\n\n    # check per user debt limit\n    availPerUser: uint256 = self._getAvailPerUserDebt(userDebt.amount, config.perUserDebtLimit)\n    if availPerUser == 0:\n        return 0\n    newBorrowAmount = min(newBorrowAmount, availPerUser)\n\n    # check global debt limit\n    availGlobal: uint256 = self._getAvailGlobalDebt(d.totalDebt, config.globalDebtLimit)\n    if availGlobal == 0:\n        return 0\n    newBorrowAmount = min(newBorrowAmount, availGlobal)\n\n    # must reach minimum debt threshold\n    if userDebt.amount + newBorrowAmount < config.minDebtAmount:\n        return 0\n\n    return newBorrowAmount\n\n\n#########\n# Repay #\n#########\n\n\n@external\ndef repayForUser(\n    _user: address,\n    _greenAmount: uint256,\n    _shouldRefundSavingsGreen: bool,\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # validation\n    repayAmount: uint256 = 0\n    refundAmount: uint256 = 0\n    repayAmount, refundAmount = self._validateOnRepay(_user, _caller, _greenAmount, userDebt.amount, a.missionControl, a.greenToken)\n    assert repayAmount != 0 # dev: cannot repay with 0 green\n\n    return self._repayDebt(_user, userDebt, d.numUserVaults, repayAmount, refundAmount, newInterest, True, _shouldRefundSavingsGreen, RepayType.STANDARD, a)\n\n\n# repay during liquidation\n\n\n@external\ndef repayDuringLiquidation(\n    _liqUser: address,\n    _userDebt: UserDebt,\n    _repayValue: uint256,\n    _newInterest: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only auction house allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    numVaults: uint256 = staticcall Ledger(a.ledger).numUserVaults(_liqUser)\n    return self._repayDebt(_liqUser, _userDebt, numVaults, _repayValue, 0, _newInterest, False, False, RepayType.LIQUIDATION, a)\n\n\n# repay during auction purchase\n\n\n@external\ndef repayDuringAuctionPurchase(_liqUser: address, _repayValue: uint256, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only auction house allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_liqUser)\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # finalize amounts\n    repayAmount: uint256 = 0\n    refundAmount: uint256 = 0\n    repayAmount, refundAmount = self._getRepayAmountAndRefundAmount(userDebt.amount, _repayValue, a.greenToken)\n    assert repayAmount != 0 # dev: cannot repay with 0 green\n\n    return self._repayDebt(_liqUser, userDebt, d.numUserVaults, repayAmount, refundAmount, newInterest, True, True, RepayType.AUCTION, a)\n\n\n# shared repay functionality\n\n\n@internal\ndef _repayDebt(\n    _user: address,\n    _userDebt: UserDebt,\n    _numUserVaults: uint256,\n    _repayValue: uint256,\n    _refundAmount: uint256,\n    _newInterest: uint256,\n    _shouldBurnGreen: bool,\n    _wantsSavingsGreen: bool,\n    _repayType: RepayType,\n    _a: addys.Addys,\n) -> bool:\n    userDebt: UserDebt = self._reduceDebtAmount(_userDebt, _repayValue)\n\n    # get latest debt terms\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, _numUserVaults, True, 0, empty(address), _a)\n    userDebt.debtTerms = bt.debtTerms\n\n    # check debt health\n    hasGoodDebtHealth: bool = self._hasGoodDebtHealth(userDebt.amount, bt.collateralVal, bt.debtTerms.ltv)\n    if hasGoodDebtHealth:\n        userDebt.inLiquidation = False\n\n    # update user debt, borrow points\n    extcall Ledger(_a.ledger).setUserDebt(_user, userDebt, _newInterest, empty(IntervalBorrow))\n    extcall LootBox(_a.lootbox).updateBorrowPoints(_user, _a)\n\n    # burn green repayment\n    if _shouldBurnGreen:\n        extcall GreenToken(_a.greenToken).burn(_repayValue)\n\n    # handle refund\n    if _refundAmount != 0:\n        self._handleGreenForUser(_user, _refundAmount, _wantsSavingsGreen, _a.greenToken, _a.savingsGreen)\n\n    log RepayDebt(user=_user, repayValue=_repayValue, repayType=_repayType, refundAmount=_refundAmount, refundWasSavingsGreen=_wantsSavingsGreen, outstandingUserDebt=userDebt.amount, userCollateralVal=bt.collateralVal, maxUserDebt=bt.totalMaxDebt, hasGoodDebtHealth=hasGoodDebtHealth)\n    return hasGoodDebtHealth\n\n\n# repay validation\n\n\n@view\n@internal\ndef _validateOnRepay(\n    _user: address,\n    _caller: address,\n    _greenAmount: uint256,\n    _userDebtAmount: uint256,\n    _missionControl: address,\n    _greenToken: address,\n) -> (uint256, uint256):\n    assert _userDebtAmount != 0 # dev: no debt outstanding\n\n    # repay config\n    repayConfig: RepayConfig = staticcall MissionControl(_missionControl).getRepayConfig(_user)\n    assert repayConfig.canRepay # dev: repay paused\n    if _user != _caller:\n        assert repayConfig.canAnyoneRepayDebt # dev: cannot repay for user\n\n    return self._getRepayAmountAndRefundAmount(_userDebtAmount, _greenAmount, _greenToken)\n\n\n# repay amount and refund amount\n\n\n@view\n@internal\ndef _getRepayAmountAndRefundAmount(_userDebtAmount: uint256, _greenAmount: uint256, _greenToken: address) -> (uint256, uint256):\n    availAmount: uint256 = min(_greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n\n    repayAmount: uint256 = min(availAmount, _userDebtAmount)\n    refundAmount: uint256 = 0\n    if repayAmount > availAmount:\n        refundAmount = repayAmount - availAmount\n\n    return repayAmount, refundAmount\n\n\n# reduce debt amount\n\n\n@view\n@internal\ndef _reduceDebtAmount(_userDebt: UserDebt, _repayAmount: uint256) -> UserDebt:\n    userDebt: UserDebt = _userDebt\n    nonPrincipalDebt: uint256 = userDebt.amount - userDebt.principal\n\n    userDebt.amount -= _repayAmount\n    if _repayAmount > nonPrincipalDebt:\n        principalToReduce: uint256 = _repayAmount - nonPrincipalDebt\n        userDebt.principal -= min(principalToReduce, userDebt.principal)\n\n    return userDebt\n\n\n#####################\n# Redeem Collateral #\n#####################\n\n\n@external\ndef redeemCollateralFromMany(\n    _redemptions: DynArray[CollateralRedemption, MAX_COLLATERAL_REDEMPTIONS],\n    _greenAmount: uint256,\n    _redeemer: address,\n    _shouldTransferBalance: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    totalGreenSpent: uint256 = 0\n    totalGreenRemaining: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert totalGreenRemaining != 0 # dev: no green to redeem\n\n    for r: CollateralRedemption in _redemptions:\n        if totalGreenRemaining == 0:\n            break\n        greenSpent: uint256 = self._redeemCollateral(r.user, r.vaultId, r.asset, r.maxGreenAmount, totalGreenRemaining, _redeemer, _shouldTransferBalance, a)\n        totalGreenRemaining -= greenSpent\n        totalGreenSpent += greenSpent\n\n    assert totalGreenSpent != 0 # dev: no redemptions occurred\n\n    # handle leftover green\n    if totalGreenRemaining != 0:\n        self._handleGreenForUser(_redeemer, totalGreenRemaining, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return totalGreenSpent\n\n\n@external\ndef redeemCollateral(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _greenAmount: uint256,\n    _redeemer: address,\n    _shouldTransferBalance: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    greenAmount: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert greenAmount != 0 # dev: no green to redeem\n    greenSpent: uint256 = self._redeemCollateral(_user, _vaultId, _asset, max_value(uint256), greenAmount, _redeemer, _shouldTransferBalance, a)\n    assert greenSpent != 0 # dev: no redemptions occurred\n\n    # handle leftover green\n    if greenAmount > greenSpent:\n        self._handleGreenForUser(_redeemer, greenAmount - greenSpent, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return greenSpent\n\n\n@internal\ndef _redeemCollateral(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _maxGreenForAsset: uint256,\n    _totalGreenRemaining: uint256,\n    _redeemer: address,\n    _shouldTransferBalance: bool,\n    _a: addys.Addys,\n) -> uint256:\n\n    # NOTE: failing gracefully here, in case of many redemptions at same time\n\n    # invalid inputs\n    if empty(address) in [_redeemer, _asset, _user] or 0 in [_maxGreenForAsset, _totalGreenRemaining, _vaultId]:\n        return 0\n\n    # vault address\n    vaultAddr: address = staticcall VaultBook(_a.vaultBook).getAddr(_vaultId)\n    if vaultAddr == empty(address):\n        return 0\n\n    # user must have balance\n    if not staticcall Vault(vaultAddr).doesUserHaveBalance(_user, _asset):\n        return 0\n\n    # redemptions not allowed on asset\n    config: RedeemCollateralConfig = staticcall MissionControl(_a.missionControl).getRedeemCollateralConfig(_asset, _redeemer)\n    if not config.canRedeemCollateralGeneral or not config.canRedeemCollateralAsset or not config.isUserAllowed:\n        return 0\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(_a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # cannot redeem if no debt or in liquidation\n    if userDebt.amount == 0 or userDebt.inLiquidation:\n        return 0\n\n    # get latest debt terms\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, True, 0, empty(address), _a)\n    if bt.collateralVal == 0:\n        return 0\n\n    # user has not reached redemption threshold\n    if not self._canRedeemUserCollateral(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold):\n        return 0\n\n    # estimated debt to pay back to achieve safe LTV\n    # won't be exact because depends on which collateral is redeemed (LTV changes)\n    targetLtv: uint256 = bt.debtTerms.ltv * (HUNDRED_PERCENT - config.ltvPaybackBuffer) // HUNDRED_PERCENT\n    maxCollateralValue: uint256 = self._calcAmountToPay(userDebt.amount, bt.collateralVal, targetLtv)\n\n    # treating green as $1\n    maxGreenAvailable: uint256 = min(_totalGreenRemaining, staticcall IERC20(_a.greenToken).balanceOf(self))\n    maxGreenForAsset: uint256 = min(_maxGreenForAsset, maxGreenAvailable)\n    maxRedeemValue: uint256 = min(maxCollateralValue, maxGreenForAsset)\n    if maxRedeemValue == 0:\n        return 0\n\n    # max asset amount to take from user\n    maxAssetAmount: uint256 = staticcall PriceDesk(_a.priceDesk).getAssetAmount(_asset, maxRedeemValue, True)\n    if maxAssetAmount == 0:\n        return 0\n\n    # withdraw or transfer balance to redeemer\n    amountSent: uint256 = 0\n    na: bool = False\n    if _shouldTransferBalance:\n        amountSent, na = extcall Vault(vaultAddr).transferBalanceWithinVault(_asset, _user, _redeemer, maxAssetAmount, _a)\n        extcall Ledger(_a.ledger).addVaultToUser(_redeemer, _vaultId)\n        extcall LootBox(_a.lootbox).updateDepositPoints(_redeemer, _vaultId, vaultAddr, _asset, _a)\n\n    else:\n        amountSent, na = extcall Vault(vaultAddr).withdrawTokensFromVault(_user, _asset, maxAssetAmount, _redeemer, _a)\n\n    # repay debt\n    repayValue: uint256 = amountSent * maxRedeemValue // maxAssetAmount\n    hasGoodDebtHealth: bool = self._repayDebt(_user, userDebt, d.numUserVaults, min(repayValue, userDebt.amount), 0, newInterest, True, False, RepayType.REDEMPTION, _a)\n\n    log CollateralRedeemed(\n        user=_user,\n        vaultId=_vaultId,\n        asset=_asset,\n        amount=amountSent,\n        redeemer=_redeemer,\n        repayValue=repayValue,\n        hasGoodDebtHealth=hasGoodDebtHealth,\n    )\n    return min(repayValue, maxRedeemValue)\n\n\n# utils\n\n\n@view\n@external\ndef getMaxRedeemValue(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = self._getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0 or userDebt.inLiquidation or bt.collateralVal == 0:\n        return 0\n\n    if not self._canRedeemUserCollateral(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold):\n        return 0\n\n    ltvPaybackBuffer: uint256 = staticcall MissionControl(a.missionControl).getLtvPaybackBuffer()\n    targetLtv: uint256 = bt.debtTerms.ltv * (HUNDRED_PERCENT - ltvPaybackBuffer) // HUNDRED_PERCENT\n    return self._calcAmountToPay(userDebt.amount, bt.collateralVal, targetLtv)\n\n\n@view\n@internal\ndef _calcAmountToPay(_debtAmount: uint256, _collateralValue: uint256, _targetLtv: uint256) -> uint256:\n    # goal here is to only reduce the debt necessary to get LTV back to safe position\n    # it will never be perfectly precise because depending on what assets are taken, the LTV might slightly change\n    collValueAdjusted: uint256 =_collateralValue * _targetLtv // HUNDRED_PERCENT\n\n    toPay: uint256 = (_debtAmount - collValueAdjusted) * HUNDRED_PERCENT // (HUNDRED_PERCENT - _targetLtv)\n    return min(toPay, _debtAmount)\n\n\n################\n# Borrow Terms #\n################\n\n\n@view\n@external\ndef getCollateralValue(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, staticcall Ledger(a.ledger).numUserVaults(_user), True, 0, empty(address), a)\n    return bt.collateralVal\n\n\n@view\n@external\ndef getUserBorrowTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _skipVaultId: uint256 = 0,\n    _skipAsset: address = empty(address),\n    _a: addys.Addys = empty(addys.Addys),\n) -> UserBorrowTerms:\n    a: addys.Addys = addys._getAddys(_a)\n    return self._getUserBorrowTerms(_user, staticcall Ledger(a.ledger).numUserVaults(_user), _shouldRaise, _skipVaultId, _skipAsset, a)\n\n\n@view\n@internal\ndef _getUserBorrowTerms(\n    _user: address,\n    _numUserVaults: uint256,\n    _shouldRaise: bool,\n    _skipVaultId: uint256,\n    _skipAsset: address,\n    _a: addys.Addys,\n) -> UserBorrowTerms:\n\n    # nothing to do here\n    if _numUserVaults == 0:\n        return empty(UserBorrowTerms)\n\n    hasSkip: bool = (_skipVaultId != 0 and _skipAsset != empty(address))\n\n    # sum vars\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    ltvSum: uint256 = 0\n    redemptionThresholdSum: uint256 = 0\n    liqThresholdSum: uint256 = 0\n    liqFeeSum: uint256 = 0\n    borrowRateSum: uint256 = 0\n    daowrySum: uint256 = 0\n    totalSum: uint256 = 0\n\n    # iterate thru each user vault\n    for i: uint256 in range(1, _numUserVaults, bound=max_value(uint256)):\n        vaultId: uint256 = staticcall Ledger(_a.ledger).userVaults(_user, i)\n        vaultAddr: address = staticcall VaultBook(_a.vaultBook).getAddr(vaultId)\n        if vaultAddr == empty(address):\n            continue\n\n        # iterate thru each user asset\n        numUserAssets: uint256 = staticcall Vault(vaultAddr).numUserAssets(_user)\n        for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n\n            # get user asset and amount\n            asset: address = empty(address)\n            amount: uint256 = 0\n            asset, amount = staticcall Vault(vaultAddr).getUserAssetAndAmountAtIndex(_user, y)\n            if asset == empty(address) or amount == 0:\n                continue\n\n            # debt terms\n            debtTerms: DebtTerms = staticcall MissionControl(_a.missionControl).getDebtTerms(asset)\n\n            # skip if no ltv (staked green, staked ripe, etc)\n            if debtTerms.ltv == 0:\n                continue\n\n            # collateral value, max debt\n            collateralVal: uint256 = staticcall PriceDesk(_a.priceDesk).getUsdValue(asset, amount, _shouldRaise)\n            maxDebt: uint256 = collateralVal * debtTerms.ltv // HUNDRED_PERCENT\n\n            # need to return some debt terms, even if not getting any price\n            debtTermsWeight: uint256 = maxDebt\n            if debtTermsWeight == 0:\n                debtTermsWeight = 1\n\n            # debt terms sums -- weight is based on max debt (ltv)\n            ltvSum += debtTermsWeight * debtTerms.ltv\n            redemptionThresholdSum += debtTermsWeight * debtTerms.redemptionThreshold\n            liqThresholdSum += debtTermsWeight * debtTerms.liqThreshold\n            liqFeeSum += debtTermsWeight * debtTerms.liqFee\n            borrowRateSum += debtTermsWeight * debtTerms.borrowRate\n            daowrySum += debtTermsWeight * debtTerms.daowry\n            totalSum += debtTermsWeight\n\n            # totals\n            if not (hasSkip and asset == _skipAsset and vaultId == _skipVaultId):\n                bt.collateralVal += collateralVal\n                bt.totalMaxDebt += maxDebt\n\n    # finalize debt terms (weighted)\n    if totalSum != 0:\n        bt.debtTerms.ltv = ltvSum // totalSum\n        bt.debtTerms.redemptionThreshold = redemptionThresholdSum // totalSum\n        bt.debtTerms.liqThreshold = liqThresholdSum // totalSum\n        bt.debtTerms.liqFee = liqFeeSum // totalSum\n        bt.debtTerms.borrowRate = borrowRateSum // totalSum\n        bt.debtTerms.daowry = daowrySum // totalSum\n\n    # overwrite ltv if collateral value is available\n    if bt.collateralVal != 0:\n        bt.debtTerms.ltv = bt.totalMaxDebt * HUNDRED_PERCENT // bt.collateralVal\n\n    # ensure liq threshold and liq fee can work together\n    liqSum: uint256 = bt.debtTerms.liqThreshold + (bt.debtTerms.liqThreshold * bt.debtTerms.liqFee // HUNDRED_PERCENT)\n    if liqSum > HUNDRED_PERCENT:\n        adjustedLiqFee: uint256 = (HUNDRED_PERCENT - bt.debtTerms.liqThreshold) * HUNDRED_PERCENT // bt.debtTerms.liqThreshold\n        bt.debtTerms.liqFee = adjustedLiqFee\n\n    return bt\n\n\n# latest user debt and terms\n\n\n@view\n@external\ndef getLatestUserDebtAndTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (UserDebt, UserBorrowTerms, uint256):\n    return self._getLatestUserDebtAndTerms(_user, _shouldRaise, addys._getAddys(_a))\n\n\n@view\n@internal\ndef _getLatestUserDebtAndTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _a: addys.Addys,\n) -> (UserDebt, UserBorrowTerms, uint256):\n\n    # get data (repay data has the only stuff we need)\n    d: RepayDataBundle = staticcall Ledger(_a.ledger).getRepayDataBundle(_user)\n\n    # accrue interest\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # debt terms for user\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, _shouldRaise, 0, empty(address), _a)\n\n    return userDebt, bt, newInterest\n\n\n###############\n# Update Debt #\n###############\n\n\n@external\ndef updateDebtForUser(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    assert addys._isValidRipeHqAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    return self._updateDebtForUser(_user, addys._getAddys(_a))\n\n\n@external\ndef updateDebtForManyUsers(_users: DynArray[address, MAX_DEBT_UPDATES], _a: addys.Addys = empty(addys.Addys)) -> bool:\n    assert addys._isValidRipeHqAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    for u: address in _users:\n        self._updateDebtForUser(u, a)\n    return True\n\n\n@internal\ndef _updateDebtForUser(_user: address, _a: addys.Addys) -> bool:\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    newInterest: uint256 = 0\n    userDebt, bt, newInterest = self._getLatestUserDebtAndTerms(_user, True, _a)\n    if userDebt.amount == 0:\n        return True\n\n    # debt health\n    hasGoodDebtHealth: bool = self._hasGoodDebtHealth(userDebt.amount, bt.collateralVal, bt.debtTerms.ltv)\n    if hasGoodDebtHealth:\n        userDebt.inLiquidation = False\n\n    userDebt.debtTerms = bt.debtTerms\n    extcall Ledger(_a.ledger).setUserDebt(_user, userDebt, newInterest, empty(IntervalBorrow))\n\n    # update borrow points\n    extcall LootBox(_a.lootbox).updateBorrowPoints(_user, _a)\n\n    return hasGoodDebtHealth\n\n\n###############\n# Debt Health #\n###############\n\n\n@view\n@external\ndef hasGoodDebtHealth(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 1, _a)\n\n\n@view\n@external\ndef canLiquidateUser(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 2, _a)\n\n\n@view\n@external\ndef canRedeemUserCollateral(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 3, _a)\n\n\n@view\n@internal\ndef _checkDebtHealth(_user: address, _debtType: uint256, _a: addys.Addys) -> bool:\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = self._getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0:\n        return _debtType == 1 # nothing to check\n\n    # check debt health\n    if _debtType == 1:\n        return self._hasGoodDebtHealth(userDebt.amount, bt.collateralVal, bt.debtTerms.ltv)\n    elif _debtType == 2:\n        return self._canLiquidateUser(userDebt.amount, bt.collateralVal, bt.debtTerms.liqThreshold)\n    elif _debtType == 3:\n        return self._canRedeemUserCollateral(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold)\n    else:\n        return False\n\n\n@view\n@internal\ndef _hasGoodDebtHealth(_userDebtAmount: uint256, _collateralVal: uint256, _ltv: uint256) -> bool:\n    maxUserDebt: uint256 = _collateralVal * _ltv // HUNDRED_PERCENT\n    return _userDebtAmount <= maxUserDebt\n\n\n@view\n@internal\ndef _canLiquidateUser(_userDebtAmount: uint256, _collateralVal: uint256, _liqThreshold: uint256) -> bool:\n    # check if collateral value is below (or equal) to liquidation threshold\n    collateralLiqThreshold: uint256 = _userDebtAmount * HUNDRED_PERCENT // _liqThreshold\n    return _collateralVal <= collateralLiqThreshold\n\n\n@view\n@internal\ndef _canRedeemUserCollateral(_userDebtAmount: uint256, _collateralVal: uint256, _redemptionThreshold: uint256) -> bool:\n    # check if collateral value is below (or equal) to redemption threshold\n    redemptionThreshold: uint256 = _userDebtAmount * HUNDRED_PERCENT // _redemptionThreshold\n    return _collateralVal <= redemptionThreshold\n\n\n# thresholds\n\n\n@view\n@external\ndef getLiquidationThreshold(_user: address) -> uint256:\n    return self._getThreshold(_user, 2)\n\n\n@view\n@external\ndef getRedemptionThreshold(_user: address) -> uint256:\n    return self._getThreshold(_user, 3)\n\n\n@view\n@internal\ndef _getThreshold(_user: address, _debtType: uint256) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = self._getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0:\n        return 0\n\n    if _debtType == 2:\n        return userDebt.amount * HUNDRED_PERCENT // bt.debtTerms.liqThreshold\n    elif _debtType == 3:\n        return userDebt.amount * HUNDRED_PERCENT // bt.debtTerms.redemptionThreshold\n    else:\n        return 0\n\n\n##################\n# Green Handling #\n##################\n\n\n@internal\ndef _handleGreenForUser(\n    _recipient: address,\n    _greenAmount: uint256,\n    _wantsSavingsGreen: bool,\n    _greenToken: address,\n    _savingsGreen: address,\n):\n    amount: uint256 = min(_greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n    if amount == 0:\n        return\n\n    if _wantsSavingsGreen:\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, amount, default_return_value=True) # dev: green approval failed\n        extcall IERC4626(_savingsGreen).deposit(amount, _recipient)\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n    else:\n        assert extcall IERC20(_greenToken).transfer(_recipient, amount, default_return_value=True) # dev: green transfer failed\n\n\n#############\n# Utilities #\n#############\n\n\n# max withdrawable\n\n\n@view\n@external\ndef getMaxWithdrawableForAsset(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    a: addys.Addys = addys._getAddys(_a)\n\n    vaultAddr: address = _vaultAddr\n    if vaultAddr == empty(address):\n        vaultAddr = staticcall VaultBook(a.vaultBook).getAddr(_vaultId)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    na: uint256 = 0\n    userDebt, na = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # no debt, can do max withdraw\n    if userDebt.amount == 0:\n        return max_value(uint256)\n\n    # cannot withdraw if in liquidation\n    if userDebt.inLiquidation:\n        return 0\n\n    # get current asset value for user\n    userBalance: uint256 = staticcall Vault(vaultAddr).getTotalAmountForUser(_user, _asset)\n    userUsdValue: uint256 = staticcall PriceDesk(a.priceDesk).getUsdValue(_asset, userBalance, False)\n    if userUsdValue == 0:\n        return 0 # cannot determine value\n\n    # get the asset's debt terms\n    assetDebtTerms: DebtTerms = staticcall MissionControl(a.missionControl).getDebtTerms(_asset)\n    if assetDebtTerms.ltv == 0:\n        return max_value(uint256) # asset doesn't contribute to borrowing power\n\n    # get borrow terms excluding the asset to withdraw\n    btExcluding: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, True, _vaultId, _asset, a)\n\n    # calculate minimum asset value that must remain\n    minAssetValueToRemain: uint256 = 0\n\n    if btExcluding.collateralVal == 0:\n\n        # entire debt must be supported by this asset\n        minAssetValueToRemain = userDebt.amount * (HUNDRED_PERCENT + ONE_PERCENT) // assetDebtTerms.ltv\n\n    # multi-asset case: check if remaining collateral is sufficient\n    else:\n        minCollateralNeeded: uint256 = userDebt.amount * (HUNDRED_PERCENT + ONE_PERCENT) // btExcluding.debtTerms.ltv\n        if btExcluding.collateralVal >= minCollateralNeeded:\n            return max_value(uint256) # remaining collateral is sufficient\n\n        # calculate additional value needed from this asset\n        additionalCollateralNeeded: uint256 = minCollateralNeeded - btExcluding.collateralVal\n        minAssetValueToRemain = additionalCollateralNeeded * HUNDRED_PERCENT // assetDebtTerms.ltv\n\n    # cannot withdraw if user has less than the minimum required\n    if userUsdValue <= minAssetValueToRemain:\n        return 0\n\n    # convert to asset amount\n    maxWithdrawableValue: uint256 = userUsdValue - minAssetValueToRemain\n    return userBalance * maxWithdrawableValue // userUsdValue\n\n\n# accrue interest\n\n\n@view\n@internal\ndef _getLatestUserDebtWithInterest(_userDebt: UserDebt) -> (UserDebt, uint256):\n    userDebt: UserDebt = _userDebt\n\n    # nothing to do here\n    if userDebt.amount == 0 or userDebt.debtTerms.borrowRate == 0 or block.timestamp <= userDebt.lastTimestamp:\n        userDebt.lastTimestamp = block.timestamp\n        return userDebt, 0\n\n    # accrue latest interest\n    timeElapsed: uint256 = block.timestamp - userDebt.lastTimestamp\n    newInterest: uint256 = userDebt.amount * userDebt.debtTerms.borrowRate * timeElapsed // HUNDRED_PERCENT // ONE_YEAR\n    userDebt.amount += newInterest\n\n    userDebt.lastTimestamp = block.timestamp\n    return userDebt, newInterest\n\n\n# daowry (origination fee)\n\n\n@view\n@internal\ndef _getDaowryAmount(\n    _borrowAmount: uint256,\n    _daowryFee: uint256,\n    _isDaowryEnabled: bool,\n) -> uint256:\n    daowry: uint256 = 0\n    if _daowryFee != 0 and _isDaowryEnabled:\n        daowry = _borrowAmount * _daowryFee // HUNDRED_PERCENT\n    return daowry\n\n\n# ltv\n\n\n@view\n@internal\ndef _getAvailBasedOnLtv(_currentUserDebt: uint256, _maxUserDebt: uint256) -> uint256:\n    availDebt: uint256 = 0\n    if _maxUserDebt > _currentUserDebt:\n        availDebt = _maxUserDebt - _currentUserDebt\n    return availDebt\n\n\n# num borrowers\n\n\n@view\n@internal\ndef _getAvailNumBorrowers(_numBorrowers: uint256, _numAllowedBorrowers: uint256) -> uint256:\n    numAllowed: uint256 = 0\n    if _numAllowedBorrowers > _numBorrowers:\n        numAllowed = _numAllowedBorrowers - _numBorrowers\n    return numAllowed\n\n\n# borrow interval\n\n\n@view \n@internal \ndef _getAvailDebtInInterval(\n    _userInterval: IntervalBorrow,\n    _maxBorrowPerInterval: uint256,\n    _numBlocksPerInterval: uint256,\n) -> (uint256, bool):\n    availToBorrow: uint256 = _maxBorrowPerInterval\n    isFreshInterval: bool = True\n    if _userInterval.start != 0 and _userInterval.start + _numBlocksPerInterval > block.number:\n        availToBorrow = _maxBorrowPerInterval - min(_userInterval.amount, _maxBorrowPerInterval)\n        isFreshInterval = False\n    return availToBorrow, isFreshInterval\n\n\n# per user debt limit\n\n\n@view \n@internal \ndef _getAvailPerUserDebt(_currentUserDebt: uint256, _perUserDebtLimit: uint256) -> uint256:\n    if _perUserDebtLimit == max_value(uint256):\n        return max_value(uint256)\n    availableDebt: uint256 = 0\n    if _perUserDebtLimit > _currentUserDebt:\n        availableDebt = _perUserDebtLimit - _currentUserDebt\n    return availableDebt\n\n\n# global debt limit\n\n\n@view \n@internal \ndef _getAvailGlobalDebt(_totalDebt: uint256, _globalDebtLimit: uint256) -> uint256:\n    availableDebt: uint256 = 0\n    if _globalDebtLimit > _totalDebt:\n        availableDebt = _globalDebtLimit - _totalDebt\n    return availableDebt",
            "sha256sum": "1861267bab559005381177d3aef9ba760e1c8b9448032f3716f27b299f02aaf9"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/CreditEngine.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "3825a3578fa22ef3cce98059e85d95e98d4d823df57998eb24386a5c65424cc4"
      },
      "args": "000000000000000000000000a14bceb2c0086acdee1b01e47c7ef3de49ed996e"
    }
  }
}