{
  "contracts": {
    "TestDeploy": {
      "address": "0x1Dd03951B887203b92AE6402E03e0E7cb19e5fB8",
      "abi": [
        {
          "name": "Deployed",
          "inputs": [
            {
              "name": "_addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/mock/TestDeploy.vy": {
            "content": "#  @version 0.4.1\n\nevent Deployed:\n    _addr: indexed(address)\n\n\n@deploy\ndef __init__():\n    log Deployed(_addr=self)",
            "sha256sum": "419af60ea9b75dbddc047d6e6c66ef92bbf63fd631a680e1e6b1f58313961b59"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/TestDeploy.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "83fa5673a3b5e3ec3f2c7a32ea20d0a1b8296c06dccd2f85f2c82c38c11ed776"
      },
      "args": "",
      "file": "contracts/mock/TestDeploy.vy"
    },
    "DefaultsBaseSepolia": {
      "address": "0x57a44Fe5caCFbeB3287242491c01c42581fD938F",
      "abi": [
        {
          "stateMutability": "view",
          "type": "function",
          "name": "genConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserMaxVaults",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxAssetsPerVault",
                  "type": "uint256"
                },
                {
                  "name": "priceStaleTime",
                  "type": "uint256"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                },
                {
                  "name": "canLiquidate",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "genDebtConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDebtAmount",
                  "type": "uint256"
                },
                {
                  "name": "numAllowedBorrowers",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "minDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "maxDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "increasePerDangerBlock",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowRate",
                  "type": "uint256"
                },
                {
                  "name": "maxLtvDeviation",
                  "type": "uint256"
                },
                {
                  "name": "keeperFeeRatio",
                  "type": "uint256"
                },
                {
                  "name": "minKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "maxKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "isDaowryEnabled",
                  "type": "bool"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "genAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hrConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contribTemplate",
                  "type": "address"
                },
                {
                  "name": "maxCompensation",
                  "type": "uint256"
                },
                {
                  "name": "minCliffLength",
                  "type": "uint256"
                },
                {
                  "name": "maxStartDelay",
                  "type": "uint256"
                },
                {
                  "name": "minVestingLength",
                  "type": "uint256"
                },
                {
                  "name": "maxVestingLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeBondConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amountPerEpoch",
                  "type": "uint256"
                },
                {
                  "name": "canBond",
                  "type": "bool"
                },
                {
                  "name": "minRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnitLockBonus",
                  "type": "uint256"
                },
                {
                  "name": "epochLength",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoRestart",
                  "type": "bool"
                },
                {
                  "name": "restartDelayBlocks",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "rewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "arePointsEnabled",
                  "type": "bool"
                },
                {
                  "name": "ripePerBlock",
                  "type": "uint256"
                },
                {
                  "name": "borrowersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "votersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "genDepositorsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeDurationRatio",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeGovVaultConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lockTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "minLockDuration",
                      "type": "uint256"
                    },
                    {
                      "name": "maxLockDuration",
                      "type": "uint256"
                    },
                    {
                      "name": "maxLockBoost",
                      "type": "uint256"
                    },
                    {
                      "name": "canExit",
                      "type": "bool"
                    },
                    {
                      "name": "exitFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "assetWeight",
                  "type": "uint256"
                },
                {
                  "name": "shouldFreezeWhenBadDebt",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "stabClaimRewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "rewardsLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "ripePerDollarClaimed",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "underscoreRegistry",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldCheckLastTouch",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeAvailForRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeAvailForHr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeAvailForBonds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Defaults.vyi": {
            "content": "# @version 0.4.1\n\nimport interfaces.ConfigStructs as cs\n\n\n# general config\n\n\n@view\n@external\ndef genConfig() -> cs.GenConfig:\n    ...\n\n\n# debt config\n\n\n@view\n@external\ndef genDebtConfig() -> cs.GenDebtConfig:\n    ...\n\n\n# hr config\n\n\n@view\n@external\ndef hrConfig() -> cs.HrConfig:\n    ...\n\n\n# ripe bond config\n\n\n@view\n@external\ndef ripeBondConfig() -> cs.RipeBondConfig:\n    ...\n\n\n# ripe rewards config\n\n\n@view\n@external\ndef rewardsConfig() -> cs.RipeRewardsConfig:\n    ...\n\n\n# ripe gov vault config\n\n\n@view\n@external\ndef ripeGovVaultConfig() -> cs.RipeGovVaultConfig:\n    ...\n\n\n# stab claim rewards config\n\n\n@view\n@external\ndef stabClaimRewardsConfig() -> cs.StabClaimRewardsConfig:\n    ...\n\n\n# underscore registry\n\n\n@view\n@external\ndef underscoreRegistry() -> address:\n    ...\n\n\n# shouldCheckLastTouchy\n\n\n@view\n@external\ndef shouldCheckLastTouch() -> bool:\n    ...\n\n\n# ripe available\n\n\n@view\n@external\ndef ripeAvailForRewards() -> uint256:\n    ...\n\n\n@view\n@external\ndef ripeAvailForHr() -> uint256:\n    ...\n\n\n@view\n@external\ndef ripeAvailForBonds() -> uint256:\n    ...",
            "sha256sum": "a03f6ebff9f709dee36d402f5b3adcd3953290787efb1d2c2a7d1d6a1cff67c6"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "contracts/config/DefaultsBaseSepolia.vy": {
            "content": "# @version 0.4.1\n\nimplements: Defaults\nfrom interfaces import Defaults\nimport interfaces.ConfigStructs as cs\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nHUNDRED_PERCENT: constant(uint256) = 100_00\n\n# seconds\nDAY_IN_SECONDS: constant(uint256) = 60 * 60 * 24\nWEEK_IN_SECONDS: constant(uint256) = 7 * DAY_IN_SECONDS\nMONTH_IN_SECONDS: constant(uint256) = 30 * DAY_IN_SECONDS\nYEAR_IN_SECONDS: constant(uint256) = 365 * DAY_IN_SECONDS\n\n# blocks\nDAY_IN_BLOCKS: constant(uint256) = 43_200\nWEEK_IN_BLOCKS: constant(uint256) = 7 * DAY_IN_BLOCKS\nMONTH_IN_BLOCKS: constant(uint256) = 30 * DAY_IN_BLOCKS\nYEAR_IN_BLOCKS: constant(uint256) = 365 * DAY_IN_BLOCKS\n\n\n@deploy\ndef __init__():\n    pass\n\n\n# general config\n\n\n@view\n@external\ndef genConfig() -> cs.GenConfig:\n    return cs.GenConfig(\n        perUserMaxVaults = 5,\n        perUserMaxAssetsPerVault = 10,\n        priceStaleTime = 0,\n        canDeposit = True,\n        canWithdraw = True,\n        canBorrow = True,\n        canRepay = True,\n        canClaimLoot = True,\n        canLiquidate = True,\n        canRedeemCollateral = True,\n        canRedeemInStabPool = True,\n        canBuyInAuction = True,\n        canClaimInStabPool = True,\n    )\n\n\n# debt config\n\n\n@view\n@external\ndef genDebtConfig() -> cs.GenDebtConfig:\n    return cs.GenDebtConfig(\n        perUserDebtLimit = 1_000_000 * EIGHTEEN_DECIMALS,\n        globalDebtLimit = 100_000_000 * EIGHTEEN_DECIMALS,\n        minDebtAmount = 100 * EIGHTEEN_DECIMALS,\n        numAllowedBorrowers = 50,\n        maxBorrowPerInterval = 100_000 * EIGHTEEN_DECIMALS,\n        numBlocksPerInterval = 100,\n        minDynamicRateBoost = 50_00,\n        maxDynamicRateBoost = 5 * HUNDRED_PERCENT,\n        increasePerDangerBlock = 10,\n        maxBorrowRate = HUNDRED_PERCENT,\n        maxLtvDeviation = 10_00,\n        keeperFeeRatio = 1_00,\n        minKeeperFee = EIGHTEEN_DECIMALS,\n        maxKeeperFee = 10_0000 * EIGHTEEN_DECIMALS,\n        isDaowryEnabled = True,\n        ltvPaybackBuffer = 5_00,\n        genAuctionParams = cs.AuctionParams(\n            hasParams = True,\n            startDiscount = 0,\n            maxDiscount = 50_00,\n            delay = 0,\n            duration = DAY_IN_BLOCKS,\n        ),\n    )\n\n\n# hr config\n\n\n@view\n@external\ndef hrConfig() -> cs.HrConfig:\n    return cs.HrConfig(\n        contribTemplate = empty(address),\n        maxCompensation = 0, # set this later, after core contributor vesting setup\n        minCliffLength = 1 * WEEK_IN_SECONDS,\n        maxStartDelay = 1 * MONTH_IN_SECONDS,\n        minVestingLength = 1 * MONTH_IN_SECONDS,\n        maxVestingLength = 5 * YEAR_IN_SECONDS,\n    )\n\n\n# ripe bond config\n\n\n@view\n@external\ndef ripeBondConfig() -> cs.RipeBondConfig:\n    return cs.RipeBondConfig(\n        asset = 0x611ce0729f6C052f49536c84a8fD717E619D5dc6,\n        amountPerEpoch = 100_000 * (10 ** 6),\n        canBond = True,\n        minRipePerUnit = 1 * EIGHTEEN_DECIMALS,\n        maxRipePerUnit = 100 * EIGHTEEN_DECIMALS,\n        maxRipePerUnitLockBonus = 10 * EIGHTEEN_DECIMALS,\n        epochLength = 1000,\n        shouldAutoRestart = True,\n        restartDelayBlocks = 100,\n    )\n\n\n# ripe rewards config\n\n\n@view\n@external\ndef rewardsConfig() -> cs.RipeRewardsConfig:\n    return cs.RipeRewardsConfig(\n        arePointsEnabled = True,\n        ripePerBlock = 1 * EIGHTEEN_DECIMALS,\n        borrowersAlloc = 50_00,\n        stakersAlloc = 10_00,\n        votersAlloc = 0,\n        genDepositorsAlloc = 0,\n        autoStakeRatio = 90_00,\n        autoStakeDurationRatio = 10_00,\n    )\n\n\n# ripe gov vault config\n\n\n@view\n@external\ndef ripeGovVaultConfig() -> cs.RipeGovVaultConfig:\n    return cs.RipeGovVaultConfig(\n        lockTerms = cs.LockTerms(\n            minLockDuration = 1 * DAY_IN_BLOCKS,\n            maxLockDuration = 1 * MONTH_IN_BLOCKS,\n            maxLockBoost = 2 * HUNDRED_PERCENT,\n            canExit = True,\n            exitFee = 10_00,\n        ),\n        assetWeight = HUNDRED_PERCENT,\n        shouldFreezeWhenBadDebt = True,\n    )\n\n\n# stab claim rewards config\n\n\n@view\n@external\ndef stabClaimRewardsConfig() -> cs.StabClaimRewardsConfig:\n    return cs.StabClaimRewardsConfig(\n        rewardsLockDuration = 1 * DAY_IN_BLOCKS,\n        ripePerDollarClaimed = 1 * EIGHTEEN_DECIMALS,\n    )\n\n\n# underscore registry\n\n\nUNDERSCORE_REGISTRY: constant(address) = 0xa89a59E14333187829528C50eBAaE6EC12Bae95d\n\n\n@view\n@external\ndef underscoreRegistry() -> address:\n    return UNDERSCORE_REGISTRY\n\n\n# should check last touch\n\n\n@view\n@external\ndef shouldCheckLastTouch() -> bool:\n    return True\n\n\n# ripe available\n\n\n@view\n@external\ndef ripeAvailForRewards() -> uint256:\n    return 100_000_000 * EIGHTEEN_DECIMALS\n\n\n@view\n@external\ndef ripeAvailForHr() -> uint256:\n    return 100_000_000 * EIGHTEEN_DECIMALS\n\n\n@view\n@external\ndef ripeAvailForBonds() -> uint256:\n    return 100_000_000 * EIGHTEEN_DECIMALS",
            "sha256sum": "57bc011f7538e77291d11440bc8a9d1e0f60091f31e10acc5efea9de02bbd3a4"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/DefaultsBaseSepolia.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "ff07adc0309239a6399c11a6cc8579fbd5c9e011482c021c1f879dd541c5fde6"
      },
      "args": "",
      "file": "contracts/config/DefaultsBaseSepolia.vy"
    },
    "GreenToken": {
      "address": "0x2E3Ee9D4f379A820665c0E560459B19FA15E7C35",
      "abi": [
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeInitiated",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeConfirmed",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeCancelled",
          "inputs": [
            {
              "name": "cancelledHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "InitialRipeHqSet",
          "inputs": [
            {
              "name": "hq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqChange",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewRipeHq",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHq",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_initialSupply",
              "type": "uint256"
            },
            {
              "name": "_initialSupplyRecipient",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/tokens/modules/Erc20Token.vy": {
            "content": "# @version 0.4.1\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface RipeHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintGreen(_addr: address) -> bool: view\n    def canMintRipe(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def greenToken() -> address: view\n    def governance() -> address: view\n    def ripeToken() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nstruct PendingHq:\n    newHq: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# ripe \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent HqChangeInitiated:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    confirmBlock: uint256\n\nevent HqChangeConfirmed:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqChangeCancelled:\n    cancelledHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent TokenPauseModified:\n    isPaused: bool\n\nevent InitialRipeHqSet:\n    hq: indexed(address)\n    timeLock: uint256\n\nevent HqChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\n# ripe hq\nripeHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\npendingHq: public(PendingHq)\nhqChangeTimeLock: public(uint256)\ntempGov: address\n\nMIN_HQ_TIME_LOCK: immutable(uint256)\nMAX_HQ_TIME_LOCK: immutable(uint256)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    MIN_HQ_TIME_LOCK = _minHqTimeLock\n    MAX_HQ_TIME_LOCK = _maxHqTimeLock\n\n    # set initial gov (green / ripe tokens)\n    if _initialGov != empty(address):\n        assert _ripeHq == empty(address) # dev: cannot set initial gov and ripe hq\n        self.tempGov = _initialGov\n\n    # set ripe hq\n    if _ripeHq != empty(address):\n        assert self._isValidNewRipeHq(_ripeHq, empty(address)) # dev: invalid ripe hq\n        assert _initialGov == empty(address) # dev: cannot set initial gov and ripe hq\n        self.ripeHq = _ripeHq\n\n    # initial supply\n    if _initialSupply != 0 and _initialSupplyRecipient not in [empty(address), self]:\n        self.balanceOf[_initialSupplyRecipient] = _initialSupply\n        self.totalSupply = _initialSupply\n        log Transfer(sender=empty(address), recipient=_initialSupplyRecipient, amount=_initialSupply)\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall RipeHq(self.ripeHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n###################\n# Ripe Hq Changes #\n###################\n\n\n@view\n@external\ndef hasPendingHqChange() -> bool:\n    return self.pendingHq.confirmBlock != 0\n\n\n# initiate hq change\n\n\n@external\ndef initiateHqChange(_newHq: address):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    # validate new hq\n    prevHq: address = self.ripeHq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid new hq\n\n    confirmBlock: uint256 = block.number + self.hqChangeTimeLock\n    self.pendingHq = PendingHq(\n        newHq= _newHq,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqChangeInitiated(prevHq=prevHq, newHq=_newHq, confirmBlock=confirmBlock)\n\n\n# confirm hq change\n\n\n@external\ndef confirmHqChange() -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # validate new hq one more time\n    prevHq: address = self.ripeHq\n    if not self._isValidNewRipeHq(data.newHq, prevHq):\n        self.pendingHq = empty(PendingHq)\n        return False\n\n    # set new ripe hq\n    self.ripeHq = data.newHq\n    self.pendingHq = empty(PendingHq)\n    log HqChangeConfirmed(prevHq=prevHq, newHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n    return True\n\n\n# cancel hq change\n\n\n@external\ndef cancelHqChange():\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingHq = empty(PendingHq)\n    log HqChangeCancelled(cancelledHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewRipeHq(_newHq: address) -> bool:\n    return self._isValidNewRipeHq(_newHq, self.ripeHq)\n\n\n@view\n@internal\ndef _isValidNewRipeHq(_newHq: address, _prevHq: address) -> bool:\n\n    # same hq, or invalid new hq\n    if _newHq == _prevHq or _newHq == empty(address) or not _newHq.is_contract:\n        return False\n\n    # if current hq has pending gov change, cannot change ripe hq now\n    if _prevHq != empty(address) and staticcall RipeHq(_prevHq).hasPendingGovChange():\n        return False\n\n    # if new hq has pending gov change, or is not set, cannot change ripe hq now\n    if staticcall RipeHq(_newHq).hasPendingGovChange() or staticcall RipeHq(_newHq).governance() == empty(address):\n        return False\n\n    # tokens must be set\n    if staticcall RipeHq(_newHq).greenToken() == empty(address) or staticcall RipeHq(_newHq).ripeToken() == empty(address):\n        return False\n\n    # make sure it has the necessary interfaces\n    assert not staticcall RipeHq(_newHq).canSetTokenBlacklist(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintGreen(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintRipe(empty(address)) # dev: invalid interface\n\n    return True\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    ripeHq: address = self.ripeHq\n    assert msg.sender == staticcall RipeHq(ripeHq).governance() # dev: no perms\n    assert not staticcall RipeHq(ripeHq).hasPendingGovChange() # dev: pending gov change\n    return self._setHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@internal\ndef _setHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidHqChangeTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.hqChangeTimeLock = _newTimeLock\n    log HqChangeTimeLockModified(prevTimeLock=_prevTimeLock, newTimeLock=_newTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_HQ_TIME_LOCK and _newTimeLock <= MAX_HQ_TIME_LOCK\n\n\n# views\n\n\n@view\n@external\ndef minHqTimeLock() -> uint256:\n    return MIN_HQ_TIME_LOCK\n\n\n@view\n@external\ndef maxHqTimeLock() -> uint256:\n    return MAX_HQ_TIME_LOCK\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n\n\n###############\n# Token Setup #\n###############\n\n\n@external\ndef finishTokenSetup(_newHq: address, _timeLock: uint256 = 0) -> bool:\n    assert msg.sender == self.tempGov # dev: no perms\n\n    prevHq: address = self.ripeHq\n    assert prevHq == empty(address) # dev: already set\n\n    # set hq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid ripe hq\n    self.ripeHq = _newHq\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_HQ_TIME_LOCK\n    prevTimeLock: uint256 = self.hqChangeTimeLock\n    if timeLock != prevTimeLock:\n        assert self._setHqChangeTimeLock(timeLock, prevTimeLock) # dev: invalid time lock\n\n    self.tempGov = empty(address)\n    log InitialRipeHqSet(hq=_newHq, timeLock=timeLock)\n    return True\n",
            "sha256sum": "66c2e657d9faa162b27fbb89751938175d9271c75685964781cfe37863b7806a"
          },
          "contracts/tokens/GreenToken.vy": {
            "content": "# @version 0.4.1\n\nexports: token.__interface__\ninitializes: token\n\nfrom contracts.tokens.modules import Erc20Token as token\n\ninterface RipeHq:\n    def canMintGreen(_addr: address) -> bool: view\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    token.__init__(\"Green USD Stablecoin\", \"GREEN\", 18, _ripeHq, _initialGov, _minHqTimeLock, _maxHqTimeLock, _initialSupply, _initialSupplyRecipient)\n\n\n###########\n# Minting #\n###########\n\n\n@external\ndef mint(_recipient: address, _amount: uint256) -> bool:\n    assert staticcall RipeHq(token.ripeHq).canMintGreen(msg.sender) # dev: cannot mint\n    return token._mint(_recipient, _amount)\n",
            "sha256sum": "d4f598449ad69fd6709748f7cf59d92631ff9a8a2ccf38bb137d7630b9a93005"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/tokens/GreenToken.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "df96d3ab4d7098847b91ca3a00a9259dae60db0827875969d8b9f935192ef555"
      },
      "args": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e",
      "file": "contracts/tokens/GreenToken.vy"
    },
    "RipeToken": {
      "address": "0x16E5c329F8b9Cf99b5Edc61dA6A6eb8700C83DB7",
      "abi": [
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeInitiated",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeConfirmed",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeCancelled",
          "inputs": [
            {
              "name": "cancelledHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "InitialRipeHqSet",
          "inputs": [
            {
              "name": "hq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqChange",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewRipeHq",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHq",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_initialSupply",
              "type": "uint256"
            },
            {
              "name": "_initialSupplyRecipient",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/tokens/modules/Erc20Token.vy": {
            "content": "# @version 0.4.1\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface RipeHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintGreen(_addr: address) -> bool: view\n    def canMintRipe(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def greenToken() -> address: view\n    def governance() -> address: view\n    def ripeToken() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nstruct PendingHq:\n    newHq: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# ripe \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent HqChangeInitiated:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    confirmBlock: uint256\n\nevent HqChangeConfirmed:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqChangeCancelled:\n    cancelledHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent TokenPauseModified:\n    isPaused: bool\n\nevent InitialRipeHqSet:\n    hq: indexed(address)\n    timeLock: uint256\n\nevent HqChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\n# ripe hq\nripeHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\npendingHq: public(PendingHq)\nhqChangeTimeLock: public(uint256)\ntempGov: address\n\nMIN_HQ_TIME_LOCK: immutable(uint256)\nMAX_HQ_TIME_LOCK: immutable(uint256)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    MIN_HQ_TIME_LOCK = _minHqTimeLock\n    MAX_HQ_TIME_LOCK = _maxHqTimeLock\n\n    # set initial gov (green / ripe tokens)\n    if _initialGov != empty(address):\n        assert _ripeHq == empty(address) # dev: cannot set initial gov and ripe hq\n        self.tempGov = _initialGov\n\n    # set ripe hq\n    if _ripeHq != empty(address):\n        assert self._isValidNewRipeHq(_ripeHq, empty(address)) # dev: invalid ripe hq\n        assert _initialGov == empty(address) # dev: cannot set initial gov and ripe hq\n        self.ripeHq = _ripeHq\n\n    # initial supply\n    if _initialSupply != 0 and _initialSupplyRecipient not in [empty(address), self]:\n        self.balanceOf[_initialSupplyRecipient] = _initialSupply\n        self.totalSupply = _initialSupply\n        log Transfer(sender=empty(address), recipient=_initialSupplyRecipient, amount=_initialSupply)\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall RipeHq(self.ripeHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n###################\n# Ripe Hq Changes #\n###################\n\n\n@view\n@external\ndef hasPendingHqChange() -> bool:\n    return self.pendingHq.confirmBlock != 0\n\n\n# initiate hq change\n\n\n@external\ndef initiateHqChange(_newHq: address):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    # validate new hq\n    prevHq: address = self.ripeHq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid new hq\n\n    confirmBlock: uint256 = block.number + self.hqChangeTimeLock\n    self.pendingHq = PendingHq(\n        newHq= _newHq,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqChangeInitiated(prevHq=prevHq, newHq=_newHq, confirmBlock=confirmBlock)\n\n\n# confirm hq change\n\n\n@external\ndef confirmHqChange() -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # validate new hq one more time\n    prevHq: address = self.ripeHq\n    if not self._isValidNewRipeHq(data.newHq, prevHq):\n        self.pendingHq = empty(PendingHq)\n        return False\n\n    # set new ripe hq\n    self.ripeHq = data.newHq\n    self.pendingHq = empty(PendingHq)\n    log HqChangeConfirmed(prevHq=prevHq, newHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n    return True\n\n\n# cancel hq change\n\n\n@external\ndef cancelHqChange():\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingHq = empty(PendingHq)\n    log HqChangeCancelled(cancelledHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewRipeHq(_newHq: address) -> bool:\n    return self._isValidNewRipeHq(_newHq, self.ripeHq)\n\n\n@view\n@internal\ndef _isValidNewRipeHq(_newHq: address, _prevHq: address) -> bool:\n\n    # same hq, or invalid new hq\n    if _newHq == _prevHq or _newHq == empty(address) or not _newHq.is_contract:\n        return False\n\n    # if current hq has pending gov change, cannot change ripe hq now\n    if _prevHq != empty(address) and staticcall RipeHq(_prevHq).hasPendingGovChange():\n        return False\n\n    # if new hq has pending gov change, or is not set, cannot change ripe hq now\n    if staticcall RipeHq(_newHq).hasPendingGovChange() or staticcall RipeHq(_newHq).governance() == empty(address):\n        return False\n\n    # tokens must be set\n    if staticcall RipeHq(_newHq).greenToken() == empty(address) or staticcall RipeHq(_newHq).ripeToken() == empty(address):\n        return False\n\n    # make sure it has the necessary interfaces\n    assert not staticcall RipeHq(_newHq).canSetTokenBlacklist(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintGreen(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintRipe(empty(address)) # dev: invalid interface\n\n    return True\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    ripeHq: address = self.ripeHq\n    assert msg.sender == staticcall RipeHq(ripeHq).governance() # dev: no perms\n    assert not staticcall RipeHq(ripeHq).hasPendingGovChange() # dev: pending gov change\n    return self._setHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@internal\ndef _setHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidHqChangeTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.hqChangeTimeLock = _newTimeLock\n    log HqChangeTimeLockModified(prevTimeLock=_prevTimeLock, newTimeLock=_newTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_HQ_TIME_LOCK and _newTimeLock <= MAX_HQ_TIME_LOCK\n\n\n# views\n\n\n@view\n@external\ndef minHqTimeLock() -> uint256:\n    return MIN_HQ_TIME_LOCK\n\n\n@view\n@external\ndef maxHqTimeLock() -> uint256:\n    return MAX_HQ_TIME_LOCK\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n\n\n###############\n# Token Setup #\n###############\n\n\n@external\ndef finishTokenSetup(_newHq: address, _timeLock: uint256 = 0) -> bool:\n    assert msg.sender == self.tempGov # dev: no perms\n\n    prevHq: address = self.ripeHq\n    assert prevHq == empty(address) # dev: already set\n\n    # set hq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid ripe hq\n    self.ripeHq = _newHq\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_HQ_TIME_LOCK\n    prevTimeLock: uint256 = self.hqChangeTimeLock\n    if timeLock != prevTimeLock:\n        assert self._setHqChangeTimeLock(timeLock, prevTimeLock) # dev: invalid time lock\n\n    self.tempGov = empty(address)\n    log InitialRipeHqSet(hq=_newHq, timeLock=timeLock)\n    return True\n",
            "sha256sum": "66c2e657d9faa162b27fbb89751938175d9271c75685964781cfe37863b7806a"
          },
          "contracts/tokens/RipeToken.vy": {
            "content": "# @version 0.4.1\n\nexports: token.__interface__\ninitializes: token\n\nfrom contracts.tokens.modules import Erc20Token as token\n\ninterface RipeHq:\n    def canMintRipe(_addr: address) -> bool: view\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    token.__init__(\"Ripe DAO Governance Token\", \"RIPE\", 18, _ripeHq, _initialGov, _minHqTimeLock, _maxHqTimeLock, _initialSupply, _initialSupplyRecipient)\n\n\n###########\n# Minting #\n###########\n\n\n@external\ndef mint(_recipient: address, _amount: uint256) -> bool:\n    assert staticcall RipeHq(token.ripeHq).canMintRipe(msg.sender) # dev: cannot mint\n    return token._mint(_recipient, _amount)\n",
            "sha256sum": "5c9cae6aba9e5c6d49ef51801cfc614d384f7b79164cde1ce48ec33fc323c7dc"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/tokens/RipeToken.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "ba4ace1cf21b6b0be7e9384eaf102aa54e83efc82c5a35b529071281f6333e1a"
      },
      "args": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000d3c21bcecceda1000000000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e",
      "file": "contracts/tokens/RipeToken.vy"
    },
    "SavingsGreen": {
      "address": "0x11De3ed496c2FA22F49BE6b4806D5603f6A54A08",
      "abi": [
        {
          "name": "Transfer",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Approval",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "spender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistModified",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeInitiated",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeConfirmed",
          "inputs": [
            {
              "name": "prevHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeCancelled",
          "inputs": [
            {
              "name": "cancelledHq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TokenPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "InitialRipeHqSet",
          "inputs": [
            {
              "name": "hq",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Deposit",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "Withdraw",
          "inputs": [
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "receiver",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "name",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "symbol",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transfer",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFrom",
          "inputs": [
            {
              "name": "_sender",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "approve",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "increaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "decreaseAllowance",
          "inputs": [
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burn",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "DOMAIN_SEPARATOR",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bytes32"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "permit",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_spender",
              "type": "address"
            },
            {
              "name": "_value",
              "type": "uint256"
            },
            {
              "name": "_deadline",
              "type": "uint256"
            },
            {
              "name": "_signature",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "burnBlacklistTokens",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqChange",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewRipeHq",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidHqChangeTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxHqTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishTokenSetup",
          "inputs": [
            {
              "name": "_newHq",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "blacklisted",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHq",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "balanceOf",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "allowance",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalSupply",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_NAME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_SYMBOL",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "TOKEN_DECIMALS",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "VERSION",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "nonces",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "asset",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxDeposit",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewDeposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxMint",
          "inputs": [
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewMint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mint",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxWithdraw",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewWithdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRedeem",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRedeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeem",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_receiver",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToShares",
          "inputs": [
            {
              "name": "_assets",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "convertToAssets",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastUnderlying",
          "inputs": [
            {
              "name": "_shares",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pricePerShare",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastPricePerShare",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxHqTimeLock",
              "type": "uint256"
            },
            {
              "name": "_initialSupply",
              "type": "uint256"
            },
            {
              "name": "_initialSupplyRecipient",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/tokens/modules/Erc20Token.vy": {
            "content": "# @version 0.4.1\n\nimplements: IERC20\nfrom ethereum.ercs import IERC20\n\ninterface RipeHq:\n    def canSetTokenBlacklist(_addr: address) -> bool: view\n    def canMintGreen(_addr: address) -> bool: view\n    def canMintRipe(_addr: address) -> bool: view\n    def hasPendingGovChange() -> bool: view\n    def greenToken() -> address: view\n    def governance() -> address: view\n    def ripeToken() -> address: view\n\ninterface ERC1271:\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes4: view\n\n# erc20\n\nstruct PendingHq:\n    newHq: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent Transfer:\n    sender: indexed(address)\n    recipient: indexed(address)\n    amount: uint256\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    amount: uint256\n\n# ripe \n\nevent BlacklistModified:\n    addr: indexed(address)\n    isBlacklisted: bool\n\nevent HqChangeInitiated:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    confirmBlock: uint256\n\nevent HqChangeConfirmed:\n    prevHq: indexed(address)\n    newHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqChangeCancelled:\n    cancelledHq: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent TokenPauseModified:\n    isPaused: bool\n\nevent InitialRipeHqSet:\n    hq: indexed(address)\n    timeLock: uint256\n\nevent HqChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\n# ripe hq\nripeHq: public(address)\n\n# config\nblacklisted: public(HashMap[address, bool])\nisPaused: public(bool)\npendingHq: public(PendingHq)\nhqChangeTimeLock: public(uint256)\ntempGov: address\n\nMIN_HQ_TIME_LOCK: immutable(uint256)\nMAX_HQ_TIME_LOCK: immutable(uint256)\n\n# erc20\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\n# token info\nTOKEN_NAME: public(immutable(String[64]))\nTOKEN_SYMBOL: public(immutable(String[32]))\nTOKEN_DECIMALS: public(immutable(uint8))\nVERSION: public(constant(String[8])) = \"v1.0.0\"\n\n# eip-712\nnonces: public(HashMap[address, uint256])\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\nECRECOVER_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000001\nERC1271_MAGIC_VAL: constant(bytes4) = 0x1626ba7e\n\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\nNAME_HASH: immutable(bytes32)\nVERSION_HASH: constant(bytes32) = keccak256(VERSION)\nCACHED_CHAIN_ID: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _tokenName: String[64],\n    _tokenSymbol: String[32],\n    _tokenDecimals: uint8,\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    # token info\n    TOKEN_NAME = _tokenName\n    TOKEN_SYMBOL = _tokenSymbol\n    TOKEN_DECIMALS = _tokenDecimals\n\n    MIN_HQ_TIME_LOCK = _minHqTimeLock\n    MAX_HQ_TIME_LOCK = _maxHqTimeLock\n\n    # set initial gov (green / ripe tokens)\n    if _initialGov != empty(address):\n        assert _ripeHq == empty(address) # dev: cannot set initial gov and ripe hq\n        self.tempGov = _initialGov\n\n    # set ripe hq\n    if _ripeHq != empty(address):\n        assert self._isValidNewRipeHq(_ripeHq, empty(address)) # dev: invalid ripe hq\n        assert _initialGov == empty(address) # dev: cannot set initial gov and ripe hq\n        self.ripeHq = _ripeHq\n\n    # initial supply\n    if _initialSupply != 0 and _initialSupplyRecipient not in [empty(address), self]:\n        self.balanceOf[_initialSupplyRecipient] = _initialSupply\n        self.totalSupply = _initialSupply\n        log Transfer(sender=empty(address), recipient=_initialSupplyRecipient, amount=_initialSupply)\n\n    # domain separator\n    NAME_HASH = keccak256(_tokenName)\n    CACHED_CHAIN_ID = chain.id\n    CACHED_DOMAIN_SEPARATOR = keccak256(\n        abi_encode(\n            EIP712_TYPEHASH,\n            NAME_HASH,\n            VERSION_HASH,\n            CACHED_CHAIN_ID,\n            self,\n        )\n    )\n\n\n##############\n# Token Info #\n##############\n\n\n@view\n@external\ndef name() -> String[64]:\n    return TOKEN_NAME\n\n\n@view\n@external\ndef symbol() -> String[32]:\n    return TOKEN_SYMBOL\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return TOKEN_DECIMALS\n\n\n#############\n# Transfers #\n#############\n\n\n@external\ndef transfer(_recipient: address, _amount: uint256) -> bool:\n    self._transfer(msg.sender, _recipient, _amount)\n    return True\n\n\n@external\ndef transferFrom(_sender: address, _recipient: address, _amount: uint256) -> bool:\n    assert not self.blacklisted[msg.sender] # dev: spender blacklisted\n    self._spendAllowance(_sender, msg.sender, _amount)\n    self._transfer(_sender, _recipient, _amount)\n    return True\n\n\n@internal\ndef _transfer(_sender: address, _recipient: address, _amount: uint256):\n    assert not self.isPaused # dev: token paused\n    assert _amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n\n    assert not self.blacklisted[_sender] # dev: sender blacklisted\n    assert not self.blacklisted[_recipient] # dev: recipient blacklisted\n\n    senderBalance: uint256 = self.balanceOf[_sender]\n    assert senderBalance >= _amount # dev: insufficient funds\n    self.balanceOf[_sender] = senderBalance - _amount\n    self.balanceOf[_recipient] += _amount\n\n    log Transfer(sender=_sender, recipient=_recipient, amount=_amount)\n\n\n#############\n# Allowance #\n#############\n\n\n# approvals\n\n\n@external\ndef approve(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    self._approve(msg.sender, _spender, _amount)\n    return True\n\n\n@internal\ndef _approve(_owner: address, _spender: address, _amount: uint256):\n    self.allowance[_owner][_spender] = _amount\n    log Approval(owner=_owner, spender=_spender, amount=_amount)\n\n\n@internal\ndef _spendAllowance(_owner: address, _spender: address, _amount: uint256):\n    currentAllowance: uint256 = self.allowance[_owner][_spender]\n    if currentAllowance != max_value(uint256):\n        assert currentAllowance >= _amount # dev: insufficient allowance\n        self._approve(_owner, _spender, currentAllowance - _amount)\n\n\n# increase / decrease allowance\n\n\n@external\ndef increaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    maxIncrease: uint256 = max_value(uint256) - currentAllowance\n    newAllowance: uint256 = currentAllowance + min(_amount, maxIncrease)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n@external\ndef decreaseAllowance(_spender: address, _amount: uint256) -> bool:\n    self._validateNewApprovals(msg.sender, _spender)\n    currentAllowance: uint256 = self.allowance[msg.sender][_spender]\n    newAllowance: uint256 = currentAllowance - min(_amount, currentAllowance)\n    if newAllowance != currentAllowance:\n        self._approve(msg.sender, _spender, newAllowance)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _validateNewApprovals(_owner: address, _spender: address):\n    assert not self.isPaused # dev: token paused\n    assert not self.blacklisted[_owner] # dev: owner blacklisted\n    assert not self.blacklisted[_spender] # dev: spender blacklisted\n    assert _spender != empty(address) # dev: invalid spender\n\n\n#####################\n# Minting / Burning #\n#####################\n\n\n# mint tokens\n\n\n@internal\ndef _mint(_recipient: address, _amount: uint256) -> bool:\n    assert _recipient not in [self, empty(address)] # dev: invalid recipient\n    assert not self.blacklisted[_recipient] # dev: blacklisted\n    assert not self.isPaused # dev: token paused\n\n    self.balanceOf[_recipient] += _amount\n    self.totalSupply += _amount\n    log Transfer(sender=empty(address), recipient=_recipient, amount=_amount)\n    return True\n\n\n# burn tokens\n\n\n@external\ndef burn(_amount: uint256) -> bool:\n    assert not self.isPaused # dev: token paused\n    self._burn(msg.sender, _amount)\n    return True\n\n\n@internal\ndef _burn(_owner: address, _amount: uint256):\n    self.balanceOf[_owner] -= _amount\n    self.totalSupply -= _amount\n    log Transfer(sender=_owner, recipient=empty(address), amount=_amount)\n\n\n###########\n# EIP 712 #\n###########\n\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self._domainSeparator()\n\n\n@view\n@internal\ndef _domainSeparator() -> bytes32:\n    if chain.id != CACHED_CHAIN_ID:\n        return keccak256(\n            abi_encode(\n                EIP712_TYPEHASH,\n                NAME_HASH,\n                VERSION_HASH,\n                chain.id,\n                self,\n            )\n        )\n    return CACHED_DOMAIN_SEPARATOR\n\n\n@external\ndef permit(\n    _owner: address,\n    _spender: address,\n    _value: uint256,\n    _deadline: uint256,\n    _signature: Bytes[65],\n) -> bool:\n    self._validateNewApprovals(_owner, _spender)\n    assert _owner != empty(address) and block.timestamp <= _deadline # dev: permit expired\n\n    nonce: uint256 = self.nonces[_owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b\"\\x19\\x01\",\n            self._domainSeparator(),\n            keccak256(abi_encode(EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline)),\n        )\n    )\n\n    if _owner.is_contract:\n        assert staticcall ERC1271(_owner).isValidSignature(digest, _signature) == ERC1271_MAGIC_VAL # dev: invalid signature\n\n    else:\n        r: bytes32 = convert(slice(_signature, 0, 32), bytes32)\n        s: bytes32 = convert(slice(_signature, 32, 32), bytes32)\n        v: uint8 = convert(slice(_signature, 64, 1), uint8)\n\n        response: Bytes[32] = raw_call(\n            ECRECOVER_PRECOMPILE,\n            abi_encode(digest, v, r, s),\n            max_outsize = 32,\n            is_static_call = True # a view function\n        )\n        assert len(response) == 32  # dev: invalid ecrecover response length\n        assert abi_decode(response, address) == _owner  # dev: invalid signature\n\n    self.nonces[_owner] = nonce + 1\n    self._approve(_owner, _spender, _value)\n    return True\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool:\n    assert staticcall RipeHq(self.ripeHq).canSetTokenBlacklist(msg.sender) # dev: no perms\n\n    assert _addr not in [self, empty(address)] # dev: invalid blacklist recipient\n    self.blacklisted[_addr] = _shouldBlacklist\n    log BlacklistModified(addr=_addr, isBlacklisted=_shouldBlacklist)\n    return True\n\n\n@external\ndef burnBlacklistTokens(_addr: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert self.blacklisted[_addr] # dev: not blacklisted\n\n    amount: uint256 = min(_amount, self.balanceOf[_addr])\n    assert amount != 0 # dev: cannot burn 0 tokens\n    self._burn(_addr, amount)\n    return True\n\n\n###################\n# Ripe Hq Changes #\n###################\n\n\n@view\n@external\ndef hasPendingHqChange() -> bool:\n    return self.pendingHq.confirmBlock != 0\n\n\n# initiate hq change\n\n\n@external\ndef initiateHqChange(_newHq: address):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    # validate new hq\n    prevHq: address = self.ripeHq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid new hq\n\n    confirmBlock: uint256 = block.number + self.hqChangeTimeLock\n    self.pendingHq = PendingHq(\n        newHq= _newHq,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqChangeInitiated(prevHq=prevHq, newHq=_newHq, confirmBlock=confirmBlock)\n\n\n# confirm hq change\n\n\n@external\ndef confirmHqChange() -> bool:\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # validate new hq one more time\n    prevHq: address = self.ripeHq\n    if not self._isValidNewRipeHq(data.newHq, prevHq):\n        self.pendingHq = empty(PendingHq)\n        return False\n\n    # set new ripe hq\n    self.ripeHq = data.newHq\n    self.pendingHq = empty(PendingHq)\n    log HqChangeConfirmed(prevHq=prevHq, newHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n    return True\n\n\n# cancel hq change\n\n\n@external\ndef cancelHqChange():\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n\n    data: PendingHq = self.pendingHq\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingHq = empty(PendingHq)\n    log HqChangeCancelled(cancelledHq=data.newHq, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewRipeHq(_newHq: address) -> bool:\n    return self._isValidNewRipeHq(_newHq, self.ripeHq)\n\n\n@view\n@internal\ndef _isValidNewRipeHq(_newHq: address, _prevHq: address) -> bool:\n\n    # same hq, or invalid new hq\n    if _newHq == _prevHq or _newHq == empty(address) or not _newHq.is_contract:\n        return False\n\n    # if current hq has pending gov change, cannot change ripe hq now\n    if _prevHq != empty(address) and staticcall RipeHq(_prevHq).hasPendingGovChange():\n        return False\n\n    # if new hq has pending gov change, or is not set, cannot change ripe hq now\n    if staticcall RipeHq(_newHq).hasPendingGovChange() or staticcall RipeHq(_newHq).governance() == empty(address):\n        return False\n\n    # tokens must be set\n    if staticcall RipeHq(_newHq).greenToken() == empty(address) or staticcall RipeHq(_newHq).ripeToken() == empty(address):\n        return False\n\n    # make sure it has the necessary interfaces\n    assert not staticcall RipeHq(_newHq).canSetTokenBlacklist(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintGreen(empty(address)) # dev: invalid interface\n    assert not staticcall RipeHq(_newHq).canMintRipe(empty(address)) # dev: invalid interface\n\n    return True\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    ripeHq: address = self.ripeHq\n    assert msg.sender == staticcall RipeHq(ripeHq).governance() # dev: no perms\n    assert not staticcall RipeHq(ripeHq).hasPendingGovChange() # dev: pending gov change\n    return self._setHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@internal\ndef _setHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidHqChangeTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.hqChangeTimeLock = _newTimeLock\n    log HqChangeTimeLockModified(prevTimeLock=_prevTimeLock, newTimeLock=_newTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidHqChangeTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidHqChangeTimeLock(_newTimeLock, self.hqChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidHqChangeTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_HQ_TIME_LOCK and _newTimeLock <= MAX_HQ_TIME_LOCK\n\n\n# views\n\n\n@view\n@external\ndef minHqTimeLock() -> uint256:\n    return MIN_HQ_TIME_LOCK\n\n\n@view\n@external\ndef maxHqTimeLock() -> uint256:\n    return MAX_HQ_TIME_LOCK\n\n\n#########\n# Pause #\n#########\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert msg.sender == staticcall RipeHq(self.ripeHq).governance() # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log TokenPauseModified(isPaused=_shouldPause)\n\n\n###############\n# Token Setup #\n###############\n\n\n@external\ndef finishTokenSetup(_newHq: address, _timeLock: uint256 = 0) -> bool:\n    assert msg.sender == self.tempGov # dev: no perms\n\n    prevHq: address = self.ripeHq\n    assert prevHq == empty(address) # dev: already set\n\n    # set hq\n    assert self._isValidNewRipeHq(_newHq, prevHq) # dev: invalid ripe hq\n    self.ripeHq = _newHq\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_HQ_TIME_LOCK\n    prevTimeLock: uint256 = self.hqChangeTimeLock\n    if timeLock != prevTimeLock:\n        assert self._setHqChangeTimeLock(timeLock, prevTimeLock) # dev: invalid time lock\n\n    self.tempGov = empty(address)\n    log InitialRipeHqSet(hq=_newHq, timeLock=timeLock)\n    return True\n",
            "sha256sum": "66c2e657d9faa162b27fbb89751938175d9271c75685964781cfe37863b7806a"
          },
          "contracts/tokens/modules/Erc4626Token.vy": {
            "content": "# @version 0.4.1\n\nimplements: IERC4626\nfrom ethereum.ercs import IERC4626\n\nuses: token\nfrom contracts.tokens.modules import Erc20Token as token\nfrom ethereum.ercs import IERC20\n\nevent Deposit:\n    sender: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nevent Withdraw:\n    sender: indexed(address)\n    receiver: indexed(address)\n    owner: indexed(address)\n    assets: uint256\n    shares: uint256\n\nlastPricePerShare: public(uint256)\n\nASSET: immutable(address)\n\n\n@deploy\ndef __init__(_asset: address):\n    assert _asset != empty(address) # dev: invalid asset\n    ASSET = _asset\n\n\n@view\n@external\ndef asset() -> address:\n    return ASSET\n\n\n@view\n@external\ndef totalAssets() -> uint256:\n    return staticcall IERC20(ASSET).balanceOf(self)\n\n\n############\n# Deposits #\n############\n\n\n@view\n@external\ndef maxDeposit(_receiver: address) -> uint256:\n    return max_value(uint256)\n\n\n@view\n@external\ndef previewDeposit(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)\n\n\n@nonreentrant\n@external\ndef deposit(_assets: uint256, _receiver: address = msg.sender) -> uint256:\n    asset: address = ASSET\n\n    amount: uint256 = _assets\n    if amount == max_value(uint256):\n        amount = staticcall IERC20(asset).balanceOf(msg.sender)\n\n    shares: uint256 = self._amountToShares(amount, token.totalSupply, staticcall IERC20(asset).balanceOf(self), False)\n    self._deposit(asset, amount, shares, _receiver)\n    return shares\n\n\n# mint\n\n\n@view\n@external\ndef maxMint(_receiver: address) -> uint256:\n    return max_value(uint256)\n\n\n@view\n@external\ndef previewMint(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), True)\n\n\n@nonreentrant\n@external\ndef mint(_shares: uint256, _receiver: address = msg.sender) -> uint256:\n    asset: address = ASSET\n    amount: uint256 = self._sharesToAmount(_shares, token.totalSupply, staticcall IERC20(asset).balanceOf(self), True)\n    self._deposit(asset, amount, _shares, _receiver)\n    return amount\n\n\n# shared deposit logic\n\n\n@internal\ndef _deposit(_asset: address, _amount: uint256, _shares: uint256, _recipient: address):\n    assert _amount != 0 # dev: cannot deposit 0 amount\n    assert _shares != 0 # dev: cannot receive 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    assert extcall IERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True) # dev: deposit failed\n    token._mint(_recipient, _shares)\n\n    # update last price per share\n    self._updateLastPricePerShare(_asset)\n\n    log Deposit(sender=msg.sender, owner=_recipient, assets=_amount, shares=_shares)\n\n\n###############\n# Withdrawals #\n###############\n\n\n@view\n@external\ndef maxWithdraw(_owner: address) -> uint256:\n    return staticcall IERC20(ASSET).balanceOf(self)\n\n\n@view\n@external\ndef previewWithdraw(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), True)\n\n\n@external\ndef withdraw(_assets: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    asset: address = ASSET\n    shares: uint256 = self._amountToShares(_assets, token.totalSupply, staticcall IERC20(asset).balanceOf(self), True)\n    self._redeem(asset, _assets, shares, msg.sender, _receiver, _owner)\n    return shares\n\n\n# redeem\n\n\n@view\n@external\ndef maxRedeem(_owner: address) -> uint256:\n    return token.balanceOf[_owner]\n\n\n@view\n@external\ndef previewRedeem(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)\n\n\n@external\ndef redeem(_shares: uint256, _receiver: address = msg.sender, _owner: address = msg.sender) -> uint256:\n    asset: address = ASSET\n\n    shares: uint256 = _shares\n    if shares == max_value(uint256):\n        shares = token.balanceOf[_owner]\n\n    amount: uint256 = self._sharesToAmount(shares, token.totalSupply, staticcall IERC20(asset).balanceOf(self), False)\n    return self._redeem(asset, amount, shares, msg.sender, _receiver, _owner)\n\n\n# shared redeem logic\n\n\n@internal\ndef _redeem(\n    _asset: address,\n    _amount: uint256,\n    _shares: uint256, \n    _sender: address, \n    _recipient: address, \n    _owner: address,\n) -> uint256:\n    assert _amount != 0 # dev: cannot withdraw 0 amount\n    assert _shares != 0 # dev: cannot redeem 0 shares\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    assert token.balanceOf[_owner] >= _shares # dev: insufficient shares\n\n    if _sender != _owner:\n        token._spendAllowance(_owner, _sender, _shares)\n\n    token._burn(_owner, _shares)\n    assert extcall IERC20(_asset).transfer(_recipient, _amount, default_return_value=True) # dev: withdrawal failed\n\n    # update last price per share\n    self._updateLastPricePerShare(_asset)\n\n    log Withdraw(sender=_sender, receiver=_recipient, owner=_owner, assets=_amount, shares=_shares)\n    return _amount\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@external\ndef convertToShares(_assets: uint256) -> uint256:\n    return self._amountToShares(_assets, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)\n\n\n@view\n@external\ndef convertToAssets(_shares: uint256) -> uint256:\n    return self._sharesToAmount(_shares, token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)\n\n\n# amount -> shares\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _amount == max_value(uint256) or _amount == 0:\n        return _amount\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _amount\n\n    # no underlying balance, price per share = 0\n    if _totalBalance == 0:\n        return 0\n\n    # calc shares\n    numerator: uint256 = _amount * _totalShares\n    shares: uint256 = numerator // _totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    if _shares == max_value(uint256) or _shares == 0:\n        return _shares\n\n    # first deposit, price per share = 1\n    if _totalShares == 0:\n        return _shares\n\n    # calc amount\n    numerator: uint256 = _shares * _totalBalance\n    amount: uint256 = numerator // _totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % _totalShares != 0):\n        amount += 1\n\n    return amount\n\n\n# price per share\n\n\n@internal\ndef _updateLastPricePerShare(_asset: address):\n    newLastPricePerShare: uint256 = self._sharesToAmount(10 ** convert(token.TOKEN_DECIMALS, uint256), token.totalSupply, staticcall IERC20(_asset).balanceOf(self), False)\n    self.lastPricePerShare = newLastPricePerShare\n\n\n@view\n@external\ndef getLastUnderlying(_shares: uint256) -> uint256:\n    return self.lastPricePerShare * _shares // (10 ** convert(token.TOKEN_DECIMALS, uint256))\n\n\n@view\n@external\ndef pricePerShare() -> uint256:\n    return self._sharesToAmount(10 ** convert(token.TOKEN_DECIMALS, uint256), token.totalSupply, staticcall IERC20(ASSET).balanceOf(self), False)",
            "sha256sum": "1e966f3816dbb8658389a592dbb9d63648521d960a66ae4c6691c42c0d6ed922"
          },
          "contracts/tokens/SavingsGreen.vy": {
            "content": "# @version 0.4.1\n\nexports: token.__interface__\nexports: erc4626.__interface__\n\ninitializes: token\ninitializes: erc4626[token := token]\n\nfrom contracts.tokens.modules import Erc20Token as token\nimport contracts.tokens.modules.Erc4626Token as erc4626\n\nfrom ethereum.ercs import IERC20Detailed\n\n\n@deploy\ndef __init__(\n    _asset: address,\n    _ripeHq: address,\n    _initialGov: address,\n    _minHqTimeLock: uint256,\n    _maxHqTimeLock: uint256,\n    _initialSupply: uint256,\n    _initialSupplyRecipient: address,\n):\n    token.__init__(\"Savings Green USD\", \"sGREEN\", staticcall IERC20Detailed(_asset).decimals(), _ripeHq, _initialGov, _minHqTimeLock, _maxHqTimeLock, _initialSupply, _initialSupplyRecipient)\n    erc4626.__init__(_asset)\n",
            "sha256sum": "9eefef3f84e6a2de2ec6b7f17d77df8f78607ff12d99d5b751735556af352f53"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/tokens/SavingsGreen.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "c58d9a7eb3402ad0d726145e21aa0ca95e3ae58ab88f7a1260137f68bface2ee"
      },
      "args": "0000000000000000000000002e3ee9d4f379a820665c0e560459b19fa15e7c350000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "file": "contracts/tokens/SavingsGreen.vy"
    },
    "RipeHq": {
      "address": "0x2a85046e01A0b3e32370dc840cDF950EfE954A03",
      "abi": [
        {
          "name": "HqConfigChangeInitiated",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canMintRipe",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqConfigChangeConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canMintRipe",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HqConfigChangeCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "canMintGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canMintRipe",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canSetTokenBlacklist",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MintingEnabled",
          "inputs": [
            {
              "name": "isEnabled",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_canMintGreen",
              "type": "bool"
            },
            {
              "name": "_canMintRipe",
              "type": "bool"
            },
            {
              "name": "_canSetTokenBlacklist",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelHqConfigChange",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "isValidHqConfig",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_canMintGreen",
              "type": "bool"
            },
            {
              "name": "_canMintRipe",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "greenToken",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "savingsGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeToken",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canSetTokenBlacklist",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMintingEnabled",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hqConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "canMintGreen",
                  "type": "bool"
                },
                {
                  "name": "canMintRipe",
                  "type": "bool"
                },
                {
                  "name": "canSetTokenBlacklist",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHqConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newHqConfig",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "description",
                      "type": "string"
                    },
                    {
                      "name": "canMintGreen",
                      "type": "bool"
                    },
                    {
                      "name": "canMintRipe",
                      "type": "bool"
                    },
                    {
                      "name": "canSetTokenBlacklist",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "mintEnabled",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_greenToken",
              "type": "address"
            },
            {
              "name": "_savingsGreen",
              "type": "address"
            },
            {
              "name": "_ripeToken",
              "type": "address"
            },
            {
              "name": "_initialGov",
              "type": "address"
            },
            {
              "name": "_minGovTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxGovTimeLock",
              "type": "uint256"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/registries/modules/AddressRegistry.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "45a6786be62ebfcd266d4b9f321aa22bfc8d125d6ce75ffcf4d895ad011ff661"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/registries/RipeHq.vy": {
            "content": "# @version 0.4.1\n\nexports: gov.__interface__\nexports: registry.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.registries.modules.AddressRegistry as registry\n\nfrom interfaces import Department\nfrom ethereum.ercs import IERC20\n\nstruct HqConfig:\n    description: String[64]\n    canMintGreen: bool\n    canMintRipe: bool\n    canSetTokenBlacklist: bool\n\nstruct PendingHqConfig:\n    newHqConfig: HqConfig\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqConfigChangeInitiated:\n    regId: uint256\n    description: String[64]\n    canMintGreen: bool\n    canMintRipe: bool\n    canSetTokenBlacklist: bool\n    confirmBlock: uint256\n\nevent HqConfigChangeConfirmed:\n    regId: uint256\n    description: String[64]\n    canMintGreen: bool\n    canMintRipe: bool\n    canSetTokenBlacklist: bool\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent HqConfigChangeCancelled:\n    regId: uint256\n    description: String[64]\n    canMintGreen: bool\n    canMintRipe: bool\n    canSetTokenBlacklist: bool\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent RipeHqFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\nevent MintingEnabled:\n    isEnabled: bool\n\n# hq config\nhqConfig: public(HashMap[uint256, HqConfig]) # reg id -> hq config\npendingHqConfig: public(HashMap[uint256, PendingHqConfig]) # reg id -> pending hq config\n\n# minting circuit breaker\nmintEnabled: public(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(\n    _greenToken: address,\n    _savingsGreen: address,\n    _ripeToken: address,\n    _initialGov: address,\n    _minGovTimeLock: uint256,\n    _maxGovTimeLock: uint256,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(empty(address), _initialGov, _minGovTimeLock, _maxGovTimeLock, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"RipeHq.vy\")\n\n    # green token\n    assert registry._startAddNewAddressToRegistry(_greenToken, \"Green Token\") # dev: failed to register green token\n    assert registry._confirmNewAddressToRegistry(_greenToken) == 1 # dev: failed to confirm green token\n\n    # savings green\n    assert registry._startAddNewAddressToRegistry(_savingsGreen, \"Savings Green\") # dev: failed to register savings green\n    assert registry._confirmNewAddressToRegistry(_savingsGreen) == 2 # dev: failed to confirm savings green\n\n    # ripe token\n    assert registry._startAddNewAddressToRegistry(_ripeToken, \"Ripe Token\") # dev: failed to register ripe token\n    assert registry._confirmNewAddressToRegistry(_ripeToken) == 3 # dev: failed to confirm ripe token\n\n    # enable minting by default\n    self.mintEnabled = True\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert not self._isTokenId(_regId) # dev: cannot disable token\n\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n#############\n# Hq Config #\n#############\n\n\n@view\n@external\ndef hasPendingHqConfigChange(_regId: uint256) -> bool:\n    return self.pendingHqConfig[_regId].confirmBlock != 0\n\n\n# start hq config change\n\n\n@external\ndef initiateHqConfigChange(\n    _regId: uint256,\n    _canMintGreen: bool,\n    _canMintRipe: bool,\n    _canSetTokenBlacklist: bool,\n):\n    assert msg.sender == gov.governance # dev: no perms\n\n    assert self._isValidHqConfig(_regId, _canMintGreen, _canMintRipe) # dev: invalid hq config\n    hqConfig: HqConfig = HqConfig(\n        description= registry._getAddrDescription(_regId),\n        canMintGreen= _canMintGreen,\n        canMintRipe= _canMintRipe,\n        canSetTokenBlacklist= _canSetTokenBlacklist,\n    )\n\n    # set pending hq config\n    confirmBlock: uint256 = block.number + registry.registryChangeTimeLock\n    self.pendingHqConfig[_regId] = PendingHqConfig(\n        newHqConfig= hqConfig,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log HqConfigChangeInitiated(\n        regId=_regId,\n        description=hqConfig.description,\n        canMintGreen=_canMintGreen,\n        canMintRipe=_canMintRipe,\n        canSetTokenBlacklist=_canSetTokenBlacklist,\n        confirmBlock=confirmBlock,\n    )\n\n\n# confirm hq config change\n\n\n@external\ndef confirmHqConfigChange(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n\n    data: PendingHqConfig = self.pendingHqConfig[_regId]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # invalid hq config\n    newConfig: HqConfig = data.newHqConfig\n    if not self._isValidHqConfig(_regId, newConfig.canMintGreen, newConfig.canMintRipe):\n        self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n        return False\n\n    # set hq config\n    self.hqConfig[_regId] = newConfig\n    self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n\n    log HqConfigChangeConfirmed(\n        regId=_regId,\n        description=newConfig.description,\n        canMintGreen=newConfig.canMintGreen,\n        canMintRipe=newConfig.canMintRipe,\n        canSetTokenBlacklist=newConfig.canSetTokenBlacklist,\n        initiatedBlock=data.initiatedBlock,\n        confirmBlock=data.confirmBlock,\n    )\n    return True\n\n\n# cancel hq config change\n\n\n@external\ndef cancelHqConfigChange(_regId: uint256) -> bool:\n    assert msg.sender == gov.governance # dev: no perms\n\n    data: PendingHqConfig = self.pendingHqConfig[_regId]\n    assert data.confirmBlock != 0 # dev: no pending change\n\n    self.pendingHqConfig[_regId] = empty(PendingHqConfig)\n    log HqConfigChangeCancelled(\n        regId=_regId,\n        description=data.newHqConfig.description,\n        canMintGreen=data.newHqConfig.canMintGreen,\n        canMintRipe=data.newHqConfig.canMintRipe,\n        canSetTokenBlacklist=data.newHqConfig.canSetTokenBlacklist,\n        initiatedBlock=data.initiatedBlock,\n        confirmBlock=data.confirmBlock\n    )\n    return True\n\n\n# validation\n\n\n@external\ndef isValidHqConfig(\n    _regId: uint256,\n    _canMintGreen: bool,\n    _canMintRipe: bool,\n) -> bool:\n    return self._isValidHqConfig(_regId, _canMintGreen, _canMintRipe)\n\n\n@internal\ndef _isValidHqConfig(\n    _regId: uint256,\n    _canMintGreen: bool,\n    _canMintRipe: bool,\n) -> bool:\n\n    # tokens cannot mint, cannot set their own blacklist, cannot modify mission control\n    if self._isTokenId(_regId):\n        return False\n\n    # invalid reg id\n    if not registry._isValidRegId(_regId):\n        return False\n\n    # no addr\n    addr: address = registry._getAddr(_regId)\n    if addr == empty(address):\n        return False\n\n    # two-factor auth on minting\n    if _canMintGreen and not staticcall Department(addr).canMintGreen():\n        return False\n\n    if _canMintRipe and not staticcall Department(addr).canMintRipe():\n        return False\n\n    return True\n\n\n@view\n@internal\ndef _isTokenId(_regId: uint256) -> bool:\n    return _regId in [1, 2, 3]\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@external\ndef greenToken() -> address:\n    return registry._getAddr(1)\n\n\n@view\n@external\ndef savingsGreen() -> address:\n    return registry._getAddr(2)\n\n\n@view\n@external\ndef ripeToken() -> address:\n    return registry._getAddr(3)\n\n\n@view\n@external\ndef canMintGreen(_addr: address) -> bool:\n    if not self.mintEnabled:\n        return False\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0 or not self.hqConfig[regId].canMintGreen:\n        return False\n    return staticcall Department(_addr).canMintGreen()\n\n\n@view\n@external\ndef canMintRipe(_addr: address) -> bool:\n    if not self.mintEnabled:\n        return False\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0 or not self.hqConfig[regId].canMintRipe:\n        return False\n    return staticcall Department(_addr).canMintRipe()\n\n\n@view\n@external\ndef canSetTokenBlacklist(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    regId: uint256 = registry._getRegId(_addr)\n    if regId == 0:\n        return False\n    return self.hqConfig[regId].canSetTokenBlacklist\n\n\n###########################\n# Minting Circuit Breaker #\n###########################\n\n\n@external\ndef setMintingEnabled(_shouldEnable: bool):\n    assert msg.sender == gov.governance # dev: no perms\n    assert self.mintEnabled != _shouldEnable # dev: already set\n\n    self.mintEnabled = _shouldEnable\n    log MintingEnabled(isEnabled=_shouldEnable)\n\n\n############\n# Recovery #\n############\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert msg.sender == gov.governance # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert msg.sender == gov.governance # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log RipeHqFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "ef55ed2a0ca3dd89d2843050ad93131c103aa18ca3015e286544925221855a70"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/RipeHq.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "acf2d42025b0f3ee3db3fdb5968bdb1fc39e86df2720770ac189ec8e23f119e6"
      },
      "args": "0000000000000000000000002e3ee9d4f379a820665c0e560459b19fa15e7c3500000000000000000000000011de3ed496c2fa22f49be6b4806d5603f6a54a0800000000000000000000000016e5c329f8b9cf99b5edc61da6a6eb8700c83db7000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d4000000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/registries/RipeHq.vy"
    },
    "GreenPool": {
      "address": "0x7531235a39BBc87945646594E92a16651c6c13F0"
    },
    "RipePool": {
      "address": "0x405fFC16Ab5E6C58c83d6110a43FF4E6Fc631a2D"
    },
    "Ledger": {
      "address": "0x2cd688aA24b4536552B66726AC1c4F97a116a88a",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "checkAndUpdateLastTouch",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldCheck",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "checkAndUpdateLastTouch",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldCheck",
              "type": "bool"
            },
            {
              "name": "_mc",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isParticipatingInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserVaults",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addVaultToUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeVaultFromUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositLedgerData",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "isParticipatingInVault",
                  "type": "bool"
                },
                {
                  "name": "numUserVaults",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDebt",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_newYield",
              "type": "uint256"
            },
            {
              "name": "_interval",
              "type": "tuple",
              "components": [
                {
                  "name": "start",
                  "type": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "flushUnrealizedYield",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasDebt",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumBorrowers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBorrowDataBundle",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "userDebt",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "name": "principal",
                      "type": "uint256"
                    },
                    {
                      "name": "debtTerms",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "ltv",
                          "type": "uint256"
                        },
                        {
                          "name": "redemptionThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqFee",
                          "type": "uint256"
                        },
                        {
                          "name": "borrowRate",
                          "type": "uint256"
                        },
                        {
                          "name": "daowry",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "lastTimestamp",
                      "type": "uint256"
                    },
                    {
                      "name": "inLiquidation",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "userBorrowInterval",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "start",
                      "type": "uint256"
                    },
                    {
                      "name": "amount",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "isUserBorrower",
                  "type": "bool"
                },
                {
                  "name": "numUserVaults",
                  "type": "uint256"
                },
                {
                  "name": "totalDebt",
                  "type": "uint256"
                },
                {
                  "name": "numBorrowers",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRepayDataBundle",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "userDebt",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "amount",
                      "type": "uint256"
                    },
                    {
                      "name": "principal",
                      "type": "uint256"
                    },
                    {
                      "name": "debtTerms",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "ltv",
                          "type": "uint256"
                        },
                        {
                          "name": "redemptionThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqFee",
                          "type": "uint256"
                        },
                        {
                          "name": "borrowRate",
                          "type": "uint256"
                        },
                        {
                          "name": "daowry",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "lastTimestamp",
                      "type": "uint256"
                    },
                    {
                      "name": "inLiquidation",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "numUserVaults",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isBorrower",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInLiquidation",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewards",
          "inputs": [
            {
              "name": "_ripeRewards",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeAvailForRewards",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "didGetRewardsFromStabClaims",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDepositPointsAndRipeRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_userPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_assetPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                },
                {
                  "name": "precision",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_globalPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_ripeRewards",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBorrowPointsAndRipeRewards",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_userPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "lastPrincipal",
                  "type": "uint256"
                },
                {
                  "name": "points",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_globalPoints",
              "type": "tuple",
              "components": [
                {
                  "name": "lastPrincipal",
                  "type": "uint256"
                },
                {
                  "name": "points",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_ripeRewards",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeRewardsBundle",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ripeRewards",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "borrowers",
                      "type": "uint256"
                    },
                    {
                      "name": "stakers",
                      "type": "uint256"
                    },
                    {
                      "name": "voters",
                      "type": "uint256"
                    },
                    {
                      "name": "genDepositors",
                      "type": "uint256"
                    },
                    {
                      "name": "newRipeRewards",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "ripeAvailForRewards",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBorrowPointsBundle",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "userPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "lastPrincipal",
                      "type": "uint256"
                    },
                    {
                      "name": "points",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "globalPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "lastPrincipal",
                      "type": "uint256"
                    },
                    {
                      "name": "points",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "userDebtPrincipal",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositPointsBundle",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "userPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "balancePoints",
                      "type": "uint256"
                    },
                    {
                      "name": "lastBalance",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "assetPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "balancePoints",
                      "type": "uint256"
                    },
                    {
                      "name": "lastBalance",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUsdValue",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeStakerPoints",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeVotePoints",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeGenPoints",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    },
                    {
                      "name": "precision",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "globalPoints",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "lastUsdValue",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeStakerPoints",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeVotePoints",
                      "type": "uint256"
                    },
                    {
                      "name": "ripeGenPoints",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasFungibleAuctions",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "createNewFungibleAuction",
          "inputs": [
            {
              "name": "_auc",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_auc",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeAllFungibleAuctions",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getFungibleAuctionDuringPurchase",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isHrContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addHrContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            },
            {
              "name": "_compensation",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeAvailForHr",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEpochData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeBondData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "paymentAmountAvailInEpoch",
                  "type": "uint256"
                },
                {
                  "name": "ripeAvailForBonds",
                  "type": "uint256"
                },
                {
                  "name": "badDebt",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeAvailForBonds",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBadDebt",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "didClearBadDebt",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_ripeAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "didPurchaseRipeBond",
          "inputs": [
            {
              "name": "_amountPaid",
              "type": "uint256"
            },
            {
              "name": "_ripePayout",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setEpochData",
          "inputs": [
            {
              "name": "_epochStart",
              "type": "uint256"
            },
            {
              "name": "_epochEnd",
              "type": "uint256"
            },
            {
              "name": "_amountAvailInEpoch",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateGreenPoolDebt",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_isIncrement",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastTouch",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfVault",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userDebt",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalDebt",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "borrowers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfBorrower",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numBorrowers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "borrowIntervals",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "start",
                  "type": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "unrealizedYield",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeAvailForRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalDepositPoints",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetDepositPoints",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                },
                {
                  "name": "precision",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userDepositPoints",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            },
            {
              "name": "arg2",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBorrowPoints",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastPrincipal",
                  "type": "uint256"
                },
                {
                  "name": "points",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalBorrowPoints",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastPrincipal",
                  "type": "uint256"
                },
                {
                  "name": "points",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fungibleAuctions",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "startBlock",
                  "type": "uint256"
                },
                {
                  "name": "endBlock",
                  "type": "uint256"
                },
                {
                  "name": "isActive",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fungibleAuctionIndex",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            },
            {
              "name": "arg2",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numFungibleAuctions",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "fungLiqUsers",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfFungLiqUser",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numFungLiqUsers",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeAvailForHr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "contributors",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfContributor",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numContributors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "epochStart",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "epochEnd",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "badDebt",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripePaidOutForBadDebt",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "paymentAmountAvailInEpoch",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeAvailForBonds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "greenPoolDebt",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_defaults",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "interfaces/Defaults.vyi": {
            "content": "# @version 0.4.1\n\nimport interfaces.ConfigStructs as cs\n\n\n# general config\n\n\n@view\n@external\ndef genConfig() -> cs.GenConfig:\n    ...\n\n\n# debt config\n\n\n@view\n@external\ndef genDebtConfig() -> cs.GenDebtConfig:\n    ...\n\n\n# hr config\n\n\n@view\n@external\ndef hrConfig() -> cs.HrConfig:\n    ...\n\n\n# ripe bond config\n\n\n@view\n@external\ndef ripeBondConfig() -> cs.RipeBondConfig:\n    ...\n\n\n# ripe rewards config\n\n\n@view\n@external\ndef rewardsConfig() -> cs.RipeRewardsConfig:\n    ...\n\n\n# ripe gov vault config\n\n\n@view\n@external\ndef ripeGovVaultConfig() -> cs.RipeGovVaultConfig:\n    ...\n\n\n# stab claim rewards config\n\n\n@view\n@external\ndef stabClaimRewardsConfig() -> cs.StabClaimRewardsConfig:\n    ...\n\n\n# underscore registry\n\n\n@view\n@external\ndef underscoreRegistry() -> address:\n    ...\n\n\n# shouldCheckLastTouchy\n\n\n@view\n@external\ndef shouldCheckLastTouch() -> bool:\n    ...\n\n\n# ripe available\n\n\n@view\n@external\ndef ripeAvailForRewards() -> uint256:\n    ...\n\n\n@view\n@external\ndef ripeAvailForHr() -> uint256:\n    ...\n\n\n@view\n@external\ndef ripeAvailForBonds() -> uint256:\n    ...",
            "sha256sum": "a03f6ebff9f709dee36d402f5b3adcd3953290787efb1d2c2a7d1d6a1cff67c6"
          },
          "contracts/data/Ledger.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\nimport interfaces.ConfigStructs as cs\nfrom interfaces import Defaults\n\nstruct DepositLedgerData:\n    isParticipatingInVault: bool\n    numUserVaults: uint256\n\nstruct RipeRewards:\n    borrowers: uint256\n    stakers: uint256\n    voters: uint256\n    genDepositors: uint256\n    newRipeRewards: uint256\n    lastUpdate: uint256\n\nstruct GlobalDepositPoints:\n    lastUsdValue: uint256\n    ripeStakerPoints: uint256\n    ripeVotePoints: uint256\n    ripeGenPoints: uint256\n    lastUpdate: uint256\n\nstruct AssetDepositPoints:\n    balancePoints: uint256\n    lastBalance: uint256\n    lastUsdValue: uint256\n    ripeStakerPoints: uint256\n    ripeVotePoints: uint256\n    ripeGenPoints: uint256\n    lastUpdate: uint256\n    precision: uint256\n\nstruct UserDepositPoints:\n    balancePoints: uint256\n    lastBalance: uint256\n    lastUpdate: uint256\n\nstruct BorrowPoints:\n    lastPrincipal: uint256\n    points: uint256\n    lastUpdate: uint256\n\nstruct BorrowPointsBundle:\n    userPoints: BorrowPoints\n    globalPoints: BorrowPoints\n    userDebtPrincipal: uint256\n\nstruct DepositPointsBundle:\n    userPoints: UserDepositPoints\n    assetPoints: AssetDepositPoints\n    globalPoints: GlobalDepositPoints\n\nstruct RipeRewardsBundle:\n    ripeRewards: RipeRewards\n    ripeAvailForRewards: uint256\n\nstruct BorrowDataBundle:\n    userDebt: UserDebt\n    userBorrowInterval: IntervalBorrow\n    isUserBorrower: bool\n    numUserVaults: uint256\n    totalDebt: uint256\n    numBorrowers: uint256\n\nstruct RepayDataBundle:\n    userDebt: UserDebt\n    numUserVaults: uint256\n\nstruct UserDebt:\n    amount: uint256\n    principal: uint256\n    debtTerms: cs.DebtTerms\n    lastTimestamp: uint256\n    inLiquidation: bool\n\nstruct IntervalBorrow:\n    start: uint256\n    amount: uint256\n\nstruct FungibleAuction:\n    liqUser: address\n    vaultId: uint256\n    asset: address \n    startDiscount: uint256\n    maxDiscount: uint256\n    startBlock: uint256\n    endBlock: uint256\n    isActive: bool\n\nstruct RipeBondData:\n    paymentAmountAvailInEpoch: uint256\n    ripeAvailForBonds: uint256\n    badDebt: uint256\n\nlastTouch: public(HashMap[address, uint256])  # user -> block number\n\n# user vault participation\nuserVaults: public(HashMap[address, HashMap[uint256, uint256]]) # user -> index -> vault id\nindexOfVault: public(HashMap[address, HashMap[uint256, uint256]]) # user -> vault id -> index\nnumUserVaults: public(HashMap[address, uint256]) # user -> num vaults\n\n# borrow data\nuserDebt: public(HashMap[address, UserDebt]) # user -> user debt\ntotalDebt: public(uint256) # total debt\nborrowers: public(HashMap[uint256, address]) # index -> borrower\nindexOfBorrower: public(HashMap[address, uint256]) # borrower -> index\nnumBorrowers: public(uint256) # num borrowers\nborrowIntervals: public(HashMap[address, IntervalBorrow]) # user -> borrow interval\nunrealizedYield: public(uint256) # unrealized yield\n\n# ripe rewards\nripeRewards: public(RipeRewards)\nripeAvailForRewards: public(uint256)\n\n# points\nglobalDepositPoints: public(GlobalDepositPoints)\nassetDepositPoints: public(HashMap[uint256, HashMap[address, AssetDepositPoints]]) # vault id -> asset -> points\nuserDepositPoints: public(HashMap[address, HashMap[uint256, HashMap[address, UserDepositPoints]]]) # user -> vault id -> asset -> points\nuserBorrowPoints:  public(HashMap[address, BorrowPoints]) # user -> BorrowPoints\nglobalBorrowPoints: public(BorrowPoints)\n\n# auctions\nfungibleAuctions: public(HashMap[address, HashMap[uint256, FungibleAuction]]) # liq user -> auction index -> FungibleAuction\nfungibleAuctionIndex: public(HashMap[address, HashMap[uint256, HashMap[address, uint256]]]) # liq user -> vault id -> asset -> auction index\nnumFungibleAuctions: public(HashMap[address, uint256]) # liq user -> num fungible auctions\n\nfungLiqUsers: public(HashMap[uint256, address]) # index -> liq user\nindexOfFungLiqUser: public(HashMap[address, uint256]) # liq user -> index\nnumFungLiqUsers: public(uint256) # num liq users\n\n# hr contributors\nripeAvailForHr: public(uint256)\ncontributors: public(HashMap[uint256, address]) # index -> contributor addr\nindexOfContributor: public(HashMap[address, uint256]) # contributor -> index\nnumContributors: public(uint256) # num contributors\n\n# bond data\nepochStart: public(uint256)\nepochEnd: public(uint256)\nbadDebt: public(uint256)\nripePaidOutForBadDebt: public(uint256)\npaymentAmountAvailInEpoch: public(uint256)\nripeAvailForBonds: public(uint256)\n\n# endaoment\ngreenPoolDebt: public(HashMap[address, uint256]) # pool -> debt\n\n\n@deploy\ndef __init__(_ripeHq: address, _defaults: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n    if _defaults != empty(address):\n        self.ripeAvailForRewards = staticcall Defaults(_defaults).ripeAvailForRewards()\n        self.ripeAvailForHr = staticcall Defaults(_defaults).ripeAvailForHr()\n        self.ripeAvailForBonds = staticcall Defaults(_defaults).ripeAvailForBonds()\n\n\n# one action per block\n\n\n@external\ndef checkAndUpdateLastTouch(_user: address, _shouldCheck: bool, _mc: address = empty(address)):\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    # check if user already interacted in this block\n    if _shouldCheck:\n        assert self.lastTouch[_user] != block.number # dev: one action per block\n\n    # update last touch\n    self.lastTouch[_user] = block.number\n\n\n###############\n# User Vaults #\n###############\n\n\n@view\n@external\ndef isParticipatingInVault(_user: address, _vaultId: uint256) -> bool:\n    return self.indexOfVault[_user][_vaultId] != 0\n\n\n@view\n@external\ndef getNumUserVaults(_user: address) -> uint256:\n    return self._getNumUserVaults(_user)\n\n\n@view\n@internal\ndef _getNumUserVaults(_user: address) -> uint256:\n    numVaults: uint256 = self.numUserVaults[_user]\n    if numVaults == 0:\n        return 0\n    return numVaults - 1\n\n\n@external\ndef addVaultToUser(_user: address, _vaultId: uint256):\n    assert msg.sender in [\n        addys._getTellerAddr(),\n        addys._getCreditEngineAddr(),\n        addys._getAuctionHouseAddr(),\n        addys._getHumanResourcesAddr(),\n    ] # dev: not allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    # already participating - fail gracefully\n    if self.indexOfVault[_user][_vaultId] != 0:\n        return\n\n    # register vault\n    vid: uint256 = self.numUserVaults[_user]\n    if vid == 0:\n        vid = 1 # not using 0 index\n\n    self.userVaults[_user][vid] = _vaultId\n    self.indexOfVault[_user][_vaultId] = vid\n    self.numUserVaults[_user] = vid + 1\n\n\n@external\ndef removeVaultFromUser(_user: address, _vaultId: uint256):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    numUserVaults: uint256 = self.numUserVaults[_user]\n    if numUserVaults == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfVault[_user][_vaultId]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numUserVaults - 1\n    self.numUserVaults[_user] = lastIndex\n    self.indexOfVault[_user][_vaultId] = 0\n\n    # have last vault replace the target vault\n    if targetIndex != lastIndex:\n        lastVaultId: uint256 = self.userVaults[_user][lastIndex]\n        self.userVaults[_user][targetIndex] = lastVaultId\n        self.indexOfVault[_user][lastVaultId] = targetIndex\n\n\n# utils\n\n\n@view\n@external\ndef getDepositLedgerData(_user: address, _vaultId: uint256) -> DepositLedgerData:\n    return DepositLedgerData(\n        isParticipatingInVault=self.indexOfVault[_user][_vaultId] != 0,\n        numUserVaults=self._getNumUserVaults(_user),\n    )\n\n\n########\n# Debt #\n########\n\n\n@external\ndef setUserDebt(_user: address, _userDebt: UserDebt, _newYield: uint256, _interval: IntervalBorrow):\n    assert msg.sender == addys._getCreditEngineAddr() # dev: only CreditEngine allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    # reduce prev user debt\n    totalDebt: uint256 = self.totalDebt\n    prevUserDebt: UserDebt = self.userDebt[_user]\n    if prevUserDebt.amount != 0:\n        totalDebt -= prevUserDebt.amount\n\n    # save new user debt\n    self.userDebt[_user] = _userDebt\n    if _userDebt.amount != 0:\n        totalDebt += _userDebt.amount\n    self.totalDebt = totalDebt\n\n    # update intervals -- during repay, we pass in empty interval\n    if _interval.start != 0:\n        self.borrowIntervals[_user] = _interval\n\n    # update unrealized yield\n    if _newYield != 0:\n        self.unrealizedYield += _newYield\n\n    # update fung auctions (if they exist)\n    if prevUserDebt.inLiquidation and not _userDebt.inLiquidation:\n        self._removeAllFungibleAuctions(_user)\n\n    # remove borrower\n    if _userDebt.amount == 0:\n        self._removeBorrower(_user)\n\n    # add borrower (if necessary)\n    elif self.indexOfBorrower[_user] == 0:\n        self._addNewBorrower(_user)\n\n\n# realize yield\n\n\n@external\ndef flushUnrealizedYield() -> uint256:\n    assert msg.sender == addys._getCreditEngineAddr() # dev: only CreditEngine allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    unrealizedYield: uint256 = self.unrealizedYield\n    self.unrealizedYield = 0\n    return unrealizedYield\n\n\n# registration\n\n\n@internal\ndef _addNewBorrower(_user: address):\n    bid: uint256 = self.numBorrowers\n    if bid == 0:\n        bid = 1 # not using 0 index\n    self.borrowers[bid] = _user\n    self.indexOfBorrower[_user] = bid\n    self.numBorrowers = bid + 1\n\n\n@internal\ndef _removeBorrower(_user: address):\n    numBorrowers: uint256 = self.numBorrowers\n    if numBorrowers == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfBorrower[_user]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numBorrowers - 1\n    self.numBorrowers = lastIndex\n    self.indexOfBorrower[_user] = 0\n\n    # shift users to replace the removed one\n    if targetIndex != lastIndex:\n        lastUser: address = self.borrowers[lastIndex]\n        self.borrowers[targetIndex] = lastUser\n        self.indexOfBorrower[lastUser] = targetIndex\n\n\n# utils\n\n\n@view\n@external\ndef hasDebt(_user: address) -> bool:\n    return self.userDebt[_user].amount != 0\n\n\n@view\n@external\ndef getNumBorrowers() -> uint256:\n    return self._getNumBorrowers()\n\n\n@view\n@internal\ndef _getNumBorrowers() -> uint256:\n    numBorrowers: uint256 = self.numBorrowers\n    if numBorrowers == 0:\n        return 0\n    return numBorrowers - 1\n\n\n@view\n@external\ndef getBorrowDataBundle(_user: address) -> BorrowDataBundle:\n    return BorrowDataBundle(\n        userDebt=self.userDebt[_user],\n        userBorrowInterval=self.borrowIntervals[_user],\n        isUserBorrower=self.indexOfBorrower[_user] != 0,\n        numUserVaults=self.numUserVaults[_user],\n        totalDebt=self.totalDebt,\n        numBorrowers=self._getNumBorrowers(),\n    )\n\n\n@view\n@external\ndef getRepayDataBundle(_user: address) -> RepayDataBundle:\n    return RepayDataBundle(\n        userDebt=self.userDebt[_user],\n        numUserVaults=self.numUserVaults[_user],\n    )\n\n\n@view\n@external\ndef isBorrower(_user: address) -> bool:\n    return self.indexOfBorrower[_user] != 0\n\n\n@view\n@external\ndef isUserInLiquidation(_user: address) -> bool:\n    return self.userDebt[_user].inLiquidation\n\n\n####################\n# Rewards / Points #\n####################\n\n\n# ripe rewards\n\n\n@external\ndef setRipeRewards(_ripeRewards: RipeRewards):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n    self._setRipeRewards(_ripeRewards)\n\n\n@internal\ndef _setRipeRewards(_ripeRewards: RipeRewards):\n    self.ripeRewards = _ripeRewards\n    if _ripeRewards.newRipeRewards != 0:\n        self.ripeAvailForRewards -= min(self.ripeAvailForRewards, _ripeRewards.newRipeRewards)\n\n\n@external\ndef setRipeAvailForRewards(_amount: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.ripeAvailForRewards = _amount\n\n\n@external\ndef didGetRewardsFromStabClaims(_amount: uint256):\n    assert msg.sender == addys._getVaultBookAddr() # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.ripeAvailForRewards -= _amount\n\n\n# deposit points\n\n\n@external\ndef setDepositPointsAndRipeRewards(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _userPoints: UserDepositPoints,\n    _assetPoints: AssetDepositPoints,\n    _globalPoints: GlobalDepositPoints,\n    _ripeRewards: RipeRewards,\n):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    if _user != empty(address):\n        self.userDepositPoints[_user][_vaultId][_asset] = _userPoints\n    self.assetDepositPoints[_vaultId][_asset] = _assetPoints\n    self.globalDepositPoints = _globalPoints\n    self._setRipeRewards(_ripeRewards)\n\n\n# borrow points\n\n\n@external\ndef setBorrowPointsAndRipeRewards(\n    _user: address,\n    _userPoints: BorrowPoints,\n    _globalPoints: BorrowPoints,\n    _ripeRewards: RipeRewards,\n):\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    self.globalBorrowPoints = _globalPoints\n    if _user != empty(address):\n        self.userBorrowPoints[_user] = _userPoints\n    self._setRipeRewards(_ripeRewards)\n\n\n# utils\n\n\n@view\n@external\ndef getRipeRewardsBundle() -> RipeRewardsBundle:\n    return RipeRewardsBundle(\n        ripeRewards=self.ripeRewards,\n        ripeAvailForRewards=self.ripeAvailForRewards,\n    )\n\n\n@view\n@external\ndef getBorrowPointsBundle(_user: address) -> BorrowPointsBundle:\n    return BorrowPointsBundle(\n        userPoints=self.userBorrowPoints[_user],\n        globalPoints=self.globalBorrowPoints,\n        userDebtPrincipal=self.userDebt[_user].principal,\n    )\n\n\n@view\n@external\ndef getDepositPointsBundle(_user: address, _vaultId: uint256, _asset: address) -> DepositPointsBundle:\n    userPoints: UserDepositPoints = empty(UserDepositPoints)\n    if _user != empty(address):\n        userPoints = self.userDepositPoints[_user][_vaultId][_asset]\n    return DepositPointsBundle(\n        userPoints=userPoints,\n        assetPoints=self.assetDepositPoints[_vaultId][_asset],\n        globalPoints=self.globalDepositPoints,\n    )\n\n\n############\n# Auctions #\n############\n\n\n@view\n@external\ndef hasFungibleAuctions(_liqUser: address) -> bool:\n    return self.numFungibleAuctions[_liqUser] != 0\n\n\n# create new auction\n\n\n@external\ndef createNewFungibleAuction(_auc: FungibleAuction) -> uint256:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    # fail gracefully if auction already exists\n    if self.fungibleAuctionIndex[_auc.liqUser][_auc.vaultId][_auc.asset] != 0:\n        return 0\n\n    # create new auction\n    aid: uint256 = self.numFungibleAuctions[_auc.liqUser]\n    if aid == 0:\n        aid = 1\n    self.fungibleAuctions[_auc.liqUser][aid] = _auc\n    self.fungibleAuctionIndex[_auc.liqUser][_auc.vaultId][_auc.asset] = aid\n    self.numFungibleAuctions[_auc.liqUser] = aid + 1\n\n    # register fungible liq user (if applicable)\n    if self.indexOfFungLiqUser[_auc.liqUser] == 0:\n        self._registerFungibleLiqUser(_auc.liqUser)\n\n    return aid\n\n\n# register fungible liq user\n\n\n@internal\ndef _registerFungibleLiqUser(_liqUser: address):\n    uid: uint256 = self.numFungLiqUsers\n    if uid == 0:\n        uid = 1\n    self.fungLiqUsers[uid] = _liqUser\n    self.indexOfFungLiqUser[_liqUser] = uid\n    self.numFungLiqUsers = uid + 1\n\n\n# removal fungible auction\n\n\n@external\ndef removeFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address):\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    numAuctions: uint256 = self.numFungibleAuctions[_liqUser]\n    if numAuctions == 0:\n        return\n\n    targetIndex: uint256 = self.fungibleAuctionIndex[_liqUser][_vaultId][_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAuctions - 1\n    self.numFungibleAuctions[_liqUser] = lastIndex\n    self.fungibleAuctionIndex[_liqUser][_vaultId][_asset] = 0\n\n    # have last auction replace the target auction\n    if targetIndex != lastIndex:\n        lastItem: FungibleAuction = self.fungibleAuctions[_liqUser][lastIndex]\n        self.fungibleAuctions[_liqUser][targetIndex] = lastItem\n        self.fungibleAuctionIndex[_liqUser][lastItem.vaultId][lastItem.asset] = targetIndex\n\n    # no more fungible auctions\n    if lastIndex <= 1:\n        self.numFungibleAuctions[_liqUser] = 0\n        self._removeFungLiqUser(_liqUser)\n\n\n# update auction\n\n\n@external\ndef setFungibleAuction(\n    _liqUser: address,\n    _vaultId: uint256,\n    _asset: address,\n    _auc: FungibleAuction,\n) -> bool:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    aid: uint256 = self.fungibleAuctionIndex[_liqUser][_vaultId][_asset]\n    if aid == 0:\n        return False # this does not yet exist\n\n    self.fungibleAuctions[_liqUser][aid] = _auc\n    return True\n\n\n# remove liq user\n\n\n@internal\ndef _removeFungLiqUser(_liqUser: address):\n    numUsers: uint256 = self.numFungLiqUsers\n    if numUsers == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfFungLiqUser[_liqUser]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numUsers - 1\n    self.numFungLiqUsers = lastIndex\n    self.indexOfFungLiqUser[_liqUser] = 0\n\n    # have last liq user replace the target liq user\n    if targetIndex != lastIndex:\n        lastUser: address = self.fungLiqUsers[lastIndex]\n        self.fungLiqUsers[targetIndex] = lastUser\n        self.indexOfFungLiqUser[lastUser] = targetIndex\n\n\n# remove all fungible auctions\n\n\n@external\ndef removeAllFungibleAuctions(_liqUser: address):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: only AuctionHouse or CreditEngine allowed\n    assert not deptBasics.isPaused # dev: not activated\n    self._removeAllFungibleAuctions(_liqUser)\n\n\n@internal\ndef _removeAllFungibleAuctions(_liqUser: address):\n    self._removeFungLiqUser(_liqUser)\n\n    numAuctions: uint256 = self.numFungibleAuctions[_liqUser]\n    if numAuctions == 0:\n        return\n\n    # zero out the auction indexes\n    for i: uint256 in range(1, numAuctions, bound=max_value(uint256)):\n        auc: FungibleAuction = self.fungibleAuctions[_liqUser][i]\n        self.fungibleAuctionIndex[_liqUser][auc.vaultId][auc.asset] = 0\n\n    # zero out total num\n    self.numFungibleAuctions[_liqUser] = 0\n\n\n# utils\n\n\n@view\n@external\ndef getFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address) -> FungibleAuction:\n    aid: uint256 = self.fungibleAuctionIndex[_liqUser][_vaultId][_asset]\n    return self.fungibleAuctions[_liqUser][aid]\n\n\n@view\n@external\ndef getFungibleAuctionDuringPurchase(_liqUser: address, _vaultId: uint256, _asset: address) -> FungibleAuction:\n    if not self.userDebt[_liqUser].inLiquidation:\n        return empty(FungibleAuction)\n    aid: uint256 = self.fungibleAuctionIndex[_liqUser][_vaultId][_asset]\n    return self.fungibleAuctions[_liqUser][aid]\n\n\n@view\n@external\ndef hasFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address) -> bool:\n    return self.fungibleAuctionIndex[_liqUser][_vaultId][_asset] != 0\n\n\n###################\n# Human Resources #\n###################\n\n\n@view\n@external\ndef isHrContributor(_contributor: address) -> bool:\n    return self.indexOfContributor[_contributor] != 0\n\n\n@external\ndef addHrContributor(_contributor: address, _compensation: uint256):\n    assert msg.sender == addys._getHumanResourcesAddr() # dev: only hr allowed\n    assert not deptBasics.isPaused # dev: not activated\n\n    if self.indexOfContributor[_contributor] != 0:\n        return\n\n    uid: uint256 = self.numContributors\n    if uid == 0:\n        uid = 1\n    self.contributors[uid] = _contributor\n    self.indexOfContributor[_contributor] = uid\n    self.numContributors = uid + 1\n\n    # update ripe avail for hr\n    self.ripeAvailForHr -= _compensation\n\n\n@external\ndef setRipeAvailForHr(_amount: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) or msg.sender == addys._getHumanResourcesAddr() # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.ripeAvailForHr = _amount\n\n\n#########\n# Bonds #\n#########\n\n\n@view\n@external\ndef getEpochData() -> (uint256, uint256):\n    return self.epochStart, self.epochEnd\n\n\n@view\n@external\ndef getRipeBondData() -> RipeBondData:\n    return RipeBondData(\n        paymentAmountAvailInEpoch=self.paymentAmountAvailInEpoch,\n        ripeAvailForBonds=self.ripeAvailForBonds,\n        badDebt=self.badDebt,\n    )\n\n\n@external\ndef setRipeAvailForBonds(_amount: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.ripeAvailForBonds = _amount\n\n\n@external\ndef setBadDebt(_amount: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.badDebt = _amount\n\n\n@external\ndef didClearBadDebt(_amount: uint256, _ripeAmount: uint256):\n    assert msg.sender == addys._getBondRoomAddr() # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.badDebt -= _amount\n    self.ripePaidOutForBadDebt += _ripeAmount\n\n\n@external\ndef didPurchaseRipeBond(_amountPaid: uint256, _ripePayout: uint256):\n    assert msg.sender == addys._getBondRoomAddr() # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n    self.paymentAmountAvailInEpoch -= _amountPaid\n    if _ripePayout != 0:\n        self.ripeAvailForBonds -= _ripePayout\n\n\n@external\ndef setEpochData(_epochStart: uint256, _epochEnd: uint256, _amountAvailInEpoch: uint256):\n    assert msg.sender == addys._getBondRoomAddr() # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n\n    self.epochStart = _epochStart\n    self.epochEnd = _epochEnd\n    self.paymentAmountAvailInEpoch = _amountAvailInEpoch\n\n\n#############\n# Endaoment #\n#############\n\n\n@external\ndef updateGreenPoolDebt(_pool: address, _amount: uint256, _isIncrement: bool):\n    assert msg.sender == addys._getEndaomentAddr() # dev: no perms\n    assert not deptBasics.isPaused # dev: not activated\n\n    greenPoolDebt: uint256 = self.greenPoolDebt[_pool]\n    if _isIncrement:\n        greenPoolDebt += _amount\n    else:\n        greenPoolDebt -= min(greenPoolDebt, _amount)\n    self.greenPoolDebt[_pool] = greenPoolDebt",
            "sha256sum": "fa3c5253e1b9737cd3fef49af1d48627006ca94d97bd276cd72dbcdb8dc47755"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/data/Ledger.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "b0712b843bf5d9572f7772dc2df9250126133f7e2624fc489ebbef76895aed41"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a0300000000000000000000000057a44fe5cacfbeb3287242491c01c42581fd938f",
      "file": "contracts/data/Ledger.vy"
    },
    "MissionControl": {
      "address": "0x7daA7fBd78136745ecb8DD8657a8F57cF35F8F98",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGeneralConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserMaxVaults",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxAssetsPerVault",
                  "type": "uint256"
                },
                {
                  "name": "priceStaleTime",
                  "type": "uint256"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                },
                {
                  "name": "canLiquidate",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGeneralDebtConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDebtAmount",
                  "type": "uint256"
                },
                {
                  "name": "numAllowedBorrowers",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "minDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "maxDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "increasePerDangerBlock",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowRate",
                  "type": "uint256"
                },
                {
                  "name": "maxLtvDeviation",
                  "type": "uint256"
                },
                {
                  "name": "keeperFeeRatio",
                  "type": "uint256"
                },
                {
                  "name": "minKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "maxKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "isDaowryEnabled",
                  "type": "bool"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "genAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setHrConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "contribTemplate",
                  "type": "address"
                },
                {
                  "name": "maxCompensation",
                  "type": "uint256"
                },
                {
                  "name": "minCliffLength",
                  "type": "uint256"
                },
                {
                  "name": "maxStartDelay",
                  "type": "uint256"
                },
                {
                  "name": "minVestingLength",
                  "type": "uint256"
                },
                {
                  "name": "maxVestingLength",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeBondConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amountPerEpoch",
                  "type": "uint256"
                },
                {
                  "name": "canBond",
                  "type": "bool"
                },
                {
                  "name": "minRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnitLockBonus",
                  "type": "uint256"
                },
                {
                  "name": "epochLength",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoRestart",
                  "type": "bool"
                },
                {
                  "name": "restartDelayBlocks",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultIds",
                  "type": "uint256[]"
                },
                {
                  "name": "stakersPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "perUserDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDepositBalance",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "shouldBurnAsPayment",
                  "type": "bool"
                },
                {
                  "name": "shouldTransferToEndaoment",
                  "type": "bool"
                },
                {
                  "name": "shouldSwapInStabPools",
                  "type": "bool"
                },
                {
                  "name": "shouldAuctionInstantly",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                },
                {
                  "name": "specialStabPoolId",
                  "type": "uint256"
                },
                {
                  "name": "customAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "whitelist",
                  "type": "address"
                },
                {
                  "name": "isNft",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "canAnyoneDeposit",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneRepayDebt",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneBondForUser",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_delegate",
              "type": "address"
            },
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canClaimFromStabPool",
                  "type": "bool"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewardsConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "arePointsEnabled",
                  "type": "bool"
                },
                {
                  "name": "ripePerBlock",
                  "type": "uint256"
                },
                {
                  "name": "borrowersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "votersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "genDepositorsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeDurationRatio",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeGovVaultConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetWeight",
              "type": "uint256"
            },
            {
              "name": "_shouldFreezeWhenBadDebt",
              "type": "bool"
            },
            {
              "name": "_lockTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockBoost",
                  "type": "uint256"
                },
                {
                  "name": "canExit",
                  "type": "bool"
                },
                {
                  "name": "exitFee",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStabClaimRewardsConfig",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "rewardsLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "ripePerDollarClaimed",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityLiqAssetVaults",
          "inputs": [
            {
              "name": "_priorityLiqAssetVaults",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityStabVaults",
          "inputs": [
            {
              "name": "_priorityStabVaults",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPerformLiteAction",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canDo",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUnderscoreRegistry",
          "inputs": [
            {
              "name": "_underscoreRegistry",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityPriceSourceIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldCheckLastTouch",
          "inputs": [
            {
              "name": "_shouldCheck",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedAssetInVault",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getFirstVaultIdForAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTellerDepositConfig",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canDepositGeneral",
                  "type": "bool"
                },
                {
                  "name": "canDepositAsset",
                  "type": "bool"
                },
                {
                  "name": "doesVaultSupportAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "perUserDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxAssetsPerVault",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxVaults",
                  "type": "uint256"
                },
                {
                  "name": "canAnyoneDeposit",
                  "type": "bool"
                },
                {
                  "name": "minDepositBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTellerWithdrawConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canWithdrawGeneral",
                  "type": "bool"
                },
                {
                  "name": "canWithdrawAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "canWithdrawForUser",
                  "type": "bool"
                },
                {
                  "name": "minDepositBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDebtTerms",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBorrowConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canBorrowForUser",
                  "type": "bool"
                },
                {
                  "name": "numAllowedBorrowers",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "perUserDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDebtAmount",
                  "type": "uint256"
                },
                {
                  "name": "isDaowryEnabled",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxLtvDeviation",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRepayConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canRepay",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneRepayDebt",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRedeemCollateralConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canRedeemCollateralGeneral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateralAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "canAnyoneDeposit",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLtvPaybackBuffer",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAuctionBuyConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canBuyInAuctionGeneral",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuctionAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneDeposit",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGenLiqConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canLiquidate",
                  "type": "bool"
                },
                {
                  "name": "keeperFeeRatio",
                  "type": "uint256"
                },
                {
                  "name": "minKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "maxKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "genAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "priorityLiqAssetVaults",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "vaultId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultAddr",
                      "type": "address"
                    },
                    {
                      "name": "asset",
                      "type": "address"
                    }
                  ]
                },
                {
                  "name": "priorityStabVaults",
                  "type": "tuple[]",
                  "components": [
                    {
                      "name": "vaultId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultAddr",
                      "type": "address"
                    },
                    {
                      "name": "asset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGenAuctionParams",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasParams",
                  "type": "bool"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "delay",
                  "type": "uint256"
                },
                {
                  "name": "duration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetLiqConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasConfig",
                  "type": "bool"
                },
                {
                  "name": "shouldBurnAsPayment",
                  "type": "bool"
                },
                {
                  "name": "shouldTransferToEndaoment",
                  "type": "bool"
                },
                {
                  "name": "shouldSwapInStabPools",
                  "type": "bool"
                },
                {
                  "name": "shouldAuctionInstantly",
                  "type": "bool"
                },
                {
                  "name": "customAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "specialStabPool",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "vaultId",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultAddr",
                      "type": "address"
                    },
                    {
                      "name": "asset",
                      "type": "address"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getStabPoolClaimsConfig",
          "inputs": [
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canClaimInStabPoolGeneral",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPoolAsset",
                  "type": "bool"
                },
                {
                  "name": "canClaimFromStabPoolForUser",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "rewardsLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "ripePerDollarClaimed",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getStabPoolRedemptionsConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canRedeemInStabPoolGeneral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPoolAsset",
                  "type": "bool"
                },
                {
                  "name": "isUserAllowed",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneDeposit",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimLootConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_ripeToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                },
                {
                  "name": "canClaimLootForUser",
                  "type": "bool"
                },
                {
                  "name": "autoStakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeDurationRatio",
                  "type": "uint256"
                },
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "arePointsEnabled",
                  "type": "bool"
                },
                {
                  "name": "ripePerBlock",
                  "type": "uint256"
                },
                {
                  "name": "borrowersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "votersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "genDepositorsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersPointsAllocTotal",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAllocTotal",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDepositPointsConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "stakersPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "isNft",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "staleTime",
                  "type": "uint256"
                },
                {
                  "name": "priorityPriceSourceIds",
                  "type": "uint256[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPurchaseRipeBondConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amountPerEpoch",
                  "type": "uint256"
                },
                {
                  "name": "canBond",
                  "type": "bool"
                },
                {
                  "name": "minRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnitLockBonus",
                  "type": "uint256"
                },
                {
                  "name": "epochLength",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoRestart",
                  "type": "bool"
                },
                {
                  "name": "restartDelayBlocks",
                  "type": "uint256"
                },
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "canAnyoneBondForUser",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDynamicBorrowRateConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "minDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "maxDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "increasePerDangerBlock",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowRate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceStaleTime",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityPriceSourceIds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityLiqAssetVaults",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriorityStabVaults",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesUndyLegoHaveAccess",
          "inputs": [
            {
              "name": "_wallet",
              "type": "address"
            },
            {
              "name": "_legoAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "genConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserMaxVaults",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxAssetsPerVault",
                  "type": "uint256"
                },
                {
                  "name": "priceStaleTime",
                  "type": "uint256"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canRepay",
                  "type": "bool"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                },
                {
                  "name": "canLiquidate",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "genDebtConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDebtAmount",
                  "type": "uint256"
                },
                {
                  "name": "numAllowedBorrowers",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "minDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "maxDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "increasePerDangerBlock",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowRate",
                  "type": "uint256"
                },
                {
                  "name": "maxLtvDeviation",
                  "type": "uint256"
                },
                {
                  "name": "keeperFeeRatio",
                  "type": "uint256"
                },
                {
                  "name": "minKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "maxKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "isDaowryEnabled",
                  "type": "bool"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "genAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hrConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contribTemplate",
                  "type": "address"
                },
                {
                  "name": "maxCompensation",
                  "type": "uint256"
                },
                {
                  "name": "minCliffLength",
                  "type": "uint256"
                },
                {
                  "name": "maxStartDelay",
                  "type": "uint256"
                },
                {
                  "name": "minVestingLength",
                  "type": "uint256"
                },
                {
                  "name": "maxVestingLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeBondConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amountPerEpoch",
                  "type": "uint256"
                },
                {
                  "name": "canBond",
                  "type": "bool"
                },
                {
                  "name": "minRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnitLockBonus",
                  "type": "uint256"
                },
                {
                  "name": "epochLength",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoRestart",
                  "type": "bool"
                },
                {
                  "name": "restartDelayBlocks",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assetConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultIds",
                  "type": "uint256[]"
                },
                {
                  "name": "stakersPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "perUserDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDepositLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDepositBalance",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "shouldBurnAsPayment",
                  "type": "bool"
                },
                {
                  "name": "shouldTransferToEndaoment",
                  "type": "bool"
                },
                {
                  "name": "shouldSwapInStabPools",
                  "type": "bool"
                },
                {
                  "name": "shouldAuctionInstantly",
                  "type": "bool"
                },
                {
                  "name": "canDeposit",
                  "type": "bool"
                },
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canRedeemCollateral",
                  "type": "bool"
                },
                {
                  "name": "canRedeemInStabPool",
                  "type": "bool"
                },
                {
                  "name": "canBuyInAuction",
                  "type": "bool"
                },
                {
                  "name": "canClaimInStabPool",
                  "type": "bool"
                },
                {
                  "name": "specialStabPoolId",
                  "type": "uint256"
                },
                {
                  "name": "customAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "whitelist",
                  "type": "address"
                },
                {
                  "name": "isNft",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canAnyoneDeposit",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneRepayDebt",
                  "type": "bool"
                },
                {
                  "name": "canAnyoneBondForUser",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userDelegation",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "canWithdraw",
                  "type": "bool"
                },
                {
                  "name": "canBorrow",
                  "type": "bool"
                },
                {
                  "name": "canClaimFromStabPool",
                  "type": "bool"
                },
                {
                  "name": "canClaimLoot",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "rewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "arePointsEnabled",
                  "type": "bool"
                },
                {
                  "name": "ripePerBlock",
                  "type": "uint256"
                },
                {
                  "name": "borrowersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "votersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "genDepositorsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeDurationRatio",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalPointsAllocs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "stakersPointsAllocTotal",
                  "type": "uint256"
                },
                {
                  "name": "voterPointsAllocTotal",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ripeGovVaultConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lockTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "minLockDuration",
                      "type": "uint256"
                    },
                    {
                      "name": "maxLockDuration",
                      "type": "uint256"
                    },
                    {
                      "name": "maxLockBoost",
                      "type": "uint256"
                    },
                    {
                      "name": "canExit",
                      "type": "bool"
                    },
                    {
                      "name": "exitFee",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "assetWeight",
                  "type": "uint256"
                },
                {
                  "name": "shouldFreezeWhenBadDebt",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "stabClaimRewardsConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "rewardsLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "ripePerDollarClaimed",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityLiqAssetVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityStabVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canPerformLiteAction",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priorityPriceSourceIds",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "underscoreRegistry",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldCheckLastTouch",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_defaults",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "interfaces/Defaults.vyi": {
            "content": "# @version 0.4.1\n\nimport interfaces.ConfigStructs as cs\n\n\n# general config\n\n\n@view\n@external\ndef genConfig() -> cs.GenConfig:\n    ...\n\n\n# debt config\n\n\n@view\n@external\ndef genDebtConfig() -> cs.GenDebtConfig:\n    ...\n\n\n# hr config\n\n\n@view\n@external\ndef hrConfig() -> cs.HrConfig:\n    ...\n\n\n# ripe bond config\n\n\n@view\n@external\ndef ripeBondConfig() -> cs.RipeBondConfig:\n    ...\n\n\n# ripe rewards config\n\n\n@view\n@external\ndef rewardsConfig() -> cs.RipeRewardsConfig:\n    ...\n\n\n# ripe gov vault config\n\n\n@view\n@external\ndef ripeGovVaultConfig() -> cs.RipeGovVaultConfig:\n    ...\n\n\n# stab claim rewards config\n\n\n@view\n@external\ndef stabClaimRewardsConfig() -> cs.StabClaimRewardsConfig:\n    ...\n\n\n# underscore registry\n\n\n@view\n@external\ndef underscoreRegistry() -> address:\n    ...\n\n\n# shouldCheckLastTouchy\n\n\n@view\n@external\ndef shouldCheckLastTouch() -> bool:\n    ...\n\n\n# ripe available\n\n\n@view\n@external\ndef ripeAvailForRewards() -> uint256:\n    ...\n\n\n@view\n@external\ndef ripeAvailForHr() -> uint256:\n    ...\n\n\n@view\n@external\ndef ripeAvailForBonds() -> uint256:\n    ...",
            "sha256sum": "a03f6ebff9f709dee36d402f5b3adcd3953290787efb1d2c2a7d1d6a1cff67c6"
          },
          "contracts/data/MissionControl.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nimport interfaces.ConfigStructs as cs\nfrom interfaces import Department\nfrom interfaces import Defaults\n\ninterface Whitelist:\n    def isUserAllowed(_user: address, _asset: address) -> bool: view\n\ninterface Vault:\n    def vaultAssets(_index: uint256) -> address: view\n\ninterface VaultBook:\n    def getAddr(_regId: uint256) -> address: view\n\nstruct TotalPointsAllocs:\n    stakersPointsAllocTotal: uint256\n    voterPointsAllocTotal: uint256\n\nstruct TellerDepositConfig:\n    canDepositGeneral: bool\n    canDepositAsset: bool\n    doesVaultSupportAsset: bool\n    isUserAllowed: bool\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    perUserMaxAssetsPerVault: uint256\n    perUserMaxVaults: uint256\n    canAnyoneDeposit: bool\n    minDepositBalance: uint256\n\nstruct TellerWithdrawConfig:\n    canWithdrawGeneral: bool\n    canWithdrawAsset: bool\n    isUserAllowed: bool\n    canWithdrawForUser: bool\n    minDepositBalance: uint256\n\nstruct BorrowConfig:\n    canBorrow: bool\n    canBorrowForUser: bool\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    isDaowryEnabled: bool\n\nstruct RepayConfig:\n    canRepay: bool\n    canAnyoneRepayDebt: bool\n\nstruct RedeemCollateralConfig:\n    canRedeemCollateralGeneral: bool\n    canRedeemCollateralAsset: bool\n    isUserAllowed: bool\n    ltvPaybackBuffer: uint256\n    canAnyoneDeposit: bool\n\nstruct AuctionBuyConfig:\n    canBuyInAuctionGeneral: bool\n    canBuyInAuctionAsset: bool\n    isUserAllowed: bool\n    canAnyoneDeposit: bool\n\nstruct GenLiqConfig:\n    canLiquidate: bool\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    ltvPaybackBuffer: uint256\n    genAuctionParams: cs.AuctionParams\n    priorityLiqAssetVaults: DynArray[VaultData, PRIORITY_VAULT_DATA]\n    priorityStabVaults: DynArray[VaultData, PRIORITY_VAULT_DATA]\n\nstruct VaultData:\n    vaultId: uint256\n    vaultAddr: address\n    asset: address\n\nstruct AssetLiqConfig:\n    hasConfig: bool\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    customAuctionParams: cs.AuctionParams\n    specialStabPool: VaultData\n\nstruct StabPoolClaimsConfig:\n    canClaimInStabPoolGeneral: bool\n    canClaimInStabPoolAsset: bool\n    canClaimFromStabPoolForUser: bool\n    isUserAllowed: bool\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct StabPoolRedemptionsConfig:\n    canRedeemInStabPoolGeneral: bool\n    canRedeemInStabPoolAsset: bool\n    isUserAllowed: bool\n    canAnyoneDeposit: bool\n\nstruct ClaimLootConfig:\n    canClaimLoot: bool\n    canClaimLootForUser: bool\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n    minLockDuration: uint256\n    maxLockDuration: uint256\n\nstruct RewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    stakersPointsAllocTotal: uint256\n    voterPointsAllocTotal: uint256\n\nstruct DepositPointsConfig:\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    isNft: bool\n\nstruct PriceConfig:\n    staleTime: uint256\n    priorityPriceSourceIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]\n\nstruct PurchaseRipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    canAnyoneBondForUser: bool\n\nstruct DynamicBorrowRateConfig:\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n\n# global cs\ngenConfig: public(cs.GenConfig)\ngenDebtConfig: public(cs.GenDebtConfig)\nhrConfig: public(cs.HrConfig)\nripeBondConfig: public(cs.RipeBondConfig)\n\n# asset cs\nassetConfig: public(HashMap[address, cs.AssetConfig]) # asset -> cs\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\n# user cs\nuserConfig: public(HashMap[address, cs.UserConfig]) # user -> cs\nuserDelegation: public(HashMap[address, HashMap[address, cs.ActionDelegation]]) # user -> delegate -> cs\n\n# ripe rewards\nrewardsConfig: public(cs.RipeRewardsConfig)\ntotalPointsAllocs: public(TotalPointsAllocs)\n\n# vault cs\nripeGovVaultConfig: public(HashMap[address, cs.RipeGovVaultConfig]) # asset -> cs\nstabClaimRewardsConfig: public(cs.StabClaimRewardsConfig)\npriorityLiqAssetVaults: public(DynArray[cs.VaultLite, PRIORITY_VAULT_DATA])\npriorityStabVaults: public(DynArray[cs.VaultLite, PRIORITY_VAULT_DATA])\n\n# access\ncanPerformLiteAction: public(HashMap[address, bool]) # user -> canPerformLiteAction\n\n# other\npriorityPriceSourceIds: public(DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES])\nunderscoreRegistry: public(address)\nshouldCheckLastTouch: public(bool)\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\nMAX_PRIORITY_PRICE_SOURCES: constant(uint256) = 10\nPRIORITY_VAULT_DATA: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_ripeHq: address, _defaults: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n    self.numAssets = 1 # not using 0 index\n\n    # defaults\n    if _defaults != empty(address):\n        self.genConfig = staticcall Defaults(_defaults).genConfig()\n        self.genDebtConfig = staticcall Defaults(_defaults).genDebtConfig()\n        self.hrConfig = staticcall Defaults(_defaults).hrConfig()\n        self.ripeBondConfig = staticcall Defaults(_defaults).ripeBondConfig()\n        self.rewardsConfig = staticcall Defaults(_defaults).rewardsConfig()\n        self.stabClaimRewardsConfig = staticcall Defaults(_defaults).stabClaimRewardsConfig()\n        self.underscoreRegistry = staticcall Defaults(_defaults).underscoreRegistry()\n        self.shouldCheckLastTouch = staticcall Defaults(_defaults).shouldCheckLastTouch()\n\n        ripeGovVaultConfig: cs.RipeGovVaultConfig = staticcall Defaults(_defaults).ripeGovVaultConfig()\n        if ripeGovVaultConfig.assetWeight != 0:\n            self.ripeGovVaultConfig[addys._getRipeToken()] = ripeGovVaultConfig\n\n\n#################\n# Global Config #\n#################\n\n\n@external\ndef setGeneralConfig(_config: cs.GenConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.genConfig = _config\n\n\n@external\ndef setGeneralDebtConfig(_config: cs.GenDebtConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.genDebtConfig = _config\n\n\n@external\ndef setHrConfig(_config: cs.HrConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.hrConfig = _config\n\n\n@external\ndef setRipeBondConfig(_config: cs.RipeBondConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.ripeBondConfig = _config\n\n\n################\n# Asset Config #\n################\n\n\n@external\ndef setAssetConfig(_asset: address, _config: cs.AssetConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._updatePointsAllocs(_asset, _config.stakersPointsAlloc, _config.voterPointsAlloc) # do first!\n    self.assetConfig[_asset] = _config\n\n    # register asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerAsset(_asset)\n\n\n# asset registration\n\n\n@internal\ndef _registerAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterAsset(_asset: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n###############\n# User Config #\n###############\n\n\n@external\ndef setUserConfig(_user: address, _config: cs.UserConfig):\n    assert addys._isSwitchboardAddr(msg.sender) or msg.sender == addys._getTellerAddr() # dev: no perms\n    self.userConfig[_user] = _config\n\n\n@external\ndef setUserDelegation(_user: address, _delegate: address, _config: cs.ActionDelegation):\n    assert addys._isSwitchboardAddr(msg.sender) or msg.sender == addys._getTellerAddr() # dev: no perms\n    self.userDelegation[_user][_delegate] = _config\n\n\n##################\n# Rewards Config #\n##################\n\n\n@external\ndef setRipeRewardsConfig(_config: cs.RipeRewardsConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.rewardsConfig = _config\n\n\n# points allocs\n\n\n@internal\ndef _updatePointsAllocs(_asset: address, _newStakersPointsAlloc: uint256, _newVoterPointsAlloc: uint256):\n    totalPointsAllocs: TotalPointsAllocs = self.totalPointsAllocs\n\n    # remove old allocs\n    prevConfig: cs.AssetConfig = self.assetConfig[_asset]\n    totalPointsAllocs.stakersPointsAllocTotal -= prevConfig.stakersPointsAlloc\n    totalPointsAllocs.voterPointsAllocTotal -= prevConfig.voterPointsAlloc\n\n    # add new allocs\n    totalPointsAllocs.stakersPointsAllocTotal += _newStakersPointsAlloc\n    totalPointsAllocs.voterPointsAllocTotal += _newVoterPointsAlloc\n    self.totalPointsAllocs = totalPointsAllocs\n\n\n################\n# Vault Config #\n################\n\n\n# ripe gov vault\n\n\n@external\ndef setRipeGovVaultConfig(\n    _asset: address,\n    _assetWeight: uint256,\n    _shouldFreezeWhenBadDebt: bool,\n    _lockTerms: cs.LockTerms,\n):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.ripeGovVaultConfig[_asset] = cs.RipeGovVaultConfig(\n        lockTerms=_lockTerms,\n        assetWeight=_assetWeight,\n        shouldFreezeWhenBadDebt=_shouldFreezeWhenBadDebt,\n    )\n\n\n# stab pool claims\n\n\n@external\ndef setStabClaimRewardsConfig(_config: cs.StabClaimRewardsConfig):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.stabClaimRewardsConfig = _config\n\n\n# priority liq asset vaults\n\n\n@external\ndef setPriorityLiqAssetVaults(_priorityLiqAssetVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.priorityLiqAssetVaults = _priorityLiqAssetVaults\n\n\n# stability pool vaults\n\n\n@external\ndef setPriorityStabVaults(_priorityStabVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.priorityStabVaults = _priorityStabVaults\n\n\n##################\n# Access Control #\n##################\n\n\n@external\ndef setCanPerformLiteAction(_user: address, _canDo: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.canPerformLiteAction[_user] = _canDo\n\n\n#########\n# Other #\n#########\n\n\n# underscore registry\n\n\n@external\ndef setUnderscoreRegistry(_underscoreRegistry: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.underscoreRegistry = _underscoreRegistry\n\n\n# price sources\n\n\n@external\ndef setPriorityPriceSourceIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.priorityPriceSourceIds = _priorityIds\n\n\n# should check last touch\n\n\n@external\ndef setShouldCheckLastTouch(_shouldCheck: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self.shouldCheckLastTouch = _shouldCheck\n\n\n###################\n# Helpers / Views #\n###################\n\n\n# asset utils\n\n\n@view\n@external\ndef isSupportedAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@view\n@external\ndef isSupportedAssetInVault(_vaultId: uint256, _asset: address) -> bool:\n    return _vaultId in self.assetConfig[_asset].vaultIds\n\n\n@view\n@external\ndef getNumAssets() -> uint256:\n    return self._getNumAssets()\n\n\n@view\n@internal\ndef _getNumAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n@view\n@external\ndef getFirstVaultIdForAsset(_asset: address) -> uint256:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET] = self.assetConfig[_asset].vaultIds\n    if len(vaultIds) == 0:\n        return 0\n    return vaultIds[0]\n\n\n# is user allowed\n\n\n@view\n@internal\ndef _isUserAllowed(_whitelist: address, _user: address, _asset: address) -> bool:\n    isUserAllowed: bool = True \n    if _whitelist != empty(address):\n        isUserAllowed = staticcall Whitelist(_whitelist).isUserAllowed(_user, _asset)\n    return isUserAllowed\n\n\n# deposits\n\n\n@view\n@external\ndef getTellerDepositConfig(_vaultId: uint256, _asset: address, _user: address) -> TellerDepositConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n    genConfig: cs.GenConfig = self.genConfig\n    return TellerDepositConfig(\n        canDepositGeneral=genConfig.canDeposit,\n        canDepositAsset=assetConfig.canDeposit,\n        doesVaultSupportAsset=_vaultId in assetConfig.vaultIds,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _user, _asset),\n        perUserDepositLimit=assetConfig.perUserDepositLimit,\n        globalDepositLimit=assetConfig.globalDepositLimit,\n        perUserMaxAssetsPerVault=genConfig.perUserMaxAssetsPerVault,\n        perUserMaxVaults=genConfig.perUserMaxVaults,\n        canAnyoneDeposit=self.userConfig[_user].canAnyoneDeposit,\n        minDepositBalance=assetConfig.minDepositBalance,\n    )\n\n\n# withdrawals\n\n\n@view\n@external\ndef getTellerWithdrawConfig(_asset: address, _user: address, _caller: address) -> TellerWithdrawConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n\n    canWithdrawForUser: bool = True\n    if _user != _caller:\n        delegation: cs.ActionDelegation = self.userDelegation[_user][_caller]\n        canWithdrawForUser = delegation.canWithdraw\n\n    return TellerWithdrawConfig(\n        canWithdrawGeneral=self.genConfig.canWithdraw,\n        canWithdrawAsset=assetConfig.canWithdraw,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _user, _asset),\n        canWithdrawForUser=canWithdrawForUser,\n        minDepositBalance=assetConfig.minDepositBalance,\n    )\n\n\n# borrow\n\n\n@view\n@external\ndef getDebtTerms(_asset: address) -> cs.DebtTerms:\n    return self.assetConfig[_asset].debtTerms\n\n\n@view\n@external\ndef getBorrowConfig(_user: address, _caller: address) -> BorrowConfig:\n    genDebtConfig: cs.GenDebtConfig = self.genDebtConfig\n\n    canBorrowForUser: bool = True\n    if _user != _caller:\n        delegation: cs.ActionDelegation = self.userDelegation[_user][_caller]\n        canBorrowForUser = delegation.canBorrow\n\n    return BorrowConfig(\n        canBorrow=self.genConfig.canBorrow,\n        canBorrowForUser=canBorrowForUser,\n        numAllowedBorrowers=genDebtConfig.numAllowedBorrowers,\n        maxBorrowPerInterval=genDebtConfig.maxBorrowPerInterval,\n        numBlocksPerInterval=genDebtConfig.numBlocksPerInterval,\n        perUserDebtLimit=genDebtConfig.perUserDebtLimit,\n        globalDebtLimit=genDebtConfig.globalDebtLimit,\n        minDebtAmount=genDebtConfig.minDebtAmount,\n        isDaowryEnabled=genDebtConfig.isDaowryEnabled,\n    )\n\n\n@view\n@external\ndef maxLtvDeviation() -> uint256:\n    return self.genDebtConfig.maxLtvDeviation\n\n\n# repay\n\n\n@view\n@external\ndef getRepayConfig(_user: address) -> RepayConfig:\n    return RepayConfig(\n        canRepay=self.genConfig.canRepay,\n        canAnyoneRepayDebt=self.userConfig[_user].canAnyoneRepayDebt,\n    )\n\n\n# redeem collateral\n\n\n@view\n@external\ndef getRedeemCollateralConfig(_asset: address, _recipient: address) -> RedeemCollateralConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n    return RedeemCollateralConfig(\n        canRedeemCollateralGeneral=self.genConfig.canRedeemCollateral,\n        canRedeemCollateralAsset=assetConfig.canRedeemCollateral,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _recipient, _asset),\n        ltvPaybackBuffer=self.genDebtConfig.ltvPaybackBuffer,\n        canAnyoneDeposit=self.userConfig[_recipient].canAnyoneDeposit,\n    )\n\n\n@view\n@external\ndef getLtvPaybackBuffer() -> uint256:\n    return self.genDebtConfig.ltvPaybackBuffer\n\n\n# auction purchases\n\n\n@view\n@external\ndef getAuctionBuyConfig(_asset: address, _recipient: address) -> AuctionBuyConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n    return AuctionBuyConfig(\n        canBuyInAuctionGeneral=self.genConfig.canBuyInAuction,\n        canBuyInAuctionAsset=assetConfig.canBuyInAuction,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _recipient, _asset),\n        canAnyoneDeposit=self.userConfig[_recipient].canAnyoneDeposit,\n    )\n\n\n# general liquidation cs\n\n\n@view\n@external\ndef getGenLiqConfig() -> GenLiqConfig:\n    genDebtConfig: cs.GenDebtConfig = self.genDebtConfig\n    vaultBook: address = addys._getVaultBookAddr()\n\n    # priority liq asset vault data\n    priorityLiqAssetVaults: DynArray[VaultData, PRIORITY_VAULT_DATA] = []\n    for pData: cs.VaultLite in self.priorityLiqAssetVaults:\n        vaultAddr: address = staticcall VaultBook(vaultBook).getAddr(pData.vaultId)\n        priorityLiqAssetVaults.append(VaultData(vaultId=pData.vaultId, vaultAddr=vaultAddr, asset=pData.asset))\n\n    # stability pool vault data\n    priorityStabVaults: DynArray[VaultData, PRIORITY_VAULT_DATA] = []\n    for pData: cs.VaultLite in self.priorityStabVaults:\n        vaultAddr: address = staticcall VaultBook(vaultBook).getAddr(pData.vaultId)\n        priorityStabVaults.append(VaultData(vaultId=pData.vaultId, vaultAddr=vaultAddr, asset=pData.asset))\n\n    return GenLiqConfig(\n        canLiquidate=self.genConfig.canLiquidate,\n        keeperFeeRatio=genDebtConfig.keeperFeeRatio,\n        minKeeperFee=genDebtConfig.minKeeperFee,\n        maxKeeperFee=genDebtConfig.maxKeeperFee,\n        ltvPaybackBuffer=genDebtConfig.ltvPaybackBuffer,\n        genAuctionParams=genDebtConfig.genAuctionParams,\n        priorityLiqAssetVaults=priorityLiqAssetVaults,\n        priorityStabVaults=priorityStabVaults,\n    )\n\n\n@view\n@external\ndef getGenAuctionParams() -> cs.AuctionParams:\n    return self.genDebtConfig.genAuctionParams\n\n\n# asset liquidation cs\n\n\n@view\n@external\ndef getAssetLiqConfig(_asset: address) -> AssetLiqConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n    vaultBook: address = addys._getVaultBookAddr()\n\n    # handle special stab pool\n    specialStabPool: VaultData = empty(VaultData)\n    if assetConfig.specialStabPoolId != 0:\n        specialVaultAddr: address = staticcall VaultBook(vaultBook).getAddr(assetConfig.specialStabPoolId)\n        if specialVaultAddr != empty(address):\n            firstAsset: address = staticcall Vault(specialVaultAddr).vaultAssets(1) # get first asset\n            if firstAsset != empty(address):\n                specialStabPool = VaultData(\n                    vaultId=assetConfig.specialStabPoolId,\n                    vaultAddr=specialVaultAddr,\n                    asset=firstAsset\n                )\n\n    return AssetLiqConfig(\n        hasConfig=True,\n        shouldBurnAsPayment=assetConfig.shouldBurnAsPayment,\n        shouldTransferToEndaoment=assetConfig.shouldTransferToEndaoment,\n        shouldSwapInStabPools=assetConfig.shouldSwapInStabPools,\n        shouldAuctionInstantly=assetConfig.shouldAuctionInstantly,\n        customAuctionParams=assetConfig.customAuctionParams,\n        specialStabPool=specialStabPool,\n    )\n\n\n# stability pool claims\n\n\n@view\n@external\ndef getStabPoolClaimsConfig(_claimAsset: address, _claimer: address, _caller: address) -> StabPoolClaimsConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_claimAsset]\n\n    canClaimFromStabPoolForUser: bool = True\n    if _claimer != _caller:\n        delegation: cs.ActionDelegation = self.userDelegation[_claimer][_caller]\n        canClaimFromStabPoolForUser = delegation.canClaimFromStabPool\n\n    rewardsConfig: cs.StabClaimRewardsConfig = self.stabClaimRewardsConfig\n    return StabPoolClaimsConfig(\n        canClaimInStabPoolGeneral=self.genConfig.canClaimInStabPool,\n        canClaimInStabPoolAsset=assetConfig.canClaimInStabPool,\n        canClaimFromStabPoolForUser=canClaimFromStabPoolForUser,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _claimer, _claimAsset),\n        rewardsLockDuration=rewardsConfig.rewardsLockDuration,\n        ripePerDollarClaimed=rewardsConfig.ripePerDollarClaimed,\n    )\n\n\n# stability pool redemptions\n\n\n@view\n@external\ndef getStabPoolRedemptionsConfig(_asset: address, _recipient: address) -> StabPoolRedemptionsConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n    return StabPoolRedemptionsConfig(\n        canRedeemInStabPoolGeneral=self.genConfig.canRedeemInStabPool,\n        canRedeemInStabPoolAsset=assetConfig.canRedeemInStabPool,\n        isUserAllowed=self._isUserAllowed(assetConfig.whitelist, _recipient, _asset),\n        canAnyoneDeposit=self.userConfig[_recipient].canAnyoneDeposit,\n    )\n\n\n# loot claims\n\n\n@view\n@external\ndef getClaimLootConfig(_user: address, _caller: address, _ripeToken: address) -> ClaimLootConfig:\n    canClaimLootForUser: bool = True\n    if _user != _caller:\n        delegation: cs.ActionDelegation = self.userDelegation[_user][_caller]\n        canClaimLootForUser = delegation.canClaimLoot\n\n    ripeTokenVaultConfig: cs.RipeGovVaultConfig = self.ripeGovVaultConfig[_ripeToken]\n    rewardsConfig: cs.RipeRewardsConfig = self.rewardsConfig\n\n    return ClaimLootConfig(\n        canClaimLoot=self.genConfig.canClaimLoot,\n        canClaimLootForUser=canClaimLootForUser,\n        autoStakeRatio=rewardsConfig.autoStakeRatio,\n        autoStakeDurationRatio=rewardsConfig.autoStakeDurationRatio,\n        minLockDuration=ripeTokenVaultConfig.lockTerms.minLockDuration,\n        maxLockDuration=ripeTokenVaultConfig.lockTerms.maxLockDuration,\n    )\n\n\n# rewards cs\n\n\n@view\n@external\ndef getRewardsConfig() -> RewardsConfig:\n    rewardsConfig: cs.RipeRewardsConfig = self.rewardsConfig\n    totalPointsAllocs: TotalPointsAllocs = self.totalPointsAllocs\n    return RewardsConfig(\n        arePointsEnabled=rewardsConfig.arePointsEnabled,\n        ripePerBlock=rewardsConfig.ripePerBlock,\n        borrowersAlloc=rewardsConfig.borrowersAlloc,\n        stakersAlloc=rewardsConfig.stakersAlloc,\n        votersAlloc=rewardsConfig.votersAlloc,\n        genDepositorsAlloc=rewardsConfig.genDepositorsAlloc,\n        stakersPointsAllocTotal=totalPointsAllocs.stakersPointsAllocTotal,\n        voterPointsAllocTotal=totalPointsAllocs.voterPointsAllocTotal,\n    )\n\n\n# deposit points\n\n\n@view\n@external\ndef getDepositPointsConfig(_asset: address) -> DepositPointsConfig:\n    assetConfig: cs.AssetConfig = self.assetConfig[_asset]\n    return DepositPointsConfig(\n        stakersPointsAlloc=assetConfig.stakersPointsAlloc,\n        voterPointsAlloc=assetConfig.voterPointsAlloc,\n        isNft=assetConfig.isNft,\n    )\n\n\n# price cs\n\n\n@view\n@external\ndef getPriceConfig() -> PriceConfig:\n    return PriceConfig(\n        staleTime=self.genConfig.priceStaleTime,\n        priorityPriceSourceIds=self.priorityPriceSourceIds,\n    )\n\n\n# ripe bond cs\n\n\n@view\n@external\ndef getPurchaseRipeBondConfig(_user: address) -> PurchaseRipeBondConfig:\n    bondConfig: cs.RipeBondConfig = self.ripeBondConfig\n    vaultConfig: cs.RipeGovVaultConfig = self.ripeGovVaultConfig[addys._getRipeToken()]\n\n    return PurchaseRipeBondConfig(\n        asset=bondConfig.asset,\n        amountPerEpoch=bondConfig.amountPerEpoch,\n        canBond=bondConfig.canBond,\n        minRipePerUnit=bondConfig.minRipePerUnit,\n        maxRipePerUnit=bondConfig.maxRipePerUnit,\n        maxRipePerUnitLockBonus=bondConfig.maxRipePerUnitLockBonus,\n        epochLength=bondConfig.epochLength,\n        shouldAutoRestart=bondConfig.shouldAutoRestart,\n        restartDelayBlocks=bondConfig.restartDelayBlocks,\n        minLockDuration=vaultConfig.lockTerms.minLockDuration,\n        maxLockDuration=vaultConfig.lockTerms.maxLockDuration,\n        canAnyoneBondForUser=self.userConfig[_user].canAnyoneBondForUser,\n    )\n\n\n# dynamic borrow rate cs\n\n\n@view\n@external\ndef getDynamicBorrowRateConfig() -> DynamicBorrowRateConfig:\n    genDebtConfig: cs.GenDebtConfig = self.genDebtConfig\n    return DynamicBorrowRateConfig(\n        minDynamicRateBoost=genDebtConfig.minDynamicRateBoost,\n        maxDynamicRateBoost=genDebtConfig.maxDynamicRateBoost,\n        increasePerDangerBlock=genDebtConfig.increasePerDangerBlock,\n        maxBorrowRate=genDebtConfig.maxBorrowRate,\n    )\n\n\n# stale price time\n\n\n@view\n@external\ndef getPriceStaleTime() -> uint256:\n    # used by some price sources\n    return self.genConfig.priceStaleTime\n\n\n# priority data\n\n\n@view \n@external \ndef getPriorityPriceSourceIds() -> DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]:\n    return self.priorityPriceSourceIds\n\n\n@view \n@external \ndef getPriorityLiqAssetVaults() -> DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]:\n    return self.priorityLiqAssetVaults\n\n\n@view \n@external \ndef getPriorityStabVaults() -> DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]:\n    return self.priorityStabVaults\n\n\n# underscore helper\n\n\n@view\n@external\ndef doesUndyLegoHaveAccess(_wallet: address, _legoAddr: address) -> bool:\n    config: cs.UserConfig = self.userConfig[_wallet]\n    if not config.canAnyoneDeposit or not config.canAnyoneRepayDebt:\n        return False\n\n    delegation: cs.ActionDelegation = self.userDelegation[_wallet][_legoAddr]\n    if not delegation.canWithdraw or not delegation.canBorrow or not delegation.canClaimLoot:\n        return False\n\n    return True",
            "sha256sum": "ec6d37acd5009c7dcb76b9be9043b4288eae81ab2ec80283aecb5a9254d09ec6"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/data/MissionControl.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "66384469a9cfca4522406424e9e26298d94bb8646ed262cd7adf7e1eaaa9ad9f"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a0300000000000000000000000057a44fe5cacfbeb3287242491c01c42581fd938f",
      "file": "contracts/data/MissionControl.vy"
    },
    "Switchboard": {
      "address": "0xAAD2e9cA0c2c0e45F8651C62D092Ee13c92571Ab",
      "abi": [
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSwitchboardAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_tokenAddr",
              "type": "address"
            },
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/registries/modules/AddressRegistry.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "45a6786be62ebfcd266d4b9f321aa22bfc8d125d6ce75ffcf4d895ad011ff661"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/registries/Switchboard.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.registries.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Department\n\ninterface TokenContract:\n    def setBlacklist(_addr: address, _shouldBlacklist: bool) -> bool: nonpayable\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"Switchboard.vy\")\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n\n@view\n@external\ndef isSwitchboardAddr(_addr: address) -> bool:\n    return registry._isValidAddr(_addr)\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n#############\n# Blacklist #\n#############\n\n\n# pass thru from specific switchboard contract\n\n\n@external\ndef setBlacklist(_tokenAddr: address, _addr: address, _shouldBlacklist: bool) -> bool:\n    assert registry._isValidAddr(msg.sender) # dev: no perms\n    extcall TokenContract(_tokenAddr).setBlacklist(_addr, _shouldBlacklist)\n    return True",
            "sha256sum": "5d39ba25b272caa7ed0cf1b61e97ce157744bec68244324bcd4a76fefe51e559"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/Switchboard.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "d90b4cb21527be85fce9c31f96f7dda37f5a54ec53b9b20a17a7b0356c3f0de1"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/registries/Switchboard.vy"
    },
    "SwitchboardAlpha": {
      "address": "0x34BD38884E5FD0a561Fd1067C28A991111505946",
      "abi": [
        {
          "name": "PendingVaultLimitsChange",
          "inputs": [
            {
              "name": "perUserMaxVaults",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "perUserMaxAssetsPerVault",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingStaleTimeChange",
          "inputs": [
            {
              "name": "priceStaleTime",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanDepositSet",
          "inputs": [
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanWithdrawSet",
          "inputs": [
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanBorrowSet",
          "inputs": [
            {
              "name": "canBorrow",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanRepaySet",
          "inputs": [
            {
              "name": "canRepay",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanClaimLootSet",
          "inputs": [
            {
              "name": "canClaimLoot",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanLiquidateSet",
          "inputs": [
            {
              "name": "canLiquidate",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanRedeemCollateralSet",
          "inputs": [
            {
              "name": "canRedeemCollateral",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanRedeemInStabPoolSet",
          "inputs": [
            {
              "name": "canRedeemInStabPool",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanBuyInAuctionSet",
          "inputs": [
            {
              "name": "canBuyInAuction",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanClaimInStabPoolSet",
          "inputs": [
            {
              "name": "canClaimInStabPool",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingGlobalDebtLimitsChange",
          "inputs": [
            {
              "name": "perUserDebtLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "globalDebtLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minDebtAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numAllowedBorrowers",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingBorrowIntervalConfigChange",
          "inputs": [
            {
              "name": "maxBorrowPerInterval",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numBlocksPerInterval",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingDynamicRateConfigChange",
          "inputs": [
            {
              "name": "minDynamicRateBoost",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxDynamicRateBoost",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "increasePerDangerBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxBorrowRate",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingKeeperConfigChange",
          "inputs": [
            {
              "name": "keeperFeeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minKeeperFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxKeeperFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingLtvPaybackBufferChange",
          "inputs": [
            {
              "name": "ltvPaybackBuffer",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingDefaultAuctionParamsChange",
          "inputs": [
            {
              "name": "startDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "delay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "duration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "IsDaowryEnabledSet",
          "inputs": [
            {
              "name": "isDaowryEnabled",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeRewardsPerBlockChange",
          "inputs": [
            {
              "name": "ripePerBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeRewardsAllocsChange",
          "inputs": [
            {
              "name": "borrowersAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stakersAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "votersAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "genDepositorsAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeRewardsAutoStakeParamsChange",
          "inputs": [
            {
              "name": "autoStakeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "autoStakeDurationRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RewardsPointsEnabledModified",
          "inputs": [
            {
              "name": "arePointsEnabled",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingPriorityLiqAssetVaultsChange",
          "inputs": [
            {
              "name": "numPriorityLiqAssetVaults",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingPriorityStabVaultsChange",
          "inputs": [
            {
              "name": "numPriorityStabVaults",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingPriorityPriceSourceIdsChange",
          "inputs": [
            {
              "name": "numPriorityPriceSourceIds",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingUnderscoreRegistryChange",
          "inputs": [
            {
              "name": "underscoreRegistry",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingCanPerformLiteAction",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": false
            },
            {
              "name": "canDo",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingShouldCheckLastTouchChange",
          "inputs": [
            {
              "name": "shouldCheck",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingMaxLtvDeviationChange",
          "inputs": [
            {
              "name": "newDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeGovVaultConfigChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "assetWeight",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shouldFreezeWhenBadDebt",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "minLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxLockBoost",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "canExit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "exitFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultLimitsSet",
          "inputs": [
            {
              "name": "perUserMaxVaults",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "perUserMaxAssetsPerVault",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StaleTimeSet",
          "inputs": [
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GlobalDebtLimitsSet",
          "inputs": [
            {
              "name": "perUserDebtLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "globalDebtLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minDebtAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numAllowedBorrowers",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BorrowIntervalConfigSet",
          "inputs": [
            {
              "name": "maxBorrowPerInterval",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numBlocksPerInterval",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DynamicRateConfigSet",
          "inputs": [
            {
              "name": "minDynamicRateBoost",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxDynamicRateBoost",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "increasePerDangerBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxBorrowRate",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "KeeperConfigSet",
          "inputs": [
            {
              "name": "keeperFeeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minKeeperFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxKeeperFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LtvPaybackBufferSet",
          "inputs": [
            {
              "name": "ltvPaybackBuffer",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GenAuctionParamsSet",
          "inputs": [
            {
              "name": "startDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "delay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "duration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRewardsPerBlockSet",
          "inputs": [
            {
              "name": "ripePerBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRewardsAllocsSet",
          "inputs": [
            {
              "name": "borrowersAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stakersAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "votersAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "genDepositorsAlloc",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRewardsAutoStakeParamsSet",
          "inputs": [
            {
              "name": "autoStakeRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "autoStakeDurationRatio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriorityLiqAssetVaultsSet",
          "inputs": [
            {
              "name": "numVaults",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriorityStabVaultsSet",
          "inputs": [
            {
              "name": "numVaults",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriorityPriceSourceIdsModified",
          "inputs": [
            {
              "name": "numIds",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UnderscoreRegistrySet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanPerformLiteAction",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canDo",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldCheckLastTouchSet",
          "inputs": [
            {
              "name": "shouldCheck",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MaxLtvDeviationSet",
          "inputs": [
            {
              "name": "newDeviation",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeGovVaultConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "assetWeight",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shouldFreezeWhenBadDebt",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "minLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxLockBoost",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "canExit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "exitFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setVaultLimits",
          "inputs": [
            {
              "name": "_perUserMaxVaults",
              "type": "uint256"
            },
            {
              "name": "_perUserMaxAssetsPerVault",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStaleTime",
          "inputs": [
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanDeposit",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanWithdraw",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanBorrow",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanRepay",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanClaimLoot",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanLiquidate",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanRedeemCollateral",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanRedeemInStabPool",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanBuyInAuction",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanClaimInStabPool",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGlobalDebtLimits",
          "inputs": [
            {
              "name": "_perUserDebtLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDebtLimit",
              "type": "uint256"
            },
            {
              "name": "_minDebtAmount",
              "type": "uint256"
            },
            {
              "name": "_numAllowedBorrowers",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBorrowIntervalConfig",
          "inputs": [
            {
              "name": "_maxBorrowPerInterval",
              "type": "uint256"
            },
            {
              "name": "_numBlocksPerInterval",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDynamicRateConfig",
          "inputs": [
            {
              "name": "_minDynamicRateBoost",
              "type": "uint256"
            },
            {
              "name": "_maxDynamicRateBoost",
              "type": "uint256"
            },
            {
              "name": "_increasePerDangerBlock",
              "type": "uint256"
            },
            {
              "name": "_maxBorrowRate",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxLtvDeviation",
          "inputs": [
            {
              "name": "_newDeviation",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setKeeperConfig",
          "inputs": [
            {
              "name": "_keeperFeeRatio",
              "type": "uint256"
            },
            {
              "name": "_minKeeperFee",
              "type": "uint256"
            },
            {
              "name": "_maxKeeperFee",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setLtvPaybackBuffer",
          "inputs": [
            {
              "name": "_ltvPaybackBuffer",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGenAuctionParams",
          "inputs": [
            {
              "name": "_startDiscount",
              "type": "uint256"
            },
            {
              "name": "_maxDiscount",
              "type": "uint256"
            },
            {
              "name": "_delay",
              "type": "uint256"
            },
            {
              "name": "_duration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "areValidAuctionParams",
          "inputs": [
            {
              "name": "_params",
              "type": "tuple",
              "components": [
                {
                  "name": "hasParams",
                  "type": "bool"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "delay",
                  "type": "uint256"
                },
                {
                  "name": "duration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setIsDaowryEnabled",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipePerBlock",
          "inputs": [
            {
              "name": "_ripePerBlock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeRewardsAllocs",
          "inputs": [
            {
              "name": "_borrowersAlloc",
              "type": "uint256"
            },
            {
              "name": "_stakersAlloc",
              "type": "uint256"
            },
            {
              "name": "_votersAlloc",
              "type": "uint256"
            },
            {
              "name": "_genDepositorsAlloc",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAutoStakeParams",
          "inputs": [
            {
              "name": "_autoStakeRatio",
              "type": "uint256"
            },
            {
              "name": "_autoStakeDurationRatio",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRewardsPointsEnabled",
          "inputs": [
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityLiqAssetVaults",
          "inputs": [
            {
              "name": "_priorityLiqAssetVaults",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityStabVaults",
          "inputs": [
            {
              "name": "_priorityStabVaults",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setPriorityPriceSourceIds",
          "inputs": [
            {
              "name": "_priorityIds",
              "type": "uint256[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUnderscoreRegistry",
          "inputs": [
            {
              "name": "_underscoreRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPerformLiteAction",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canDo",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldCheckLastTouch",
          "inputs": [
            {
              "name": "_shouldCheck",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeGovVaultConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_assetWeight",
              "type": "uint256"
            },
            {
              "name": "_shouldFreezeWhenBadDebt",
              "type": "bool"
            },
            {
              "name": "_minLockDuration",
              "type": "uint256"
            },
            {
              "name": "_maxLockDuration",
              "type": "uint256"
            },
            {
              "name": "_maxLockBoost",
              "type": "uint256"
            },
            {
              "name": "_exitFee",
              "type": "uint256"
            },
            {
              "name": "_canExit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRipeRewardsConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "arePointsEnabled",
                  "type": "bool"
                },
                {
                  "name": "ripePerBlock",
                  "type": "uint256"
                },
                {
                  "name": "borrowersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "stakersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "votersAlloc",
                  "type": "uint256"
                },
                {
                  "name": "genDepositorsAlloc",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeRatio",
                  "type": "uint256"
                },
                {
                  "name": "autoStakeDurationRatio",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGeneralConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserMaxVaults",
                  "type": "uint256"
                },
                {
                  "name": "perUserMaxAssetsPerVault",
                  "type": "uint256"
                },
                {
                  "name": "priceStaleTime",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingDebtConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "perUserDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "globalDebtLimit",
                  "type": "uint256"
                },
                {
                  "name": "minDebtAmount",
                  "type": "uint256"
                },
                {
                  "name": "numAllowedBorrowers",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksPerInterval",
                  "type": "uint256"
                },
                {
                  "name": "minDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "maxDynamicRateBoost",
                  "type": "uint256"
                },
                {
                  "name": "increasePerDangerBlock",
                  "type": "uint256"
                },
                {
                  "name": "maxBorrowRate",
                  "type": "uint256"
                },
                {
                  "name": "maxLtvDeviation",
                  "type": "uint256"
                },
                {
                  "name": "keeperFeeRatio",
                  "type": "uint256"
                },
                {
                  "name": "minKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "maxKeeperFee",
                  "type": "uint256"
                },
                {
                  "name": "isDaowryEnabled",
                  "type": "bool"
                },
                {
                  "name": "ltvPaybackBuffer",
                  "type": "uint256"
                },
                {
                  "name": "genAuctionParams",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "hasParams",
                      "type": "bool"
                    },
                    {
                      "name": "startDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "maxDiscount",
                      "type": "uint256"
                    },
                    {
                      "name": "delay",
                      "type": "uint256"
                    },
                    {
                      "name": "duration",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPriorityLiqAssetVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPriorityStabVaults",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPriorityPriceSourceIds",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUnderscoreRegistry",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingCanPerformLiteAction",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "canDo",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingShouldCheckLastTouch",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRipeGovVaultConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "assetWeight",
                  "type": "uint256"
                },
                {
                  "name": "shouldFreezeWhenBadDebt",
                  "type": "bool"
                },
                {
                  "name": "lockTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "minLockDuration",
                      "type": "uint256"
                    },
                    {
                      "name": "maxLockDuration",
                      "type": "uint256"
                    },
                    {
                      "name": "maxLockBoost",
                      "type": "uint256"
                    },
                    {
                      "name": "canExit",
                      "type": "bool"
                    },
                    {
                      "name": "exitFee",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MIN_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "MAX_STALE_TIME",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minStaleTime",
              "type": "uint256"
            },
            {
              "name": "_maxStaleTime",
              "type": "uint256"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "d3cc46c981ea30e6cd26b22d4c6b6a72250055331934280527b5eb6de8ad8189"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "contracts/config/SwitchboardAlpha.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\nfrom interfaces import Vault\nimport interfaces.ConfigStructs as cs\n\ninterface MissionControl:\n    def setRipeGovVaultConfig(_asset: address, _assetWeight: uint256, _shouldFreezeWhenBadDebt: bool, _lockTerms: cs.LockTerms): nonpayable\n    def setPriorityLiqAssetVaults(_priorityLiqAssetVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]): nonpayable\n    def setPriorityPriceSourceIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]): nonpayable\n    def setPriorityStabVaults(_priorityStabVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]): nonpayable\n    def isSupportedAssetInVault(_vaultId: uint256, _asset: address) -> bool: view\n    def setRipeRewardsConfig(_rewardsConfig: cs.RipeRewardsConfig): nonpayable\n    def setCanPerformLiteAction(_user: address, _canDisable: bool): nonpayable\n    def setGeneralDebtConfig(_genDebtConfig: cs.GenDebtConfig): nonpayable\n    def setUnderscoreRegistry(_underscoreRegistry: address): nonpayable\n    def setShouldCheckLastTouch(_shouldCheck: bool): nonpayable\n    def setGeneralConfig(_genConfig: cs.GenConfig): nonpayable\n    def canPerformLiteAction(_user: address) -> bool: view\n    def isSupportedAsset(_asset: address) -> bool: view\n    def rewardsConfig() -> cs.RipeRewardsConfig: view\n    def genDebtConfig() -> cs.GenDebtConfig: view\n    def underscoreRegistry() -> address: view\n    def shouldCheckLastTouch() -> bool: view\n    def genConfig() -> cs.GenConfig: view\n\ninterface VaultBook:\n    def isValidRegId(_regId: uint256) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface PriceDesk:\n    def isValidRegId(_regId: uint256) -> bool: view\n\ninterface UnderscoreAgentFactory:\n    def isUserWallet(_addr: address) -> bool: view\n\ninterface UnderscoreRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface RipeHq:\n    def getAddr(_regId: uint256) -> address: view\n\nflag ActionType:\n    GEN_CONFIG_VAULT_LIMITS\n    GEN_CONFIG_STALE_TIME\n    DEBT_GLOBAL_LIMITS\n    DEBT_BORROW_INTERVAL\n    DEBT_DYNAMIC_RATE_CONFIG\n    DEBT_MAX_LTV_DEVIATION\n    DEBT_KEEPER_CONFIG\n    DEBT_LTV_PAYBACK_BUFFER\n    DEBT_AUCTION_PARAMS\n    RIPE_REWARDS_BLOCK\n    RIPE_REWARDS_ALLOCS\n    RIPE_REWARDS_AUTO_STAKE_PARAMS\n    OTHER_PRIORITY_LIQ_ASSET_VAULTS\n    OTHER_PRIORITY_STAB_VAULTS\n    OTHER_PRIORITY_PRICE_SOURCE_IDS\n    OTHER_UNDERSCORE_REGISTRY\n    OTHER_CAN_PERFORM_LITE_ACTION\n    OTHER_SHOULD_CHECK_LAST_TOUCH\n    RIPE_VAULT_CONFIG\n\nflag GenConfigFlag:\n    CAN_DEPOSIT\n    CAN_WITHDRAW\n    CAN_BORROW\n    CAN_REPAY\n    CAN_CLAIM_LOOT\n    CAN_LIQUIDATE\n    CAN_REDEEM_COLLATERAL\n    CAN_REDEEM_IN_STAB_POOL\n    CAN_BUY_IN_AUCTION\n    CAN_CLAIM_IN_STAB_POOL\n\nstruct GenConfigLite:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n\nstruct CanPerform:\n    user: address\n    canDo: bool\n\nstruct PendingRipeGovVaultConfig:\n    asset: address\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n    lockTerms: cs.LockTerms\n\nevent PendingVaultLimitsChange:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingStaleTimeChange:\n    priceStaleTime: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CanDepositSet:\n    canDeposit: bool\n    caller: indexed(address)\n\nevent CanWithdrawSet:\n    canWithdraw: bool\n    caller: indexed(address)\n\nevent CanBorrowSet:\n    canBorrow: bool\n    caller: indexed(address)\n\nevent CanRepaySet:\n    canRepay: bool\n    caller: indexed(address)\n\nevent CanClaimLootSet:\n    canClaimLoot: bool\n    caller: indexed(address)\n\nevent CanLiquidateSet:\n    canLiquidate: bool\n    caller: indexed(address)\n\nevent CanRedeemCollateralSet:\n    canRedeemCollateral: bool\n    caller: indexed(address)\n\nevent CanRedeemInStabPoolSet:\n    canRedeemInStabPool: bool\n    caller: indexed(address)\n\nevent CanBuyInAuctionSet:\n    canBuyInAuction: bool\n    caller: indexed(address)\n\nevent CanClaimInStabPoolSet:\n    canClaimInStabPool: bool\n    caller: indexed(address)\n\nevent PendingGlobalDebtLimitsChange:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingBorrowIntervalConfigChange:\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingDynamicRateConfigChange:\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingKeeperConfigChange:\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingLtvPaybackBufferChange:\n    ltvPaybackBuffer: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingDefaultAuctionParamsChange:\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent IsDaowryEnabledSet:\n    isDaowryEnabled: bool\n    caller: indexed(address)\n\nevent PendingRipeRewardsPerBlockChange:\n    ripePerBlock: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRipeRewardsAllocsChange:\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRipeRewardsAutoStakeParamsChange:\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent RewardsPointsEnabledModified:\n    arePointsEnabled: bool\n    caller: indexed(address)\n\nevent PendingPriorityLiqAssetVaultsChange:\n    numPriorityLiqAssetVaults: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingPriorityStabVaultsChange:\n    numPriorityStabVaults: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingPriorityPriceSourceIdsChange:\n    numPriorityPriceSourceIds: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingUnderscoreRegistryChange:\n    underscoreRegistry: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingCanPerformLiteAction:\n    user: address\n    canDo: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingShouldCheckLastTouchChange:\n    shouldCheck: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingMaxLtvDeviationChange:\n    newDeviation: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRipeGovVaultConfigChange:\n    asset: address\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent VaultLimitsSet:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n\nevent StaleTimeSet:\n    staleTime: uint256\n\nevent GlobalDebtLimitsSet:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n\nevent BorrowIntervalConfigSet:\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n\nevent DynamicRateConfigSet:\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n\nevent KeeperConfigSet:\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n\nevent LtvPaybackBufferSet:\n    ltvPaybackBuffer: uint256\n\nevent GenAuctionParamsSet:\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nevent RipeRewardsPerBlockSet:\n    ripePerBlock: uint256\n\nevent RipeRewardsAllocsSet:\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n\nevent RipeRewardsAutoStakeParamsSet:\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nevent PriorityLiqAssetVaultsSet:\n    numVaults: uint256\n\nevent PriorityStabVaultsSet:\n    numVaults: uint256\n\nevent PriorityPriceSourceIdsModified:\n    numIds: uint256\n\nevent UnderscoreRegistrySet:\n    addr: indexed(address)\n\nevent CanPerformLiteAction:\n    user: indexed(address)\n    canDo: bool\n\nevent ShouldCheckLastTouchSet:\n    shouldCheck: bool\n\nevent MaxLtvDeviationSet:\n    newDeviation: uint256\n\nevent RipeGovVaultConfigSet:\n    asset: address\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\n# pending config changes\nactionType: public(HashMap[uint256, ActionType]) # aid -> type\npendingRipeRewardsConfig: public(HashMap[uint256, cs.RipeRewardsConfig]) # aid -> config\npendingGeneralConfig: public(HashMap[uint256, GenConfigLite]) # aid -> config\npendingDebtConfig: public(HashMap[uint256, cs.GenDebtConfig]) # aid -> config\n\npendingPriorityLiqAssetVaults: public(HashMap[uint256, DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]])\npendingPriorityStabVaults: public(HashMap[uint256, DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]])\npendingPriorityPriceSourceIds: public(HashMap[uint256, DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]])\npendingUnderscoreRegistry: public(HashMap[uint256, address])\npendingCanPerformLiteAction: public(HashMap[uint256, CanPerform])\npendingShouldCheckLastTouch: public(HashMap[uint256, bool])\npendingRipeGovVaultConfig: public(HashMap[uint256, PendingRipeGovVaultConfig]) # aid -> config\n\n# temp data\nvaultDedupe: transient(HashMap[uint256, HashMap[address, bool]]) # vault id -> asset\n\nMIN_STALE_TIME: public(immutable(uint256))\nMAX_STALE_TIME: public(immutable(uint256))\n\nMAX_PRIORITY_PRICE_SOURCES: constant(uint256) = 10\nPRIORITY_VAULT_DATA: constant(uint256) = 20\nUNDERSCORE_AGENT_FACTORY_ID: constant(uint256) = 1\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\n\nMISSION_CONTROL_ID: constant(uint256) = 5\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minStaleTime: uint256,\n    _maxStaleTime: uint256,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n    assert _minStaleTime < _maxStaleTime # dev: invalid stale time range\n    MIN_STALE_TIME = _minStaleTime\n    MAX_STALE_TIME = _maxStaleTime\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPermsToEnable(_caller: address, _shouldEnable: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if not _shouldEnable:\n        return staticcall MissionControl(self._getMissionControlAddr()).canPerformLiteAction(_caller)\n    return False\n\n\n# addys lite\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(MISSION_CONTROL_ID)\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(PRICE_DESK_ID)\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(VAULT_BOOK_ID)\n\n\n##################\n# General Config #\n##################\n\n\n# vault limits\n\n\n@external\ndef setVaultLimits(_perUserMaxVaults: uint256, _perUserMaxAssetsPerVault: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidVaultLimits(_perUserMaxVaults, _perUserMaxAssetsPerVault) # dev: invalid vault limits\n    return self._setPendingGenConfig(ActionType.GEN_CONFIG_VAULT_LIMITS, _perUserMaxVaults, _perUserMaxAssetsPerVault)\n\n\n@view\n@internal\ndef _areValidVaultLimits(_perUserMaxVaults: uint256, _perUserMaxAssetsPerVault: uint256) -> bool:\n    if 0 in [_perUserMaxVaults, _perUserMaxAssetsPerVault]:\n        return False\n    if max_value(uint256) in [_perUserMaxVaults, _perUserMaxAssetsPerVault]:\n        return False\n    return True\n\n\n# stale time for prices\n\n\n@external\ndef setStaleTime(_staleTime: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidStaleTime(_staleTime) # dev: invalid stale time\n    return self._setPendingGenConfig(ActionType.GEN_CONFIG_STALE_TIME, 0, 0, _staleTime)\n\n\n@view\n@internal\ndef _isValidStaleTime(_staleTime: uint256) -> bool:\n    return _staleTime >= MIN_STALE_TIME and _staleTime <= MAX_STALE_TIME\n\n\n# set pending general config\n\n\n@internal\ndef _setPendingGenConfig(\n    _actionType: ActionType,\n    _perUserMaxVaults: uint256 = 0,\n    _perUserMaxAssetsPerVault: uint256 = 0,\n    _priceStaleTime: uint256 = 0,\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = _actionType\n    self.pendingGeneralConfig[aid] = GenConfigLite(\n        perUserMaxVaults=_perUserMaxVaults,\n        perUserMaxAssetsPerVault=_perUserMaxAssetsPerVault,\n        priceStaleTime=_priceStaleTime,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.GEN_CONFIG_VAULT_LIMITS:\n        log PendingVaultLimitsChange(\n            perUserMaxVaults=_perUserMaxVaults,\n            perUserMaxAssetsPerVault=_perUserMaxAssetsPerVault,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.GEN_CONFIG_STALE_TIME:\n        log PendingStaleTimeChange(\n            priceStaleTime=_priceStaleTime,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n# enable / disable\n\n\n@external\ndef setCanDeposit(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_DEPOSIT, _shouldEnable)\n\n\n@external\ndef setCanWithdraw(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_WITHDRAW, _shouldEnable)\n\n\n@external\ndef setCanBorrow(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_BORROW, _shouldEnable)\n\n\n@external\ndef setCanRepay(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_REPAY, _shouldEnable)\n\n\n@external\ndef setCanClaimLoot(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_CLAIM_LOOT, _shouldEnable)\n\n\n@external\ndef setCanLiquidate(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_LIQUIDATE, _shouldEnable)\n\n\n@external\ndef setCanRedeemCollateral(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_REDEEM_COLLATERAL, _shouldEnable)\n\n\n@external\ndef setCanRedeemInStabPool(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_REDEEM_IN_STAB_POOL, _shouldEnable)\n\n\n@external\ndef setCanBuyInAuction(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_BUY_IN_AUCTION, _shouldEnable)\n\n\n@external\ndef setCanClaimInStabPool(_shouldEnable: bool) -> bool:\n    return self._setGenConfigFlag(GenConfigFlag.CAN_CLAIM_IN_STAB_POOL, _shouldEnable)\n\n\n@internal\ndef _setGenConfigFlag(_flag: GenConfigFlag, _shouldEnable: bool) -> bool:\n    assert self._hasPermsToEnable(msg.sender, _shouldEnable) # dev: no perms\n\n    mc: address = self._getMissionControlAddr()\n    config: cs.GenConfig = staticcall MissionControl(mc).genConfig()\n\n    # get current value and validate\n    if _flag == GenConfigFlag.CAN_DEPOSIT:\n        assert config.canDeposit != _shouldEnable # dev: already set\n        config.canDeposit = _shouldEnable\n        log CanDepositSet(canDeposit=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_WITHDRAW:\n        assert config.canWithdraw != _shouldEnable # dev: already set\n        config.canWithdraw = _shouldEnable\n        log CanWithdrawSet(canWithdraw=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_BORROW:\n        assert config.canBorrow != _shouldEnable # dev: already set\n        config.canBorrow = _shouldEnable\n        log CanBorrowSet(canBorrow=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_REPAY:\n        assert config.canRepay != _shouldEnable # dev: already set\n        config.canRepay = _shouldEnable\n        log CanRepaySet(canRepay=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_CLAIM_LOOT:\n        assert config.canClaimLoot != _shouldEnable # dev: already set\n        config.canClaimLoot = _shouldEnable\n        log CanClaimLootSet(canClaimLoot=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_LIQUIDATE:\n        assert config.canLiquidate != _shouldEnable # dev: already set\n        config.canLiquidate = _shouldEnable\n        log CanLiquidateSet(canLiquidate=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_REDEEM_COLLATERAL:\n        assert config.canRedeemCollateral != _shouldEnable # dev: already set\n        config.canRedeemCollateral = _shouldEnable\n        log CanRedeemCollateralSet(canRedeemCollateral=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_REDEEM_IN_STAB_POOL:\n        assert config.canRedeemInStabPool != _shouldEnable # dev: already set\n        config.canRedeemInStabPool = _shouldEnable\n        log CanRedeemInStabPoolSet(canRedeemInStabPool=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_BUY_IN_AUCTION:\n        assert config.canBuyInAuction != _shouldEnable # dev: already set\n        config.canBuyInAuction = _shouldEnable\n        log CanBuyInAuctionSet(canBuyInAuction=_shouldEnable, caller=msg.sender)\n\n    elif _flag == GenConfigFlag.CAN_CLAIM_IN_STAB_POOL:\n        assert config.canClaimInStabPool != _shouldEnable # dev: already set\n        config.canClaimInStabPool = _shouldEnable\n        log CanClaimInStabPoolSet(canClaimInStabPool=_shouldEnable, caller=msg.sender)\n\n    extcall MissionControl(mc).setGeneralConfig(config)\n    return True\n\n\n###############\n# Debt Config #\n###############\n\n\n# global debt limits\n\n\n@external\ndef setGlobalDebtLimits(_perUserDebtLimit: uint256, _globalDebtLimit: uint256, _minDebtAmount: uint256, _numAllowedBorrowers: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidDebtLimits(_perUserDebtLimit, _globalDebtLimit, _minDebtAmount, _numAllowedBorrowers) # dev: invalid debt limits\n    return self._setPendingDebtConfig(ActionType.DEBT_GLOBAL_LIMITS, _perUserDebtLimit, _globalDebtLimit, _minDebtAmount, _numAllowedBorrowers)\n\n\n@view\n@internal\ndef _areValidDebtLimits(_perUserDebtLimit: uint256, _globalDebtLimit: uint256, _minDebtAmount: uint256, _numAllowedBorrowers: uint256) -> bool:\n    if 0 in [_perUserDebtLimit, _globalDebtLimit, _numAllowedBorrowers]:\n        return False\n    if max_value(uint256) in [_perUserDebtLimit, _globalDebtLimit, _minDebtAmount, _numAllowedBorrowers]:\n        return False\n    if _perUserDebtLimit > _globalDebtLimit:\n        return False\n    if _minDebtAmount > _perUserDebtLimit:\n        return False\n    return True\n\n\n# borrow intervals\n\n\n@external\ndef setBorrowIntervalConfig(_maxBorrowPerInterval: uint256, _numBlocksPerInterval: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._areValidBorrowIntervalConfig(_maxBorrowPerInterval, _numBlocksPerInterval) # dev: invalid borrow interval config\n    return self._setPendingDebtConfig(ActionType.DEBT_BORROW_INTERVAL, 0, 0, 0, 0, _maxBorrowPerInterval, _numBlocksPerInterval)\n\n\n@view\n@internal\ndef _areValidBorrowIntervalConfig(_maxBorrowPerInterval: uint256, _numBlocksPerInterval: uint256) -> bool:\n    if 0 in [_maxBorrowPerInterval, _numBlocksPerInterval]:\n        return False\n    if max_value(uint256) in [_maxBorrowPerInterval, _numBlocksPerInterval]:\n        return False\n    config: cs.GenDebtConfig = staticcall MissionControl(self._getMissionControlAddr()).genDebtConfig()\n    if _maxBorrowPerInterval < config.minDebtAmount:\n        return False\n    return True\n\n\n# dynamic rate config\n\n\n@external\ndef setDynamicRateConfig(_minDynamicRateBoost: uint256, _maxDynamicRateBoost: uint256, _increasePerDangerBlock: uint256, _maxBorrowRate: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self._isValidDynamicRateConfig(_minDynamicRateBoost, _maxDynamicRateBoost, _increasePerDangerBlock, _maxBorrowRate) # dev: invalid dynamic rate config\n    return self._setPendingDebtConfig(ActionType.DEBT_DYNAMIC_RATE_CONFIG, 0, 0, 0, 0, 0, 0, _minDynamicRateBoost, _maxDynamicRateBoost, _increasePerDangerBlock, _maxBorrowRate)\n\n\n@view\n@internal\ndef _isValidDynamicRateConfig(_minDynamicRateBoost: uint256, _maxDynamicRateBoost: uint256, _increasePerDangerBlock: uint256, _maxBorrowRate: uint256) -> bool:\n    # NOTE: denominator for `_increasePerDangerBlock` is 100_0000 (100.0000%)\n\n    if 0 in [_minDynamicRateBoost, _maxDynamicRateBoost, _increasePerDangerBlock, _maxBorrowRate]:\n        return False\n    if max_value(uint256) in [_minDynamicRateBoost, _maxDynamicRateBoost, _increasePerDangerBlock, _maxBorrowRate]:\n        return False\n    if _minDynamicRateBoost > _maxDynamicRateBoost:\n        return False\n    if _maxDynamicRateBoost > 1000_00: # 1000% max\n        return False\n    if _maxBorrowRate > 200_00: # 200% max\n        return False\n    return True\n\n\n# max ltv deviation\n\n\n@external\ndef setMaxLtvDeviation(_newDeviation: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidMaxDeviation(_newDeviation) # dev: invalid max deviation\n    return self._setPendingDebtConfig(ActionType.DEBT_MAX_LTV_DEVIATION, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, _newDeviation)\n\n\n@view\n@internal\ndef _isValidMaxDeviation(_newDeviation: uint256) -> bool:\n    if _newDeviation == 0:\n        return False\n    return _newDeviation <= HUNDRED_PERCENT\n\n\n# keeper config\n\n\n@external\ndef setKeeperConfig(\n    _keeperFeeRatio: uint256,\n    _minKeeperFee: uint256,\n    _maxKeeperFee: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidKeeperConfig(_keeperFeeRatio, _minKeeperFee, _maxKeeperFee) # dev: invalid keeper config\n    return self._setPendingDebtConfig(ActionType.DEBT_KEEPER_CONFIG, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, _keeperFeeRatio, _minKeeperFee, _maxKeeperFee)\n\n\n@view\n@internal\ndef _isValidKeeperConfig(_keeperFeeRatio: uint256, _minKeeperFee: uint256, _maxKeeperFee: uint256) -> bool:\n    if max_value(uint256) in [_keeperFeeRatio, _minKeeperFee, _maxKeeperFee]:\n        return False\n    if _keeperFeeRatio > 10_00: # 10% max\n        return False\n    if _minKeeperFee > _maxKeeperFee:\n        return False\n    if _minKeeperFee > 200 * EIGHTEEN_DECIMALS: # $200 max\n        return False\n    if _maxKeeperFee > 100_000 * EIGHTEEN_DECIMALS: # 100k max\n        return False\n    return True\n\n\n# ltv payback buffer\n\n\n@external\ndef setLtvPaybackBuffer(_ltvPaybackBuffer: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidLtvPaybackBuffer(_ltvPaybackBuffer) # dev: invalid ltv payback buffer\n    return self._setPendingDebtConfig(ActionType.DEBT_LTV_PAYBACK_BUFFER, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, _ltvPaybackBuffer)\n\n\n@view\n@internal\ndef _isValidLtvPaybackBuffer(_ltvPaybackBuffer: uint256) -> bool:\n    if _ltvPaybackBuffer == 0 or _ltvPaybackBuffer > 10_00: # 10% max\n        return False\n    return True\n\n\n# gen auction params\n\n\n@external\ndef setGenAuctionParams(\n    _startDiscount: uint256,\n    _maxDiscount: uint256,\n    _delay: uint256,\n    _duration: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    params: cs.AuctionParams= cs.AuctionParams(\n        hasParams=True,\n        startDiscount=_startDiscount,\n        maxDiscount=_maxDiscount,\n        delay=_delay,\n        duration=_duration,\n    )\n    assert self._areValidAuctionParams(params) # dev: invalid auction params\n    return self._setPendingDebtConfig(ActionType.DEBT_AUCTION_PARAMS, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, params)\n\n\n@view\n@external\ndef areValidAuctionParams(_params: cs.AuctionParams) -> bool:\n    return self._areValidAuctionParams(_params)\n\n\n@view\n@internal\ndef _areValidAuctionParams(_params: cs.AuctionParams) -> bool:\n    if not _params.hasParams:\n        return False\n    if _params.startDiscount > HUNDRED_PERCENT:\n        return False\n    if _params.maxDiscount > HUNDRED_PERCENT:\n        return False\n    if _params.startDiscount >= _params.maxDiscount:\n        return False\n    if _params.delay == max_value(uint256):\n        return False\n    if _params.duration == 0 or _params.duration == max_value(uint256):\n        return False\n    return True\n\n\n# set pending debt config\n\n\n@internal\ndef _setPendingDebtConfig(\n    _actionType: ActionType,\n    _perUserDebtLimit: uint256 = 0,\n    _globalDebtLimit: uint256 = 0,\n    _minDebtAmount: uint256 = 0,\n    _numAllowedBorrowers: uint256 = 0,\n    _maxBorrowPerInterval: uint256 = 0,\n    _numBlocksPerInterval: uint256 = 0,\n    _minDynamicRateBoost: uint256 = 0,\n    _maxDynamicRateBoost: uint256 = 0,\n    _increasePerDangerBlock: uint256 = 0,\n    _maxBorrowRate: uint256 = 0,\n    _maxLtvDeviation: uint256 = 0,\n    _keeperFeeRatio: uint256 = 0,\n    _minKeeperFee: uint256 = 0,\n    _maxKeeperFee: uint256 = 0,\n    _ltvPaybackBuffer: uint256 = 0,\n    _genAuctionParams: cs.AuctionParams = empty(cs.AuctionParams),\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = _actionType\n    self.pendingDebtConfig[aid] = cs.GenDebtConfig(\n        perUserDebtLimit=_perUserDebtLimit,\n        globalDebtLimit=_globalDebtLimit,\n        minDebtAmount=_minDebtAmount,\n        numAllowedBorrowers=_numAllowedBorrowers,\n        maxBorrowPerInterval=_maxBorrowPerInterval,\n        numBlocksPerInterval=_numBlocksPerInterval,\n        minDynamicRateBoost=_minDynamicRateBoost,\n        maxDynamicRateBoost=_maxDynamicRateBoost,\n        increasePerDangerBlock=_increasePerDangerBlock,\n        maxBorrowRate=_maxBorrowRate,\n        maxLtvDeviation=_maxLtvDeviation,\n        keeperFeeRatio=_keeperFeeRatio,\n        minKeeperFee=_minKeeperFee,\n        maxKeeperFee=_maxKeeperFee,\n        isDaowryEnabled=False,\n        ltvPaybackBuffer=_ltvPaybackBuffer,\n        genAuctionParams=_genAuctionParams,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.DEBT_GLOBAL_LIMITS:\n        log PendingGlobalDebtLimitsChange(\n            perUserDebtLimit=_perUserDebtLimit,\n            globalDebtLimit=_globalDebtLimit,\n            minDebtAmount=_minDebtAmount,\n            numAllowedBorrowers=_numAllowedBorrowers,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEBT_BORROW_INTERVAL:\n        log PendingBorrowIntervalConfigChange(\n            maxBorrowPerInterval=_maxBorrowPerInterval,\n            numBlocksPerInterval=_numBlocksPerInterval,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEBT_DYNAMIC_RATE_CONFIG:\n        log PendingDynamicRateConfigChange(\n            minDynamicRateBoost=_minDynamicRateBoost,\n            maxDynamicRateBoost=_maxDynamicRateBoost,\n            increasePerDangerBlock=_increasePerDangerBlock,\n            maxBorrowRate=_maxBorrowRate,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEBT_MAX_LTV_DEVIATION:\n        log PendingMaxLtvDeviationChange(\n            newDeviation=_maxLtvDeviation,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEBT_KEEPER_CONFIG:\n        log PendingKeeperConfigChange(\n            keeperFeeRatio=_keeperFeeRatio,\n            minKeeperFee=_minKeeperFee,\n            maxKeeperFee=_maxKeeperFee,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEBT_LTV_PAYBACK_BUFFER:\n        log PendingLtvPaybackBufferChange(\n            ltvPaybackBuffer=_ltvPaybackBuffer,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.DEBT_AUCTION_PARAMS:\n        log PendingDefaultAuctionParamsChange(\n            startDiscount=_genAuctionParams.startDiscount,\n            maxDiscount=_genAuctionParams.maxDiscount,\n            delay=_genAuctionParams.delay,\n            duration=_genAuctionParams.duration,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n# daowry\n\n\n@external\ndef setIsDaowryEnabled(_shouldEnable: bool) -> bool:\n    assert self._hasPermsToEnable(msg.sender, _shouldEnable) # dev: no perms\n\n    mc: address = self._getMissionControlAddr()\n    config: cs.GenDebtConfig = staticcall MissionControl(mc).genDebtConfig()\n    assert config.isDaowryEnabled != _shouldEnable # dev: already set\n    config.isDaowryEnabled = _shouldEnable\n    extcall MissionControl(mc).setGeneralDebtConfig(config)\n\n    log IsDaowryEnabledSet(isDaowryEnabled=_shouldEnable, caller=msg.sender)\n    return True\n\n\n####################\n# Rewards / Points #\n####################\n\n\n# ripe per block\n\n\n@external\ndef setRipePerBlock(_ripePerBlock: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _ripePerBlock != max_value(uint256) # dev: invalid ripe per block\n    return self._setPendingRipeRewardsConfig(ActionType.RIPE_REWARDS_BLOCK, _ripePerBlock)\n\n\n# allocs\n\n\n@external\ndef setRipeRewardsAllocs(\n    _borrowersAlloc: uint256,\n    _stakersAlloc: uint256,\n    _votersAlloc: uint256,\n    _genDepositorsAlloc: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self._areValidRipeRewardsAllocs(_borrowersAlloc, _stakersAlloc, _votersAlloc, _genDepositorsAlloc) # dev: invalid rewards allocs\n    return self._setPendingRipeRewardsConfig(ActionType.RIPE_REWARDS_ALLOCS, 0, _borrowersAlloc, _stakersAlloc, _votersAlloc, _genDepositorsAlloc)\n\n\n@view\n@internal\ndef _areValidRipeRewardsAllocs(_borrowersAlloc: uint256, _stakersAlloc: uint256, _votersAlloc: uint256, _genDepositorsAlloc: uint256) -> bool:\n    if _borrowersAlloc + _stakersAlloc + _votersAlloc + _genDepositorsAlloc > HUNDRED_PERCENT:\n        return False\n    return True\n\n\n# auto stake ratios\n\n\n@external\ndef setAutoStakeParams(_autoStakeRatio: uint256, _autoStakeDurationRatio: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self._areValidAutoStakeParams(_autoStakeRatio, _autoStakeDurationRatio) # dev: invalid auto stake params\n    return self._setPendingRipeRewardsConfig(ActionType.RIPE_REWARDS_AUTO_STAKE_PARAMS, 0, 0, 0, 0, 0, _autoStakeRatio, _autoStakeDurationRatio)\n\n\n@view\n@internal\ndef _areValidAutoStakeParams(_autoStakeRatio: uint256, _autoStakeDurationRatio: uint256) -> bool:\n    if _autoStakeRatio > HUNDRED_PERCENT:\n        return False\n    if _autoStakeDurationRatio > HUNDRED_PERCENT:\n        return False\n    return True\n\n\n# set pending ripe rewards config\n\n\n@internal\ndef _setPendingRipeRewardsConfig(\n    _actionType: ActionType,\n    _ripePerBlock: uint256 = 0,\n    _borrowersAlloc: uint256 = 0,\n    _stakersAlloc: uint256 = 0,\n    _votersAlloc: uint256 = 0,\n    _genDepositorsAlloc: uint256 = 0,\n    _autoStakeRatio: uint256 = 0,\n    _autoStakeDurationRatio: uint256 = 0,\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = _actionType\n    self.pendingRipeRewardsConfig[aid] = cs.RipeRewardsConfig(\n        arePointsEnabled=False,\n        ripePerBlock=_ripePerBlock,\n        borrowersAlloc=_borrowersAlloc,\n        stakersAlloc=_stakersAlloc,\n        votersAlloc=_votersAlloc,\n        genDepositorsAlloc=_genDepositorsAlloc,\n        autoStakeRatio=_autoStakeRatio,\n        autoStakeDurationRatio=_autoStakeDurationRatio,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.RIPE_REWARDS_BLOCK:\n        log PendingRipeRewardsPerBlockChange(\n            ripePerBlock=_ripePerBlock,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n\n    elif _actionType == ActionType.RIPE_REWARDS_ALLOCS:\n        log PendingRipeRewardsAllocsChange(\n            borrowersAlloc=_borrowersAlloc,\n            stakersAlloc=_stakersAlloc,\n            votersAlloc=_votersAlloc,\n            genDepositorsAlloc=_genDepositorsAlloc,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.RIPE_REWARDS_AUTO_STAKE_PARAMS:\n        log PendingRipeRewardsAutoStakeParamsChange(\n            autoStakeRatio=_autoStakeRatio,\n            autoStakeDurationRatio=_autoStakeDurationRatio,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n# enable points\n\n\n@external\ndef setRewardsPointsEnabled(_shouldEnable: bool) -> bool:\n    assert self._hasPermsToEnable(msg.sender, _shouldEnable) # dev: no perms\n\n    mc: address = self._getMissionControlAddr()\n    rewardsConfig: cs.RipeRewardsConfig = staticcall MissionControl(mc).rewardsConfig()\n    assert rewardsConfig.arePointsEnabled != _shouldEnable # dev: already set\n    rewardsConfig.arePointsEnabled = _shouldEnable\n    extcall MissionControl(mc).setRipeRewardsConfig(rewardsConfig)\n\n    log RewardsPointsEnabledModified(arePointsEnabled=_shouldEnable, caller=msg.sender)\n    return True\n\n\n#######################\n# Priority Vault Data #\n#######################\n\n\n# priority liquidation\n\n\n@external\ndef setPriorityLiqAssetVaults(_priorityLiqAssetVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    priorityVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA] = self._sanitizePriorityVaults(_priorityLiqAssetVaults)\n    assert len(priorityVaults) != 0 # dev: invalid priority vaults\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.OTHER_PRIORITY_LIQ_ASSET_VAULTS\n    self.pendingPriorityLiqAssetVaults[aid] = priorityVaults\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingPriorityLiqAssetVaultsChange(\n        numPriorityLiqAssetVaults=len(priorityVaults),\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n# priority stability pools\n\n\n@external\ndef setPriorityStabVaults(_priorityStabVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    priorityVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA] = self._sanitizePriorityVaults(_priorityStabVaults)\n    assert len(priorityVaults) != 0 # dev: invalid priority vaults\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.OTHER_PRIORITY_STAB_VAULTS\n    self.pendingPriorityStabVaults[aid] = priorityVaults\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingPriorityStabVaultsChange(\n        numPriorityStabVaults=len(priorityVaults),\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n# sanitize\n\n\n@internal\ndef _sanitizePriorityVaults(_priorityVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]) -> DynArray[cs.VaultLite, PRIORITY_VAULT_DATA]:\n    sanitizedVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA] = []\n    vaultBook: address = self._getVaultBookAddr()\n    mc: address = self._getMissionControlAddr()\n    for vault: cs.VaultLite in _priorityVaults:\n        if self.vaultDedupe[vault.vaultId][vault.asset]:\n            continue\n        if not staticcall VaultBook(vaultBook).isValidRegId(vault.vaultId):\n            continue\n        if not staticcall MissionControl(mc).isSupportedAssetInVault(vault.vaultId, vault.asset):\n            continue\n        sanitizedVaults.append(vault)\n        self.vaultDedupe[vault.vaultId][vault.asset] = True\n    return sanitizedVaults\n\n\n#############################\n# Prices - Priority Sources #\n#############################\n\n\n@external\ndef setPriorityPriceSourceIds(_priorityIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    priorityIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES] = self._sanitizePrioritySources(_priorityIds)\n    assert len(priorityIds) != 0 # dev: invalid priority sources\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.OTHER_PRIORITY_PRICE_SOURCE_IDS\n    self.pendingPriorityPriceSourceIds[aid] = priorityIds\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingPriorityPriceSourceIdsChange(\n        numPriorityPriceSourceIds=len(priorityIds),\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@view\n@internal\ndef _sanitizePrioritySources(_priorityIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]) -> DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]:\n    sanitizedIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES] = []\n    priceDesk: address = self._getPriceDeskAddr()\n    for pid: uint256 in _priorityIds:\n        if not staticcall PriceDesk(priceDesk).isValidRegId(pid):\n            continue\n        if pid in sanitizedIds:\n            continue\n        sanitizedIds.append(pid)\n    return sanitizedIds\n\n\n#######################\n# Underscore Registry #\n#######################\n\n\n@external\ndef setUnderscoreRegistry(_underscoreRegistry: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert self._isValidUnderscoreAddr(_underscoreRegistry) # dev: invalid underscore registry\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.OTHER_UNDERSCORE_REGISTRY\n    self.pendingUnderscoreRegistry[aid] = _underscoreRegistry\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingUnderscoreRegistryChange(\n        underscoreRegistry=_underscoreRegistry,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidUnderscoreAddr(_addr: address) -> bool:\n    agentFactory: address = staticcall UnderscoreRegistry(_addr).getAddy(UNDERSCORE_AGENT_FACTORY_ID)\n    if agentFactory == empty(address):\n        return False\n\n    # make sure has interface\n    return not staticcall UnderscoreAgentFactory(agentFactory).isUserWallet(empty(address))\n\n\n###########################\n# Can Perform Lite Action #\n###########################\n\n\n@external\ndef setCanPerformLiteAction(_user: address, _canDo: bool) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.OTHER_CAN_PERFORM_LITE_ACTION\n    self.pendingCanPerformLiteAction[aid] = CanPerform(user=_user, canDo=_canDo)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingCanPerformLiteAction(user=_user, canDo=_canDo, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n###########################\n# Should Check Last Touch #\n###########################\n\n\n@external\ndef setShouldCheckLastTouch(_shouldCheck: bool) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.OTHER_SHOULD_CHECK_LAST_TOUCH\n    self.pendingShouldCheckLastTouch[aid] = _shouldCheck\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingShouldCheckLastTouchChange(shouldCheck=_shouldCheck, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n#########################\n# Ripe Gov Vault Config #\n#########################\n\n\n@external\ndef setRipeGovVaultConfig(\n    _asset: address,\n    _assetWeight: uint256,\n    _shouldFreezeWhenBadDebt: bool,\n    _minLockDuration: uint256,\n    _maxLockDuration: uint256,\n    _maxLockBoost: uint256,\n    _exitFee: uint256,\n    _canExit: bool,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    lockTerms: cs.LockTerms = cs.LockTerms(\n        minLockDuration=_minLockDuration,\n        maxLockDuration=_maxLockDuration,\n        maxLockBoost=_maxLockBoost,\n        canExit=_canExit,\n        exitFee=_exitFee,\n    )\n    assert self._isValidRipeVaultConfig(_asset, _assetWeight, lockTerms) # dev: invalid ripe vault config\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_VAULT_CONFIG\n    self.pendingRipeGovVaultConfig[aid] = PendingRipeGovVaultConfig(\n        asset=_asset,\n        assetWeight=_assetWeight,\n        shouldFreezeWhenBadDebt=_shouldFreezeWhenBadDebt,\n        lockTerms=lockTerms,\n    )\n\n    log PendingRipeGovVaultConfigChange(\n        asset=_asset,\n        assetWeight=_assetWeight,\n        shouldFreezeWhenBadDebt=_shouldFreezeWhenBadDebt,\n        minLockDuration=_minLockDuration,\n        maxLockDuration=_maxLockDuration,\n        maxLockBoost=_maxLockBoost,\n        canExit=_canExit,\n        exitFee=_exitFee,\n        confirmationBlock=timeLock._getActionConfirmationBlock(aid),\n        actionId=aid,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidRipeVaultConfig(_asset: address, _assetWeight: uint256, _lockTerms: cs.LockTerms) -> bool:\n    if _asset == empty(address):\n        return False\n\n    mc: address = self._getMissionControlAddr()\n    if not staticcall MissionControl(mc).isSupportedAsset(_asset):\n        return False\n\n    # NOTE: this assumes that vault id 2 is ripe gov vault !!\n    if not staticcall MissionControl(mc).isSupportedAssetInVault(2, _asset):\n        return False\n\n    if _assetWeight > 500_00: # max 500%\n        return False\n\n    if _lockTerms.minLockDuration > _lockTerms.maxLockDuration:\n        return False\n\n    if _lockTerms.maxLockBoost > 1000_00: # max 1000%\n        return False\n\n    if _lockTerms.exitFee > HUNDRED_PERCENT:\n        return False\n\n    if _lockTerms.canExit and _lockTerms.exitFee == 0:\n        return False\n\n    if not _lockTerms.canExit and _lockTerms.exitFee != 0:\n        return False\n\n    return True\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n    mc: address = self._getMissionControlAddr()\n\n    if actionType == ActionType.GEN_CONFIG_VAULT_LIMITS:\n        config: cs.GenConfig = staticcall MissionControl(mc).genConfig()\n        p: GenConfigLite = self.pendingGeneralConfig[_aid]\n        config.perUserMaxVaults = p.perUserMaxVaults\n        config.perUserMaxAssetsPerVault = p.perUserMaxAssetsPerVault\n        extcall MissionControl(mc).setGeneralConfig(config)\n        log VaultLimitsSet(perUserMaxVaults=p.perUserMaxVaults, perUserMaxAssetsPerVault=p.perUserMaxAssetsPerVault)\n\n    elif actionType == ActionType.GEN_CONFIG_STALE_TIME:\n        config: cs.GenConfig = staticcall MissionControl(mc).genConfig()\n        config.priceStaleTime = self.pendingGeneralConfig[_aid].priceStaleTime\n        extcall MissionControl(mc).setGeneralConfig(config)\n        log StaleTimeSet(staleTime=config.priceStaleTime)\n\n    elif actionType == ActionType.DEBT_GLOBAL_LIMITS:\n        config: cs.GenDebtConfig = staticcall MissionControl(mc).genDebtConfig()\n        p: cs.GenDebtConfig = self.pendingDebtConfig[_aid]\n        config.perUserDebtLimit = p.perUserDebtLimit\n        config.globalDebtLimit = p.globalDebtLimit\n        config.minDebtAmount = p.minDebtAmount\n        config.numAllowedBorrowers = p.numAllowedBorrowers\n        extcall MissionControl(mc).setGeneralDebtConfig(config)\n        log GlobalDebtLimitsSet(perUserDebtLimit=p.perUserDebtLimit, globalDebtLimit=p.globalDebtLimit, minDebtAmount=p.minDebtAmount, numAllowedBorrowers=p.numAllowedBorrowers)\n\n    elif actionType == ActionType.DEBT_BORROW_INTERVAL:\n        config: cs.GenDebtConfig = staticcall MissionControl(mc).genDebtConfig()\n        p: cs.GenDebtConfig = self.pendingDebtConfig[_aid]\n        config.maxBorrowPerInterval = p.maxBorrowPerInterval\n        config.numBlocksPerInterval = p.numBlocksPerInterval\n        extcall MissionControl(mc).setGeneralDebtConfig(config)\n        log BorrowIntervalConfigSet(maxBorrowPerInterval=p.maxBorrowPerInterval, numBlocksPerInterval=p.numBlocksPerInterval)\n\n    elif actionType == ActionType.DEBT_DYNAMIC_RATE_CONFIG:\n        config: cs.GenDebtConfig = staticcall MissionControl(mc).genDebtConfig()\n        p: cs.GenDebtConfig = self.pendingDebtConfig[_aid]\n        config.minDynamicRateBoost = p.minDynamicRateBoost\n        config.maxDynamicRateBoost = p.maxDynamicRateBoost\n        config.increasePerDangerBlock = p.increasePerDangerBlock\n        config.maxBorrowRate = p.maxBorrowRate\n        extcall MissionControl(mc).setGeneralDebtConfig(config)\n        log DynamicRateConfigSet(minDynamicRateBoost=p.minDynamicRateBoost, maxDynamicRateBoost=p.maxDynamicRateBoost, increasePerDangerBlock=p.increasePerDangerBlock, maxBorrowRate=p.maxBorrowRate)\n\n    elif actionType == ActionType.DEBT_MAX_LTV_DEVIATION:\n        config: cs.GenDebtConfig = staticcall MissionControl(mc).genDebtConfig()\n        config.maxLtvDeviation = self.pendingDebtConfig[_aid].maxLtvDeviation\n        extcall MissionControl(mc).setGeneralDebtConfig(config)\n        log MaxLtvDeviationSet(newDeviation=config.maxLtvDeviation)\n\n    elif actionType == ActionType.DEBT_KEEPER_CONFIG:\n        config: cs.GenDebtConfig = staticcall MissionControl(mc).genDebtConfig()\n        p: cs.GenDebtConfig = self.pendingDebtConfig[_aid]\n        config.keeperFeeRatio = p.keeperFeeRatio\n        config.minKeeperFee = p.minKeeperFee\n        config.maxKeeperFee = p.maxKeeperFee\n        extcall MissionControl(mc).setGeneralDebtConfig(config)\n        log KeeperConfigSet(keeperFeeRatio=p.keeperFeeRatio, minKeeperFee=p.minKeeperFee, maxKeeperFee=p.maxKeeperFee)\n\n    elif actionType == ActionType.DEBT_LTV_PAYBACK_BUFFER:\n        config: cs.GenDebtConfig = staticcall MissionControl(mc).genDebtConfig()\n        config.ltvPaybackBuffer = self.pendingDebtConfig[_aid].ltvPaybackBuffer\n        extcall MissionControl(mc).setGeneralDebtConfig(config)\n        log LtvPaybackBufferSet(ltvPaybackBuffer=config.ltvPaybackBuffer)\n\n    elif actionType == ActionType.DEBT_AUCTION_PARAMS:\n        config: cs.GenDebtConfig = staticcall MissionControl(mc).genDebtConfig()\n        p: cs.GenDebtConfig = self.pendingDebtConfig[_aid]\n        config.genAuctionParams = p.genAuctionParams\n        extcall MissionControl(mc).setGeneralDebtConfig(config)\n        log GenAuctionParamsSet(startDiscount=p.genAuctionParams.startDiscount, maxDiscount=p.genAuctionParams.maxDiscount, delay=p.genAuctionParams.delay, duration=p.genAuctionParams.duration)\n\n    elif actionType == ActionType.RIPE_REWARDS_BLOCK:\n        config: cs.RipeRewardsConfig = staticcall MissionControl(mc).rewardsConfig()\n        config.ripePerBlock = self.pendingRipeRewardsConfig[_aid].ripePerBlock\n        extcall MissionControl(mc).setRipeRewardsConfig(config)\n        log RipeRewardsPerBlockSet(ripePerBlock=config.ripePerBlock)\n\n    elif actionType == ActionType.RIPE_REWARDS_ALLOCS:\n        config: cs.RipeRewardsConfig = staticcall MissionControl(mc).rewardsConfig()\n        p: cs.RipeRewardsConfig = self.pendingRipeRewardsConfig[_aid]\n        config.borrowersAlloc = p.borrowersAlloc\n        config.stakersAlloc = p.stakersAlloc\n        config.votersAlloc = p.votersAlloc\n        config.genDepositorsAlloc = p.genDepositorsAlloc\n        extcall MissionControl(mc).setRipeRewardsConfig(config)\n        log RipeRewardsAllocsSet(borrowersAlloc=p.borrowersAlloc, stakersAlloc=p.stakersAlloc, votersAlloc=p.votersAlloc, genDepositorsAlloc=p.genDepositorsAlloc)\n\n    elif actionType == ActionType.RIPE_REWARDS_AUTO_STAKE_PARAMS:\n        config: cs.RipeRewardsConfig = staticcall MissionControl(mc).rewardsConfig()\n        p: cs.RipeRewardsConfig = self.pendingRipeRewardsConfig[_aid]\n        config.autoStakeRatio = p.autoStakeRatio\n        config.autoStakeDurationRatio = p.autoStakeDurationRatio\n        extcall MissionControl(mc).setRipeRewardsConfig(config)\n        log RipeRewardsAutoStakeParamsSet(autoStakeRatio=p.autoStakeRatio, autoStakeDurationRatio=p.autoStakeDurationRatio)\n\n    elif actionType == ActionType.OTHER_PRIORITY_LIQ_ASSET_VAULTS:\n        priorityVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA] = self.pendingPriorityLiqAssetVaults[_aid]\n        extcall MissionControl(mc).setPriorityLiqAssetVaults(priorityVaults)\n        log PriorityLiqAssetVaultsSet(numVaults=len(priorityVaults))\n\n    elif actionType == ActionType.OTHER_PRIORITY_STAB_VAULTS:\n        priorityVaults: DynArray[cs.VaultLite, PRIORITY_VAULT_DATA] = self.pendingPriorityStabVaults[_aid]\n        extcall MissionControl(mc).setPriorityStabVaults(priorityVaults)\n        log PriorityStabVaultsSet(numVaults=len(priorityVaults))\n\n    elif actionType == ActionType.OTHER_PRIORITY_PRICE_SOURCE_IDS:\n        priorityIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES] = self.pendingPriorityPriceSourceIds[_aid]\n        extcall MissionControl(mc).setPriorityPriceSourceIds(priorityIds)\n        log PriorityPriceSourceIdsModified(numIds=len(priorityIds))\n\n    elif actionType == ActionType.OTHER_UNDERSCORE_REGISTRY:\n        underscoreRegistry: address = self.pendingUnderscoreRegistry[_aid]\n        extcall MissionControl(mc).setUnderscoreRegistry(underscoreRegistry)\n        log UnderscoreRegistrySet(addr=underscoreRegistry)\n\n    elif actionType == ActionType.OTHER_CAN_PERFORM_LITE_ACTION:\n        data: CanPerform = self.pendingCanPerformLiteAction[_aid]\n        extcall MissionControl(mc).setCanPerformLiteAction(data.user, data.canDo)\n        log CanPerformLiteAction(user=data.user, canDo=data.canDo)\n\n    elif actionType == ActionType.OTHER_SHOULD_CHECK_LAST_TOUCH:\n        shouldCheck: bool = self.pendingShouldCheckLastTouch[_aid]\n        extcall MissionControl(mc).setShouldCheckLastTouch(shouldCheck)\n        log ShouldCheckLastTouchSet(shouldCheck=shouldCheck)\n\n    elif actionType == ActionType.RIPE_VAULT_CONFIG:\n        p: PendingRipeGovVaultConfig = self.pendingRipeGovVaultConfig[_aid]\n        extcall MissionControl(mc).setRipeGovVaultConfig(p.asset, p.assetWeight, p.shouldFreezeWhenBadDebt, p.lockTerms)\n        log RipeGovVaultConfigSet(asset=p.asset, assetWeight=p.assetWeight, shouldFreezeWhenBadDebt=p.shouldFreezeWhenBadDebt, minLockDuration=p.lockTerms.minLockDuration, maxLockDuration=p.lockTerms.maxLockDuration, maxLockBoost=p.lockTerms.maxLockBoost, canExit=p.lockTerms.canExit, exitFee=p.lockTerms.exitFee)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n# cancel action\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)",
            "sha256sum": "34b156d7807d8b7ceb92c69bde30a4e4ac54210f94efe0164a42754f674e27b9"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardAlpha.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "6040a207b43d23d957e1a4c70e78fe3204d6c8170bb8d89157dec7b786343438"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000003f480000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/config/SwitchboardAlpha.vy"
    },
    "SwitchboardBravo": {
      "address": "0x020B0D64e19cB0C703a10F73A1201D62Db7576F1",
      "abi": [
        {
          "name": "NewAssetPending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numVaults",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stakersPointsAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "voterPointsAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "perUserDepositLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "globalDepositLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minDepositBalance",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "debtTermsLtv",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "debtTermsRedemptionThreshold",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "debtTermsLiqThreshold",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "debtTermsLiqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "debtTermsBorrowRate",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "debtTermsDaowry",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shouldBurnAsPayment",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldTransferToEndaoment",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldSwapInStabPools",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldAuctionInstantly",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRedeemCollateral",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canRedeemInStabPool",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canBuyInAuction",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimInStabPool",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "specialStabPoolId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionStartDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionMaxDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "whitelist",
              "type": "address",
              "indexed": false
            },
            {
              "name": "isNft",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetDepositParamsChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numVaultIds",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stakersPointsAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "voterPointsAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "perUserDepositLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "globalDepositLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minDepositBalance",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetLiqConfigChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldBurnAsPayment",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldTransferToEndaoment",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldSwapInStabPools",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldAuctionInstantly",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "specialStabPoolId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionStartDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionMaxDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetDebtTermsChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ltv",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "redemptionThreshold",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqThreshold",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "borrowRate",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "daowry",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetWhitelistChange",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "whitelist",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanDepositAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanWithdrawAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanRedeemInStabPoolAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canRedeemInStabPool",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanBuyInAuctionAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canBuyInAuction",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanClaimInStabPoolAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canClaimInStabPool",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanRedeemCollateralAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canRedeemCollateral",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetDepositParamsSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numVaultIds",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stakersPointsAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "voterPointsAlloc",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "perUserDepositLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "globalDepositLimit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minDepositBalance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetLiqConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldBurnAsPayment",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldTransferToEndaoment",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldSwapInStabPools",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shouldAuctionInstantly",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "specialStabPoolId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionStartDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionMaxDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "auctionDuration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetDebtTermsSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ltv",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "redemptionThreshold",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqThreshold",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "borrowRate",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "daowry",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "WhitelistAssetSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "whitelist",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canRedeemCollateral",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canRedeemCollateral",
              "type": "bool"
            },
            {
              "name": "_canRedeemInStabPool",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canRedeemCollateral",
              "type": "bool"
            },
            {
              "name": "_canRedeemInStabPool",
              "type": "bool"
            },
            {
              "name": "_canBuyInAuction",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canRedeemCollateral",
              "type": "bool"
            },
            {
              "name": "_canRedeemInStabPool",
              "type": "bool"
            },
            {
              "name": "_canBuyInAuction",
              "type": "bool"
            },
            {
              "name": "_canClaimInStabPool",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canRedeemCollateral",
              "type": "bool"
            },
            {
              "name": "_canRedeemInStabPool",
              "type": "bool"
            },
            {
              "name": "_canBuyInAuction",
              "type": "bool"
            },
            {
              "name": "_canClaimInStabPool",
              "type": "bool"
            },
            {
              "name": "_specialStabPoolId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canRedeemCollateral",
              "type": "bool"
            },
            {
              "name": "_canRedeemInStabPool",
              "type": "bool"
            },
            {
              "name": "_canBuyInAuction",
              "type": "bool"
            },
            {
              "name": "_canClaimInStabPool",
              "type": "bool"
            },
            {
              "name": "_specialStabPoolId",
              "type": "uint256"
            },
            {
              "name": "_customAuctionParams",
              "type": "tuple",
              "components": [
                {
                  "name": "hasParams",
                  "type": "bool"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "delay",
                  "type": "uint256"
                },
                {
                  "name": "duration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canRedeemCollateral",
              "type": "bool"
            },
            {
              "name": "_canRedeemInStabPool",
              "type": "bool"
            },
            {
              "name": "_canBuyInAuction",
              "type": "bool"
            },
            {
              "name": "_canClaimInStabPool",
              "type": "bool"
            },
            {
              "name": "_specialStabPoolId",
              "type": "uint256"
            },
            {
              "name": "_customAuctionParams",
              "type": "tuple",
              "components": [
                {
                  "name": "hasParams",
                  "type": "bool"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "delay",
                  "type": "uint256"
                },
                {
                  "name": "duration",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_whitelist",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            },
            {
              "name": "_debtTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "ltv",
                  "type": "uint256"
                },
                {
                  "name": "redemptionThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqThreshold",
                  "type": "uint256"
                },
                {
                  "name": "liqFee",
                  "type": "uint256"
                },
                {
                  "name": "borrowRate",
                  "type": "uint256"
                },
                {
                  "name": "daowry",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_canDeposit",
              "type": "bool"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canRedeemCollateral",
              "type": "bool"
            },
            {
              "name": "_canRedeemInStabPool",
              "type": "bool"
            },
            {
              "name": "_canBuyInAuction",
              "type": "bool"
            },
            {
              "name": "_canClaimInStabPool",
              "type": "bool"
            },
            {
              "name": "_specialStabPoolId",
              "type": "uint256"
            },
            {
              "name": "_customAuctionParams",
              "type": "tuple",
              "components": [
                {
                  "name": "hasParams",
                  "type": "bool"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "delay",
                  "type": "uint256"
                },
                {
                  "name": "duration",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_whitelist",
              "type": "address"
            },
            {
              "name": "_isNft",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetDepositParams",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultIds",
              "type": "uint256[]"
            },
            {
              "name": "_stakersPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_voterPointsAlloc",
              "type": "uint256"
            },
            {
              "name": "_perUserDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_globalDepositLimit",
              "type": "uint256"
            },
            {
              "name": "_minDepositBalance",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetLiqConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetLiqConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_specialStabPoolId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetLiqConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldBurnAsPayment",
              "type": "bool"
            },
            {
              "name": "_shouldTransferToEndaoment",
              "type": "bool"
            },
            {
              "name": "_shouldSwapInStabPools",
              "type": "bool"
            },
            {
              "name": "_shouldAuctionInstantly",
              "type": "bool"
            },
            {
              "name": "_specialStabPoolId",
              "type": "uint256"
            },
            {
              "name": "_customAuctionParams",
              "type": "tuple",
              "components": [
                {
                  "name": "hasParams",
                  "type": "bool"
                },
                {
                  "name": "startDiscount",
                  "type": "uint256"
                },
                {
                  "name": "maxDiscount",
                  "type": "uint256"
                },
                {
                  "name": "delay",
                  "type": "uint256"
                },
                {
                  "name": "duration",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setAssetDebtTerms",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_ltv",
              "type": "uint256"
            },
            {
              "name": "_redemptionThreshold",
              "type": "uint256"
            },
            {
              "name": "_liqThreshold",
              "type": "uint256"
            },
            {
              "name": "_liqFee",
              "type": "uint256"
            },
            {
              "name": "_borrowRate",
              "type": "uint256"
            },
            {
              "name": "_daowry",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setWhitelistForAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_whitelist",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanDepositAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanWithdrawAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanRedeemInStabPoolAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanBuyInAuctionAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanClaimInStabPoolAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanRedeemCollateralAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldEnable",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAssetConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "config",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "vaultIds",
                      "type": "uint256[]"
                    },
                    {
                      "name": "stakersPointsAlloc",
                      "type": "uint256"
                    },
                    {
                      "name": "voterPointsAlloc",
                      "type": "uint256"
                    },
                    {
                      "name": "perUserDepositLimit",
                      "type": "uint256"
                    },
                    {
                      "name": "globalDepositLimit",
                      "type": "uint256"
                    },
                    {
                      "name": "minDepositBalance",
                      "type": "uint256"
                    },
                    {
                      "name": "debtTerms",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "ltv",
                          "type": "uint256"
                        },
                        {
                          "name": "redemptionThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqThreshold",
                          "type": "uint256"
                        },
                        {
                          "name": "liqFee",
                          "type": "uint256"
                        },
                        {
                          "name": "borrowRate",
                          "type": "uint256"
                        },
                        {
                          "name": "daowry",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "shouldBurnAsPayment",
                      "type": "bool"
                    },
                    {
                      "name": "shouldTransferToEndaoment",
                      "type": "bool"
                    },
                    {
                      "name": "shouldSwapInStabPools",
                      "type": "bool"
                    },
                    {
                      "name": "shouldAuctionInstantly",
                      "type": "bool"
                    },
                    {
                      "name": "canDeposit",
                      "type": "bool"
                    },
                    {
                      "name": "canWithdraw",
                      "type": "bool"
                    },
                    {
                      "name": "canRedeemCollateral",
                      "type": "bool"
                    },
                    {
                      "name": "canRedeemInStabPool",
                      "type": "bool"
                    },
                    {
                      "name": "canBuyInAuction",
                      "type": "bool"
                    },
                    {
                      "name": "canClaimInStabPool",
                      "type": "bool"
                    },
                    {
                      "name": "specialStabPoolId",
                      "type": "uint256"
                    },
                    {
                      "name": "customAuctionParams",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "hasParams",
                          "type": "bool"
                        },
                        {
                          "name": "startDiscount",
                          "type": "uint256"
                        },
                        {
                          "name": "maxDiscount",
                          "type": "uint256"
                        },
                        {
                          "name": "delay",
                          "type": "uint256"
                        },
                        {
                          "name": "duration",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "whitelist",
                      "type": "address"
                    },
                    {
                      "name": "isNft",
                      "type": "bool"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "d3cc46c981ea30e6cd26b22d4c6b6a72250055331934280527b5eb6de8ad8189"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "contracts/config/SwitchboardBravo.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\nimport interfaces.ConfigStructs as cs\n\ninterface MissionControl:\n    def setAssetConfig(_asset: address, _assetConfig: cs.AssetConfig): nonpayable\n    def canPerformLiteAction(_user: address) -> bool: view\n    def assetConfig(_asset: address) -> cs.AssetConfig: view\n    def isSupportedAsset(_asset: address) -> bool: view\n    def maxLtvDeviation() -> uint256: view\n\ninterface SwitchboardAlpha:\n    def areValidAuctionParams(_params: cs.AuctionParams) -> bool: view\n\ninterface Whitelist:\n    def isUserAllowed(_user: address, _asset: address) -> bool: view\n\ninterface VaultBook:\n    def isValidRegId(_regId: uint256) -> bool: view\n\ninterface RipeHq:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def getAddr(_regId: uint256) -> address: view\n\nflag ActionType:\n    ASSET_ADD_NEW\n    ASSET_DEPOSIT_PARAMS\n    ASSET_LIQ_CONFIG\n    ASSET_DEBT_TERMS\n    ASSET_WHITELIST\n\nflag AssetFlag:\n    CAN_DEPOSIT\n    CAN_WITHDRAW\n    CAN_REDEEM_IN_STAB_POOL\n    CAN_BUY_IN_AUCTION\n    CAN_CLAIM_IN_STAB_POOL\n    CAN_REDEEM_COLLATERAL\n\nstruct AssetUpdate:\n    asset: address\n    config: cs.AssetConfig\n\nevent NewAssetPending:\n    asset: indexed(address)\n    numVaults: uint256\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTermsLtv: uint256\n    debtTermsRedemptionThreshold: uint256\n    debtTermsLiqThreshold: uint256\n    debtTermsLiqFee: uint256\n    debtTermsBorrowRate: uint256\n    debtTermsDaowry: uint256\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    auctionStartDiscount: uint256\n    auctionMaxDiscount: uint256\n    auctionDelay: uint256\n    auctionDuration: uint256\n    whitelist: address\n    isNft: bool\n\nevent PendingAssetDepositParamsChange:\n    asset: indexed(address)\n    numVaultIds: uint256\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingAssetLiqConfigChange:\n    asset: indexed(address)\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    specialStabPoolId: uint256\n    auctionStartDiscount: uint256\n    auctionMaxDiscount: uint256\n    auctionDelay: uint256\n    auctionDuration: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingAssetDebtTermsChange:\n    asset: indexed(address)\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingAssetWhitelistChange:\n    asset: indexed(address)\n    whitelist: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CanDepositAssetSet:\n    asset: indexed(address)\n    canDeposit: bool\n    caller: indexed(address)\n\nevent CanWithdrawAssetSet:\n    asset: indexed(address)\n    canWithdraw: bool\n    caller: indexed(address)\n\nevent CanRedeemInStabPoolAssetSet:\n    asset: indexed(address)\n    canRedeemInStabPool: bool\n    caller: indexed(address)\n\nevent CanBuyInAuctionAssetSet:\n    asset: indexed(address)\n    canBuyInAuction: bool\n    caller: indexed(address)\n\nevent CanClaimInStabPoolAssetSet:\n    asset: indexed(address)\n    canClaimInStabPool: bool\n    caller: indexed(address)\n\nevent CanRedeemCollateralAssetSet:\n    asset: indexed(address)\n    canRedeemCollateral: bool\n    caller: indexed(address)\n\nevent AssetAdded:\n    asset: indexed(address)\n\nevent AssetDepositParamsSet:\n    asset: indexed(address)\n    numVaultIds: uint256\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n\nevent AssetLiqConfigSet:\n    asset: indexed(address)\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    specialStabPoolId: uint256\n    auctionStartDiscount: uint256\n    auctionMaxDiscount: uint256\n    auctionDelay: uint256\n    auctionDuration: uint256\n\nevent AssetDebtTermsSet:\n    asset: indexed(address)\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nevent WhitelistAssetSet:\n    asset: indexed(address)\n    whitelist: indexed(address)\n\n# pending config changes\nactionType: public(HashMap[uint256, ActionType]) # aid -> type\npendingAssetConfig: public(HashMap[uint256, AssetUpdate]) # aid -> asset\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nMISSION_CONTROL_ID: constant(uint256) = 5\nVAULT_BOOK_ID: constant(uint256) = 8\nSWITCHBOARD_ID: constant(uint256) = 6\nSWITCHBOARD_ALPHA_ID: constant(uint256) = 1\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPermsToEnable(_caller: address, _shouldEnable: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if not _shouldEnable:\n        return staticcall MissionControl(self._getMissionControlAddr()).canPerformLiteAction(_caller)\n    return False\n\n\n# addys lite\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(MISSION_CONTROL_ID)\n\n\n#############\n# Add Asset #\n#############\n\n\n@external\ndef addAsset(\n    _asset: address,\n    _vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET],\n    _stakersPointsAlloc: uint256,\n    _voterPointsAlloc: uint256,\n    _perUserDepositLimit: uint256,\n    _globalDepositLimit: uint256,\n    _minDepositBalance: uint256 = 0,\n    _debtTerms: cs.DebtTerms = empty(cs.DebtTerms),\n    _shouldBurnAsPayment: bool = False,\n    _shouldTransferToEndaoment: bool = False,\n    _shouldSwapInStabPools: bool = True,\n    _shouldAuctionInstantly: bool = True,\n    _canDeposit: bool = True,\n    _canWithdraw: bool = True,\n    _canRedeemCollateral: bool = True,\n    _canRedeemInStabPool: bool = True,\n    _canBuyInAuction: bool = True,\n    _canClaimInStabPool: bool = True,\n    _specialStabPoolId: uint256 = 0,\n    _customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams),\n    _whitelist: address = empty(address),\n    _isNft: bool = False,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not staticcall MissionControl(self._getMissionControlAddr()).isSupportedAsset(_asset) # dev: must be new asset\n\n    customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams)\n    if _customAuctionParams.hasParams:\n        customAuctionParams = _customAuctionParams\n\n    config: cs.AssetConfig = cs.AssetConfig(\n        vaultIds=_vaultIds,\n        stakersPointsAlloc=_stakersPointsAlloc,\n        voterPointsAlloc=_voterPointsAlloc,\n        perUserDepositLimit=_perUserDepositLimit,\n        globalDepositLimit=_globalDepositLimit,\n        minDepositBalance=_minDepositBalance,\n        debtTerms=_debtTerms,\n        shouldBurnAsPayment=_shouldBurnAsPayment,\n        shouldTransferToEndaoment=_shouldTransferToEndaoment,\n        shouldSwapInStabPools=_shouldSwapInStabPools,\n        shouldAuctionInstantly=_shouldAuctionInstantly,\n        canDeposit=_canDeposit,\n        canWithdraw=_canWithdraw,\n        canRedeemCollateral=_canRedeemCollateral,\n        canRedeemInStabPool=_canRedeemInStabPool,\n        canBuyInAuction=_canBuyInAuction,\n        canClaimInStabPool=_canClaimInStabPool,\n        specialStabPoolId=_specialStabPoolId,\n        customAuctionParams=customAuctionParams,\n        whitelist=_whitelist,\n        isNft=_isNft,\n    )\n    assert self._isValidAssetConfig(_asset, config) # dev: invalid asset\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ASSET_ADD_NEW\n    self.pendingAssetConfig[aid] = AssetUpdate(\n        asset=_asset,\n        config=config,\n    )\n\n    log NewAssetPending(\n        asset=_asset,\n        numVaults=len(config.vaultIds),\n        stakersPointsAlloc=config.stakersPointsAlloc,\n        voterPointsAlloc=config.voterPointsAlloc,\n        perUserDepositLimit=config.perUserDepositLimit,\n        globalDepositLimit=config.globalDepositLimit,\n        minDepositBalance=config.minDepositBalance,\n        debtTermsLtv=config.debtTerms.ltv,\n        debtTermsRedemptionThreshold=config.debtTerms.redemptionThreshold,\n        debtTermsLiqThreshold=config.debtTerms.liqThreshold,\n        debtTermsLiqFee=config.debtTerms.liqFee,\n        debtTermsBorrowRate=config.debtTerms.borrowRate,\n        debtTermsDaowry=config.debtTerms.daowry,\n        shouldBurnAsPayment=config.shouldBurnAsPayment,\n        shouldTransferToEndaoment=config.shouldTransferToEndaoment,\n        shouldSwapInStabPools=config.shouldSwapInStabPools,\n        shouldAuctionInstantly=config.shouldAuctionInstantly,\n        canDeposit=config.canDeposit,\n        canWithdraw=config.canWithdraw,\n        canRedeemCollateral=config.canRedeemCollateral,\n        canRedeemInStabPool=config.canRedeemInStabPool,\n        canBuyInAuction=config.canBuyInAuction,\n        canClaimInStabPool=config.canClaimInStabPool,\n        specialStabPoolId=config.specialStabPoolId,\n        auctionStartDiscount=config.customAuctionParams.startDiscount,\n        auctionMaxDiscount=config.customAuctionParams.maxDiscount,\n        auctionDelay=config.customAuctionParams.delay,\n        auctionDuration=config.customAuctionParams.duration,\n        whitelist=config.whitelist,\n        isNft=config.isNft,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidAssetConfig(_asset: address, _config: cs.AssetConfig) -> bool:\n    if _asset == empty(address):\n        return False\n    if not self._isValidDebtTerms(_config.debtTerms):\n        return False\n    if not self._isValidAssetDepositParams(_asset, _config.vaultIds, _config.stakersPointsAlloc, _config.voterPointsAlloc, _config.perUserDepositLimit, _config.globalDepositLimit, _config.minDepositBalance):\n        return False\n    if not self._isValidAssetLiqConfig(_asset, _config.shouldBurnAsPayment, _config.shouldTransferToEndaoment, _config.shouldSwapInStabPools, _config.shouldAuctionInstantly, _config.specialStabPoolId, _config.isNft, _config.whitelist, _config.debtTerms.ltv):\n        return False\n    if not self._isValidRedeemCollateralConfig(_asset, _config.canRedeemCollateral, _config.isNft, _config.debtTerms.ltv, _config.shouldTransferToEndaoment):\n        return False\n    if not self._isValidWhitelist(_config.whitelist):\n        return False\n    if _config.customAuctionParams.hasParams and not self._areValidAuctionParams(_config.customAuctionParams):\n        return False\n    return True\n\n\n##########################\n# Asset - Deposit Params #\n##########################\n\n\n@external\ndef setAssetDepositParams(\n    _asset: address,\n    _vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET],\n    _stakersPointsAlloc: uint256,\n    _voterPointsAlloc: uint256,\n    _perUserDepositLimit: uint256,\n    _globalDepositLimit: uint256,\n    _minDepositBalance: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert staticcall MissionControl(self._getMissionControlAddr()).isSupportedAsset(_asset) # dev: invalid asset\n    assert self._isValidAssetDepositParams(_asset, _vaultIds, _stakersPointsAlloc, _voterPointsAlloc, _perUserDepositLimit, _globalDepositLimit, _minDepositBalance) # dev: invalid asset deposit params\n    return self._setPendingAssetConfig(ActionType.ASSET_DEPOSIT_PARAMS, _asset, _vaultIds, _stakersPointsAlloc, _voterPointsAlloc, _perUserDepositLimit, _globalDepositLimit, _minDepositBalance)\n\n\n@view\n@internal\ndef _isValidAssetDepositParams(\n    _asset: address,\n    _vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET],\n    _stakersPointsAlloc: uint256,\n    _voterPointsAlloc: uint256,\n    _perUserDepositLimit: uint256,\n    _globalDepositLimit: uint256,\n    _minDepositBalance: uint256,\n) -> bool:\n    vaultBook: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(VAULT_BOOK_ID)\n    if 0 in [_perUserDepositLimit, _globalDepositLimit]:\n        return False\n    if max_value(uint256) in [_perUserDepositLimit, _globalDepositLimit, _stakersPointsAlloc, _voterPointsAlloc]:\n        return False\n    if _stakersPointsAlloc + _voterPointsAlloc > HUNDRED_PERCENT:\n        return False\n    if _perUserDepositLimit > _globalDepositLimit:\n        return False\n    if _minDepositBalance > _perUserDepositLimit:\n        return False\n    for vaultId: uint256 in _vaultIds:\n        if not staticcall VaultBook(vaultBook).isValidRegId(vaultId):\n            return False\n    return True\n\n\n######################\n# Asset - Liq Config #\n######################\n\n\n@external\ndef setAssetLiqConfig(\n    _asset: address,\n    _shouldBurnAsPayment: bool,\n    _shouldTransferToEndaoment: bool,\n    _shouldSwapInStabPools: bool,\n    _shouldAuctionInstantly: bool,\n    _specialStabPoolId: uint256 = 0,\n    _customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams),\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams)\n    if _customAuctionParams.hasParams:\n        assert self._areValidAuctionParams(_customAuctionParams) # dev: invalid auction params\n        customAuctionParams = _customAuctionParams\n\n    mc: address = self._getMissionControlAddr()\n    assert staticcall MissionControl(mc).isSupportedAsset(_asset) # dev: invalid asset\n    assetConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n    assert self._isValidAssetLiqConfig(_asset, _shouldBurnAsPayment, _shouldTransferToEndaoment, _shouldSwapInStabPools, _shouldAuctionInstantly, _specialStabPoolId, assetConfig.isNft, assetConfig.whitelist, assetConfig.debtTerms.ltv) # dev: invalid asset liq config\n    return self._setPendingAssetConfig(ActionType.ASSET_LIQ_CONFIG, _asset, [], 0, 0, 0, 0, 0, empty(cs.DebtTerms), _shouldBurnAsPayment, _shouldTransferToEndaoment, _shouldSwapInStabPools, _shouldAuctionInstantly, _specialStabPoolId, customAuctionParams)\n\n\n@view\n@internal\ndef _isValidAssetLiqConfig(\n    _asset: address,\n    _shouldBurnAsPayment: bool,\n    _shouldTransferToEndaoment: bool,\n    _shouldSwapInStabPools: bool,\n    _shouldAuctionInstantly: bool,\n    _specialStabPoolId: uint256,\n    _isNft: bool,\n    _whitelist: address,\n    _debtTermsLtv: uint256,\n) -> bool:\n    greenToken: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(GREEN_TOKEN_ID)\n    savingsGreen: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(SAVINGS_GREEN_ID)\n    vaultBook: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(VAULT_BOOK_ID)\n\n    if _shouldBurnAsPayment:\n\n        # can only burn if green or savings green\n        if _asset not in [greenToken, savingsGreen]:\n            return False\n\n    if _shouldTransferToEndaoment:\n\n        # cannot transfer to endaoment if green or savings green\n        if _asset in [greenToken, savingsGreen]:\n            return False\n\n    if _shouldSwapInStabPools:\n\n        # cannot be nft\n        if _isNft:\n            return False\n\n        # cannot have whitelist if no special stab pool\n        if _whitelist != empty(address) and _specialStabPoolId == 0:\n            return False\n\n        # must have ltv\n        if _debtTermsLtv == 0:\n            return False\n\n    # make sure special stab pool is valid\n    if _specialStabPoolId != 0 and not staticcall VaultBook(vaultBook).isValidRegId(_specialStabPoolId):\n        return False\n\n    return True\n\n\n@view\n@internal\ndef _areValidAuctionParams(_params: cs.AuctionParams) -> bool:\n    switchboard: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(SWITCHBOARD_ID)\n    switchboardAlpha: address = staticcall Switchboard(switchboard).getAddr(SWITCHBOARD_ALPHA_ID)\n    return staticcall SwitchboardAlpha(switchboardAlpha).areValidAuctionParams(_params)\n\n\n######################\n# Asset - Debt Terms #\n######################\n\n\n@external\ndef setAssetDebtTerms(\n    _asset: address,\n    _ltv: uint256,\n    _redemptionThreshold: uint256,\n    _liqThreshold: uint256,\n    _liqFee: uint256,\n    _borrowRate: uint256,\n    _daowry: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._getMissionControlAddr()\n    assert staticcall MissionControl(mc).isSupportedAsset(_asset) # dev: invalid asset\n    assetConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n    assert self._isLtvWithinMaxDeviation(_ltv, assetConfig.debtTerms.ltv, staticcall MissionControl(mc).maxLtvDeviation()) # dev: ltv is outside max deviation\n\n    debtTerms: cs.DebtTerms = cs.DebtTerms(\n        ltv=_ltv,\n        redemptionThreshold=_redemptionThreshold,\n        liqThreshold=_liqThreshold,\n        liqFee=_liqFee,\n        borrowRate=_borrowRate,\n        daowry=_daowry,\n    )\n    assert self._isValidDebtTerms(debtTerms) # dev: invalid debt terms\n    return self._setPendingAssetConfig(ActionType.ASSET_DEBT_TERMS, _asset, [], 0, 0, 0, 0, 0, debtTerms)\n\n\n@view\n@internal\ndef _isValidDebtTerms(_debtTerms: cs.DebtTerms) -> bool:\n    if _debtTerms.liqThreshold > HUNDRED_PERCENT:\n        return False\n    if _debtTerms.redemptionThreshold > _debtTerms.liqThreshold:\n        return False\n    if _debtTerms.ltv > _debtTerms.redemptionThreshold:\n        return False\n    if _debtTerms.liqFee > HUNDRED_PERCENT or _debtTerms.borrowRate > HUNDRED_PERCENT or _debtTerms.daowry > HUNDRED_PERCENT:\n        return False\n    if _debtTerms.ltv != 0 and 0 in [_debtTerms.liqFee, _debtTerms.borrowRate]:\n        return False\n\n    # if ltv > 0, liq threshold and redemption threshold must be > 0\n    if _debtTerms.ltv != 0 and (_debtTerms.liqThreshold == 0 or _debtTerms.redemptionThreshold == 0):\n        return False\n\n    # make liq threshold and liq bonus work together\n    liqSum: uint256 = _debtTerms.liqThreshold + (_debtTerms.liqThreshold * _debtTerms.liqFee // HUNDRED_PERCENT)\n    return liqSum <= HUNDRED_PERCENT\n\n\n@view\n@internal\ndef _isLtvWithinMaxDeviation(_newLtv: uint256, _prevLtv: uint256, _maxDeviation: uint256) -> bool:\n\n    # cannot set ltv to 0 after already non-zero\n    if _prevLtv != 0 and _newLtv == 0:\n        return False\n\n    if _prevLtv == 0 or _maxDeviation == 0:\n        return True\n\n    upperBound: uint256 = min(_prevLtv + _maxDeviation, HUNDRED_PERCENT)\n    lowerBound: uint256 = _prevLtv - min(_maxDeviation, _prevLtv)\n    return upperBound >= _newLtv and _newLtv >= lowerBound\n\n\n#####################\n# Asset - Whitelist #\n#####################\n\n\n@external\ndef setWhitelistForAsset(_asset: address, _whitelist: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert staticcall MissionControl(self._getMissionControlAddr()).isSupportedAsset(_asset) # dev: invalid asset\n    assert self._isValidWhitelist(_whitelist) # dev: invalid whitelist\n    return self._setPendingAssetConfig(ActionType.ASSET_WHITELIST, _asset, [], 0, 0, 0, 0, 0, empty(cs.DebtTerms), False, False, False, False, 0, empty(cs.AuctionParams), _whitelist)\n\n\n@view\n@internal\ndef _isValidWhitelist(_whitelist: address) -> bool:\n    # make sure has interface\n    if _whitelist != empty(address):\n        assert not staticcall Whitelist(_whitelist).isUserAllowed(empty(address), empty(address)) # dev: invalid whitelist\n    return True\n\n\n##########################\n# Asset - Pending Config #\n##########################\n\n\n@internal\ndef _setPendingAssetConfig(\n    _actionType: ActionType,\n    _asset: address,\n    _vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET] = [],\n    _stakersPointsAlloc: uint256 = 0,\n    _voterPointsAlloc: uint256 = 0,\n    _perUserDepositLimit: uint256 = 0,\n    _globalDepositLimit: uint256 = 0,\n    _minDepositBalance: uint256 = 0,\n    _debtTerms: cs.DebtTerms = empty(cs.DebtTerms),\n    _shouldBurnAsPayment: bool = False,\n    _shouldTransferToEndaoment: bool = False,\n    _shouldSwapInStabPools: bool = False,\n    _shouldAuctionInstantly: bool = False,\n    _specialStabPoolId: uint256 = 0,\n    _customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams),\n    _whitelist: address = empty(address),\n) -> uint256:\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = _actionType\n    config: cs.AssetConfig = cs.AssetConfig(\n        vaultIds=_vaultIds,\n        stakersPointsAlloc=_stakersPointsAlloc,\n        voterPointsAlloc=_voterPointsAlloc,\n        perUserDepositLimit=_perUserDepositLimit,\n        globalDepositLimit=_globalDepositLimit,\n        minDepositBalance=_minDepositBalance,\n        debtTerms=_debtTerms,\n        shouldBurnAsPayment=_shouldBurnAsPayment,\n        shouldTransferToEndaoment=_shouldTransferToEndaoment,\n        shouldSwapInStabPools=_shouldSwapInStabPools,\n        shouldAuctionInstantly=_shouldAuctionInstantly,\n        canDeposit=False,\n        canWithdraw=False,\n        canRedeemCollateral=False,\n        canRedeemInStabPool=False,\n        canBuyInAuction=False,\n        canClaimInStabPool=False,\n        specialStabPoolId=_specialStabPoolId,\n        customAuctionParams=_customAuctionParams,\n        whitelist=_whitelist,\n        isNft=False,\n    )\n    self.pendingAssetConfig[aid] = AssetUpdate(\n        asset=_asset,\n        config=config,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.ASSET_DEPOSIT_PARAMS:\n        log PendingAssetDepositParamsChange(\n            asset=_asset,\n            numVaultIds=len(_vaultIds),\n            stakersPointsAlloc=_stakersPointsAlloc,\n            voterPointsAlloc=_voterPointsAlloc,\n            perUserDepositLimit=_perUserDepositLimit,\n            globalDepositLimit=_globalDepositLimit,\n            minDepositBalance=_minDepositBalance,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.ASSET_LIQ_CONFIG:\n        log PendingAssetLiqConfigChange(\n            asset=_asset,\n            shouldBurnAsPayment=_shouldBurnAsPayment,\n            shouldTransferToEndaoment=_shouldTransferToEndaoment,\n            shouldSwapInStabPools=_shouldSwapInStabPools,\n            shouldAuctionInstantly=_shouldAuctionInstantly,\n            specialStabPoolId=_specialStabPoolId,\n            auctionStartDiscount=_customAuctionParams.startDiscount,\n            auctionMaxDiscount=_customAuctionParams.maxDiscount,\n            auctionDelay=_customAuctionParams.delay,\n            auctionDuration=_customAuctionParams.duration,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.ASSET_DEBT_TERMS:\n        log PendingAssetDebtTermsChange(\n            asset=_asset,\n            ltv=_debtTerms.ltv,\n            redemptionThreshold=_debtTerms.redemptionThreshold,\n            liqThreshold=_debtTerms.liqThreshold,\n            liqFee=_debtTerms.liqFee,\n            borrowRate=_debtTerms.borrowRate,\n            daowry=_debtTerms.daowry,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.ASSET_WHITELIST:\n        log PendingAssetWhitelistChange(\n            asset=_asset,\n            whitelist=_whitelist,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n############################\n# Asset - Enable / Disable #\n############################\n\n\n@external\ndef setCanDepositAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_DEPOSIT, _shouldEnable)\n\n\n@external\ndef setCanWithdrawAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_WITHDRAW, _shouldEnable)\n\n\n@external\ndef setCanRedeemInStabPoolAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_REDEEM_IN_STAB_POOL, _shouldEnable)\n\n\n@external\ndef setCanBuyInAuctionAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_BUY_IN_AUCTION, _shouldEnable)\n\n\n@external\ndef setCanClaimInStabPoolAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_CLAIM_IN_STAB_POOL, _shouldEnable)\n\n\n@external\ndef setCanRedeemCollateralAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_REDEEM_COLLATERAL, _shouldEnable)\n\n\n@internal\ndef _setAssetFlag(_asset: address, _flag: AssetFlag, _shouldEnable: bool) -> bool:\n    assert self._hasPermsToEnable(msg.sender, _shouldEnable) # dev: no perms\n\n    mc: address = self._getMissionControlAddr()\n    assert staticcall MissionControl(mc).isSupportedAsset(_asset) # dev: invalid asset\n    assetConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n\n    # get current value and validate\n    if _flag == AssetFlag.CAN_DEPOSIT:\n        assert assetConfig.canDeposit != _shouldEnable # dev: already set\n        assetConfig.canDeposit = _shouldEnable\n        log CanDepositAssetSet(asset=_asset, canDeposit=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_WITHDRAW:\n        assert assetConfig.canWithdraw != _shouldEnable # dev: already set\n        assetConfig.canWithdraw = _shouldEnable\n        log CanWithdrawAssetSet(asset=_asset, canWithdraw=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_REDEEM_IN_STAB_POOL:\n        assert assetConfig.canRedeemInStabPool != _shouldEnable # dev: already set\n        assetConfig.canRedeemInStabPool = _shouldEnable\n        log CanRedeemInStabPoolAssetSet(asset=_asset, canRedeemInStabPool=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_BUY_IN_AUCTION:\n        assert assetConfig.canBuyInAuction != _shouldEnable # dev: already set\n        assetConfig.canBuyInAuction = _shouldEnable\n        log CanBuyInAuctionAssetSet(asset=_asset, canBuyInAuction=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_CLAIM_IN_STAB_POOL:\n        assert assetConfig.canClaimInStabPool != _shouldEnable # dev: already set\n        assetConfig.canClaimInStabPool = _shouldEnable\n        log CanClaimInStabPoolAssetSet(asset=_asset, canClaimInStabPool=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_REDEEM_COLLATERAL:\n        assert assetConfig.canRedeemCollateral != _shouldEnable # dev: already set\n        assert self._isValidRedeemCollateralConfig(_asset, _shouldEnable, assetConfig.isNft, assetConfig.debtTerms.ltv, assetConfig.shouldTransferToEndaoment) # dev: invalid redeem collateral config\n        assetConfig.canRedeemCollateral = _shouldEnable\n        log CanRedeemCollateralAssetSet(asset=_asset, canRedeemCollateral=_shouldEnable, caller=msg.sender)\n\n    extcall MissionControl(mc).setAssetConfig(_asset, assetConfig)\n    return True\n\n\n# validation on collateral redemption\n\n\n@view\n@internal\ndef _isValidRedeemCollateralConfig(\n    _asset: address,\n    _shouldEnable: bool,\n    _isNft: bool,\n    _debtTermsLtv: uint256,\n    _shouldTransferToEndaoment: bool,\n) -> bool:\n    if not _shouldEnable:\n        return True\n\n    # cannot redeem collateral if nft\n    if _isNft:\n        return False\n\n    # must have ltv\n    if _debtTermsLtv == 0:\n        return False\n\n    # any stable-ish assets cannot be redeemed\n    if _shouldTransferToEndaoment:\n        return False\n\n    return True\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n    mc: address = self._getMissionControlAddr()\n\n    if actionType == ActionType.ASSET_ADD_NEW:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        assert self._isValidAssetConfig(p.asset, p.config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, p.config)\n        log AssetAdded(asset=p.asset)\n\n    elif actionType == ActionType.ASSET_DEPOSIT_PARAMS:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.vaultIds = p.config.vaultIds\n        config.stakersPointsAlloc = p.config.stakersPointsAlloc\n        config.voterPointsAlloc = p.config.voterPointsAlloc\n        config.perUserDepositLimit = p.config.perUserDepositLimit\n        config.globalDepositLimit = p.config.globalDepositLimit\n        config.minDepositBalance = p.config.minDepositBalance\n        assert self._isValidAssetConfig(p.asset, config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetDepositParamsSet(asset=p.asset, numVaultIds=len(p.config.vaultIds), stakersPointsAlloc=p.config.stakersPointsAlloc, voterPointsAlloc=p.config.voterPointsAlloc, perUserDepositLimit=p.config.perUserDepositLimit, globalDepositLimit=p.config.globalDepositLimit, minDepositBalance=p.config.minDepositBalance)\n\n    elif actionType == ActionType.ASSET_LIQ_CONFIG:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.shouldBurnAsPayment = p.config.shouldBurnAsPayment\n        config.shouldTransferToEndaoment = p.config.shouldTransferToEndaoment\n        config.shouldSwapInStabPools = p.config.shouldSwapInStabPools\n        config.shouldAuctionInstantly = p.config.shouldAuctionInstantly\n        config.specialStabPoolId = p.config.specialStabPoolId\n        config.customAuctionParams = p.config.customAuctionParams\n        assert self._isValidAssetConfig(p.asset, config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetLiqConfigSet(asset=p.asset, shouldBurnAsPayment=p.config.shouldBurnAsPayment, shouldTransferToEndaoment=p.config.shouldTransferToEndaoment, shouldSwapInStabPools=p.config.shouldSwapInStabPools, shouldAuctionInstantly=p.config.shouldAuctionInstantly, specialStabPoolId=p.config.specialStabPoolId, auctionStartDiscount=p.config.customAuctionParams.startDiscount, auctionMaxDiscount=p.config.customAuctionParams.maxDiscount, auctionDelay=p.config.customAuctionParams.delay, auctionDuration=p.config.customAuctionParams.duration)\n\n    elif actionType == ActionType.ASSET_DEBT_TERMS:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.debtTerms = p.config.debtTerms\n        assert self._isValidAssetConfig(p.asset, config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetDebtTermsSet(asset=p.asset, ltv=p.config.debtTerms.ltv, redemptionThreshold=p.config.debtTerms.redemptionThreshold, liqThreshold=p.config.debtTerms.liqThreshold, liqFee=p.config.debtTerms.liqFee, borrowRate=p.config.debtTerms.borrowRate, daowry=p.config.debtTerms.daowry)\n\n    elif actionType == ActionType.ASSET_WHITELIST:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.whitelist = p.config.whitelist\n        assert self._isValidAssetConfig(p.asset, config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log WhitelistAssetSet(asset=p.asset, whitelist=p.config.whitelist)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n# cancel action\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n",
            "sha256sum": "260ed3e9be0e1919ffdf3c7006f82564cd63568a20a2b82e716b3c53ebd87854"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardBravo.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "e3cc9c3a86eb4a76592c003d4e44977bc4a28c829ba34965108960510fea777c"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/config/SwitchboardBravo.vy"
    },
    "SwitchboardCharlie": {
      "address": "0xdb33ad20bb84EcFc60AD904Db4A4EA943D0b2c5D",
      "abi": [
        {
          "name": "PendingRecoverFundsAction",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRecoverFundsManyAction",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numAssets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingStartAuctionAction",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingStartManyAuctionsAction",
          "inputs": [
            {
              "name": "numAuctions",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingPauseAuctionAction",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingPauseManyAuctionsAction",
          "inputs": [
            {
              "name": "numAuctions",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingEndaoSwapAction",
          "inputs": [
            {
              "name": "numSwapInstructions",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingEndaoAddLiquidityAction",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingEndaoRemoveLiquidityAction",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingEndaoPartnerMintAction",
          "inputs": [
            {
              "name": "partner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingEndaoPartnerPoolAction",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "partner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingEndaoRepayAction",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingEndaoRecoverNftAction",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PauseExecuted",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldPause",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RecoverFundsExecuted",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RecoverFundsManyExecuted",
          "inputs": [
            {
              "name": "contractAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "numAssets",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StartAuctionExecuted",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "success",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StartManyAuctionsExecuted",
          "inputs": [
            {
              "name": "numAuctionsStarted",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PauseAuctionExecuted",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "success",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PauseManyAuctionsExecuted",
          "inputs": [
            {
              "name": "numAuctionsPaused",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BlacklistSet",
          "inputs": [
            {
              "name": "tokenAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isBlacklisted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DebtUpdatedForUser",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "success",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DebtUpdatedForManyUsers",
          "inputs": [
            {
              "name": "numUsers",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootClaimedForUser",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldStake",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "ripeAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LootClaimedForManyUsers",
          "inputs": [
            {
              "name": "numUsers",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldStake",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "totalRipeAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeRewardsUpdated",
          "inputs": [
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            },
            {
              "name": "success",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositLootClaimedForAsset",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ripeAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepositPointsUpdated",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentDepositPerformed",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vault",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentWithdrawalPerformed",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "withdrawAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "hasVaultToken",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentReblanacePerformed",
          "inputs": [
            {
              "name": "fromLegoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "fromAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "fromVaultAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "toLegoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "toVaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentEthToWethPerformed",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "depositLegoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "depositVault",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentWethToEthPerformed",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "withdrawLegoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "withdrawVaultAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "hasWithdrawVaultToken",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentClaimPerformed",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "market",
              "type": "address",
              "indexed": true
            },
            {
              "name": "rewardToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentStabilizerPerformed",
          "inputs": [
            {
              "name": "success",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaoSwapExecuted",
          "inputs": [
            {
              "name": "numSwapInstructions",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaoAddLiquidityExecuted",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaoRemoveLiquidityExecuted",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaoPartnerMintExecuted",
          "inputs": [
            {
              "name": "partner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "greenMinted",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaoPartnerPoolExecuted",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "partner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaoRepayExecuted",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "success",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaoRecoverNftExecuted",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "success",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_contractAddr",
              "type": "address"
            },
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_contractAddr",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_contractAddr",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBlacklist",
          "inputs": [
            {
              "name": "_tokenAddr",
              "type": "address"
            },
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_shouldBlacklist",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldStake",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            },
            {
              "name": "_shouldStake",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateRipeRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimDepositLootForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentDeposit",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentDeposit",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWithdraw",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWithdraw",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_withdrawAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWithdraw",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_withdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_hasVaultToken",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentRebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultAddr",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentRebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultAddr",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentRebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultAddr",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            },
            {
              "name": "_hasFromVaultToken",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "performEndaomentEthToWeth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "performEndaomentEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "performEndaomentEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "performEndaomentEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWethToEth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultAddr",
              "type": "address"
            },
            {
              "name": "_hasWithdrawVaultToken",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentClaim",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentClaim",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentClaim",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentClaim",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentClaim",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentStabilizer",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "performEndaomentSwap",
          "inputs": [
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintPartnerLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintPartnerLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPartnerLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPartnerLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPartnerLiquidityInEndaoment",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayPoolDebtInEndaoment",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayPoolDebtInEndaoment",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNftInEndaoment",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPauseActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contractAddr",
                  "type": "address"
                },
                {
                  "name": "shouldPause",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRecoverFundsActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contractAddr",
                  "type": "address"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRecoverFundsManyActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contractAddr",
                  "type": "address"
                },
                {
                  "name": "recipient",
                  "type": "address"
                },
                {
                  "name": "assets",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingStartAuctionActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingStartManyAuctionsActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPauseAuctionActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPauseManyAuctionsActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingEndaoSwapActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingEndaoAddLiquidityActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenA",
                  "type": "address"
                },
                {
                  "name": "tokenB",
                  "type": "address"
                },
                {
                  "name": "amountA",
                  "type": "uint256"
                },
                {
                  "name": "amountB",
                  "type": "uint256"
                },
                {
                  "name": "tickLower",
                  "type": "int24"
                },
                {
                  "name": "tickUpper",
                  "type": "int24"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingEndaoRemoveLiquidityActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "nftAddr",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "tokenA",
                  "type": "address"
                },
                {
                  "name": "tokenB",
                  "type": "address"
                },
                {
                  "name": "liqToRemove",
                  "type": "uint256"
                },
                {
                  "name": "minAmountA",
                  "type": "uint256"
                },
                {
                  "name": "minAmountB",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingEndaoPartnerMintActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "partner",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingEndaoPartnerPoolActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "partner",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "minLpAmount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingEndaoRepayActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingEndaoRecoverNftActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collection",
                  "type": "address"
                },
                {
                  "name": "nftTokenId",
                  "type": "uint256"
                },
                {
                  "name": "recipient",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "d3cc46c981ea30e6cd26b22d4c6b6a72250055331934280527b5eb6de8ad8189"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/config/SwitchboardCharlie.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\nimport contracts.modules.Addys as addys\n\ninterface Endaoment:\n    def addLiquidity(_legoId: uint256, _nftAddr: address, _nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _tickLower: int24, _tickUpper: int24, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256) -> (uint256, uint256, uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_legoId: uint256, _nftAddr: address, _nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256) -> (uint256, uint256, uint256, bool): nonpayable\n    def rebalance(_fromLegoId: uint256, _fromAsset: address, _fromVaultAddr: address, _toLegoId: uint256, _toVaultAddr: address, _fromVaultAmount: uint256, _hasFromVaultToken: bool) -> (uint256, address, uint256, uint256): nonpayable\n    def addPartnerLiquidity(_legoId: uint256, _pool: address, _partner: address, _asset: address, _amount: uint256, _minLpAmount: uint256) -> (uint256, uint256, uint256): nonpayable\n    def convertWethToEth(_amount: uint256, _recipient: address, _withdrawLegoId: uint256, _withdrawVaultAddr: address, _hasWithdrawVaultToken: bool) -> uint256: nonpayable\n    def withdrawTokens(_legoId: uint256, _asset: address, _vaultAddr: address, _withdrawAmount: uint256, _hasVaultToken: bool) -> (uint256, uint256, uint256): nonpayable\n    def depositTokens(_legoId: uint256, _asset: address, _vault: address, _amount: uint256) -> (uint256, address, uint256, uint256): nonpayable\n    def claimRewards(_legoId: uint256, _market: address, _rewardToken: address, _rewardAmount: uint256, _proof: bytes32): nonpayable\n    def convertEthToWeth(_amount: uint256, _depositLegoId: uint256, _depositVault: address) -> (uint256, address, uint256): payable\n    def swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256): nonpayable\n    def mintPartnerLiquidity(_partner: address, _asset: address, _amount: uint256) -> uint256: nonpayable\n    def recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool: nonpayable\n    def repayPoolDebt(_pool: address, _amount: uint256) -> bool: nonpayable\n    def stabilizeGreenRefPool() -> bool: nonpayable\n\ninterface AuctionHouse:\n    def startManyAuctions(_auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS], _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def pauseManyAuctions(_auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS], _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def pauseAuction(_liqUser: address, _liqVaultId: uint256, _liqAsset: address, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n    def startAuction(_liqUser: address, _liqVaultId: uint256, _liqAsset: address, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n    def canStartAuction(_liqUser: address, _liqVaultId: uint256, _liqAsset: address) -> bool: view\n\ninterface Lootbox:\n    def claimLootForManyUsers(_users: DynArray[address, MAX_CLAIM_USERS], _caller: address, _shouldStake: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n    def claimLootForUser(_user: address, _caller: address, _shouldStake: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def claimDepositLootForAsset(_user: address, _vaultId: uint256, _asset: address) -> uint256: nonpayable\n    def updateRipeRewards(_a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface RipeEcoContract:\n    def recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]): nonpayable\n    def recoverFunds(_recipient: address, _asset: address): nonpayable\n    def pause(_shouldPause: bool): nonpayable\n\ninterface CreditEngine:\n    def updateDebtForManyUsers(_users: DynArray[address, MAX_DEBT_UPDATES], _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n    def updateDebtForUser(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n\ninterface Switchboard:\n    def setBlacklist(_tokenAddr: address, _addr: address, _shouldBlacklist: bool) -> bool: nonpayable\n\ninterface MissionControl:\n    def canPerformLiteAction(_user: address) -> bool: view\n\ninterface VaultBook:\n    def getAddr(_vaultId: uint256) -> address: view\n\ninterface RipeHq:\n    def getAddr(_regId: uint256) -> address: view\n\nflag ActionType:\n    RECOVER_FUNDS\n    RECOVER_FUNDS_MANY\n    START_AUCTION\n    START_MANY_AUCTIONS\n    PAUSE_AUCTION\n    PAUSE_MANY_AUCTIONS\n    ENDAO_SWAP\n    ENDAO_ADD_LIQUIDITY\n    ENDAO_REMOVE_LIQUIDITY\n    ENDAO_PARTNER_MINT\n    ENDAO_PARTNER_POOL\n    ENDAO_REPAY\n    ENDOA_RECOVER_NFT\n\nstruct PauseAction:\n    contractAddr: address\n    shouldPause: bool\n\nstruct RecoverFundsAction:\n    contractAddr: address\n    recipient: address\n    asset: address\n\nstruct RecoverFundsManyAction:\n    contractAddr: address\n    recipient: address\n    assets: DynArray[address, MAX_RECOVER_ASSETS]\n\nstruct FungAuctionConfig:\n    liqUser: address\n    vaultId: uint256\n    asset: address\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct EndaoAddLiquidityAction:\n    legoId: uint256\n    nftAddr: address\n    nftTokenId: uint256\n    pool: address\n    tokenA: address\n    tokenB: address\n    amountA: uint256\n    amountB: uint256\n    tickLower: int24\n    tickUpper: int24\n    minAmountA: uint256\n    minAmountB: uint256\n    minLpAmount: uint256\n\nstruct EndaoRemoveLiquidityAction:\n    legoId: uint256\n    nftAddr: address\n    nftTokenId: uint256\n    pool: address\n    tokenA: address\n    tokenB: address\n    liqToRemove: uint256\n    minAmountA: uint256\n    minAmountB: uint256\n\nstruct EndaoPartnerMintAction:\n    partner: address\n    asset: address\n    amount: uint256\n\nstruct EndaoPartnerPoolAction:\n    legoId: uint256\n    pool: address\n    partner: address\n    asset: address\n    amount: uint256\n    minLpAmount: uint256\n\nstruct EndaoRepayAction:\n    pool: address\n    amount: uint256\n\nstruct EndaoRecoverNftAction:\n    collection: address\n    nftTokenId: uint256\n    recipient: address\n\nevent PendingRecoverFundsAction:\n    contractAddr: indexed(address)\n    recipient: indexed(address)\n    asset: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRecoverFundsManyAction:\n    contractAddr: indexed(address)\n    recipient: indexed(address)\n    numAssets: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingStartAuctionAction:\n    liqUser: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingStartManyAuctionsAction:\n    numAuctions: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingPauseAuctionAction:\n    liqUser: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingPauseManyAuctionsAction:\n    numAuctions: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingEndaoSwapAction:\n    numSwapInstructions: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingEndaoAddLiquidityAction:\n    legoId: uint256\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingEndaoRemoveLiquidityAction:\n    legoId: uint256\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingEndaoPartnerMintAction:\n    partner: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingEndaoPartnerPoolAction:\n    legoId: uint256\n    pool: indexed(address)\n    partner: indexed(address)\n    asset: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingEndaoRepayAction:\n    pool: indexed(address)\n    amount: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingEndaoRecoverNftAction:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PauseExecuted:\n    contractAddr: indexed(address)\n    shouldPause: bool\n\nevent RecoverFundsExecuted:\n    contractAddr: indexed(address)\n    recipient: indexed(address)\n    asset: indexed(address)\n\nevent RecoverFundsManyExecuted:\n    contractAddr: indexed(address)\n    recipient: indexed(address)\n    numAssets: uint256\n\nevent StartAuctionExecuted:\n    liqUser: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    success: bool\n\nevent StartManyAuctionsExecuted:\n    numAuctionsStarted: uint256\n\nevent PauseAuctionExecuted:\n    liqUser: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    success: bool\n\nevent PauseManyAuctionsExecuted:\n    numAuctionsPaused: uint256\n\nevent BlacklistSet:\n    tokenAddr: indexed(address)\n    addr: indexed(address)\n    isBlacklisted: bool\n    caller: indexed(address)\n\nevent DebtUpdatedForUser:\n    user: indexed(address)\n    success: bool\n    caller: indexed(address)\n\nevent DebtUpdatedForManyUsers:\n    numUsers: uint256\n    caller: indexed(address)\n\nevent LootClaimedForUser:\n    user: indexed(address)\n    caller: indexed(address)\n    shouldStake: bool\n    ripeAmount: uint256\n\nevent LootClaimedForManyUsers:\n    numUsers: uint256\n    caller: indexed(address)\n    shouldStake: bool\n    totalRipeAmount: uint256\n\nevent RipeRewardsUpdated:\n    caller: indexed(address)\n    success: bool\n\nevent DepositLootClaimedForAsset:\n    user: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    ripeAmount: uint256\n    caller: indexed(address)\n\nevent DepositPointsUpdated:\n    user: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    caller: indexed(address)\n\nevent EndaomentDepositPerformed:\n    legoId: uint256\n    asset: indexed(address)\n    vault: indexed(address)\n    amount: uint256\n    caller: indexed(address)\n\nevent EndaomentWithdrawalPerformed:\n    legoId: uint256\n    asset: indexed(address)\n    vaultAddr: indexed(address)\n    withdrawAmount: uint256\n    hasVaultToken: bool\n    caller: indexed(address)\n\nevent EndaomentReblanacePerformed:\n    fromLegoId: uint256\n    fromAsset: indexed(address)\n    fromVaultAddr: address\n    toLegoId: uint256\n    toVaultAddr: indexed(address)\n    caller: indexed(address)\n\nevent EndaomentEthToWethPerformed:\n    amount: uint256\n    depositLegoId: uint256\n    depositVault: indexed(address)\n    caller: indexed(address)\n\nevent EndaomentWethToEthPerformed:\n    amount: uint256\n    recipient: indexed(address)\n    withdrawLegoId: uint256\n    withdrawVaultAddr: indexed(address)\n    hasWithdrawVaultToken: bool\n    caller: indexed(address)\n\nevent EndaomentClaimPerformed:\n    legoId: uint256\n    market: indexed(address)\n    rewardToken: indexed(address)\n    caller: indexed(address)\n\nevent EndaomentStabilizerPerformed:\n    success: bool\n    caller: indexed(address)\n\nevent EndaoSwapExecuted:\n    numSwapInstructions: uint256\n\nevent EndaoAddLiquidityExecuted:\n    legoId: uint256\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n\nevent EndaoRemoveLiquidityExecuted:\n    legoId: uint256\n    pool: indexed(address)\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n\nevent EndaoPartnerMintExecuted:\n    partner: indexed(address)\n    asset: indexed(address)\n    greenMinted: uint256\n\nevent EndaoPartnerPoolExecuted:\n    legoId: uint256\n    pool: indexed(address)\n    partner: indexed(address)\n    asset: indexed(address)\n\nevent EndaoRepayExecuted:\n    pool: indexed(address)\n    success: bool\n\nevent EndaoRecoverNftExecuted:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n    success: bool\n\n# pending actions storage\nactionType: public(HashMap[uint256, ActionType])\npendingPauseActions: public(HashMap[uint256, PauseAction])\npendingRecoverFundsActions: public(HashMap[uint256, RecoverFundsAction])\npendingRecoverFundsManyActions: public(HashMap[uint256, RecoverFundsManyAction])\npendingStartAuctionActions: public(HashMap[uint256, FungAuctionConfig])\npendingStartManyAuctionsActions: public(HashMap[uint256, DynArray[FungAuctionConfig, MAX_AUCTIONS]])\npendingPauseAuctionActions: public(HashMap[uint256, FungAuctionConfig])\npendingPauseManyAuctionsActions: public(HashMap[uint256, DynArray[FungAuctionConfig, MAX_AUCTIONS]])\npendingEndaoSwapActions: public(HashMap[uint256, DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]])\npendingEndaoAddLiquidityActions: public(HashMap[uint256, EndaoAddLiquidityAction])\npendingEndaoRemoveLiquidityActions: public(HashMap[uint256, EndaoRemoveLiquidityAction])\npendingEndaoPartnerMintActions: public(HashMap[uint256, EndaoPartnerMintAction])\npendingEndaoPartnerPoolActions: public(HashMap[uint256, EndaoPartnerPoolAction])\npendingEndaoRepayActions: public(HashMap[uint256, EndaoRepayAction])\npendingEndaoRecoverNftActions: public(HashMap[uint256, EndaoRecoverNftAction])\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\nMAX_AUCTIONS: constant(uint256) = 20\nMAX_DEBT_UPDATES: constant(uint256) = 50\nMAX_CLAIM_USERS: constant(uint256) = 50\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_TOKEN_PATH: constant(uint256) = 5\n\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nLOOTBOX_ID: constant(uint256) = 16\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef hasPermsForLiteAction(_caller: address, _hasLiteAccess: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if _hasLiteAccess:\n        return staticcall MissionControl(self._getMissionControlAddr()).canPerformLiteAction(_caller)\n    return False\n\n\n# addys lite\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(AUCTION_HOUSE_ID)\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(MISSION_CONTROL_ID)\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(CREDIT_ENGINE_ID)\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(LOOTBOX_ID)\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(VAULT_BOOK_ID)\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(ENDAOMENT_ID)\n\n\n#################\n# Pause Actions #\n#################\n\n\n@external\ndef pause(_contractAddr: address, _shouldPause: bool) -> bool:\n    assert self.hasPermsForLiteAction(msg.sender, _shouldPause) # dev: no perms\n\n    extcall RipeEcoContract(_contractAddr).pause(_shouldPause)\n    log PauseExecuted(contractAddr=_contractAddr, shouldPause=_shouldPause)\n    return True\n\n\n#########################\n# Fund Recovery Actions #\n#########################\n\n\n@external\ndef recoverFunds(_contractAddr: address, _recipient: address, _asset: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_contractAddr, _recipient, _asset] # dev: invalid parameters\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RECOVER_FUNDS\n    self.pendingRecoverFundsActions[aid] = RecoverFundsAction(\n        contractAddr=_contractAddr,\n        recipient=_recipient,\n        asset=_asset\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRecoverFundsAction(\n        contractAddr=_contractAddr,\n        recipient=_recipient,\n        asset=_asset,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef recoverFundsMany(_contractAddr: address, _recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_contractAddr, _recipient] # dev: invalid parameters\n    assert len(_assets) != 0 # dev: no assets provided\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RECOVER_FUNDS_MANY\n    self.pendingRecoverFundsManyActions[aid] = RecoverFundsManyAction(\n        contractAddr=_contractAddr,\n        recipient=_recipient,\n        assets=_assets\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRecoverFundsManyAction(\n        contractAddr=_contractAddr,\n        recipient=_recipient,\n        numAssets=len(_assets),\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n#############\n# Blacklist #\n#############\n\n\n@external\ndef setBlacklist(_tokenAddr: address, _addr: address, _shouldBlacklist: bool) -> bool:\n    assert self.hasPermsForLiteAction(msg.sender, _shouldBlacklist) # dev: no perms\n    assert empty(address) not in [_tokenAddr, _addr] # dev: invalid parameters\n\n    switchboard: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(SWITCHBOARD_ID)\n    extcall Switchboard(switchboard).setBlacklist(_tokenAddr, _addr, _shouldBlacklist)\n    log BlacklistSet(tokenAddr=_tokenAddr, addr=_addr, isBlacklisted=_shouldBlacklist, caller=msg.sender)\n    return True\n\n\n################\n# Debt Updates #\n################\n\n\n@external\ndef updateDebtForUser(_user: address) -> bool:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert _user != empty(address) # dev: invalid user\n\n    success: bool = extcall CreditEngine(self._getCreditEngineAddr()).updateDebtForUser(_user)\n    log DebtUpdatedForUser(user=_user, success=success, caller=msg.sender)\n    return success\n\n\n@external\ndef updateDebtForManyUsers(_users: DynArray[address, MAX_DEBT_UPDATES]) -> bool:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert len(_users) != 0 # dev: no users provided\n\n    creditEngineAddr: address = self._getCreditEngineAddr()\n    for u: address in _users:\n        extcall CreditEngine(creditEngineAddr).updateDebtForUser(u)\n\n    log DebtUpdatedForManyUsers(numUsers=len(_users), caller=msg.sender)\n    return True\n\n\n###############\n# Loot Claims #\n###############\n\n\n@external\ndef claimLootForUser(_user: address, _shouldStake: bool) -> uint256:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert _user != empty(address) # dev: invalid user\n\n    ripeAmount: uint256 = extcall Lootbox(self._getLootboxAddr()).claimLootForUser(_user, msg.sender, _shouldStake)\n    log LootClaimedForUser(user=_user, caller=msg.sender, shouldStake=_shouldStake, ripeAmount=ripeAmount)\n    return ripeAmount\n\n\n@external\ndef claimLootForManyUsers(_users: DynArray[address, MAX_CLAIM_USERS], _shouldStake: bool) -> uint256:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert len(_users) != 0 # dev: no users provided\n\n    totalRipeAmount: uint256 = extcall Lootbox(self._getLootboxAddr()).claimLootForManyUsers(_users, msg.sender, _shouldStake)\n    log LootClaimedForManyUsers(numUsers=len(_users), caller=msg.sender, shouldStake=_shouldStake, totalRipeAmount=totalRipeAmount)\n    return totalRipeAmount\n\n\n@external\ndef updateRipeRewards() -> bool:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n\n    extcall Lootbox(self._getLootboxAddr()).updateRipeRewards()\n    log RipeRewardsUpdated(caller=msg.sender, success=True)\n    return True\n\n\n@external\ndef claimDepositLootForAsset(_user: address, _vaultId: uint256, _asset: address) -> uint256:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert empty(address) not in [_user, _asset] # dev: invalid parameters\n\n    ripeAmount: uint256 = extcall Lootbox(self._getLootboxAddr()).claimDepositLootForAsset(_user, _vaultId, _asset)\n    log DepositLootClaimedForAsset(user=_user, vaultId=_vaultId, asset=_asset, ripeAmount=ripeAmount, caller=msg.sender)\n    return ripeAmount\n\n\n@external\ndef updateDepositPoints(_user: address, _vaultId: uint256, _asset: address) -> bool:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert empty(address) not in [_user, _asset] # dev: invalid parameters\n\n    # Get vault address from vault book\n    vaultAddr: address = staticcall VaultBook(self._getVaultBookAddr()).getAddr(_vaultId)\n    assert vaultAddr != empty(address) # dev: invalid vault\n\n    extcall Lootbox(self._getLootboxAddr()).updateDepositPoints(_user, _vaultId, vaultAddr, _asset)\n    log DepositPointsUpdated(user=_user, vaultId=_vaultId, asset=_asset, caller=msg.sender)\n    return True\n\n\n###################\n# Auction Actions #\n###################\n\n\n# start auctions\n\n\n@external\ndef startAuction(_liqUser: address, _vaultId: uint256, _asset: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_liqUser, _asset] # dev: invalid parameters\n\n    # validate auction can be started\n    auctionHouseAddr: address = self._getAuctionHouseAddr()\n    assert staticcall AuctionHouse(auctionHouseAddr).canStartAuction(_liqUser, _vaultId, _asset) # dev: cannot start auction\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.START_AUCTION\n    self.pendingStartAuctionActions[aid] = FungAuctionConfig(\n        liqUser=_liqUser,\n        vaultId=_vaultId,\n        asset=_asset\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingStartAuctionAction(\n        liqUser=_liqUser,\n        vaultId=_vaultId,\n        asset=_asset,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef startManyAuctions(_auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert len(_auctions) != 0 # dev: no auctions provided\n\n    # validate all auctions can be started\n    auctionHouseAddr: address = self._getAuctionHouseAddr()\n    for auction: FungAuctionConfig in _auctions:\n        assert staticcall AuctionHouse(auctionHouseAddr).canStartAuction(auction.liqUser, auction.vaultId, auction.asset) # dev: cannot start auction\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.START_MANY_AUCTIONS\n    self.pendingStartManyAuctionsActions[aid] = _auctions\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingStartManyAuctionsAction(\n        numAuctions=len(_auctions),\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n# pause auctions\n\n\n@external\ndef pauseAuction(_liqUser: address, _vaultId: uint256, _asset: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_liqUser, _asset] # dev: invalid parameters\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.PAUSE_AUCTION\n    self.pendingPauseAuctionActions[aid] = FungAuctionConfig(\n        liqUser=_liqUser,\n        vaultId=_vaultId,\n        asset=_asset\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingPauseAuctionAction(\n        liqUser=_liqUser,\n        vaultId=_vaultId,\n        asset=_asset,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef pauseManyAuctions(_auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert len(_auctions) != 0 # dev: no auctions provided\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.PAUSE_MANY_AUCTIONS\n    self.pendingPauseManyAuctionsActions[aid] = _auctions\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingPauseManyAuctionsAction(\n        numAuctions=len(_auctions),\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n#############\n# Endaoment #\n#############\n\n\n# no timelock required\n\n\n@external\ndef performEndaomentDeposit(_legoId: uint256, _asset: address, _vault: address, _amount: uint256 = max_value(uint256)) -> (uint256, address, uint256, uint256):\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert empty(address) not in [_asset, _vault] # dev: invalid parameters\n    assert _legoId != 0 # dev: invalid lego id\n\n    result: (uint256, address, uint256, uint256) = extcall Endaoment(self._getEndaomentAddr()).depositTokens(_legoId, _asset, _vault, _amount)\n    log EndaomentDepositPerformed(legoId=_legoId, asset=_asset, vault=_vault, amount=_amount, caller=msg.sender)\n    return result\n\n\n@external\ndef performEndaomentWithdraw(_legoId: uint256, _asset: address, _vaultAddr: address, _withdrawAmount: uint256 = max_value(uint256), _hasVaultToken: bool = True) -> (uint256, uint256, uint256):\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert empty(address) not in [_asset, _vaultAddr] # dev: invalid parameters\n    assert _legoId != 0 # dev: invalid lego id\n\n    result: (uint256, uint256, uint256) = extcall Endaoment(self._getEndaomentAddr()).withdrawTokens(_legoId, _asset, _vaultAddr, _withdrawAmount, _hasVaultToken)\n    log EndaomentWithdrawalPerformed(legoId=_legoId, asset=_asset, vaultAddr=_vaultAddr, withdrawAmount=_withdrawAmount, hasVaultToken=_hasVaultToken, caller=msg.sender)\n    return result\n\n\n@external\ndef performEndaomentRebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultAddr: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address,\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _hasFromVaultToken: bool = True,\n) -> (uint256, address, uint256, uint256):\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert empty(address) not in [_fromAsset, _fromVaultAddr, _toVaultAddr] # dev: invalid parameters\n    assert _fromLegoId != 0 and _toLegoId != 0 # dev: invalid lego ids\n\n    result: (uint256, address, uint256, uint256) = extcall Endaoment(self._getEndaomentAddr()).rebalance(_fromLegoId, _fromAsset, _fromVaultAddr, _toLegoId, _toVaultAddr, _fromVaultAmount, _hasFromVaultToken)\n    log EndaomentReblanacePerformed(fromLegoId=_fromLegoId, fromAsset=_fromAsset, fromVaultAddr=_fromVaultAddr, toLegoId=_toLegoId, toVaultAddr=_toVaultAddr, caller=msg.sender)\n    return result\n\n\n@payable\n@external\ndef performEndaomentEthToWeth(_amount: uint256 = max_value(uint256), _depositLegoId: uint256 = 0, _depositVault: address = empty(address)) -> (uint256, address, uint256):\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n\n    result: (uint256, address, uint256) = extcall Endaoment(self._getEndaomentAddr()).convertEthToWeth(_amount, _depositLegoId, _depositVault, value=msg.value)\n    log EndaomentEthToWethPerformed(amount=_amount, depositLegoId=_depositLegoId, depositVault=_depositVault, caller=msg.sender)\n    return result\n\n\n@external\ndef performEndaomentWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultAddr: address = empty(address),\n    _hasWithdrawVaultToken: bool = True,\n) -> uint256:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n\n    result: uint256 = extcall Endaoment(self._getEndaomentAddr()).convertWethToEth(_amount, _recipient, _withdrawLegoId, _withdrawVaultAddr, _hasWithdrawVaultToken)\n    log EndaomentWethToEthPerformed(amount=_amount, recipient=_recipient, withdrawLegoId=_withdrawLegoId, withdrawVaultAddr=_withdrawVaultAddr, hasWithdrawVaultToken=_hasWithdrawVaultToken, caller=msg.sender)\n    return result\n\n\n@external\ndef performEndaomentClaim(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n) -> bool:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n    assert _legoId != 0 # dev: invalid lego id\n\n    extcall Endaoment(self._getEndaomentAddr()).claimRewards(_legoId, _market, _rewardToken, _rewardAmount, _proof)\n    log EndaomentClaimPerformed(legoId=_legoId, market=_market, rewardToken=_rewardToken, caller=msg.sender)\n    return True\n\n\n@external\ndef performEndaomentStabilizer() -> bool:\n    assert self.hasPermsForLiteAction(msg.sender, True) # dev: no perms\n\n    success: bool = extcall Endaoment(self._getEndaomentAddr()).stabilizeGreenRefPool()\n    log EndaomentStabilizerPerformed(success=success, caller=msg.sender)\n    return success\n\n\n# timelock actions\n\n\n@external\ndef performEndaomentSwap(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert len(_swapInstructions) != 0 # dev: no swap instructions provided\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ENDAO_SWAP\n    self.pendingEndaoSwapActions[aid] = _swapInstructions\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingEndaoSwapAction(\n        numSwapInstructions=len(_swapInstructions),\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef addLiquidityInEndaoment(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _legoId != 0 # dev: invalid lego id\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ENDAO_ADD_LIQUIDITY\n    self.pendingEndaoAddLiquidityActions[aid] = EndaoAddLiquidityAction(\n        legoId=_legoId,\n        nftAddr=_nftAddr,\n        nftTokenId=_nftTokenId,\n        pool=_pool,\n        tokenA=_tokenA,\n        tokenB=_tokenB,\n        amountA=_amountA,\n        amountB=_amountB,\n        tickLower=_tickLower,\n        tickUpper=_tickUpper,\n        minAmountA=_minAmountA,\n        minAmountB=_minAmountB,\n        minLpAmount=_minLpAmount\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingEndaoAddLiquidityAction(\n        legoId=_legoId,\n        pool=_pool,\n        tokenA=_tokenA,\n        tokenB=_tokenB,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef removeLiquidityInEndaoment(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _legoId != 0 # dev: invalid lego id\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ENDAO_REMOVE_LIQUIDITY\n    self.pendingEndaoRemoveLiquidityActions[aid] = EndaoRemoveLiquidityAction(\n        legoId=_legoId,\n        nftAddr=_nftAddr,\n        nftTokenId=_nftTokenId,\n        pool=_pool,\n        tokenA=_tokenA,\n        tokenB=_tokenB,\n        liqToRemove=_liqToRemove,\n        minAmountA=_minAmountA,\n        minAmountB=_minAmountB\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingEndaoRemoveLiquidityAction(\n        legoId=_legoId,\n        pool=_pool,\n        tokenA=_tokenA,\n        tokenB=_tokenB,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef mintPartnerLiquidityInEndaoment(_partner: address, _asset: address, _amount: uint256 = max_value(uint256)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_partner, _asset] # dev: invalid parameters\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ENDAO_PARTNER_MINT\n    self.pendingEndaoPartnerMintActions[aid] = EndaoPartnerMintAction(\n        partner=_partner,\n        asset=_asset,\n        amount=_amount\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingEndaoPartnerMintAction(\n        partner=_partner,\n        asset=_asset,\n        amount=_amount,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef addPartnerLiquidityInEndaoment(\n    _legoId: uint256,\n    _pool: address,\n    _partner: address,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _minLpAmount: uint256 = 0,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_pool, _partner, _asset] # dev: invalid parameters\n    assert _legoId != 0 # dev: invalid lego id\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ENDAO_PARTNER_POOL\n    self.pendingEndaoPartnerPoolActions[aid] = EndaoPartnerPoolAction(\n        legoId=_legoId,\n        pool=_pool,\n        partner=_partner,\n        asset=_asset,\n        amount=_amount,\n        minLpAmount=_minLpAmount\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingEndaoPartnerPoolAction(\n        legoId=_legoId,\n        pool=_pool,\n        partner=_partner,\n        asset=_asset,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef repayPoolDebtInEndaoment(_pool: address, _amount: uint256 = max_value(uint256)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _pool != empty(address) # dev: invalid pool\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ENDAO_REPAY\n    self.pendingEndaoRepayActions[aid] = EndaoRepayAction(\n        pool=_pool,\n        amount=_amount\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingEndaoRepayAction(\n        pool=_pool,\n        amount=_amount,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n@external\ndef recoverNftInEndaoment(_collection: address, _nftTokenId: uint256, _recipient: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert empty(address) not in [_collection, _recipient] # dev: invalid parameters\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ENDOA_RECOVER_NFT\n    self.pendingEndaoRecoverNftActions[aid] = EndaoRecoverNftAction(\n        collection=_collection,\n        nftTokenId=_nftTokenId,\n        recipient=_recipient\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingEndaoRecoverNftAction(\n        collection=_collection,\n        nftTokenId=_nftTokenId,\n        recipient=_recipient,\n        confirmationBlock=confirmationBlock,\n        actionId=aid\n    )\n    return aid\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n\n    if actionType == ActionType.RECOVER_FUNDS:\n        p: RecoverFundsAction = self.pendingRecoverFundsActions[_aid]\n        extcall RipeEcoContract(p.contractAddr).recoverFunds(p.recipient, p.asset)\n        log RecoverFundsExecuted(contractAddr=p.contractAddr, recipient=p.recipient, asset=p.asset)\n\n    elif actionType == ActionType.RECOVER_FUNDS_MANY:\n        p: RecoverFundsManyAction = self.pendingRecoverFundsManyActions[_aid]\n        extcall RipeEcoContract(p.contractAddr).recoverFundsMany(p.recipient, p.assets)\n        log RecoverFundsManyExecuted(contractAddr=p.contractAddr, recipient=p.recipient, numAssets=len(p.assets))\n\n    elif actionType == ActionType.START_AUCTION:\n        p: FungAuctionConfig = self.pendingStartAuctionActions[_aid]\n        success: bool = extcall AuctionHouse(self._getAuctionHouseAddr()).startAuction(p.liqUser, p.vaultId, p.asset)\n        log StartAuctionExecuted(liqUser=p.liqUser, vaultId=p.vaultId, asset=p.asset, success=success)\n\n    elif actionType == ActionType.START_MANY_AUCTIONS:\n        auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS] = self.pendingStartManyAuctionsActions[_aid]\n        numStarted: uint256 = extcall AuctionHouse(self._getAuctionHouseAddr()).startManyAuctions(auctions)\n        log StartManyAuctionsExecuted(numAuctionsStarted=numStarted)\n\n    elif actionType == ActionType.PAUSE_AUCTION:\n        p: FungAuctionConfig = self.pendingPauseAuctionActions[_aid]\n        success: bool = extcall AuctionHouse(self._getAuctionHouseAddr()).pauseAuction(p.liqUser, p.vaultId, p.asset)\n        log PauseAuctionExecuted(liqUser=p.liqUser, vaultId=p.vaultId, asset=p.asset, success=success)\n\n    elif actionType == ActionType.PAUSE_MANY_AUCTIONS:\n        auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS] = self.pendingPauseManyAuctionsActions[_aid]\n        numPaused: uint256 = extcall AuctionHouse(self._getAuctionHouseAddr()).pauseManyAuctions(auctions)\n        log PauseManyAuctionsExecuted(numAuctionsPaused=numPaused)\n\n    elif actionType == ActionType.ENDAO_SWAP:\n        swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS] = self.pendingEndaoSwapActions[_aid]\n        extcall Endaoment(self._getEndaomentAddr()).swapTokens(swapInstructions)\n        log EndaoSwapExecuted(numSwapInstructions=len(swapInstructions))\n\n    elif actionType == ActionType.ENDAO_ADD_LIQUIDITY:\n        p: EndaoAddLiquidityAction = self.pendingEndaoAddLiquidityActions[_aid]\n        extcall Endaoment(self._getEndaomentAddr()).addLiquidity(p.legoId, p.nftAddr, p.nftTokenId, p.pool, p.tokenA, p.tokenB, p.amountA, p.amountB, p.tickLower, p.tickUpper, p.minAmountA, p.minAmountB, p.minLpAmount)\n        log EndaoAddLiquidityExecuted(legoId=p.legoId, pool=p.pool, tokenA=p.tokenA, tokenB=p.tokenB)\n\n    elif actionType == ActionType.ENDAO_REMOVE_LIQUIDITY:\n        p: EndaoRemoveLiquidityAction = self.pendingEndaoRemoveLiquidityActions[_aid]\n        extcall Endaoment(self._getEndaomentAddr()).removeLiquidity(p.legoId, p.nftAddr, p.nftTokenId, p.pool, p.tokenA, p.tokenB, p.liqToRemove, p.minAmountA, p.minAmountB)\n        log EndaoRemoveLiquidityExecuted(legoId=p.legoId, pool=p.pool, tokenA=p.tokenA, tokenB=p.tokenB)\n\n    elif actionType == ActionType.ENDAO_PARTNER_MINT:\n        p: EndaoPartnerMintAction = self.pendingEndaoPartnerMintActions[_aid]\n        greenMinted: uint256 = extcall Endaoment(self._getEndaomentAddr()).mintPartnerLiquidity(p.partner, p.asset, p.amount)\n        log EndaoPartnerMintExecuted(partner=p.partner, asset=p.asset, greenMinted=greenMinted)\n\n    elif actionType == ActionType.ENDAO_PARTNER_POOL:\n        p: EndaoPartnerPoolAction = self.pendingEndaoPartnerPoolActions[_aid]\n        extcall Endaoment(self._getEndaomentAddr()).addPartnerLiquidity(p.legoId, p.pool, p.partner, p.asset, p.amount, p.minLpAmount)\n        log EndaoPartnerPoolExecuted(legoId=p.legoId, pool=p.pool, partner=p.partner, asset=p.asset)\n\n    elif actionType == ActionType.ENDAO_REPAY:\n        p: EndaoRepayAction = self.pendingEndaoRepayActions[_aid]\n        success: bool = extcall Endaoment(self._getEndaomentAddr()).repayPoolDebt(p.pool, p.amount)\n        log EndaoRepayExecuted(pool=p.pool, success=success)\n\n    elif actionType == ActionType.ENDOA_RECOVER_NFT:\n        p: EndaoRecoverNftAction = self.pendingEndaoRecoverNftActions[_aid]\n        success: bool = extcall Endaoment(self._getEndaomentAddr()).recoverNft(p.collection, p.nftTokenId, p.recipient)\n        log EndaoRecoverNftExecuted(collection=p.collection, nftTokenId=p.nftTokenId, recipient=p.recipient, success=success)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n#################\n# Cancel Action #\n#################\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n",
            "sha256sum": "55b551d923f07e2371adac869d66974da17a2e09bc3abae321cde584004706a8"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardCharlie.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "57709b73d84a1ce7b15a37e6befa6c4bcb8470b113f832520bf0aa5f2f2dec95"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/config/SwitchboardCharlie.vy"
    },
    "SwitchboardDelta": {
      "address": "0x13fEca66C62022a9B747DF1158ae97902f6B69D7",
      "abi": [
        {
          "name": "PendingHrContribTemplateChange",
          "inputs": [
            {
              "name": "contribTemplate",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingHrMaxCompensationChange",
          "inputs": [
            {
              "name": "maxCompensation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingHrMinCliffLengthChange",
          "inputs": [
            {
              "name": "minCliffLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingHrMaxStartDelayChange",
          "inputs": [
            {
              "name": "maxStartDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingHrVestingLengthBoundariesChange",
          "inputs": [
            {
              "name": "minVestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxVestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingManagerSet",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "manager",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingCancelPaycheckSet",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeCheckCashedFromSwitchboard",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cashedBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeTransferCancelledFromSwitchboard",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelledFromSwitchboard",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ContributorFrozenFromSwitchboard",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "frozenBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldFreeze",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeBondConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountPerEpoch",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxRipePerUnitLockBonus",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shouldAutoRestart",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "restartDelayBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeBondEpochLengthSet",
          "inputs": [
            {
              "name": "epochLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingStartEpochAtBlockSet",
          "inputs": [
            {
              "name": "startBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanPurchaseRipeBondModified",
          "inputs": [
            {
              "name": "canPurchaseRipeBond",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "modifier",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingBadDebtSet",
          "inputs": [
            {
              "name": "badDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingStabClaimRewardsConfigSet",
          "inputs": [
            {
              "name": "rewardsLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripePerDollarClaimed",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrContribTemplateSet",
          "inputs": [
            {
              "name": "contribTemplate",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrMaxCompensationSet",
          "inputs": [
            {
              "name": "maxCompensation",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrMinCliffLengthSet",
          "inputs": [
            {
              "name": "minCliffLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrMaxStartDelaySet",
          "inputs": [
            {
              "name": "maxStartDelay",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrVestingLengthBoundariesSet",
          "inputs": [
            {
              "name": "minVestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxVestingLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrContributorManagerSet",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "manager",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrContributorCancelPaycheckSet",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBondConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountPerEpoch",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxRipePerUnitLockBonus",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shouldAutoRestart",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBondEpochLengthSet",
          "inputs": [
            {
              "name": "epochLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBondStartEpochAtBlockSet",
          "inputs": [
            {
              "name": "startBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BadDebtSet",
          "inputs": [
            {
              "name": "badDebt",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabClaimRewardsConfigSet",
          "inputs": [
            {
              "name": "rewardsLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripePerDollarClaimed",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setContributorTemplate",
          "inputs": [
            {
              "name": "_contribTemplate",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxCompensation",
          "inputs": [
            {
              "name": "_maxComp",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMinCliffLength",
          "inputs": [
            {
              "name": "_minCliffLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxStartDelay",
          "inputs": [
            {
              "name": "_maxStartDelay",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setVestingLengthBoundaries",
          "inputs": [
            {
              "name": "_minVestingLength",
              "type": "uint256"
            },
            {
              "name": "_maxVestingLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPaycheckForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManagerForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            },
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cashRipeCheckForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelRipeTransferForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChangeForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "freezeContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            },
            {
              "name": "_shouldFreeze",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeBondConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amountPerEpoch",
              "type": "uint256"
            },
            {
              "name": "_minRipePerUnit",
              "type": "uint256"
            },
            {
              "name": "_maxRipePerUnit",
              "type": "uint256"
            },
            {
              "name": "_maxRipePerUnitLockBonus",
              "type": "uint256"
            },
            {
              "name": "_shouldAutoRestart",
              "type": "bool"
            },
            {
              "name": "_restartDelayBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeBondEpochLength",
          "inputs": [
            {
              "name": "_epochLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStartEpochAtBlock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStartEpochAtBlock",
          "inputs": [
            {
              "name": "_block",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPurchaseRipeBond",
          "inputs": [
            {
              "name": "_canBond",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBadDebt",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStabClaimRewardsConfig",
          "inputs": [
            {
              "name": "_rewardsLockDuration",
              "type": "uint256"
            },
            {
              "name": "_ripePerDollarClaimed",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHrConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contribTemplate",
                  "type": "address"
                },
                {
                  "name": "maxCompensation",
                  "type": "uint256"
                },
                {
                  "name": "minCliffLength",
                  "type": "uint256"
                },
                {
                  "name": "maxStartDelay",
                  "type": "uint256"
                },
                {
                  "name": "minVestingLength",
                  "type": "uint256"
                },
                {
                  "name": "maxVestingLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingManager",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contributor",
                  "type": "address"
                },
                {
                  "name": "pendingManager",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingCancelPaycheck",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRipeBondConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amountPerEpoch",
                  "type": "uint256"
                },
                {
                  "name": "canBond",
                  "type": "bool"
                },
                {
                  "name": "minRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnitLockBonus",
                  "type": "uint256"
                },
                {
                  "name": "epochLength",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoRestart",
                  "type": "bool"
                },
                {
                  "name": "restartDelayBlocks",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRipeBondConfigValue",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingStabClaimRewardsConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "rewardsLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "ripePerDollarClaimed",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "d3cc46c981ea30e6cd26b22d4c6b6a72250055331934280527b5eb6de8ad8189"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "contracts/config/SwitchboardDelta.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\nfrom interfaces import Vault\nimport interfaces.ConfigStructs as cs\n\ninterface HrContributor:\n    def setIsFrozen(_shouldFreeze: bool) -> bool: nonpayable\n    def setManager(_manager: address): nonpayable\n    def cashRipeCheck() -> uint256: nonpayable\n    def cancelOwnershipChange(): nonpayable\n    def cancelRipeTransfer(): nonpayable\n    def cancelPaycheck(): nonpayable\n\ninterface MissionControl:\n    def setStabClaimRewardsConfig(_config: cs.StabClaimRewardsConfig): nonpayable\n    def setRipeBondConfig(_config: cs.RipeBondConfig): nonpayable\n    def canPerformLiteAction(_user: address) -> bool: view\n    def setHrConfig(_config: cs.HrConfig): nonpayable\n    def ripeBondConfig() -> cs.RipeBondConfig: view\n    def hrConfig() -> cs.HrConfig: view\n\ninterface Ledger:\n    def isHrContributor(_contributor: address) -> bool: view\n    def setBadDebt(_amount: uint256): nonpayable\n\ninterface BondRoom:\n    def startBondEpochAtBlock(_block: uint256): nonpayable\n\ninterface RipeHq:\n    def getAddr(_regId: uint256) -> address: view\n\nflag ActionType:\n    HR_CONFIG_TEMPLATE\n    HR_CONFIG_MAX_COMP\n    HR_CONFIG_MIN_CLIFF\n    HR_CONFIG_MAX_START_DELAY\n    HR_CONFIG_VESTING\n    HR_MANAGER\n    HR_CANCEL_PAYCHECK\n    RIPE_BOND_CONFIG\n    RIPE_BOND_EPOCH_LENGTH\n    RIPE_BOND_START_EPOCH\n    RIPE_BAD_DEBT\n    STAB_CLAIM_REWARDS\n\nstruct PendingManager:\n    contributor: address\n    pendingManager: address\n\nstruct PendingCancelPaycheck:\n    contributor: address\n    pendingShouldCancel: bool\n\nevent PendingHrContribTemplateChange:\n    contribTemplate: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingHrMaxCompensationChange:\n    maxCompensation: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingHrMinCliffLengthChange:\n    minCliffLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingHrMaxStartDelayChange:\n    maxStartDelay: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingHrVestingLengthBoundariesChange:\n    minVestingLength: uint256\n    maxVestingLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingManagerSet:\n    contributor: indexed(address)\n    manager: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingCancelPaycheckSet:\n    contributor: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent RipeCheckCashedFromSwitchboard:\n    contributor: indexed(address)\n    cashedBy: indexed(address)\n    amount: uint256\n\nevent RipeTransferCancelledFromSwitchboard:\n    contributor: indexed(address)\n    cancelledBy: indexed(address)\n\nevent OwnershipChangeCancelledFromSwitchboard:\n    contributor: indexed(address)\n    cancelledBy: indexed(address)\n\nevent ContributorFrozenFromSwitchboard:\n    contributor: indexed(address)\n    frozenBy: indexed(address)\n    shouldFreeze: bool\n\nevent PendingRipeBondConfigSet:\n    asset: indexed(address)\n    amountPerEpoch: uint256\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRipeBondEpochLengthSet:\n    epochLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingStartEpochAtBlockSet:\n    startBlock: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CanPurchaseRipeBondModified:\n    canPurchaseRipeBond: bool\n    modifier: indexed(address)\n\nevent PendingBadDebtSet:\n    badDebt: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingStabClaimRewardsConfigSet:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent HrContribTemplateSet:\n    contribTemplate: indexed(address)\n\nevent HrMaxCompensationSet:\n    maxCompensation: uint256\n\nevent HrMinCliffLengthSet:\n    minCliffLength: uint256\n\nevent HrMaxStartDelaySet:\n    maxStartDelay: uint256\n\nevent HrVestingLengthBoundariesSet:\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nevent HrContributorManagerSet:\n    contributor: indexed(address)\n    manager: indexed(address)\n\nevent HrContributorCancelPaycheckSet:\n    contributor: indexed(address)\n\nevent RipeBondConfigSet:\n    asset: indexed(address)\n    amountPerEpoch: uint256\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    shouldAutoRestart: bool\n\nevent RipeBondEpochLengthSet:\n    epochLength: uint256\n\nevent RipeBondStartEpochAtBlockSet:\n    startBlock: uint256\n\nevent BadDebtSet:\n    badDebt: uint256\n\nevent StabClaimRewardsConfigSet:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\n# pending config changes\nactionType: public(HashMap[uint256, ActionType]) # aid -> type\npendingHrConfig: public(HashMap[uint256, cs.HrConfig]) # aid -> config\npendingManager: public(HashMap[uint256, PendingManager]) # aid -> pending manager\npendingCancelPaycheck: public(HashMap[uint256, address]) # aid -> contributor\npendingRipeBondConfig: public(HashMap[uint256, cs.RipeBondConfig]) # aid -> config\npendingRipeBondConfigValue: public(HashMap[uint256, uint256]) # aid -> block\npendingStabClaimRewardsConfig: public(HashMap[uint256, cs.StabClaimRewardsConfig]) # aid -> config\n\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nBOND_ROOM_ID: constant(uint256) = 12\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\n\n# timestamp units (not blocks!)\nDAY_IN_SECONDS: constant(uint256) = 60 * 60 * 24\nWEEK_IN_SECONDS: constant(uint256) = 7 * DAY_IN_SECONDS\nMONTH_IN_SECONDS: constant(uint256) = 30 * DAY_IN_SECONDS\nYEAR_IN_SECONDS: constant(uint256) = 365 * DAY_IN_SECONDS\n\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPermsToEnable(_caller: address, _isLite: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if _isLite:\n        return staticcall MissionControl(self._getMissionControlAddr()).canPerformLiteAction(_caller)\n    return False\n\n\n# addys lite\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(MISSION_CONTROL_ID)\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(LEDGER_ID)\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(BOND_ROOM_ID)\n\n\n#############\n# HR Config #\n#############\n\n\n# contrib template\n\n\n@external\ndef setContributorTemplate(_contribTemplate: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _contribTemplate.is_contract and _contribTemplate != empty(address) # dev: invalid contrib template\n    return self._setPendingHrConfig(ActionType.HR_CONFIG_TEMPLATE, _contribTemplate)\n\n\n# max compensation\n\n\n@external\ndef setMaxCompensation(_maxComp: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _maxComp != 0 and _maxComp <= 20_000_000 * EIGHTEEN_DECIMALS # dev: invalid max compensation\n    return self._setPendingHrConfig(ActionType.HR_CONFIG_MAX_COMP, empty(address), _maxComp)\n\n\n# min cliff length\n\n\n@external\ndef setMinCliffLength(_minCliffLength: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _minCliffLength > WEEK_IN_SECONDS # dev: invalid min cliff length\n    return self._setPendingHrConfig(ActionType.HR_CONFIG_MIN_CLIFF, empty(address), 0, _minCliffLength)\n\n\n# max start delay\n\n\n@external\ndef setMaxStartDelay(_maxStartDelay: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _maxStartDelay <= 3 * MONTH_IN_SECONDS # dev: invalid max start delay\n    return self._setPendingHrConfig(ActionType.HR_CONFIG_MAX_START_DELAY, empty(address), 0, 0, _maxStartDelay)\n\n\n# min vesting length\n\n\n@external\ndef setVestingLengthBoundaries(_minVestingLength: uint256, _maxVestingLength: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _minVestingLength < _maxVestingLength # dev: invalid vesting length boundaries\n    assert _minVestingLength > MONTH_IN_SECONDS # dev: invalid min vesting length\n    assert _maxVestingLength <= 5 * YEAR_IN_SECONDS # dev: invalid max vesting length\n    return self._setPendingHrConfig(ActionType.HR_CONFIG_VESTING, empty(address), 0, 0, 0, _minVestingLength, _maxVestingLength)\n\n\n# set pending hr config\n\n\n@internal\ndef _setPendingHrConfig(\n    _actionType: ActionType,\n    _contribTemplate: address = empty(address),\n    _maxCompensation: uint256 = 0,\n    _minCliffLength: uint256 = 0,\n    _maxStartDelay: uint256 = 0,\n    _minVestingLength: uint256 = 0,\n    _maxVestingLength: uint256 = 0,\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = _actionType\n    self.pendingHrConfig[aid] = cs.HrConfig(\n        contribTemplate=_contribTemplate,\n        maxCompensation=_maxCompensation,\n        minCliffLength=_minCliffLength,\n        maxStartDelay=_maxStartDelay,\n        minVestingLength=_minVestingLength,\n        maxVestingLength=_maxVestingLength,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.HR_CONFIG_TEMPLATE:\n        log PendingHrContribTemplateChange(\n            contribTemplate=_contribTemplate,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.HR_CONFIG_MAX_COMP:\n        log PendingHrMaxCompensationChange(\n            maxCompensation=_maxCompensation,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.HR_CONFIG_MIN_CLIFF:\n        log PendingHrMinCliffLengthChange(\n            minCliffLength=_minCliffLength,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.HR_CONFIG_MAX_START_DELAY:\n        log PendingHrMaxStartDelayChange(\n            maxStartDelay=_maxStartDelay,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.HR_CONFIG_VESTING:\n        log PendingHrVestingLengthBoundariesChange(\n            minVestingLength=_minVestingLength,\n            maxVestingLength=_maxVestingLength,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n#######################\n# Contributor Options #\n#######################\n\n\n# cancel paycheck\n\n\n@external\ndef cancelPaycheckForContributor(_contributor: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert staticcall Ledger(self._getLedgerAddr()).isHrContributor(_contributor) # dev: not a contributor\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.HR_CANCEL_PAYCHECK\n    self.pendingCancelPaycheck[aid] = _contributor\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingCancelPaycheckSet(contributor=_contributor, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# set manager\n\n\n@external\ndef setManagerForContributor(_contributor: address, _manager: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _manager != empty(address) # dev: invalid manager\n    assert staticcall Ledger(self._getLedgerAddr()).isHrContributor(_contributor) # dev: not a contributor\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.HR_MANAGER\n    self.pendingManager[aid] = PendingManager(contributor=_contributor, pendingManager=_manager)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingManagerSet(contributor=_contributor, manager=_manager, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# lite actions\n\n\n@external\ndef cashRipeCheckForContributor(_contributor: address) -> bool:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    amount: uint256 = extcall HrContributor(_contributor).cashRipeCheck()\n    log RipeCheckCashedFromSwitchboard(contributor=_contributor, cashedBy=msg.sender, amount=amount)\n    return True\n\n\n@external\ndef cancelRipeTransferForContributor(_contributor: address) -> bool:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    extcall HrContributor(_contributor).cancelRipeTransfer()\n    log RipeTransferCancelledFromSwitchboard(contributor=_contributor, cancelledBy=msg.sender)\n    return True\n\n\n@external\ndef cancelOwnershipChangeForContributor(_contributor: address) -> bool:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    extcall HrContributor(_contributor).cancelOwnershipChange()\n    log OwnershipChangeCancelledFromSwitchboard(contributor=_contributor, cancelledBy=msg.sender)\n    return True\n\n\n@external\ndef freezeContributor(_contributor: address, _shouldFreeze: bool) -> bool:\n    assert self._hasPermsToEnable(msg.sender, _shouldFreeze) # dev: no perms\n    assert extcall HrContributor(_contributor).setIsFrozen(_shouldFreeze) # dev: could not freeze\n    log ContributorFrozenFromSwitchboard(contributor=_contributor, frozenBy=msg.sender, shouldFreeze=_shouldFreeze)\n    return True\n\n\n####################\n# Ripe Bond Config #\n####################\n\n\n# main config\n\n\n@external\ndef setRipeBondConfig(\n    _asset: address,\n    _amountPerEpoch: uint256,\n    _minRipePerUnit: uint256,\n    _maxRipePerUnit: uint256,\n    _maxRipePerUnitLockBonus: uint256,\n    _shouldAutoRestart: bool,\n    _restartDelayBlocks: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_BOND_CONFIG\n\n    assert _asset != empty(address) # dev: invalid asset\n    assert 0 not in [_amountPerEpoch, _maxRipePerUnit] # dev: invalid config\n    assert _minRipePerUnit < _maxRipePerUnit # dev: invalid min/max ripe per unit\n\n    self.pendingRipeBondConfig[aid] = cs.RipeBondConfig(\n        asset=_asset,\n        amountPerEpoch=_amountPerEpoch,\n        canBond=False,\n        minRipePerUnit=_minRipePerUnit,\n        maxRipePerUnit=_maxRipePerUnit,\n        maxRipePerUnitLockBonus=_maxRipePerUnitLockBonus,\n        epochLength=0,\n        shouldAutoRestart=_shouldAutoRestart,\n        restartDelayBlocks=_restartDelayBlocks,\n    )\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRipeBondConfigSet(\n        asset=_asset,\n        amountPerEpoch=_amountPerEpoch,\n        minRipePerUnit=_minRipePerUnit,\n        maxRipePerUnit=_maxRipePerUnit,\n        maxRipePerUnitLockBonus=_maxRipePerUnitLockBonus,\n        shouldAutoRestart=_shouldAutoRestart,\n        restartDelayBlocks=_restartDelayBlocks,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n# epoch length\n\n\n@external\ndef setRipeBondEpochLength(_epochLength: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _epochLength != 0 # dev: invalid epoch length\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_BOND_EPOCH_LENGTH\n    self.pendingRipeBondConfigValue[aid] = _epochLength\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRipeBondEpochLengthSet(epochLength=_epochLength, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# start epoch at block\n\n\n@external\ndef setStartEpochAtBlock(_block: uint256 = 0) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_BOND_START_EPOCH\n    blockNum: uint256 = max(_block, block.number)\n    self.pendingRipeBondConfigValue[aid] = blockNum\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingStartEpochAtBlockSet(startBlock=blockNum, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# disable / enable bonding\n\n\n@external\ndef setCanPurchaseRipeBond(_canBond: bool) -> bool:\n    assert self._hasPermsToEnable(msg.sender, not _canBond) # dev: no perms\n    mc: address = self._getMissionControlAddr()\n    config: cs.RipeBondConfig = staticcall MissionControl(mc).ripeBondConfig()\n    assert config.canBond != _canBond # dev: no change\n    config.canBond = _canBond\n    extcall MissionControl(mc).setRipeBondConfig(config)\n    log CanPurchaseRipeBondModified(canPurchaseRipeBond=_canBond, modifier=msg.sender)\n    return True\n\n\n# set bad debt\n\n\n@external\ndef setBadDebt(_amount: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_BAD_DEBT\n    self.pendingRipeBondConfigValue[aid] = _amount\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingBadDebtSet(badDebt=_amount, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n###########################\n# Stab Pool Claim Rewards #\n###########################\n\n\n@external\ndef setStabClaimRewardsConfig(_rewardsLockDuration: uint256, _ripePerDollarClaimed: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _ripePerDollarClaimed != 0 # dev: invalid ripe per dollar claimed\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.STAB_CLAIM_REWARDS\n    self.pendingStabClaimRewardsConfig[aid] = cs.StabClaimRewardsConfig(\n        rewardsLockDuration=_rewardsLockDuration,\n        ripePerDollarClaimed=_ripePerDollarClaimed,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingStabClaimRewardsConfigSet(\n        rewardsLockDuration=_rewardsLockDuration,\n        ripePerDollarClaimed=_ripePerDollarClaimed,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n    mc: address = self._getMissionControlAddr()\n\n    if actionType == ActionType.HR_CONFIG_TEMPLATE:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        config.contribTemplate = self.pendingHrConfig[_aid].contribTemplate\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrContribTemplateSet(contribTemplate=config.contribTemplate)\n\n    elif actionType == ActionType.HR_CONFIG_MAX_COMP:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        p: cs.HrConfig = self.pendingHrConfig[_aid]\n        config.maxCompensation = p.maxCompensation\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrMaxCompensationSet(maxCompensation=p.maxCompensation)\n\n    elif actionType == ActionType.HR_CONFIG_MIN_CLIFF:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        p: cs.HrConfig = self.pendingHrConfig[_aid]\n        config.minCliffLength = p.minCliffLength\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrMinCliffLengthSet(minCliffLength=p.minCliffLength)\n\n    elif actionType == ActionType.HR_CONFIG_MAX_START_DELAY:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        p: cs.HrConfig = self.pendingHrConfig[_aid]\n        config.maxStartDelay = p.maxStartDelay\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrMaxStartDelaySet(maxStartDelay=p.maxStartDelay)\n\n    elif actionType == ActionType.HR_CONFIG_VESTING:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        p: cs.HrConfig = self.pendingHrConfig[_aid]\n        config.minVestingLength = p.minVestingLength\n        config.maxVestingLength = p.maxVestingLength\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrVestingLengthBoundariesSet(minVestingLength=p.minVestingLength, maxVestingLength=p.maxVestingLength)\n\n    elif actionType == ActionType.HR_MANAGER:\n        p: PendingManager = self.pendingManager[_aid]\n        extcall HrContributor(p.contributor).setManager(p.pendingManager)\n        log HrContributorManagerSet(contributor=p.contributor, manager=p.pendingManager)\n\n    elif actionType == ActionType.HR_CANCEL_PAYCHECK:\n        p: address = self.pendingCancelPaycheck[_aid]\n        extcall HrContributor(p).cancelPaycheck()\n        log HrContributorCancelPaycheckSet(contributor=p)\n\n    elif actionType == ActionType.RIPE_BOND_CONFIG:\n        p: cs.RipeBondConfig = self.pendingRipeBondConfig[_aid]\n        config: cs.RipeBondConfig = staticcall MissionControl(mc).ripeBondConfig()\n        config.asset = p.asset\n        config.amountPerEpoch = p.amountPerEpoch\n        config.minRipePerUnit = p.minRipePerUnit\n        config.maxRipePerUnit = p.maxRipePerUnit\n        config.maxRipePerUnitLockBonus = p.maxRipePerUnitLockBonus\n        config.shouldAutoRestart = p.shouldAutoRestart\n        config.restartDelayBlocks = p.restartDelayBlocks\n        extcall MissionControl(mc).setRipeBondConfig(config)\n        extcall BondRoom(self._getBondRoomAddr()).startBondEpochAtBlock(0) # reset epoch\n        log RipeBondConfigSet(asset=p.asset, amountPerEpoch=p.amountPerEpoch, minRipePerUnit=p.minRipePerUnit, maxRipePerUnit=p.maxRipePerUnit, maxRipePerUnitLockBonus=p.maxRipePerUnitLockBonus, shouldAutoRestart=p.shouldAutoRestart)\n\n    elif actionType == ActionType.RIPE_BOND_EPOCH_LENGTH:\n        config: cs.RipeBondConfig = staticcall MissionControl(mc).ripeBondConfig()\n        config.epochLength = self.pendingRipeBondConfigValue[_aid]\n        extcall MissionControl(mc).setRipeBondConfig(config)\n        extcall BondRoom(self._getBondRoomAddr()).startBondEpochAtBlock(0) # reset epoch\n        log RipeBondEpochLengthSet(epochLength=config.epochLength)\n\n    elif actionType == ActionType.RIPE_BOND_START_EPOCH:\n        startBlock: uint256 = self.pendingRipeBondConfigValue[_aid]\n        extcall BondRoom(self._getBondRoomAddr()).startBondEpochAtBlock(startBlock)\n        log RipeBondStartEpochAtBlockSet(startBlock=startBlock)\n\n    elif actionType == ActionType.RIPE_BAD_DEBT:\n        amount: uint256 = self.pendingRipeBondConfigValue[_aid]\n        extcall Ledger(self._getLedgerAddr()).setBadDebt(amount)\n        log BadDebtSet(badDebt=amount)\n\n    elif actionType == ActionType.STAB_CLAIM_REWARDS:\n        p: cs.StabClaimRewardsConfig = self.pendingStabClaimRewardsConfig[_aid]\n        extcall MissionControl(mc).setStabClaimRewardsConfig(p)\n        log StabClaimRewardsConfigSet(rewardsLockDuration=p.rewardsLockDuration, ripePerDollarClaimed=p.ripePerDollarClaimed)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n# cancel action\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n\n\n",
            "sha256sum": "527d77a36e580ad142416d48c8e6c59afda6e94ea237092e2960622e0d00c0e1"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardDelta.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "2d9562131c20a925998854200f96bc9e66bf9839ea12d892fe057ba9c3904e45"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/config/SwitchboardDelta.vy"
    },
    "PriceDesk": {
      "address": "0x013f4FEb481Ce850C62Bd35115259A5bD9804858",
      "abi": [
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAssetAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthUsdValue",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getEthAmount",
          "inputs": [
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/registries/modules/AddressRegistry.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "45a6786be62ebfcd266d4b9f321aa22bfc8d125d6ce75ffcf4d895ad011ff661"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/PriceSource.vyi": {
            "content": "# @version 0.4.1\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, 50]:\n    ...\n\n\n@external \ndef addPriceSnapshot(_asset: address) -> bool:\n    ...\n\n\n################\n# Feed Changes #\n################\n\n\n# new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    ...\n\n\n# update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n# disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n#############\n# Time Lock #\n#############\n\n\n@view\n@external\ndef actionTimeLock() -> uint256:\n    ...\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    ...\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    ...\n\n\n@external\ndef setActionTimeLock(_numBlocks: uint256) -> bool:\n    ...\n\n\n@external\ndef setActionTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "5cd017242bcfbc143e3d3caa968bf871568aefdee7980349a611b92447d8fd1d"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/registries/PriceDesk.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.registries.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import PriceSource\nfrom interfaces import Department\nfrom ethereum.ercs import IERC20Detailed\n\ninterface MissionControl:\n    def getPriceConfig() -> PriceConfig: view\n    def underscoreRegistry() -> address: view\n\ninterface UnderscoreRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\nstruct PriceConfig:\n    staleTime: uint256\n    priorityPriceSourceIds: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES]\n\nETH: public(immutable(address))\nMAX_PRIORITY_PRICE_SOURCES: constant(uint256) = 10\nLEGO_REGISTRY_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _ethAddr: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    assert _ethAddr != empty(address) # dev: invalid eth addr\n    ETH = _ethAddr\n\n    # modules\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"PriceDesk.vy\")\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n\n#############################\n# Asset Amount -> USD Value #\n#############################\n\n\n@view\n@external\ndef getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256:\n    if _amount == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return price * _amount // (10 ** decimals)\n\n\n#############################\n# USD Value -> Asset Amount #\n#############################\n\n\n@view\n@external\ndef getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    if _usdValue == 0 or _asset == empty(address):\n        return 0\n    price: uint256 = self._getPrice(_asset, _shouldRaise)\n    if price == 0:\n        return 0\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    return _usdValue * (10 ** decimals) // price\n\n\n#############\n# Get Price #\n#############\n\n\n@view\n@external\ndef getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    if _asset == empty(address):\n        return 0\n    return self._getPrice(_asset, _shouldRaise)\n\n\n@view\n@internal\ndef _getPrice(_asset: address, _shouldRaise: bool = False) -> uint256:\n    price: uint256 = 0\n    hasFeedConfig: bool = False\n    alreadyLooked: DynArray[uint256, MAX_PRIORITY_PRICE_SOURCES] = []\n\n    # config\n    config: PriceConfig = staticcall MissionControl(addys._getMissionControlAddr()).getPriceConfig()\n\n    # go thru priority partners first\n    for pid: uint256 in config.priorityPriceSourceIds:\n        hasFeed: bool = False\n        price, hasFeed = self._getPriceFromPriceSource(pid, _asset, config.staleTime)\n        if price != 0:\n            break\n        if hasFeed:\n            hasFeedConfig = True\n        alreadyLooked.append(pid)\n\n    # go thru rest of price sources\n    if price == 0:\n        numSources: uint256 = registry.numAddrs\n        if numSources != 0:\n            for pid: uint256 in range(1, numSources, bound=max_value(uint256)):\n                if pid in alreadyLooked:\n                    continue\n                hasFeed: bool = False\n                price, hasFeed = self._getPriceFromPriceSource(pid, _asset, config.staleTime)\n                if price != 0:\n                    break\n                if hasFeed:\n                    hasFeedConfig = True\n\n    # raise exception if feed exists but no price\n    if price == 0 and hasFeedConfig and _shouldRaise:\n        raise \"has price config, no price\"\n\n    return price\n\n\n@view\n@internal\ndef _getPriceFromPriceSource(_pid: uint256, _asset: address, _staleTime: uint256) -> (uint256, bool):\n    priceSource: address = registry._getAddr(_pid)\n    if priceSource == empty(address):\n        return 0, False\n    return staticcall PriceSource(priceSource).getPriceAndHasFeed(_asset, _staleTime, self)\n\n\n###############\n# Other Utils #\n###############\n\n\n# ETH\n\n\n@view\n@external\ndef getEthUsdValue(_amount: uint256, _shouldRaise: bool = False) -> uint256:\n    if _amount == 0:\n        return 0\n    return self._getPrice(ETH, _shouldRaise) * _amount // (10 ** 18)\n\n\n@view\n@external\ndef getEthAmount(_usdValue: uint256, _shouldRaise: bool = False) -> uint256:\n    if _usdValue == 0:\n        return 0\n    price: uint256 = self._getPrice(ETH, _shouldRaise)\n    if price == 0:\n        return 0\n    return _usdValue * (10 ** 18) // price\n\n\n# has feed\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    numSources: uint256 = registry.numAddrs\n    if numSources == 0:\n        return False\n    for pid: uint256 in range(1, numSources, bound=max_value(uint256)):\n        priceSource: address = registry._getAddr(pid)\n        if priceSource == empty(address):\n            continue\n        if staticcall PriceSource(priceSource).hasPriceFeed(_asset):\n            return True\n    return False\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n@external \ndef addPriceSnapshot(_asset: address) -> bool:\n    if not addys._isValidRipeAddr(msg.sender):\n        assert self._isUndyLegoRegistry(msg.sender) # dev: no perms\n\n    numSources: uint256 = registry.numAddrs\n    if numSources == 0:\n        return False\n\n    didUpdate: bool = False\n    for pid: uint256 in range(1, numSources, bound=max_value(uint256)):\n        priceSource: address = registry._getAddr(pid)\n        if priceSource == empty(address):\n            continue\n\n        if staticcall PriceSource(priceSource).hasPriceFeed(_asset):\n            extcall PriceSource(priceSource).addPriceSnapshot(_asset)\n            didUpdate = True\n\n    return didUpdate\n\n\n@view\n@internal\ndef _isUndyLegoRegistry(_addr: address) -> bool:\n    underscore: address = staticcall MissionControl(addys._getMissionControlAddr()).underscoreRegistry()\n    if underscore == empty(address):\n        return False\n    return _addr == staticcall UnderscoreRegistry(underscore).getAddy(LEGO_REGISTRY_ID)",
            "sha256sum": "23c59136332348b0c745137bbd4a6aba896aaf713b247d7c9abb9e8b64aad314"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/PriceDesk.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "ca3f6e272ddb43c3a4c68e4fe6c8f5f3c05d66ceda3d1c116b1246a211ae004a"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee00000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/registries/PriceDesk.vy"
    },
    "MockUsdcFeed": {
      "address": "0xB6FCFc7f765ac97e5b27Fd2Ae99291f34A7D7934",
      "abi": [
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernance",
          "inputs": [
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "latestRoundData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "roundId",
                  "type": "uint80"
                },
                {
                  "name": "answer",
                  "type": "int256"
                },
                {
                  "name": "startedAt",
                  "type": "uint256"
                },
                {
                  "name": "updatedAt",
                  "type": "uint256"
                },
                {
                  "name": "answeredInRound",
                  "type": "uint80"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDecimals",
          "inputs": [
            {
              "name": "_decimals",
              "type": "uint8"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            },
            {
              "name": "_updatedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_localPrice",
              "type": "uint256"
            },
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/mock/MockChainlinkFeed.vy": {
            "content": "# @version 0.4.1\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nmockData: ChainlinkRound\n_decimals: uint8\n\n\ngovernance: public(address)\n\n@deploy\ndef __init__(_localPrice: uint256, _governance: address): # should be 18 decimals\n    self.governance = _governance\n    self._decimals = 8\n    if _localPrice != 0:\n        self.mockData = ChainlinkRound(\n            roundId=1,\n            answer=convert(_localPrice // (10 ** 10), int256),\n            startedAt=block.timestamp,\n            updatedAt=block.timestamp,\n            answeredInRound=1,\n        )\n\n    # set governance\n    self.governance = _governance\n\n@external\ndef setGovernance(\n    _governance: address,\n):\n    assert msg.sender == self.governance\n    self.governance = _governance\n\n@view \n@external \ndef latestRoundData() -> ChainlinkRound:\n    return self.mockData\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return self._decimals\n\n\n@external\ndef setDecimals(\n    _decimals: uint8,\n):\n    self._decimals = _decimals\n\n\n@external\ndef setMockData(\n    _price: int256, # 8 decimals\n    _roundId: uint80 = 1,\n    _answeredInRound: uint80 = 1,\n    _startedAt: uint256 = block.timestamp,\n    _updatedAt: uint256 = block.timestamp,\n):\n    assert msg.sender == self.governance\n    self.mockData = ChainlinkRound(\n        roundId=_roundId,\n        answer=_price,\n        startedAt=_startedAt,\n        updatedAt=_updatedAt,\n        answeredInRound=_answeredInRound,\n    )",
            "sha256sum": "8e162121c8d47bcffbbda16175bee3e50dee2728b27efc631cf5454c1cc9f4a7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/MockChainlinkFeed.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "cd94a10aedb3a0d0a09db7c4d017483c8a53cbc51df3f58e3b03e659c6a0dede"
      },
      "args": "0000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e",
      "file": "contracts/mock/MockChainlinkFeed.vy"
    },
    "MockBtcFeed": {
      "address": "0x187864a434E238fA2ED6bc599bc7BeC6EC9cf108",
      "abi": [
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernance",
          "inputs": [
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "latestRoundData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "roundId",
                  "type": "uint80"
                },
                {
                  "name": "answer",
                  "type": "int256"
                },
                {
                  "name": "startedAt",
                  "type": "uint256"
                },
                {
                  "name": "updatedAt",
                  "type": "uint256"
                },
                {
                  "name": "answeredInRound",
                  "type": "uint80"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDecimals",
          "inputs": [
            {
              "name": "_decimals",
              "type": "uint8"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            },
            {
              "name": "_updatedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_localPrice",
              "type": "uint256"
            },
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/mock/MockChainlinkFeed.vy": {
            "content": "# @version 0.4.1\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nmockData: ChainlinkRound\n_decimals: uint8\n\n\ngovernance: public(address)\n\n@deploy\ndef __init__(_localPrice: uint256, _governance: address): # should be 18 decimals\n    self.governance = _governance\n    self._decimals = 8\n    if _localPrice != 0:\n        self.mockData = ChainlinkRound(\n            roundId=1,\n            answer=convert(_localPrice // (10 ** 10), int256),\n            startedAt=block.timestamp,\n            updatedAt=block.timestamp,\n            answeredInRound=1,\n        )\n\n    # set governance\n    self.governance = _governance\n\n@external\ndef setGovernance(\n    _governance: address,\n):\n    assert msg.sender == self.governance\n    self.governance = _governance\n\n@view \n@external \ndef latestRoundData() -> ChainlinkRound:\n    return self.mockData\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return self._decimals\n\n\n@external\ndef setDecimals(\n    _decimals: uint8,\n):\n    self._decimals = _decimals\n\n\n@external\ndef setMockData(\n    _price: int256, # 8 decimals\n    _roundId: uint80 = 1,\n    _answeredInRound: uint80 = 1,\n    _startedAt: uint256 = block.timestamp,\n    _updatedAt: uint256 = block.timestamp,\n):\n    assert msg.sender == self.governance\n    self.mockData = ChainlinkRound(\n        roundId=_roundId,\n        answer=_price,\n        startedAt=_startedAt,\n        updatedAt=_updatedAt,\n        answeredInRound=_answeredInRound,\n    )",
            "sha256sum": "8e162121c8d47bcffbbda16175bee3e50dee2728b27efc631cf5454c1cc9f4a7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/MockChainlinkFeed.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "cd94a10aedb3a0d0a09db7c4d017483c8a53cbc51df3f58e3b03e659c6a0dede"
      },
      "args": "00000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e",
      "file": "contracts/mock/MockChainlinkFeed.vy"
    },
    "MockEthFeed": {
      "address": "0xc501B300F2808F6b28F6c08AFb72441a97394F18",
      "abi": [
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovernance",
          "inputs": [
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "latestRoundData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "roundId",
                  "type": "uint80"
                },
                {
                  "name": "answer",
                  "type": "int256"
                },
                {
                  "name": "startedAt",
                  "type": "uint256"
                },
                {
                  "name": "updatedAt",
                  "type": "uint256"
                },
                {
                  "name": "answeredInRound",
                  "type": "uint80"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "decimals",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint8"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDecimals",
          "inputs": [
            {
              "name": "_decimals",
              "type": "uint8"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMockData",
          "inputs": [
            {
              "name": "_price",
              "type": "int256"
            },
            {
              "name": "_roundId",
              "type": "uint80"
            },
            {
              "name": "_answeredInRound",
              "type": "uint80"
            },
            {
              "name": "_startedAt",
              "type": "uint256"
            },
            {
              "name": "_updatedAt",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_localPrice",
              "type": "uint256"
            },
            {
              "name": "_governance",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/mock/MockChainlinkFeed.vy": {
            "content": "# @version 0.4.1\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nmockData: ChainlinkRound\n_decimals: uint8\n\n\ngovernance: public(address)\n\n@deploy\ndef __init__(_localPrice: uint256, _governance: address): # should be 18 decimals\n    self.governance = _governance\n    self._decimals = 8\n    if _localPrice != 0:\n        self.mockData = ChainlinkRound(\n            roundId=1,\n            answer=convert(_localPrice // (10 ** 10), int256),\n            startedAt=block.timestamp,\n            updatedAt=block.timestamp,\n            answeredInRound=1,\n        )\n\n    # set governance\n    self.governance = _governance\n\n@external\ndef setGovernance(\n    _governance: address,\n):\n    assert msg.sender == self.governance\n    self.governance = _governance\n\n@view \n@external \ndef latestRoundData() -> ChainlinkRound:\n    return self.mockData\n\n\n@view\n@external\ndef decimals() -> uint8:\n    return self._decimals\n\n\n@external\ndef setDecimals(\n    _decimals: uint8,\n):\n    self._decimals = _decimals\n\n\n@external\ndef setMockData(\n    _price: int256, # 8 decimals\n    _roundId: uint80 = 1,\n    _answeredInRound: uint80 = 1,\n    _startedAt: uint256 = block.timestamp,\n    _updatedAt: uint256 = block.timestamp,\n):\n    assert msg.sender == self.governance\n    self.mockData = ChainlinkRound(\n        roundId=_roundId,\n        answer=_price,\n        startedAt=_startedAt,\n        updatedAt=_updatedAt,\n        answeredInRound=_answeredInRound,\n    )",
            "sha256sum": "8e162121c8d47bcffbbda16175bee3e50dee2728b27efc631cf5454c1cc9f4a7"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/MockChainlinkFeed.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "cd94a10aedb3a0d0a09db7c4d017483c8a53cbc51df3f58e3b03e659c6a0dede"
      },
      "args": "0000000000000000000000000000000000000000000000878678326eac900000000000000000000000000000e0c49e98bd4129d8dd7e52be7862e54a842d723e",
      "file": "contracts/mock/MockChainlinkFeed.vy"
    },
    "ChainlinkPrices": {
      "address": "0x4f350Ae81Ce475327525E3c17b4c5A5959593CA2",
      "abi": [
        {
          "name": "NewChainlinkFeedPending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewChainlinkFeedAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewChainlinkFeedCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedUpdatePending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "oldFeed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedUpdated",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "needsEthToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "needsBtcToUsd",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "oldFeed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedUpdateCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "oldFeed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisableChainlinkFeedPending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ChainlinkFeedDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisableChainlinkFeedCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "feed",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourcePauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourceFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricedAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getChainlinkData",
          "inputs": [
            {
              "name": "_feed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewPendingPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUpdateFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newFeed",
              "type": "address"
            },
            {
              "name": "_decimals",
              "type": "uint256"
            },
            {
              "name": "_needsEthToUsd",
              "type": "bool"
            },
            {
              "name": "_needsBtcToUsd",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "feedConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "feed",
                  "type": "address"
                },
                {
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "name": "needsEthToUsd",
                  "type": "bool"
                },
                {
                  "name": "needsBtcToUsd",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUpdates",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "actionId",
                  "type": "uint256"
                },
                {
                  "name": "config",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "feed",
                      "type": "address"
                    },
                    {
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "name": "needsEthToUsd",
                      "type": "bool"
                    },
                    {
                      "name": "needsBtcToUsd",
                      "type": "bool"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "ETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "BTC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minPriceChangeTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxPriceChangeTimeLock",
              "type": "uint256"
            },
            {
              "name": "_wethAddr",
              "type": "address"
            },
            {
              "name": "_ethAddr",
              "type": "address"
            },
            {
              "name": "_btcAddr",
              "type": "address"
            },
            {
              "name": "_ethUsdFeed",
              "type": "address"
            },
            {
              "name": "_btcUsdFeed",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/priceSources/modules/PriceSourceData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent PriceSourcePauseModified:\n    isPaused: bool\n\nevent PriceSourceFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# priced assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n##############\n# Asset Data #\n##############\n\n\n# add priced asset\n\n\n@internal\ndef _addPricedAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove priced asset\n\n\n@internal\ndef _removePricedAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n\n# get priced assets\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log PriceSourcePauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log PriceSourceFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "e02eae5ee7a25e95fb1d853631f84be9399c674f251d12ca6bb56f32fe2acd0a"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "d3cc46c981ea30e6cd26b22d4c6b6a72250055331934280527b5eb6de8ad8189"
          },
          "interfaces/PriceSource.vyi": {
            "content": "# @version 0.4.1\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, 50]:\n    ...\n\n\n@external \ndef addPriceSnapshot(_asset: address) -> bool:\n    ...\n\n\n################\n# Feed Changes #\n################\n\n\n# new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    ...\n\n\n# update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n# disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n#############\n# Time Lock #\n#############\n\n\n@view\n@external\ndef actionTimeLock() -> uint256:\n    ...\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    ...\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    ...\n\n\n@external\ndef setActionTimeLock(_numBlocks: uint256) -> bool:\n    ...\n\n\n@external\ndef setActionTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "5cd017242bcfbc143e3d3caa968bf871568aefdee7980349a611b92447d8fd1d"
          },
          "contracts/priceSources/ChainlinkPrices.vy": {
            "content": "# @version 0.4.1\n\nimplements: PriceSource\n\nexports: gov.__interface__\nexports: addys.__interface__\nexports: priceData.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: addys\ninitializes: priceData[addys := addys]\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Addys as addys\nimport contracts.priceSources.modules.PriceSourceData as priceData\nimport contracts.modules.TimeLock as timeLock\n\nimport interfaces.PriceSource as PriceSource\n\ninterface ChainlinkFeed:\n    def latestRoundData() -> ChainlinkRound: view\n    def decimals() -> uint8: view \n\ninterface MissionControl:\n    def getPriceStaleTime() -> uint256: view\n\nstruct ChainlinkRound:\n    roundId: uint80\n    answer: int256\n    startedAt: uint256\n    updatedAt: uint256\n    answeredInRound: uint80\n\nstruct ChainlinkConfig:\n    feed: address\n    decimals: uint256\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nstruct PendingChainlinkConfig:\n    actionId: uint256\n    config: ChainlinkConfig\n\nevent NewChainlinkFeedPending:\n    asset: indexed(address)\n    feed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent NewChainlinkFeedAdded:\n    asset: indexed(address)\n    feed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n\nevent NewChainlinkFeedCancelled:\n    asset: indexed(address)\n    feed: indexed(address)\n\nevent ChainlinkFeedUpdatePending:\n    asset: indexed(address)\n    feed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n    confirmationBlock: uint256\n    oldFeed: indexed(address)\n    actionId: uint256\n\nevent ChainlinkFeedUpdated:\n    asset: indexed(address)\n    feed: indexed(address)\n    needsEthToUsd: bool\n    needsBtcToUsd: bool\n    oldFeed: indexed(address)\n\nevent ChainlinkFeedUpdateCancelled:\n    asset: indexed(address)\n    feed: indexed(address)\n    oldFeed: indexed(address)\n\nevent DisableChainlinkFeedPending:\n    asset: indexed(address)\n    feed: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent ChainlinkFeedDisabled:\n    asset: indexed(address)\n    feed: indexed(address)\n\nevent DisableChainlinkFeedCancelled:\n    asset: indexed(address)\n    feed: indexed(address)\n\n# core config\nfeedConfig: public(HashMap[address, ChainlinkConfig]) # asset -> config\n\n# pending changes\npendingUpdates: public(HashMap[address, PendingChainlinkConfig]) # asset -> config\n\n# default assets\nWETH: public(immutable(address))\nETH: public(immutable(address))\nBTC: public(immutable(address))\n\nNORMALIZED_DECIMALS: constant(uint256) = 18\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minPriceChangeTimeLock: uint256,\n    _maxPriceChangeTimeLock: uint256,\n    _wethAddr: address,\n    _ethAddr: address,\n    _btcAddr: address,\n    _ethUsdFeed: address,\n    _btcUsdFeed: address,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    addys.__init__(_ripeHq)\n    priceData.__init__(False)\n    timeLock.__init__(_minPriceChangeTimeLock, _maxPriceChangeTimeLock, 0, _maxPriceChangeTimeLock)\n\n    # set default assets\n    assert empty(address) not in [_wethAddr, _ethAddr, _btcAddr] # dev: invalid asset addrs\n    WETH = _wethAddr\n    ETH = _ethAddr\n    BTC = _btcAddr\n\n    # set default feeds\n    if _ethUsdFeed != empty(address):\n        assert self._setDefaultFeedOnDeploy(_ethAddr, _ethUsdFeed) # dev: invalid feed\n        assert self._setDefaultFeedOnDeploy(_wethAddr, _ethUsdFeed) # dev: invalid feed\n    if _btcUsdFeed != empty(address):\n        assert self._setDefaultFeedOnDeploy(_btcAddr, _btcUsdFeed) # dev: invalid feed\n\n\n# set default feeds\n\n\n@internal\ndef _setDefaultFeedOnDeploy(_asset: address, _newFeed: address) -> bool:\n    decimals: uint256 = convert(staticcall ChainlinkFeed(_newFeed).decimals(), uint256)\n    if not self._isValidNewFeed(_asset, _newFeed, decimals, False, False):\n        return False\n    self.feedConfig[_asset] = ChainlinkConfig(\n        feed=_newFeed,\n        decimals=decimals,\n        needsEthToUsd=False,\n        needsBtcToUsd=False,\n    )\n    priceData._addPricedAsset(_asset)\n    return True\n\n\n###############\n# Core Prices #\n###############\n\n\n# get price\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> uint256:\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> (uint256, bool):\n    config: ChainlinkConfig = self.feedConfig[_asset]\n    if config.feed == empty(address):\n        return 0, False\n    return self._getPrice(config.feed, config.decimals, config.needsEthToUsd, config.needsBtcToUsd, _staleTime), True\n\n\n@view\n@internal\ndef _getPrice(\n    _feed: address, \n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n    _staleTime: uint256,\n) -> uint256:\n    price: uint256 = self._getChainlinkData(_feed, _decimals, _staleTime)\n    if price == 0:\n        return 0\n\n    # if price needs ETH -> USD conversion\n    if _needsEthToUsd:\n        ethConfig: ChainlinkConfig = self.feedConfig[ETH]\n        ethUsdPrice: uint256 = self._getChainlinkData(ethConfig.feed, ethConfig.decimals, _staleTime)\n        price = price * ethUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    # if price needs BTC -> USD conversion\n    elif _needsBtcToUsd:\n        btcConfig: ChainlinkConfig = self.feedConfig[BTC]\n        btcUsdPrice: uint256 = self._getChainlinkData(btcConfig.feed, btcConfig.decimals, _staleTime)\n        price = price * btcUsdPrice // (10 ** NORMALIZED_DECIMALS)\n\n    return price\n\n\n# utilities\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self.feedConfig[_asset].feed != empty(address)\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    return timeLock._hasPendingAction(self.pendingUpdates[_asset].actionId)\n\n\n@external \ndef addPriceSnapshot(_asset: address) -> bool:\n    return False\n\n\n##################\n# Chainlink Data #\n##################\n\n\n@view\n@external\ndef getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256 = 0) -> uint256:\n    return self._getChainlinkData(_feed, _decimals, _staleTime)\n\n\n@view\n@internal\ndef _getChainlinkData(_feed: address, _decimals: uint256, _staleTime: uint256) -> uint256:\n    oracle: ChainlinkRound = staticcall ChainlinkFeed(_feed).latestRoundData()\n\n    # oracle has no price\n    if oracle.answer <= 0:\n        return 0\n\n    # bad decimals\n    if _decimals > NORMALIZED_DECIMALS:\n        return 0\n\n    # cannot have future timestamp\n    if oracle.updatedAt > block.timestamp:\n        return 0\n\n    # validate round ID\n    if oracle.roundId == 0:\n        return 0\n    if oracle.answeredInRound < oracle.roundId:\n        return 0\n\n    # price is too stale\n    if _staleTime != 0 and block.timestamp - oracle.updatedAt > _staleTime:\n        return 0\n\n    # handle decimal normalization\n    price: uint256 = convert(oracle.answer, uint256)\n    decimals: uint256 = _decimals\n    if decimals < NORMALIZED_DECIMALS:\n        decimals = NORMALIZED_DECIMALS - decimals\n        price = price * (10 ** decimals)\n\n    return price\n\n\n################\n# Add New Feed #\n################\n\n\n# initiate new feed\n\n\n@external\ndef addNewPriceFeed(\n    _asset: address, \n    _newFeed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    decimals: uint256 = 0\n    if _newFeed != empty(address):\n        decimals = convert(staticcall ChainlinkFeed(_newFeed).decimals(), uint256)\n    assert self._isValidNewFeed(_asset, _newFeed, decimals, _needsEthToUsd, _needsBtcToUsd) # dev: invalid feed\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingChainlinkConfig(\n        actionId=aid,\n        config=ChainlinkConfig(\n            feed=_newFeed,\n            decimals=decimals,\n            needsEthToUsd=_needsEthToUsd,\n            needsBtcToUsd=_needsBtcToUsd,\n        ),\n    )\n\n    log NewChainlinkFeedPending(asset=_asset, feed=_newFeed, needsEthToUsd=_needsEthToUsd, needsBtcToUsd=_needsBtcToUsd, confirmationBlock=timeLock._getActionConfirmationBlock(aid), actionId=aid)\n    return True\n\n\n# confirm new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    assert d.config.feed != empty(address) # dev: no pending new feed\n    if not self._isValidNewFeed(_asset, d.config.feed, d.config.decimals, d.config.needsEthToUsd, d.config.needsBtcToUsd):\n        self._cancelNewPendingPriceFeed(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # save new feed config\n    self.feedConfig[_asset] = d.config\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n    priceData._addPricedAsset(_asset)\n\n    log NewChainlinkFeedAdded(asset=_asset, feed=d.config.feed, needsEthToUsd=d.config.needsEthToUsd, needsBtcToUsd=d.config.needsBtcToUsd)\n    return True\n\n\n# cancel new feed\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    self._cancelNewPendingPriceFeed(_asset, d.actionId)\n    log NewChainlinkFeedCancelled(asset=_asset, feed=d.config.feed)\n    return True\n\n\n@internal\ndef _cancelNewPendingPriceFeed(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewFeed(_asset: address, _newFeed: address, _decimals: uint256, _needsEthToUsd: bool, _needsBtcToUsd: bool) -> bool:\n    return self._isValidNewFeed(_asset, _newFeed, _decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidNewFeed(_asset: address, _newFeed: address, _decimals: uint256, _needsEthToUsd: bool, _needsBtcToUsd: bool) -> bool:\n    if priceData.indexOfAsset[_asset] != 0 or self.feedConfig[_asset].feed != empty(address): # use the `updatePriceFeed` function instead\n        return False\n    return self._isValidFeedConfig(_asset, _newFeed, _decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n###############\n# Update Feed #\n###############\n\n\n# initiate update feed\n\n\n@external\ndef updatePriceFeed(\n    _asset: address, \n    _newFeed: address, \n    _needsEthToUsd: bool = False,\n    _needsBtcToUsd: bool = False,\n) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    decimals: uint256 = 0\n    if _newFeed != empty(address):\n        decimals = convert(staticcall ChainlinkFeed(_newFeed).decimals(), uint256)\n    oldFeed: address = self.feedConfig[_asset].feed\n    assert self._isValidUpdateFeed(_asset, _newFeed, oldFeed, decimals, _needsEthToUsd, _needsBtcToUsd) # dev: invalid feed\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingChainlinkConfig(\n        actionId=aid,\n        config=ChainlinkConfig(\n            feed=_newFeed,\n            decimals=decimals,\n            needsEthToUsd=_needsEthToUsd,\n            needsBtcToUsd=_needsBtcToUsd,\n        ),\n    )\n    log ChainlinkFeedUpdatePending(asset=_asset, feed=_newFeed, needsEthToUsd=_needsEthToUsd, needsBtcToUsd=_needsBtcToUsd, confirmationBlock=timeLock._getActionConfirmationBlock(aid), oldFeed=oldFeed, actionId=aid)\n    return True\n\n\n# confirm update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    assert d.config.feed != empty(address) # dev: no pending update feed\n    oldFeed: address = self.feedConfig[_asset].feed\n    if not self._isValidUpdateFeed(_asset, d.config.feed, oldFeed, d.config.decimals, d.config.needsEthToUsd, d.config.needsBtcToUsd):\n        self._cancelPriceFeedUpdate(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # save new feed config\n    self.feedConfig[_asset] = d.config\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n\n    log ChainlinkFeedUpdated(asset=_asset, feed=d.config.feed, needsEthToUsd=d.config.needsEthToUsd, needsBtcToUsd=d.config.needsBtcToUsd, oldFeed=oldFeed)\n    return True\n\n\n# cancel update feed\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    self._cancelPriceFeedUpdate(_asset, d.actionId)\n    log ChainlinkFeedUpdateCancelled(asset=_asset, feed=d.config.feed, oldFeed=self.feedConfig[_asset].feed)\n    return True\n\n\n@internal\ndef _cancelPriceFeedUpdate(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidUpdateFeed(_asset: address, _newFeed: address, _decimals: uint256, _needsEthToUsd: bool, _needsBtcToUsd: bool) -> bool:\n    return self._isValidUpdateFeed(_asset, _newFeed, self.feedConfig[_asset].feed, _decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidUpdateFeed(_asset: address, _newFeed: address, _oldFeed: address, _decimals: uint256, _needsEthToUsd: bool, _needsBtcToUsd: bool) -> bool:\n    if _newFeed == _oldFeed:\n        return False\n    if priceData.indexOfAsset[_asset] == 0 or _oldFeed == empty(address): # use the `addNewPriceFeed` function instead\n        return False\n    return self._isValidFeedConfig(_asset, _newFeed, _decimals, _needsEthToUsd, _needsBtcToUsd)\n\n\n@view\n@internal\ndef _isValidFeedConfig(\n    _asset: address, \n    _feed: address,\n    _decimals: uint256,\n    _needsEthToUsd: bool,\n    _needsBtcToUsd: bool,\n) -> bool:\n    if empty(address) in [_asset, _feed]:\n        return False\n    if _needsEthToUsd and _needsBtcToUsd:\n        return False\n\n    staleTime: uint256 = 0\n    missionControl: address = addys._getMissionControlAddr()\n    if missionControl != empty(address):\n        staleTime = staticcall MissionControl(missionControl).getPriceStaleTime()\n\n    return self._getPrice(_feed, _decimals, _needsEthToUsd, _needsBtcToUsd, staleTime) != 0\n\n\n################\n# Disable Feed #\n################\n\n\n# initiate disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    oldFeed: address = self.feedConfig[_asset].feed\n    assert self._isValidDisablePriceFeed(_asset, oldFeed) # dev: invalid asset\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingChainlinkConfig(\n        actionId=aid,\n        config=empty(ChainlinkConfig),\n    )\n\n    log DisableChainlinkFeedPending(asset=_asset, feed=oldFeed, confirmationBlock=timeLock._getActionConfirmationBlock(aid), actionId=aid)\n    return True\n\n\n# confirm disable feed\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    oldFeed: address = self.feedConfig[_asset].feed\n    d: PendingChainlinkConfig = self.pendingUpdates[_asset]\n    assert d.actionId != 0 # dev: no pending disable feed\n    if not self._isValidDisablePriceFeed(_asset, oldFeed):\n        self._cancelDisablePriceFeed(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # disable feed\n    self.feedConfig[_asset] = empty(ChainlinkConfig)\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n    priceData._removePricedAsset(_asset)\n\n    log ChainlinkFeedDisabled(asset=_asset, feed=oldFeed)\n    return True\n\n\n# cancel disable feed\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    self._cancelDisablePriceFeed(_asset, self.pendingUpdates[_asset].actionId)\n    log DisableChainlinkFeedCancelled(asset=_asset, feed=self.feedConfig[_asset].feed)\n    return True\n\n\n@internal\ndef _cancelDisablePriceFeed(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingChainlinkConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidDisablePriceFeed(_asset: address) -> bool:\n    return self._isValidDisablePriceFeed(_asset, self.feedConfig[_asset].feed)\n\n\n@view\n@internal\ndef _isValidDisablePriceFeed(_asset: address, _oldFeed: address) -> bool:\n    if priceData.indexOfAsset[_asset] == 0:\n        return False\n    if _oldFeed == empty(address):\n        return False\n    return _asset not in [ETH, WETH, BTC]\n",
            "sha256sum": "af6dd10ebe248be4e46d644a5d64a03bd02b9c835902365997367f3eddb4f176"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/priceSources/ChainlinkPrices.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "66b542208e6b54d043e061bb5605f293c568c69519015f6e356a2dc36b4bfac1"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a0300000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d400000000000000000000000004200000000000000000000000000000000000006000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb000000000000000000000000c501b300f2808f6b28f6c08afb72441a97394f18000000000000000000000000187864a434e238fa2ed6bc599bc7bec6ec9cf108",
      "file": "contracts/priceSources/ChainlinkPrices.vy"
    },
    "CurvePrices": {
      "address": "0x8Ce5dEf1Ca5674a183c44E34BdC3214197c08Ac5",
      "abi": [
        {
          "name": "NewCurvePricePending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewCurvePriceAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewCurvePriceCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurvePriceConfigUpdatePending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevPool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurvePriceConfigUpdated",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevPool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurvePriceConfigUpdateCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevPool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisableCurvePricePending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevPool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CurvePriceDisabled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevPool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisableCurvePriceCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevPool",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GreenRefPoolConfigPending",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "dangerTrigger",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabilizerAdjustWeight",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabilizerMaxPoolDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GreenRefPoolConfigUpdated",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "dangerTrigger",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabilizerAdjustWeight",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabilizerMaxPoolDebt",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GreenRefPoolConfigUpdateCancelled",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "dangerTrigger",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabilizerAdjustWeight",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabilizerMaxPoolDebt",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GreenRefPoolSnapshotAdded",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "greenBalance",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "greenRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "inDanger",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourcePauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourceFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricedAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getStableLpPrice",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_coins",
              "type": "address[4]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCryptoLpPrice",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_firstAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSingleTokenPrice",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetAsset",
              "type": "address"
            },
            {
              "name": "_coins",
              "type": "address[2]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getSingleTokenPrice",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_targetAsset",
              "type": "address"
            },
            {
              "name": "_coins",
              "type": "address[2]"
            },
            {
              "name": "_poolType",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewPendingPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUpdateFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newPool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCurvePoolConfig",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "lpToken",
                  "type": "address"
                },
                {
                  "name": "numUnderlying",
                  "type": "uint256"
                },
                {
                  "name": "underlying",
                  "type": "address[4]"
                },
                {
                  "name": "poolType",
                  "type": "uint256"
                },
                {
                  "name": "hasEcoToken",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGreenRefPoolConfig",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            },
            {
              "name": "_dangerTrigger",
              "type": "uint256"
            },
            {
              "name": "_staleBlocks",
              "type": "uint256"
            },
            {
              "name": "_stabilizerAdjustWeight",
              "type": "uint256"
            },
            {
              "name": "_stabilizerMaxPoolDebt",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGreenRefPoolConfig",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGreenRefPoolConfig",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCurrentGreenPoolStatus",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "weightedRatio",
                  "type": "uint256"
                },
                {
                  "name": "dangerTrigger",
                  "type": "uint256"
                },
                {
                  "name": "numBlocksInDanger",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addGreenRefPoolSnapshot",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCurvePoolData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGreenStabilizerConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "lpToken",
                  "type": "address"
                },
                {
                  "name": "greenBalance",
                  "type": "uint256"
                },
                {
                  "name": "greenRatio",
                  "type": "uint256"
                },
                {
                  "name": "greenIndex",
                  "type": "uint256"
                },
                {
                  "name": "stabilizerAdjustWeight",
                  "type": "uint256"
                },
                {
                  "name": "stabilizerMaxPoolDebt",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "curveConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "lpToken",
                  "type": "address"
                },
                {
                  "name": "numUnderlying",
                  "type": "uint256"
                },
                {
                  "name": "underlying",
                  "type": "address[4]"
                },
                {
                  "name": "poolType",
                  "type": "uint256"
                },
                {
                  "name": "hasEcoToken",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUpdates",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "actionId",
                  "type": "uint256"
                },
                {
                  "name": "config",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "pool",
                      "type": "address"
                    },
                    {
                      "name": "lpToken",
                      "type": "address"
                    },
                    {
                      "name": "numUnderlying",
                      "type": "uint256"
                    },
                    {
                      "name": "underlying",
                      "type": "address[4]"
                    },
                    {
                      "name": "poolType",
                      "type": "uint256"
                    },
                    {
                      "name": "hasEcoToken",
                      "type": "bool"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "greenRefPoolConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "lpToken",
                  "type": "address"
                },
                {
                  "name": "greenIndex",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altAssetDecimals",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "dangerTrigger",
                  "type": "uint256"
                },
                {
                  "name": "staleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "stabilizerAdjustWeight",
                  "type": "uint256"
                },
                {
                  "name": "stabilizerMaxPoolDebt",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "greenRefPoolData",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastSnapshot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "greenBalance",
                      "type": "uint256"
                    },
                    {
                      "name": "ratio",
                      "type": "uint256"
                    },
                    {
                      "name": "update",
                      "type": "uint256"
                    },
                    {
                      "name": "inDanger",
                      "type": "bool"
                    }
                  ]
                },
                {
                  "name": "numBlocksInDanger",
                  "type": "uint256"
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "greenBalance",
                  "type": "uint256"
                },
                {
                  "name": "ratio",
                  "type": "uint256"
                },
                {
                  "name": "update",
                  "type": "uint256"
                },
                {
                  "name": "inDanger",
                  "type": "bool"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGreenRefPoolConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "pool",
                  "type": "address"
                },
                {
                  "name": "lpToken",
                  "type": "address"
                },
                {
                  "name": "greenIndex",
                  "type": "uint256"
                },
                {
                  "name": "altAsset",
                  "type": "address"
                },
                {
                  "name": "altAssetDecimals",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "dangerTrigger",
                  "type": "uint256"
                },
                {
                  "name": "staleBlocks",
                  "type": "uint256"
                },
                {
                  "name": "stabilizerAdjustWeight",
                  "type": "uint256"
                },
                {
                  "name": "stabilizerMaxPoolDebt",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_META_REGISTRY",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "CURVE_REGISTRIES",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "StableSwapNg",
                  "type": "address"
                },
                {
                  "name": "TwoCryptoNg",
                  "type": "address"
                },
                {
                  "name": "TricryptoNg",
                  "type": "address"
                },
                {
                  "name": "TwoCrypto",
                  "type": "address"
                },
                {
                  "name": "MetaPool",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_curveAddressProvider",
              "type": "address"
            },
            {
              "name": "_minPriceChangeTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxPriceChangeTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/priceSources/modules/PriceSourceData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent PriceSourcePauseModified:\n    isPaused: bool\n\nevent PriceSourceFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# priced assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n##############\n# Asset Data #\n##############\n\n\n# add priced asset\n\n\n@internal\ndef _addPricedAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove priced asset\n\n\n@internal\ndef _removePricedAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n\n# get priced assets\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log PriceSourcePauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log PriceSourceFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "e02eae5ee7a25e95fb1d853631f84be9399c674f251d12ca6bb56f32fe2acd0a"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "d3cc46c981ea30e6cd26b22d4c6b6a72250055331934280527b5eb6de8ad8189"
          },
          "interfaces/PriceSource.vyi": {
            "content": "# @version 0.4.1\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, 50]:\n    ...\n\n\n@external \ndef addPriceSnapshot(_asset: address) -> bool:\n    ...\n\n\n################\n# Feed Changes #\n################\n\n\n# new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    ...\n\n\n# update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n# disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n#############\n# Time Lock #\n#############\n\n\n@view\n@external\ndef actionTimeLock() -> uint256:\n    ...\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    ...\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    ...\n\n\n@external\ndef setActionTimeLock(_numBlocks: uint256) -> bool:\n    ...\n\n\n@external\ndef setActionTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "5cd017242bcfbc143e3d3caa968bf871568aefdee7980349a611b92447d8fd1d"
          },
          "contracts/priceSources/CurvePrices.vy": {
            "content": "# @version 0.4.1\n\nimplements: PriceSource\n\nexports: gov.__interface__\nexports: addys.__interface__\nexports: priceData.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: addys\ninitializes: priceData[addys := addys]\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Addys as addys\nimport contracts.priceSources.modules.PriceSourceData as priceData\nimport contracts.modules.TimeLock as timeLock\n\nimport interfaces.PriceSource as PriceSource\nfrom ethereum.ercs import IERC20Detailed\n\ninterface CurveMetaRegistry:\n    def get_registry_handlers_from_pool(_pool: address) -> address[10]: view\n    def get_underlying_coins(_pool: address) -> address[8]: view\n    def get_n_underlying_coins(_pool: address) -> uint256: view \n    def get_base_registry(_addr: address) -> address: view\n    def get_lp_token(_pool: address) -> address: view\n    def is_registered(_pool: address) -> bool: view\n\ninterface CurvePool:\n    def balances(_index: uint256) -> uint256: view\n    def get_virtual_price() -> uint256: view\n    def price_oracle() -> uint256: view\n    def totalSupply() -> uint256: view\n    def lp_price() -> uint256: view\n\ninterface PriceDesk:\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface CurvePoolNg:\n    def price_oracle(_index: uint256) -> uint256: view\n\ninterface CurveAddressProvider:\n    def get_address(_id: uint256) -> address: view\n\nflag PoolType:\n    STABLESWAP_NG\n    TWO_CRYPTO_NG\n    TRICRYPTO_NG\n    TWO_CRYPTO\n    METAPOOL\n    CRYPTO\n\nstruct CurvePriceConfig:\n    pool: address\n    lpToken: address\n    numUnderlying: uint256\n    underlying: address[4]\n    poolType: PoolType\n    hasEcoToken: bool\n\nstruct PendingCurvePrice:\n    actionId: uint256\n    config: CurvePriceConfig\n\nstruct CurveRegistries:\n    StableSwapNg: address\n    TwoCryptoNg: address\n    TricryptoNg: address\n    TwoCrypto: address\n    MetaPool: address\n\nstruct GreenRefPoolConfig:\n    pool: address\n    lpToken: address\n    greenIndex: uint256\n    altAsset: address\n    altAssetDecimals: uint256\n    maxNumSnapshots: uint256\n    dangerTrigger: uint256\n    staleBlocks: uint256\n    stabilizerAdjustWeight: uint256\n    stabilizerMaxPoolDebt: uint256\n\nstruct RefPoolSnapshot:\n    greenBalance: uint256\n    ratio: uint256\n    update: uint256\n    inDanger: bool\n\nstruct GreenRefPoolData:\n    lastSnapshot: RefPoolSnapshot\n    numBlocksInDanger: uint256\n    nextIndex: uint256\n\nstruct CurrentGreenPoolStatus:\n    weightedRatio: uint256\n    dangerTrigger: uint256\n    numBlocksInDanger: uint256\n\nstruct StabilizerConfig:\n    pool: address\n    lpToken: address\n    greenBalance: uint256\n    greenRatio: uint256\n    greenIndex: uint256\n    stabilizerAdjustWeight: uint256\n    stabilizerMaxPoolDebt: uint256\n\nevent NewCurvePricePending:\n    asset: indexed(address)\n    pool: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent NewCurvePriceAdded:\n    asset: indexed(address)\n    pool: indexed(address)\n\nevent NewCurvePriceCancelled:\n    asset: indexed(address)\n    pool: indexed(address)\n\nevent CurvePriceConfigUpdatePending:\n    asset: indexed(address)\n    pool: indexed(address)\n    prevPool: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CurvePriceConfigUpdated:\n    asset: indexed(address)\n    pool: indexed(address)\n    prevPool: indexed(address)\n\nevent CurvePriceConfigUpdateCancelled:\n    asset: indexed(address)\n    pool: indexed(address)\n    prevPool: indexed(address)\n\nevent DisableCurvePricePending:\n    asset: indexed(address)\n    prevPool: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CurvePriceDisabled:\n    asset: indexed(address)\n    prevPool: indexed(address)\n\nevent DisableCurvePriceCancelled:\n    asset: indexed(address)\n    prevPool: indexed(address)\n\nevent GreenRefPoolConfigPending:\n    pool: indexed(address)\n    maxNumSnapshots: uint256\n    dangerTrigger: uint256\n    staleBlocks: uint256\n    stabilizerAdjustWeight: uint256\n    stabilizerMaxPoolDebt: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent GreenRefPoolConfigUpdated:\n    pool: indexed(address)\n    maxNumSnapshots: uint256\n    dangerTrigger: uint256\n    staleBlocks: uint256\n    stabilizerAdjustWeight: uint256\n    stabilizerMaxPoolDebt: uint256\n\nevent GreenRefPoolConfigUpdateCancelled:\n    pool: indexed(address)\n    maxNumSnapshots: uint256\n    dangerTrigger: uint256\n    staleBlocks: uint256\n    stabilizerAdjustWeight: uint256\n    stabilizerMaxPoolDebt: uint256\n\nevent GreenRefPoolSnapshotAdded:\n    pool: indexed(address)\n    greenBalance: uint256\n    greenRatio: uint256\n    inDanger: bool\n\n# config\ncurveConfig: public(HashMap[address, CurvePriceConfig]) # asset -> config\npendingUpdates: public(HashMap[address, PendingCurvePrice]) # asset -> config\n\n# green reference pool\ngreenRefPoolConfig: public(GreenRefPoolConfig)\ngreenRefPoolData: public(GreenRefPoolData)\nsnapShots: public(HashMap[uint256, RefPoolSnapshot]) # index -> snapshot\npendingGreenRefPoolConfig: public(HashMap[uint256, GreenRefPoolConfig]) # actionId -> config\n\n# curve\nCURVE_META_REGISTRY: public(immutable(address))\nCURVE_REGISTRIES: public(immutable(CurveRegistries))\n\n# curve address provider ids\nMETAPOOL_FACTORY_ID: constant(uint256) = 3\nTWO_CRYPTO_FACTORY_ID: constant(uint256) = 6\nMETA_REGISTRY_ID: constant(uint256) = 7\nTRICRYPTO_NG_FACTORY_ID: constant(uint256) = 11\nSTABLESWAP_NG_FACTORY_ID: constant(uint256) = 12\nTWO_CRYPTO_NG_FACTORY_ID: constant(uint256) = 13\n\nMAX_POOLS: constant(uint256) = 50\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _curveAddressProvider: address,\n    _minPriceChangeTimeLock: uint256,\n    _maxPriceChangeTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    addys.__init__(_ripeHq)\n    priceData.__init__(False)\n    timeLock.__init__(_minPriceChangeTimeLock, _maxPriceChangeTimeLock, 0, _maxPriceChangeTimeLock)\n\n    # set curve address provider\n    if _curveAddressProvider != empty(address):\n        CURVE_META_REGISTRY = staticcall CurveAddressProvider(_curveAddressProvider).get_address(META_REGISTRY_ID)\n        CURVE_REGISTRIES = CurveRegistries(\n            StableSwapNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(STABLESWAP_NG_FACTORY_ID),\n            TwoCryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_NG_FACTORY_ID),\n            TricryptoNg= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TRICRYPTO_NG_FACTORY_ID),\n            TwoCrypto= staticcall CurveAddressProvider(_curveAddressProvider).get_address(TWO_CRYPTO_FACTORY_ID),\n            MetaPool= staticcall CurveAddressProvider(_curveAddressProvider).get_address(METAPOOL_FACTORY_ID),\n        )\n\n\n###############\n# Core Prices #\n###############\n\n\n# get price\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> uint256:\n    config: CurvePriceConfig = self.curveConfig[_asset]\n    if config.pool == empty(address):\n        return 0\n    return self._getCurvePrice(_asset, config, _priceDesk)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> (uint256, bool):\n    config: CurvePriceConfig = self.curveConfig[_asset]\n    if config.pool == empty(address):\n        return 0, False\n    return self._getCurvePrice(_asset, config, _priceDesk), True\n\n\n# utilities\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self.curveConfig[_asset].pool != empty(address)\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    return timeLock._hasPendingAction(self.pendingUpdates[_asset].actionId)\n\n\n@external \ndef addPriceSnapshot(_asset: address) -> bool:\n    return False\n\n\n###############\n# Curve Price #\n###############\n\n\n@view\n@internal\ndef _getCurvePrice(_asset: address, _config: CurvePriceConfig, _priceDesk: address) -> uint256:\n    price: uint256 = 0\n\n    priceDesk: address = _priceDesk\n    if _priceDesk == empty(address):\n        priceDesk = addys._getPriceDeskAddr()\n\n    # lp tokens\n    if _asset == _config.lpToken:\n\n        # stable lp tokens\n        if _config.poolType == PoolType.STABLESWAP_NG or _config.poolType == PoolType.METAPOOL:\n            price = self._getStableLpPrice(_config.pool, _config.underlying, priceDesk)\n\n        # crypto lp tokens\n        else:\n            price = self._getCryptoLpPrice(_config.pool, _config.underlying[0], priceDesk)\n\n    # single asset (only supporting pools with 2 assets)\n    elif _config.numUnderlying == 2:\n        price = self._getSingleTokenPrice(_config.pool, _asset, [_config.underlying[0], _config.underlying[1]], _config.poolType, priceDesk)\n\n    return price\n\n\n# stable lp tokens\n\n\n@view \n@internal \ndef _getStableLpPrice(_pool: address, _coins: address[4], _priceDesk: address) -> uint256: \n\n    # REQUIREMENTS:\n    # all assets must be stable-ish to each other\n    # each underlying asset must have price feed (Price Desk)\n    # Note: see this article: https://news.curve.fi/chainlink-oracles-and-curve-pools/\n\n    lowestPrice: uint256 = max_value(uint256)\n    for c: address in _coins:\n        if c == empty(address):\n            break\n\n        underlyingPrice: uint256 = staticcall PriceDesk(_priceDesk).getPrice(c, False)\n        if underlyingPrice < lowestPrice:\n            lowestPrice = underlyingPrice \n\n    # if no price feed, return 0\n    if lowestPrice == 0 or lowestPrice == max_value(uint256):\n        return 0\n\n    # curve virtual price\n    virtualPrice: uint256 = staticcall CurvePool(_pool).get_virtual_price()\n    if virtualPrice == 0:\n        return 0\n\n    return lowestPrice * virtualPrice // EIGHTEEN_DECIMALS\n\n\n@view \n@external \ndef getStableLpPrice(_pool: address, _coins: address[4]) -> uint256: \n    # mostly for testing\n    return self._getStableLpPrice(_pool, _coins, addys._getPriceDeskAddr())\n\n\n# crypto lp token price\n\n\n@view\n@internal \ndef _getCryptoLpPrice(_pool: address, _firstAsset: address, _priceDesk: address) -> uint256:\n\n    # REQUIREMENTS:\n    # pool must have `lp_price()`\n    # 0 index asset must have price feed (Price Desk)\n\n    lpPrice: uint256 = staticcall CurvePool(_pool).lp_price()\n    if lpPrice == 0:\n        return 0\n\n    assetPrice: uint256 = staticcall PriceDesk(_priceDesk).getPrice(_firstAsset)\n    if assetPrice == 0:\n        return 0\n\n    return assetPrice * lpPrice // EIGHTEEN_DECIMALS\n\n\n@view\n@external \ndef getCryptoLpPrice(_pool: address, _firstAsset: address) -> uint256:\n    # mostly for testing\n    return self._getCryptoLpPrice(_pool, _firstAsset, addys._getPriceDeskAddr())\n\n\n# single asset price\n\n\n@view\n@internal \ndef _getSingleTokenPrice(\n    _pool: address,\n    _targetAsset: address,\n    _coins: address[2],\n    _poolType: PoolType,\n    _priceDesk: address,\n) -> uint256:\n    price: uint256 = 0\n\n    # REQUIREMENTS:\n    # pool must have `price_oracle()`\n    # can only have 2 assets in pool\n    # alt asset must have price feed (Price Desk)\n\n    # curve price oracle\n    priceOracle: uint256 = 0\n    if _poolType == PoolType.STABLESWAP_NG:\n        priceOracle = staticcall CurvePoolNg(_pool).price_oracle(0)\n    else:\n        priceOracle = staticcall CurvePool(_pool).price_oracle()\n\n    if priceOracle == 0:\n        return 0\n\n    # in relation to alt asset\n    altPrice: uint256 = 0\n    if _targetAsset == _coins[0]:\n        altPrice = staticcall PriceDesk(_priceDesk).getPrice(_coins[1], False)\n        price = altPrice * EIGHTEEN_DECIMALS // priceOracle\n    else:\n        altPrice = staticcall PriceDesk(_priceDesk).getPrice(_coins[0], False)\n        price = altPrice * priceOracle // EIGHTEEN_DECIMALS\n\n    return price\n\n\n@view\n@external\ndef getSingleTokenPrice(_pool: address, _targetAsset: address, _coins: address[2], _poolType: PoolType = empty(PoolType)) -> uint256:\n    # mostly for testing\n    return self._getSingleTokenPrice(_pool, _targetAsset, _coins, _poolType, addys._getPriceDeskAddr())\n\n\n################\n# Add New Feed #\n################\n\n\n# initiate new feed\n\n\n@external\ndef addNewPriceFeed(_asset: address, _pool: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    config: CurvePriceConfig = self._getCurvePoolConfig(_pool)\n    assert self._isValidNewFeed(_asset, config) # dev: invalid pool\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingCurvePrice(\n        actionId=aid,\n        config=config,\n    )\n\n    log NewCurvePricePending(asset=_asset, pool=_pool, confirmationBlock=timeLock._getActionConfirmationBlock(aid), actionId=aid)\n    return True\n\n\n# confirm new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: PendingCurvePrice = self.pendingUpdates[_asset]\n    assert d.config.pool != empty(address) # dev: no pending new feed\n    if not self._isValidNewFeed(_asset, d.config):\n        self._cancelNewPendingPriceFeed(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # save new feed config\n    self.curveConfig[_asset] = d.config\n    self.pendingUpdates[_asset] = empty(PendingCurvePrice)\n    priceData._addPricedAsset(_asset)\n\n    log NewCurvePriceAdded(asset=_asset, pool=d.config.pool)\n    return True\n\n\n# cancel new feed\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: PendingCurvePrice = self.pendingUpdates[_asset]\n    self._cancelNewPendingPriceFeed(_asset, d.actionId)\n    log NewCurvePriceCancelled(asset=_asset, pool=d.config.pool)\n    return True\n\n\n@internal\ndef _cancelNewPendingPriceFeed(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingCurvePrice)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewFeed(_asset: address, _pool: address) -> bool:\n    config: CurvePriceConfig = self._getCurvePoolConfig(_pool)\n    return self._isValidNewFeed(_asset, config)\n\n\n@view\n@internal\ndef _isValidNewFeed(_asset: address, _config: CurvePriceConfig) -> bool:\n    if priceData.indexOfAsset[_asset] != 0 or self.curveConfig[_asset].pool != empty(address): # use the `updatePriceFeed` function instead\n        return False\n    return self._isValidFeedConfig(_asset, _config)\n\n\n###############\n# Update Feed #\n###############\n\n\n# initiate update feed\n\n\n@external\ndef updatePriceFeed(_asset: address, _pool: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    prevPool: address = self.curveConfig[_asset].pool\n    config: CurvePriceConfig = self._getCurvePoolConfig(_pool)\n    assert self._isValidUpdateFeed(_asset, config, prevPool) # dev: invalid feed\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingCurvePrice(\n        actionId=aid,\n        config=config,\n    )\n    log CurvePriceConfigUpdatePending(asset=_asset, pool=_pool, prevPool=prevPool, confirmationBlock=timeLock._getActionConfirmationBlock(aid), actionId=aid)\n    return True\n\n\n# confirm update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: PendingCurvePrice = self.pendingUpdates[_asset]\n    assert d.config.pool != empty(address) # dev: no pending update feed\n    prevPool: address = self.curveConfig[_asset].pool\n    if not self._isValidUpdateFeed(_asset, d.config, prevPool):\n        self._cancelPriceFeedUpdate(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # save new feed config\n    self.curveConfig[_asset] = d.config\n    self.pendingUpdates[_asset] = empty(PendingCurvePrice)\n\n    log CurvePriceConfigUpdated(asset=_asset, pool=d.config.pool, prevPool=prevPool)\n    return True\n\n\n# cancel update feed\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: PendingCurvePrice = self.pendingUpdates[_asset]\n    self._cancelPriceFeedUpdate(_asset, d.actionId)\n    log CurvePriceConfigUpdateCancelled(asset=_asset, pool=d.config.pool, prevPool=self.curveConfig[_asset].pool)\n    return True\n\n\n@internal\ndef _cancelPriceFeedUpdate(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingCurvePrice)\n\n\n# validation\n\n\n@view\n@external\ndef isValidUpdateFeed(_asset: address, _newPool: address) -> bool:\n    config: CurvePriceConfig = self._getCurvePoolConfig(_newPool)\n    return self._isValidUpdateFeed(_asset, config, self.curveConfig[_asset].pool)\n\n\n@view\n@internal\ndef _isValidUpdateFeed(_asset: address, _config: CurvePriceConfig, _prevPool: address) -> bool:\n    if _config.pool == _prevPool:\n        return False\n    if priceData.indexOfAsset[_asset] == 0 or _prevPool == empty(address): # use the `addNewPriceFeed` function instead\n        return False\n    return self._isValidFeedConfig(_asset, _config)\n\n\n@view\n@internal\ndef _isValidFeedConfig(_asset: address, _config: CurvePriceConfig) -> bool:\n    if empty(address) in [_asset, _config.pool, _config.lpToken]:\n        return False\n\n    if _asset not in _config.underlying and _asset != _config.lpToken:\n        return False\n\n    # for initial ripe/green lp deployment, need to skip checking price -- when totalSupply is zero, the `get_virtual_price()` will fail\n    if _config.hasEcoToken and _asset == _config.pool and staticcall CurvePool(_config.pool).totalSupply() == 0:\n        return True\n\n    return self._getCurvePrice(_asset, _config, empty(address)) != 0\n\n\n################\n# Disable Feed #\n################\n\n\n# initiate disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    prevPool: address = self.curveConfig[_asset].pool\n    assert self._isValidDisablePriceFeed(_asset, prevPool) # dev: invalid asset\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingUpdates[_asset] = PendingCurvePrice(\n        actionId=aid,\n        config=empty(CurvePriceConfig),\n    )\n\n    log DisableCurvePricePending(asset=_asset, prevPool=prevPool, confirmationBlock=timeLock._getActionConfirmationBlock(aid), actionId=aid)\n    return True\n\n\n# confirm disable feed\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    prevPool: address = self.curveConfig[_asset].pool\n    d: PendingCurvePrice = self.pendingUpdates[_asset]\n    assert d.actionId != 0 # dev: no pending disable feed\n    if not self._isValidDisablePriceFeed(_asset, prevPool):\n        self._cancelDisablePriceFeed(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # disable feed\n    self.curveConfig[_asset] = empty(CurvePriceConfig)\n    self.pendingUpdates[_asset] = empty(PendingCurvePrice)\n    priceData._removePricedAsset(_asset)\n\n    log CurvePriceDisabled(asset=_asset, prevPool=prevPool)\n    return True\n\n\n# cancel disable feed\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    self._cancelDisablePriceFeed(_asset, self.pendingUpdates[_asset].actionId)\n    log DisableCurvePriceCancelled(asset=_asset, prevPool=self.curveConfig[_asset].pool)\n    return True\n\n\n@internal\ndef _cancelDisablePriceFeed(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingUpdates[_asset] = empty(PendingCurvePrice)\n\n\n# validation\n\n\n@view\n@external\ndef isValidDisablePriceFeed(_asset: address) -> bool:\n    return self._isValidDisablePriceFeed(_asset, self.curveConfig[_asset].pool)\n\n\n@view\n@internal\ndef _isValidDisablePriceFeed(_asset: address, _prevPool: address) -> bool:\n    if priceData.indexOfAsset[_asset] == 0:\n        return False\n    return _prevPool != empty(address)\n\n\n##############\n# Curve Data #\n##############\n\n\n@view\n@external\ndef getCurvePoolConfig(_pool: address) -> CurvePriceConfig:\n    return self._getCurvePoolConfig(_pool)\n\n\n@view\n@internal\ndef _getCurvePoolConfig(_pool: address) -> CurvePriceConfig:\n    mr: address = CURVE_META_REGISTRY\n    if not staticcall CurveMetaRegistry(mr).is_registered(_pool):\n        return empty(CurvePriceConfig)\n\n    lpToken: address = staticcall CurveMetaRegistry(mr).get_lp_token(_pool)\n    underlying: address[8] = staticcall CurveMetaRegistry(mr).get_underlying_coins(_pool)\n\n    # check if ripe ecosystem token\n    hasEcoToken: bool = False\n    for token: address in [addys._getGreenToken(), addys._getSavingsGreen(), addys._getRipeToken()]:\n        if token in underlying:\n            hasEcoToken = True\n            break\n\n    return CurvePriceConfig(\n        pool = _pool,\n        lpToken = lpToken,\n        numUnderlying = staticcall CurveMetaRegistry(mr).get_n_underlying_coins(_pool),\n        underlying = [underlying[0], underlying[1], underlying[2], underlying[3]],\n        poolType = self._getPoolType(_pool, mr),\n        hasEcoToken = hasEcoToken,\n    )\n\n\n@view\n@internal\ndef _getPoolType(_pool: address, _mr: address) -> PoolType:\n    # check what type of pool this is based on where it's registered on Curve\n    registryHandlers: address[10] = staticcall CurveMetaRegistry(_mr).get_registry_handlers_from_pool(_pool)\n    baseRegistry: address = staticcall CurveMetaRegistry(_mr).get_base_registry(registryHandlers[0])\n\n    curveRegistries: CurveRegistries = CURVE_REGISTRIES\n    poolType: PoolType = empty(PoolType)\n    if baseRegistry == curveRegistries.StableSwapNg:\n        poolType = PoolType.STABLESWAP_NG\n    elif baseRegistry == curveRegistries.TwoCryptoNg:\n        poolType = PoolType.TWO_CRYPTO_NG\n    elif baseRegistry == curveRegistries.TricryptoNg:\n        poolType = PoolType.TRICRYPTO_NG\n    elif baseRegistry == curveRegistries.TwoCrypto:\n        poolType = PoolType.TWO_CRYPTO\n    elif baseRegistry == curveRegistries.MetaPool:\n        poolType = PoolType.METAPOOL\n    else:\n        poolType = PoolType.CRYPTO\n    return poolType\n\n\n#########################\n# Green Ref Pool Config #\n#########################\n\n\n@external\ndef setGreenRefPoolConfig(\n    _pool: address,\n    _maxNumSnapshots: uint256,\n    _dangerTrigger: uint256,\n    _staleBlocks: uint256,\n    _stabilizerAdjustWeight: uint256,\n    _stabilizerMaxPoolDebt: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # pool data\n    poolConfig: CurvePriceConfig = self._getCurvePoolConfig(_pool)\n    greenToken: address = addys._getGreenToken()\n    greenIndex: uint256 = 0\n    if greenToken == poolConfig.underlying[1]:\n        greenIndex = 1\n    altAsset: address = poolConfig.underlying[1 - greenIndex]\n\n    refConfig: GreenRefPoolConfig = GreenRefPoolConfig(\n        pool=_pool,\n        lpToken=poolConfig.lpToken,\n        greenIndex=greenIndex,\n        altAsset=altAsset,\n        altAssetDecimals=convert(staticcall IERC20Detailed(altAsset).decimals(), uint256),\n        maxNumSnapshots=_maxNumSnapshots,\n        dangerTrigger=_dangerTrigger,\n        staleBlocks=_staleBlocks,\n        stabilizerAdjustWeight=_stabilizerAdjustWeight,\n        stabilizerMaxPoolDebt=_stabilizerMaxPoolDebt,\n    )\n    assert self._isValidGreenRefPoolConfig(poolConfig, refConfig, _maxNumSnapshots, _dangerTrigger, _staleBlocks, _stabilizerAdjustWeight, _stabilizerMaxPoolDebt, greenToken) # dev: invalid ref pool config\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingGreenRefPoolConfig[aid] = refConfig\n    log GreenRefPoolConfigPending(pool=_pool, maxNumSnapshots=_maxNumSnapshots, dangerTrigger=_dangerTrigger, staleBlocks=_staleBlocks, stabilizerAdjustWeight=_stabilizerAdjustWeight, stabilizerMaxPoolDebt=_stabilizerMaxPoolDebt, confirmationBlock=timeLock._getActionConfirmationBlock(aid), actionId=aid)\n    return aid\n\n\n# confirm green ref pool config\n\n\n@external\ndef confirmGreenRefPoolConfig(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: GreenRefPoolConfig = self.pendingGreenRefPoolConfig[_aid]\n    assert d.pool != empty(address) # dev: no pending update\n\n    # check time lock\n    assert timeLock._confirmAction(_aid) # dev: time lock not reached\n\n    # save new ref pool config\n    self.greenRefPoolConfig = d\n    self.pendingGreenRefPoolConfig[_aid] = empty(GreenRefPoolConfig)\n    log GreenRefPoolConfigUpdated(pool=d.pool, maxNumSnapshots=d.maxNumSnapshots, dangerTrigger=d.dangerTrigger, staleBlocks=d.staleBlocks, stabilizerAdjustWeight=d.stabilizerAdjustWeight, stabilizerMaxPoolDebt=d.stabilizerMaxPoolDebt)\n\n    # add snapshot\n    self._addGreenRefPoolSnapshot()\n    return True\n\n\n# cancel update feed\n\n\n@external\ndef cancelGreenRefPoolConfig(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: GreenRefPoolConfig = self.pendingGreenRefPoolConfig[_aid]\n    assert d.pool != empty(address) # dev: no pending update\n\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingGreenRefPoolConfig[_aid] = empty(GreenRefPoolConfig)\n\n    log GreenRefPoolConfigUpdateCancelled(pool=d.pool, maxNumSnapshots=d.maxNumSnapshots, dangerTrigger=d.dangerTrigger, staleBlocks=d.staleBlocks, stabilizerAdjustWeight=d.stabilizerAdjustWeight, stabilizerMaxPoolDebt=d.stabilizerMaxPoolDebt)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidGreenRefPoolConfig(\n    _poolConfig: CurvePriceConfig,\n    _refConfig: GreenRefPoolConfig,\n    _maxNumSnapshots: uint256,\n    _dangerTrigger: uint256,\n    _staleBlocks: uint256,\n    _stabilizerAdjustWeight: uint256,\n    _stabilizerMaxPoolDebt: uint256,\n    _greenToken: address,\n) -> bool:\n    if _greenToken not in _poolConfig.underlying:\n        return False\n\n    if _poolConfig.numUnderlying != 2: # only 2 underlying tokens\n        return False\n\n    if _maxNumSnapshots == 0 or _maxNumSnapshots > 100: # 100 max\n        return False\n\n    if _dangerTrigger < 50_00 or _dangerTrigger >= HUNDRED_PERCENT: # 50% - 99.99%\n        return False\n\n    if _stabilizerAdjustWeight == 0 or _stabilizerAdjustWeight > HUNDRED_PERCENT:\n        return False\n\n    if _stabilizerMaxPoolDebt == 0 or _stabilizerMaxPoolDebt > 1_000_000 * EIGHTEEN_DECIMALS: # 1 million\n        return False\n\n    # make sure this curve integration works\n    greenBalance: uint256 = 0\n    greenRatio: uint256 = 0\n    greenBalance, greenRatio = self._getCurvePoolData(_refConfig.pool, _refConfig.greenIndex, _refConfig.altAssetDecimals)\n    if greenRatio == 0:\n        return False\n\n    return True\n\n\n########################\n# Green Ref Pool Utils #\n########################\n\n\n# get ref pool data\n\n\n@view\n@external\ndef getCurrentGreenPoolStatus() -> CurrentGreenPoolStatus:\n    config: GreenRefPoolConfig = self.greenRefPoolConfig\n    if config.pool == empty(address) or config.maxNumSnapshots == 0:\n        return empty(CurrentGreenPoolStatus)\n\n    data: GreenRefPoolData = self.greenRefPoolData\n\n    # calculate weighted ratio using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: RefPoolSnapshot = self.snapShots[i]\n        if snapShot.greenBalance == 0 or snapShot.ratio == 0 or snapShot.update == 0:\n            continue\n\n        # too stale, skip\n        if config.staleBlocks != 0 and block.number > snapShot.update + config.staleBlocks:\n            continue\n\n        numerator += (snapShot.greenBalance * snapShot.ratio)\n        denominator += snapShot.greenBalance\n\n    # weighted ratio\n    weightedRatio: uint256 = 0\n    if numerator != 0:\n        weightedRatio = numerator // denominator\n    else:\n        weightedRatio = data.lastSnapshot.ratio\n\n    return CurrentGreenPoolStatus(\n        weightedRatio=weightedRatio,\n        dangerTrigger=config.dangerTrigger,\n        numBlocksInDanger=data.numBlocksInDanger,\n    )\n\n\n# add snapshot\n\n\n@external \ndef addGreenRefPoolSnapshot() -> bool:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    if priceData.isPaused:\n        return False # fail gracefully\n    return self._addGreenRefPoolSnapshot()\n\n\n@internal \ndef _addGreenRefPoolSnapshot() -> bool:\n    data: GreenRefPoolData = self.greenRefPoolData\n    if data.lastSnapshot.update == block.number:\n        return False\n\n    # balance data\n    config: GreenRefPoolConfig = self.greenRefPoolConfig\n    if config.pool == empty(address):\n        return False\n\n    # curve pool data\n    greenBalance: uint256 = 0\n    greenRatio: uint256 = 0\n    greenBalance, greenRatio = self._getCurvePoolData(config.pool, config.greenIndex, config.altAssetDecimals)\n    if greenBalance == 0 or greenRatio == 0:\n        return False\n\n    inDanger: bool = greenRatio >= config.dangerTrigger\n\n    # update danger data (using OLD snapshot before overwriting)\n    if not inDanger:\n        data.numBlocksInDanger = 0\n    elif data.lastSnapshot.inDanger and data.lastSnapshot.update != 0:\n        elapsedBlocks: uint256 = block.number - data.lastSnapshot.update\n        data.numBlocksInDanger += elapsedBlocks\n\n    # create and store new snapshot\n    newSnapshot: RefPoolSnapshot = RefPoolSnapshot(\n        greenBalance=greenBalance,\n        ratio=greenRatio,\n        update=block.number,\n        inDanger=inDanger,\n    )\n    data.lastSnapshot = newSnapshot\n    self.snapShots[data.nextIndex] = newSnapshot\n\n    # update index\n    data.nextIndex += 1\n    if data.nextIndex >= config.maxNumSnapshots:\n        data.nextIndex = 0\n\n    # save data\n    self.greenRefPoolData = data\n\n    log GreenRefPoolSnapshotAdded(pool=config.pool, greenBalance=greenBalance, greenRatio=greenRatio, inDanger=inDanger)\n    return True\n\n\n# curve pool balance\n\n\n@view\n@external \ndef getCurvePoolData() -> (uint256, uint256):\n    config: GreenRefPoolConfig = self.greenRefPoolConfig\n    return self._getCurvePoolData(config.pool, config.greenIndex, config.altAssetDecimals)\n\n\n@view\n@internal \ndef _getCurvePoolData(\n    _pool: address,\n    _greenIndex: uint256,\n    _altAssetDecimals: uint256,\n) -> (uint256, uint256):\n    normalize: uint256 = 10 ** (18 - _altAssetDecimals)\n\n    # get balances\n    greenBalance: uint256 = staticcall CurvePool(_pool).balances(_greenIndex)\n    altAssetBalance: uint256 = staticcall CurvePool(_pool).balances(1 - _greenIndex) * normalize\n\n    totalSupply: uint256 = greenBalance + altAssetBalance\n    ratio: uint256 = 50_00 # 50%\n    if totalSupply != 0:\n        ratio = greenBalance * HUNDRED_PERCENT // totalSupply\n\n    return greenBalance, ratio\n\n\n# stabilizer data / config\n\n\n@view\n@external\ndef getGreenStabilizerConfig() -> StabilizerConfig:\n    config: GreenRefPoolConfig = self.greenRefPoolConfig\n    if config.pool == empty(address):\n        return empty(StabilizerConfig)\n\n    # green pool data\n    greenBalance: uint256 = 0\n    greenRatio: uint256 = 0\n    greenBalance, greenRatio = self._getCurvePoolData(config.pool, config.greenIndex, config.altAssetDecimals)\n\n    return StabilizerConfig(\n        pool=config.pool,\n        lpToken=config.lpToken,\n        greenBalance=greenBalance,\n        greenRatio=greenRatio,\n        greenIndex=config.greenIndex,\n        stabilizerAdjustWeight=config.stabilizerAdjustWeight,\n        stabilizerMaxPoolDebt=config.stabilizerMaxPoolDebt,\n    )\n",
            "sha256sum": "4bd9754e1bb92a83c6a74936134d32e9d5e14b3c69ab53ea2ec48a324e44be65"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/priceSources/CurvePrices.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "5c8869e3408d31780ae6eaaf22935fd610dca877f436108dc13926a7935e6c48"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a0300000000000000000000000088953b3eba73d6b5252b00b1827769b5a561759900000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/priceSources/CurvePrices.vy"
    },
    "MockSGreenPrice": {
      "address": "0x04Ce3EF7d5E4C2E50d32dbEb232a2b5765923C11",
      "abi": [
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewPendingPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_sGreen",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/mock/MockSGreenPrice.vy": {
            "content": "# @version 0.4.1\n\ninterface SavingsGreen:\n    def pricePerShare() -> uint256: view\n\nsGreen: public(address)\n\n@deploy\ndef __init__(\n    _sGreen: address,\n):\n    self.sGreen = _sGreen\n\n\n########\n# Core #\n########\n\n\n@view\n@internal\ndef _getPrice() -> uint256:\n    return staticcall SavingsGreen(self.sGreen).pricePerShare()\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> uint256:\n    if _asset != self.sGreen:\n        return 0\n\n    return self._getPrice()\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> (uint256, bool):\n    if _asset != self.sGreen:\n      return 0, False\n\n    return self._getPrice(), True\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return _asset == self.sGreen\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    return False\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    return True\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    return True\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    return True\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    return True\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    return True\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    return True\n",
            "sha256sum": "0db23ab0db7122f9382d8266c427d8d5b667eb8a23a45ceb0aaa77eabc8d413a"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/mock/MockSGreenPrice.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "1265b0e74a49462f0998caa8855611f2a68ca3d81b517a7811e5e85ddaa4bf40"
      },
      "args": "00000000000000000000000011de3ed496c2fa22f49be6b4806d5603f6a54a08",
      "file": "contracts/mock/MockSGreenPrice.vy"
    },
    "VaultBook": {
      "address": "0xe5218EbdE2ccED168C9481c8b0D1DfcC4DADdca7",
      "abi": [
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RegistryTimeLockModified",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressPending",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressConfirmed",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewAddressCancelled",
          "inputs": [
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdatePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressUpdateCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "newAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "prevAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisablePending",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableConfirmed",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "version",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AddressDisableCancelled",
          "inputs": [
            {
              "name": "regId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "description",
              "type": "string",
              "indexed": false
            },
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "registry",
              "type": "string",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegistryDescription",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewAddress",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressUpdate",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddressDisable",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegistryTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRegistryTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxRegistryTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidRegId",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRegId",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddr",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrInfo",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddrDescription",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "string"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastAddr",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLastRegId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "registryChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrInfo",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "addr",
                  "type": "address"
                },
                {
                  "name": "version",
                  "type": "uint256"
                },
                {
                  "name": "lastModified",
                  "type": "uint256"
                },
                {
                  "name": "description",
                  "type": "string"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "addrToRegId",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAddrs",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingNewAddr",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "description",
                  "type": "string"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrUpdate",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newAddr",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAddrDisable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isVaultBookAddr",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            },
            {
              "name": "_description",
              "type": "string"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewAddressToRegistry",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            },
            {
              "name": "_newAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressUpdateToRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelAddressDisableInRegistry",
          "inputs": [
            {
              "name": "_regId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintRipeForStabPoolClaims",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_ripeToken",
              "type": "address"
            },
            {
              "name": "_ledger",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minRegistryTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxRegistryTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/registries/modules/AddressRegistry.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct AddressInfo:\n    addr: address\n    version: uint256\n    lastModified: uint256\n    description: String[64]\n\nstruct PendingNewAddress:\n    description: String[64]\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressUpdate:\n    newAddr: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nstruct PendingAddressDisable:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent NewAddressPending:\n    addr: indexed(address)\n    description: String[64]\n    confirmBlock: uint256\n    registry: String[28]\n\nevent NewAddressConfirmed:\n    addr: indexed(address)\n    regId: uint256\n    description: String[64]\n    registry: String[28]\n\nevent NewAddressCancelled:\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdatePending:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressUpdateConfirmed:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressUpdateCancelled:\n    regId: uint256\n    description: String[64]\n    newAddr: indexed(address)\n    prevAddr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisablePending:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent AddressDisableConfirmed:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    version: uint256\n    registry: String[28]\n\nevent AddressDisableCancelled:\n    regId: uint256\n    description: String[64]\n    addr: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    registry: String[28]\n\nevent RegistryTimeLockModified:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n    registry: String[28]\n\n# time lock\nregistryChangeTimeLock: public(uint256)\n\n# core data (address registry)\naddrInfo: public(HashMap[uint256, AddressInfo]) # regId -> address info\naddrToRegId: public(HashMap[address, uint256]) # addr -> regId\nnumAddrs: public(uint256) # number of addrs in registry\n\n# pending changes\npendingNewAddr: public(HashMap[address, PendingNewAddress]) # addr -> pending new addr\npendingAddrUpdate: public(HashMap[uint256, PendingAddressUpdate]) # regId -> pending addr update\npendingAddrDisable: public(HashMap[uint256, PendingAddressDisable]) # regId -> pending addr disable\n\nREGISTRY_STR: immutable(String[28])\nMIN_REG_TIME_LOCK: immutable(uint256)\nMAX_REG_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _registryStr: String[28],\n):\n    REGISTRY_STR = _registryStr\n\n    assert _minTimeLock < _maxTimeLock # dev: invalid time lock\n    assert _minTimeLock != 0 and _maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_REG_TIME_LOCK = _minTimeLock\n    MAX_REG_TIME_LOCK = _maxTimeLock\n\n    # set initial time lock -- this may be zero during inital setup of registry\n    if _initialTimeLock != 0:\n        assert self._setRegistryTimeLock(_initialTimeLock) # dev: invalid time lock\n\n    # start at 1 index\n    self.numAddrs = 1\n\n\n@view\n@external\ndef getRegistryDescription() -> String[28]:\n    return REGISTRY_STR\n\n\n###############\n# New Address #\n###############\n\n\n# register new address\n\n\n@internal\ndef _startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert self._isValidNewAddress(_addr) # dev: invalid addy\n\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingNewAddr[_addr] = PendingNewAddress(\n        description=_description,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log NewAddressPending(addr=_addr, description=_description, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm new address\n\n\n@internal\ndef _confirmNewAddressToRegistry(_addr: address) -> uint256:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    if not self._isValidNewAddress(_addr):\n        self.pendingNewAddr[_addr] = empty(PendingNewAddress) # clear pending\n        return 0\n\n    # register new addy\n    regId: uint256 = self.numAddrs\n    self.addrToRegId[_addr] = regId\n    self.numAddrs = regId + 1\n    self.addrInfo[regId] = AddressInfo(\n        addr=_addr,\n        version=1,\n        lastModified=block.timestamp,\n        description=data.description,\n    )\n\n    # clear pending\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n\n    log NewAddressConfirmed(addr=_addr, regId=regId, description=data.description, registry=REGISTRY_STR)\n    return regId\n\n\n# cancel new address\n\n\n@internal\ndef _cancelNewAddressToRegistry(_addr: address) -> bool:\n    data: PendingNewAddress = self.pendingNewAddr[_addr]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingNewAddr[_addr] = empty(PendingNewAddress)\n    log NewAddressCancelled(description=data.description, addr=_addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewAddress(_addr: address) -> bool:\n    return self._isValidNewAddress(_addr)\n\n\n@view\n@internal\ndef _isValidNewAddress(_addr: address) -> bool:\n    if _addr == empty(address) or not _addr.is_contract:\n        return False\n    return self.addrToRegId[_addr] == 0\n\n\n###################\n# Address Updates #\n###################\n\n\n# update address\n\n\n@internal\ndef _startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressUpdate(_regId, _newAddr, data.addr) # dev: invalid update\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrUpdate[_regId] = PendingAddressUpdate(\n        newAddr=_newAddr,\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressUpdatePending(regId=_regId, description=data.description, newAddr=_newAddr, prevAddr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm update address\n\n\n@internal\ndef _confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressUpdate(_regId, newData.newAddr, prevAddr):\n        self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate) # clear pending\n        return False\n\n    # update addy data\n    data.addr = newData.newAddr\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[newData.newAddr] = _regId\n\n    # handle previous addr\n    if prevAddr != empty(address):\n        self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n\n    log AddressUpdateConfirmed(regId=_regId, description=data.description, newAddr=newData.newAddr, prevAddr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel update address\n\n\n@internal\ndef _cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    data: PendingAddressUpdate = self.pendingAddrUpdate[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrUpdate[_regId] = empty(PendingAddressUpdate)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressUpdateCancelled(regId=_regId, description=prevData.description, newAddr=data.newAddr, prevAddr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressUpdate(_regId: uint256, _newAddr: address) -> bool:\n    return self._isValidAddressUpdate(_regId, _newAddr, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressUpdate(_regId: uint256, _newAddr: address, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    if not self._isValidNewAddress(_newAddr):\n        return False\n    return _newAddr != _prevAddr\n\n\n###################\n# Disable Address #\n###################\n\n\n# start disable address\n\n\n@internal\ndef _startAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: AddressInfo = self.addrInfo[_regId]\n    assert self._isValidAddressDisable(_regId, data.addr) # dev: invalid disable\n\n    # set pending\n    confirmBlock: uint256 = block.number + self.registryChangeTimeLock\n    self.pendingAddrDisable[_regId] = PendingAddressDisable(\n        initiatedBlock=block.number,\n        confirmBlock=confirmBlock,\n    )\n\n    log AddressDisablePending(regId=_regId, description=data.description, addr=data.addr, version=data.version, confirmBlock=confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# confirm disable address\n\n\n@internal\ndef _confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    newData: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert newData.confirmBlock != 0 and block.number >= newData.confirmBlock # dev: time lock not reached\n\n    data: AddressInfo = self.addrInfo[_regId]\n    prevAddr: address = data.addr # needed for later\n    if not self._isValidAddressDisable(_regId, prevAddr):\n        self.pendingAddrDisable[_regId] = empty(PendingAddressDisable) # clear pending\n        return False\n\n    # disable addy\n    data.addr = empty(address)\n    data.lastModified = block.timestamp\n    data.version += 1\n    self.addrInfo[_regId] = data\n    self.addrToRegId[prevAddr] = 0\n\n    # clear pending\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n\n    log AddressDisableConfirmed(regId=_regId, description=data.description, addr=prevAddr, version=data.version, registry=REGISTRY_STR)\n    return True\n\n\n# cancel disable address\n\n\n@internal\ndef _cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    data: PendingAddressDisable = self.pendingAddrDisable[_regId]\n    assert data.confirmBlock != 0 # dev: no pending\n\n    self.pendingAddrDisable[_regId] = empty(PendingAddressDisable)\n    prevData: AddressInfo = self.addrInfo[_regId]\n    log AddressDisableCancelled(regId=_regId, description=prevData.description, addr=prevData.addr, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidAddressDisable(_regId: uint256) -> bool:\n    return self._isValidAddressDisable(_regId, self.addrInfo[_regId].addr)\n\n\n@view\n@internal\ndef _isValidAddressDisable(_regId: uint256, _prevAddr: address) -> bool:\n    if not self._isValidRegId(_regId):\n        return False\n    return _prevAddr != empty(address)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n@external\ndef setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setRegistryTimeLock(_numBlocks)\n\n\n@internal\ndef _setRegistryTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.registryChangeTimeLock\n    assert self._isValidRegistryTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.registryChangeTimeLock = _numBlocks\n    log RegistryTimeLockModified(newTimeLock=_numBlocks, prevTimeLock=prevTimeLock, registry=REGISTRY_STR)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidRegistryTimeLock(_numBlocks: uint256) -> bool:\n    return self._isValidRegistryTimeLock(_numBlocks, self.registryChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidRegistryTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False\n    return _newTimeLock >= MIN_REG_TIME_LOCK and _newTimeLock <= MAX_REG_TIME_LOCK\n\n\n# finish setup\n\n\n@external\ndef setRegistryTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self.registryChangeTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _numBlocks\n    if timeLock == 0:\n        timeLock = MIN_REG_TIME_LOCK\n    return self._setRegistryTimeLock(timeLock)\n\n\n# utils\n\n\n@view\n@external\ndef minRegistryTimeLock() -> uint256:\n    return MIN_REG_TIME_LOCK\n\n\n@view\n@external\ndef maxRegistryTimeLock() -> uint256:\n    return MAX_REG_TIME_LOCK\n\n\n#################\n# Views / Utils #\n#################\n\n\n# is valid addr\n\n\n@view\n@external\ndef isValidAddr(_addr: address) -> bool:\n    return self._isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isValidAddr(_addr: address) -> bool:\n    return self.addrToRegId[_addr] != 0\n\n\n# is valid addr id\n\n\n@view\n@external\ndef isValidRegId(_regId: uint256) -> bool:\n    return self._isValidRegId(_regId)\n\n\n@view\n@internal\ndef _isValidRegId(_regId: uint256) -> bool:\n    return _regId != 0 and _regId < self.numAddrs\n\n\n# get reg id\n\n\n@view\n@external\ndef getRegId(_addr: address) -> uint256:\n    return self._getRegId(_addr)\n\n\n@view\n@internal\ndef _getRegId(_addr: address) -> uint256:\n    return self.addrToRegId[_addr]\n\n\n# get addr\n\n\n@view\n@external\ndef getAddr(_regId: uint256) -> address:\n    return self._getAddr(_regId)\n\n\n@view\n@internal\ndef _getAddr(_regId: uint256) -> address:\n    return self.addrInfo[_regId].addr\n\n\n# get addr info\n\n\n@view\n@external\ndef getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self._getAddrInfo(_regId)\n\n\n@view\n@internal\ndef _getAddrInfo(_regId: uint256) -> AddressInfo:\n    return self.addrInfo[_regId]\n\n\n# get addr description\n\n\n@view\n@external\ndef getAddrDescription(_regId: uint256) -> String[64]:\n    return self._getAddrDescription(_regId)\n\n\n@view\n@internal\ndef _getAddrDescription(_regId: uint256) -> String[64]:\n    return self.addrInfo[_regId].description\n\n\n# get num addrs\n\n\n@view\n@external\ndef getNumAddrs() -> uint256:\n    return self._getNumAddrs()\n\n\n@view\n@internal\ndef _getNumAddrs() -> uint256:\n    return self.numAddrs - 1\n\n\n# get last addr\n\n\n@view\n@external\ndef getLastAddr() -> address:\n    return self._getLastAddr()\n\n\n@view\n@internal\ndef _getLastAddr() -> address:\n    lastRegId: uint256 = self.numAddrs - 1\n    return self.addrInfo[lastRegId].addr\n\n\n# get last reg id\n\n\n@view\n@external\ndef getLastRegId() -> uint256:\n    return self._getLastRegId()\n\n\n@view\n@internal\ndef _getLastRegId() -> uint256:\n    return self.numAddrs - 1\n",
            "sha256sum": "45a6786be62ebfcd266d4b9f321aa22bfc8d125d6ce75ffcf4d895ad011ff661"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/registries/VaultBook.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: gov.__interface__\nexports: registry.__interface__\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: gov\ninitializes: registry[gov := gov]\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.registries.modules.AddressRegistry as registry\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Vault\nfrom interfaces import Department\n\ninterface Ledger:\n    def didGetRewardsFromStabClaims(_amount: uint256): nonpayable\n\ninterface RipeToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minRegistryTimeLock: uint256,\n    _maxRegistryTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    registry.__init__(_minRegistryTimeLock, _maxRegistryTimeLock, 0, \"VaultBook.vy\")\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, True) # can mint ripe only\n\n\n@view\n@external\ndef isVaultBookAddr(_addr: address) -> bool:\n    return registry._isValidAddr(_addr)\n\n\n############\n# Registry #\n############\n\n\n# new address\n\n\n@external\ndef startAddNewAddressToRegistry(_addr: address, _description: String[64]) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddNewAddressToRegistry(_addr, _description)\n\n\n@external\ndef confirmNewAddressToRegistry(_addr: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmNewAddressToRegistry(_addr)\n\n\n@external\ndef cancelNewAddressToRegistry(_addr: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelNewAddressToRegistry(_addr)\n\n\n# address update\n\n\n@external\ndef startAddressUpdateToRegistry(_regId: uint256, _newAddr: address) -> bool:\n    assert not self._doesVaultIdHaveAnyFunds(_regId) # dev: vault has funds\n\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressUpdateToRegistry(_regId, _newAddr)\n\n\n@external\ndef confirmAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressUpdateToRegistry(_regId)\n\n\n@external\ndef cancelAddressUpdateToRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressUpdateToRegistry(_regId)\n\n\n# address disable\n\n\n@external\ndef startAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert not self._doesVaultIdHaveAnyFunds(_regId) # dev: vault has funds\n\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._startAddressDisableInRegistry(_regId)\n\n\n@external\ndef confirmAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._confirmAddressDisableInRegistry(_regId)\n\n\n@external\ndef cancelAddressDisableInRegistry(_regId: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return registry._cancelAddressDisableInRegistry(_regId)\n\n\n# check if vault has funds\n\n\n@view\n@internal\ndef _doesVaultIdHaveAnyFunds(_vaultId: uint256) -> bool:\n    vaultAddr: address = registry._getAddr(_vaultId)\n    return staticcall Vault(vaultAddr).doesVaultHaveAnyFunds()\n\n\n######################\n# Stab Claim Rewards #\n######################\n\n\n# pass thru from stability pool\n\n\n@external\ndef mintRipeForStabPoolClaims(_amount: uint256, _ripeToken: address, _ledger: address) -> bool:\n    assert registry._isValidAddr(msg.sender) # dev: no perms\n    extcall RipeToken(_ripeToken).mint(msg.sender, _amount)\n    extcall Ledger(_ledger).didGetRewardsFromStabClaims(_amount)\n    return True",
            "sha256sum": "c513587c4ed2e50b002552ab66091d414aeb0e07a9d76956ad97dd4ab623bc41"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/registries/VaultBook.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "518a88e69663ae4e1697a2b0ab96cb3c60ddbc6be985361ab4c9fc9b963cf81f"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a0300000000000000000000000000000000000000000000000000000000000054600000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/registries/VaultBook.vy"
    },
    "SimpleErc20": {
      "address": "0x11E46fd924e3E6459F50f67D47488233C4C72C01",
      "abi": [
        {
          "name": "SimpleErc20VaultDeposit",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SimpleErc20VaultWithdrawal",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "SimpleErc20VaultTransfer",
          "inputs": [
            {
              "name": "fromUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "toUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "transferAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isFromUserDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInVaultAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesUserHaveBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterUserAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesVaultHaveAnyFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumVaultAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfUserAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultDataOnDeposit",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasPosition",
                  "type": "bool"
                },
                {
                  "name": "numAssets",
                  "type": "uint256"
                },
                {
                  "name": "userBalance",
                  "type": "uint256"
                },
                {
                  "name": "totalBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserLootBoxShare",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAndAmountAtIndex",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAtIndexAndHasBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/vaults/modules/VaultData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent VaultPauseModified:\n    isPaused: bool\n\nevent VaultFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# balances (may be shares or actual balance)\nuserBalances: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> balance\ntotalBalances: public(HashMap[address, uint256]) # asset -> balance\n\n# user assets (iterable)\nuserAssets: public(HashMap[address, HashMap[uint256, address]]) # user -> index -> asset\nindexOfUserAsset: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> index\nnumUserAssets: public(HashMap[address, uint256]) # user -> num assets\n\n# vault assets (iterable)\nvaultAssets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###################\n# Balance Changes #\n###################\n\n\n# deposit\n\n\n@internal\ndef _addBalanceOnDeposit(\n    _user: address,\n    _asset: address,\n    _depositBal: uint256,\n    _shouldUpdateTotal: bool,\n):\n    # update balances\n    self.userBalances[_user][_asset] += _depositBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] += _depositBal\n\n    # register user asset (if necessary)\n    if self.indexOfUserAsset[_user][_asset] == 0:\n        self._registerUserAsset(_user, _asset)\n\n    # register vault asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerVaultAsset(_asset)\n\n\n# withdrawal\n\n\n@internal\ndef _reduceBalanceOnWithdrawal(\n    _user: address,\n    _asset: address,\n    _withdrawBal: uint256,\n    _shouldUpdateTotal: bool,\n) -> (uint256, bool):\n    assert self.indexOfUserAsset[_user][_asset] != 0 # dev: user does not have this asset\n\n    currentBal: uint256 = self.userBalances[_user][_asset]\n    withdrawBal: uint256 = min(_withdrawBal, currentBal)\n    assert withdrawBal != 0 # dev: nothing to withdraw\n\n    # update balances\n    currentBal -= withdrawBal\n    self.userBalances[_user][_asset] = currentBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] -= withdrawBal\n\n    return withdrawBal, currentBal == 0\n\n\n###############\n# User Assets #\n###############\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    return self.indexOfUserAsset[_user][_asset] != 0\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    return self.userBalances[_user][_asset] != 0\n\n\n@internal\ndef _registerUserAsset(_user: address, _asset: address):\n    aid: uint256 = self.numUserAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.userAssets[_user][aid] = _asset\n    self.indexOfUserAsset[_user][_asset] = aid\n    self.numUserAssets[_user] = aid + 1\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n\n    if self.userBalances[_user][_asset] != 0:\n        return True\n\n    numUserAssets: uint256 = self.numUserAssets[_user]\n    if numUserAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfUserAsset[_user][_asset]\n    if targetIndex == 0:\n        return numUserAssets > 1\n\n    # update data\n    lastIndex: uint256 = numUserAssets - 1\n    self.numUserAssets[_user] = lastIndex\n    self.indexOfUserAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.userAssets[_user][lastIndex]\n        self.userAssets[_user][targetIndex] = lastItem\n        self.indexOfUserAsset[_user][lastItem] = targetIndex\n\n    return lastIndex > 1\n\n\n################\n# Vault Assets #\n################\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@internal\ndef _registerVaultAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.vaultAssets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if self.totalBalances[_asset] != 0:\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.vaultAssets[lastIndex]\n        self.vaultAssets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n##############\n# Data Utils #\n##############\n\n\n# any vault funds\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.vaultAssets[i]\n        if self.totalBalances[asset] != 0:\n            return True\n    return False\n\n\n# num user assets\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    return self._getNumUserAssets(_user)\n\n\n@view\n@internal\ndef _getNumUserAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numUserAssets[_user]\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n# num vault assets\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    return self._getNumVaultAssets()\n\n\n@view\n@internal\ndef _getNumVaultAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log VaultPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    # cannot recover funds from a registered asset with a balance\n    assert self.indexOfAsset[_asset] == 0 and self.totalBalances[_asset] == 0 # dev: invalid recovery\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log VaultFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "a40dbc674354ec85dd7c1ad8573db4995a56c7a58284b9e3357ba5145fc34de5"
          },
          "contracts/vaults/modules/BasicVault.vy": {
            "content": "# @version 0.4.1\n\nuses: vaultData\nimport contracts.vaults.modules.VaultData as vaultData\n\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC20\n\n\n@deploy\ndef __init__():\n    pass\n\n\n########\n# Core #\n########\n\n\n@internal\ndef _depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n) -> uint256:\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset] # dev: invalid user or asset\n    depositAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(self))\n    assert depositAmount != 0 # dev: invalid deposit amount\n\n    # add balance on deposit\n    vaultData._addBalanceOnDeposit(_user, _asset, depositAmount, True)\n\n    return depositAmount\n\n\n@internal\ndef _withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n) -> (uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset, _recipient] # dev: invalid user, asset, or recipient\n    assert _amount != 0 # dev: invalid withdrawal amount\n\n    # reduce balance on withdrawal\n    withdrawalAmount: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, isDepleted = vaultData._reduceBalanceOnWithdrawal(_user, _asset, _amount, True)\n\n    # move tokens to recipient\n    withdrawalAmount = min(withdrawalAmount, staticcall IERC20(_asset).balanceOf(self))\n    assert withdrawalAmount != 0 # dev: no withdrawal amount\n    assert extcall IERC20(_asset).transfer(_recipient, withdrawalAmount, default_return_value=True) # dev: token transfer failed\n\n    return withdrawalAmount, isDepleted\n\n\n@internal\ndef _transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n) -> (uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_fromUser, _toUser, _asset] # dev: invalid users or asset\n    assert _transferAmount != 0 # dev: invalid transfer amount\n\n    # transfer balances\n    transferAmount: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, isFromUserDepleted = vaultData._reduceBalanceOnWithdrawal(_fromUser, _asset, _transferAmount, False)\n    vaultData._addBalanceOnDeposit(_toUser, _asset, transferAmount, False)\n\n    return transferAmount, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@internal\ndef _getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return Vault.VaultDataOnDeposit(\n        hasPosition=vaultData.indexOfUserAsset[_user][_asset] != 0,\n        numAssets=vaultData._getNumUserAssets(_user),\n        userBalance=vaultData.userBalances[_user][_asset],\n        totalBalance=vaultData.totalBalances[_asset],\n    )\n\n\n@view\n@internal\ndef _getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return vaultData.userBalances[_user][_asset]\n\n\n@view\n@internal\ndef _getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), 0\n    return asset, vaultData.userBalances[_user][asset]\n\n\n@view\n@internal\ndef _getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), False\n    return asset, vaultData.userBalances[_user][asset] != 0\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@internal\ndef _getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return vaultData.userBalances[_user][_asset]\n\n\n@view\n@internal\ndef _getTotalAmountForVault(_asset: address) -> uint256:\n    return vaultData.totalBalances[_asset]\n",
            "sha256sum": "330fca9b966f89bcc7a8583a6bdae810a3e524abce8e49e43dd88d3046df5e0a"
          },
          "contracts/vaults/SimpleErc20.vy": {
            "content": "# @version 0.4.1\n\nimplements: Vault\n\nexports: addys.__interface__\nexports: vaultData.__interface__\n\ninitializes: addys\ninitializes: vaultData[addys := addys]\ninitializes: basicVault[vaultData := vaultData]\n\nfrom interfaces import Vault\nimport contracts.modules.Addys as addys\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.vaults.modules.BasicVault as basicVault\nfrom ethereum.ercs import IERC20\n\nevent SimpleErc20VaultDeposit:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n\nevent SimpleErc20VaultWithdrawal:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    isDepleted: bool\n\nevent SimpleErc20VaultTransfer:\n    fromUser: indexed(address)\n    toUser: indexed(address)\n    asset: indexed(address)\n    transferAmount: uint256\n    isFromUserDepleted: bool\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    vaultData.__init__(False)\n    basicVault.__init__()\n\n\n########\n# Core #\n########\n\n\n@nonreentrant\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n\n    depositAmount: uint256 = basicVault._depositTokensInVault(_user, _asset, _amount)\n    log SimpleErc20VaultDeposit(user=_user, asset=_asset, amount=depositAmount)\n    return depositAmount\n\n\n@nonreentrant\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getTellerAddr(), addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n\n    withdrawalAmount: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, isDepleted = basicVault._withdrawTokensFromVault(_user, _asset, _amount, _recipient)\n    log SimpleErc20VaultWithdrawal(user=_user, asset=_asset, amount=withdrawalAmount, isDepleted=isDepleted)\n    return withdrawalAmount, isDepleted\n\n\n@nonreentrant\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n\n    transferAmount: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, isFromUserDepleted = basicVault._transferBalanceWithinVault(_asset, _fromUser, _toUser, _transferAmount)\n    log SimpleErc20VaultTransfer(fromUser=_fromUser, toUser=_toUser, asset=_asset, transferAmount=transferAmount, isFromUserDepleted=isFromUserDepleted)\n    return transferAmount, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return basicVault._getVaultDataOnDeposit(_user, _asset)\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return basicVault._getUserLootBoxShare(_user, _asset)\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    return basicVault._getUserAssetAndAmountAtIndex(_user, _index)\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    return basicVault._getUserAssetAtIndexAndHasBalance(_user, _index)\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return basicVault._getTotalAmountForUser(_user, _asset)\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    return basicVault._getTotalAmountForVault(_asset)\n",
            "sha256sum": "c08571f15af501fb291cdca7f1894b0bebde5bd67e73763e5143b5df9927e2ec"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/SimpleErc20.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "80c9ea166307412fbde0c184a5abc41fabe3f56bdbe20a14a3829676973077ff"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/vaults/SimpleErc20.vy"
    },
    "RebaseErc20": {
      "address": "0x60b67F6641706e0C1573F4a271bE5D66BA392D88",
      "abi": [
        {
          "name": "RebaseErc20VaultDeposit",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RebaseErc20VaultWithdrawal",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RebaseErc20VaultTransfer",
          "inputs": [
            {
              "name": "fromUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "toUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "transferAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isFromUserDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "transferShares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInVaultAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesUserHaveBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterUserAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesVaultHaveAnyFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumVaultAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfUserAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "amountToShares",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sharesToAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultDataOnDeposit",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasPosition",
                  "type": "bool"
                },
                {
                  "name": "numAssets",
                  "type": "uint256"
                },
                {
                  "name": "userBalance",
                  "type": "uint256"
                },
                {
                  "name": "totalBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserLootBoxShare",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAndAmountAtIndex",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAtIndexAndHasBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/vaults/modules/VaultData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent VaultPauseModified:\n    isPaused: bool\n\nevent VaultFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# balances (may be shares or actual balance)\nuserBalances: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> balance\ntotalBalances: public(HashMap[address, uint256]) # asset -> balance\n\n# user assets (iterable)\nuserAssets: public(HashMap[address, HashMap[uint256, address]]) # user -> index -> asset\nindexOfUserAsset: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> index\nnumUserAssets: public(HashMap[address, uint256]) # user -> num assets\n\n# vault assets (iterable)\nvaultAssets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###################\n# Balance Changes #\n###################\n\n\n# deposit\n\n\n@internal\ndef _addBalanceOnDeposit(\n    _user: address,\n    _asset: address,\n    _depositBal: uint256,\n    _shouldUpdateTotal: bool,\n):\n    # update balances\n    self.userBalances[_user][_asset] += _depositBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] += _depositBal\n\n    # register user asset (if necessary)\n    if self.indexOfUserAsset[_user][_asset] == 0:\n        self._registerUserAsset(_user, _asset)\n\n    # register vault asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerVaultAsset(_asset)\n\n\n# withdrawal\n\n\n@internal\ndef _reduceBalanceOnWithdrawal(\n    _user: address,\n    _asset: address,\n    _withdrawBal: uint256,\n    _shouldUpdateTotal: bool,\n) -> (uint256, bool):\n    assert self.indexOfUserAsset[_user][_asset] != 0 # dev: user does not have this asset\n\n    currentBal: uint256 = self.userBalances[_user][_asset]\n    withdrawBal: uint256 = min(_withdrawBal, currentBal)\n    assert withdrawBal != 0 # dev: nothing to withdraw\n\n    # update balances\n    currentBal -= withdrawBal\n    self.userBalances[_user][_asset] = currentBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] -= withdrawBal\n\n    return withdrawBal, currentBal == 0\n\n\n###############\n# User Assets #\n###############\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    return self.indexOfUserAsset[_user][_asset] != 0\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    return self.userBalances[_user][_asset] != 0\n\n\n@internal\ndef _registerUserAsset(_user: address, _asset: address):\n    aid: uint256 = self.numUserAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.userAssets[_user][aid] = _asset\n    self.indexOfUserAsset[_user][_asset] = aid\n    self.numUserAssets[_user] = aid + 1\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n\n    if self.userBalances[_user][_asset] != 0:\n        return True\n\n    numUserAssets: uint256 = self.numUserAssets[_user]\n    if numUserAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfUserAsset[_user][_asset]\n    if targetIndex == 0:\n        return numUserAssets > 1\n\n    # update data\n    lastIndex: uint256 = numUserAssets - 1\n    self.numUserAssets[_user] = lastIndex\n    self.indexOfUserAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.userAssets[_user][lastIndex]\n        self.userAssets[_user][targetIndex] = lastItem\n        self.indexOfUserAsset[_user][lastItem] = targetIndex\n\n    return lastIndex > 1\n\n\n################\n# Vault Assets #\n################\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@internal\ndef _registerVaultAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.vaultAssets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if self.totalBalances[_asset] != 0:\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.vaultAssets[lastIndex]\n        self.vaultAssets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n##############\n# Data Utils #\n##############\n\n\n# any vault funds\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.vaultAssets[i]\n        if self.totalBalances[asset] != 0:\n            return True\n    return False\n\n\n# num user assets\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    return self._getNumUserAssets(_user)\n\n\n@view\n@internal\ndef _getNumUserAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numUserAssets[_user]\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n# num vault assets\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    return self._getNumVaultAssets()\n\n\n@view\n@internal\ndef _getNumVaultAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log VaultPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    # cannot recover funds from a registered asset with a balance\n    assert self.indexOfAsset[_asset] == 0 and self.totalBalances[_asset] == 0 # dev: invalid recovery\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log VaultFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "a40dbc674354ec85dd7c1ad8573db4995a56c7a58284b9e3357ba5145fc34de5"
          },
          "contracts/vaults/modules/SharesVault.vy": {
            "content": "# @version 0.4.1\n\nuses: vaultData\nimport contracts.vaults.modules.VaultData as vaultData\n\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC20\n\nDECIMAL_OFFSET: constant(uint256) = 10 ** 8\n\n\n@deploy\ndef __init__():\n    pass\n\n\n########\n# Core #\n########\n\n\n@internal\ndef _depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n) -> (uint256, uint256):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset] # dev: invalid user or asset\n    totalAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    depositAmount: uint256 = min(_amount, totalAssetBalance)\n    assert depositAmount != 0 # dev: invalid deposit amount\n\n    # calc shares\n    prevTotalBalance: uint256 = totalAssetBalance - depositAmount # remove the deposited amount to calc shares accurately\n    newShares: uint256 = self._amountToShares(depositAmount, vaultData.totalBalances[_asset], prevTotalBalance, False)\n\n    # add balance on deposit\n    vaultData._addBalanceOnDeposit(_user, _asset, newShares, True)\n\n    return depositAmount, newShares\n\n\n@internal\ndef _withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_user, _asset, _recipient] # dev: invalid user, asset, or recipient\n\n    # calc shares + amount to withdraw\n    withdrawalShares: uint256 = 0\n    withdrawalAmount: uint256 = 0\n    withdrawalShares, withdrawalAmount = self._calcWithdrawalSharesAndAmount(_user, _asset, _amount)\n\n    # reduce balance on withdrawal\n    isDepleted: bool = False\n    withdrawalShares, isDepleted = vaultData._reduceBalanceOnWithdrawal(_user, _asset, withdrawalShares, True)\n\n    # move tokens to recipient\n    assert extcall IERC20(_asset).transfer(_recipient, withdrawalAmount, default_return_value=True) # dev: token transfer failed\n    return withdrawalAmount, withdrawalShares, isDepleted\n\n\n@internal\ndef _transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_fromUser, _toUser, _asset] # dev: invalid users or asset\n\n    # calc shares + amount to transfer\n    transferShares: uint256 = 0\n    transferAmount: uint256 = 0\n    transferShares, transferAmount = self._calcWithdrawalSharesAndAmount(_fromUser, _asset, _transferAmount)\n\n    # transfer shares\n    isFromUserDepleted: bool = False\n    transferShares, isFromUserDepleted = vaultData._reduceBalanceOnWithdrawal(_fromUser, _asset, transferShares, False)\n    vaultData._addBalanceOnDeposit(_toUser, _asset, transferShares, False)\n\n    return transferAmount, transferShares, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@internal\ndef _getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return Vault.VaultDataOnDeposit(\n        hasPosition=vaultData.indexOfUserAsset[_user][_asset] != 0,\n        numAssets=vaultData._getNumUserAssets(_user),\n        userBalance=self._getTotalAmountForUserWithTotalBal(_user, _asset, totalBalance),\n        totalBalance=totalBalance,\n    )\n\n\n@view\n@internal\ndef _getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return vaultData.userBalances[_user][_asset] // DECIMAL_OFFSET\n\n\n@view\n@internal\ndef _getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), 0\n    userShares: uint256 = vaultData.userBalances[_user][asset]\n    if userShares == 0:\n        return empty(address), 0\n    return asset, self._sharesToAmount(userShares, vaultData.totalBalances[asset], staticcall IERC20(asset).balanceOf(self), False)\n\n\n@view\n@internal\ndef _getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), False\n    return asset, vaultData.userBalances[_user][asset] != 0\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@internal\ndef _getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return self._getTotalAmountForUserWithTotalBal(_user, _asset, staticcall IERC20(_asset).balanceOf(self))\n\n\n@view\n@internal\ndef _getTotalAmountForUserWithTotalBal(_user: address, _asset: address, _totalBalance: uint256) -> uint256:\n    userShares: uint256 = vaultData.userBalances[_user][_asset]\n    return self._sharesToAmount(userShares, vaultData.totalBalances[_asset], _totalBalance, False)\n\n\n@view\n@internal\ndef _getTotalAmountForVault(_asset: address) -> uint256:\n    return staticcall IERC20(_asset).balanceOf(self)\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@internal\ndef _calcWithdrawalSharesAndAmount(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n) -> (uint256, uint256):\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert totalBalance != 0 # dev: no asset to withdraw\n\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n\n    # user shares\n    withdrawalShares: uint256 = vaultData.userBalances[_user][_asset]\n    assert withdrawalShares != 0 # dev: user has no shares\n\n    # calc amount + shares to withdraw\n    withdrawalAmount: uint256 = min(totalBalance, self._sharesToAmount(withdrawalShares, totalShares, totalBalance, False))\n    if _amount < withdrawalAmount:\n        withdrawalShares = min(withdrawalShares, self._amountToShares(_amount, totalShares, totalBalance, True))\n        withdrawalAmount = _amount\n\n    assert withdrawalAmount != 0 # dev: no withdrawal amount\n    return withdrawalShares, withdrawalAmount\n\n\n# amount -> shares\n\n\n@view\n@external\ndef amountToShares(_asset: address, _amount: uint256, _shouldRoundUp: bool) -> uint256:\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return self._amountToShares(_amount, totalShares, totalBalance, _shouldRoundUp)\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalBalance: uint256 = _totalBalance\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalBalance += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc shares\n    numerator: uint256 = _amount * totalShares\n    shares: uint256 = numerator // totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@external\ndef sharesToAmount(_asset: address, _shares: uint256, _shouldRoundUp: bool) -> uint256:\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return self._sharesToAmount(_shares, totalShares, totalBalance, _shouldRoundUp)\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalBalance: uint256 = _totalBalance\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalBalance += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc amount\n    numerator: uint256 = _shares * totalBalance\n    amount: uint256 = numerator // totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalShares != 0):\n        amount += 1\n\n    return amount\n",
            "sha256sum": "e5950f837a378ea674587140082327b4113dcd19b9f77b9c86bbedc6ee329860"
          },
          "contracts/vaults/RebaseErc20.vy": {
            "content": "# @version 0.4.1\n\nimplements: Vault\n\nexports: addys.__interface__\nexports: vaultData.__interface__\nexports: sharesVault.__interface__\n\ninitializes: addys\ninitializes: vaultData[addys := addys]\ninitializes: sharesVault[vaultData := vaultData]\n\nfrom interfaces import Vault\nimport contracts.modules.Addys as addys\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.vaults.modules.SharesVault as sharesVault\nfrom ethereum.ercs import IERC20\n\nevent RebaseErc20VaultDeposit:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    shares: uint256\n\nevent RebaseErc20VaultWithdrawal:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    isDepleted: bool\n    shares: uint256\n\nevent RebaseErc20VaultTransfer:\n    fromUser: indexed(address)\n    toUser: indexed(address)\n    asset: indexed(address)\n    transferAmount: uint256\n    isFromUserDepleted: bool\n    transferShares: uint256\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    vaultData.__init__(False)\n    sharesVault.__init__()\n\n\n########\n# Core #\n########\n\n\n@nonreentrant\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n\n    depositAmount: uint256 = 0\n    newShares: uint256 = 0\n    depositAmount, newShares = sharesVault._depositTokensInVault(_user, _asset, _amount)\n    log RebaseErc20VaultDeposit(user=_user, asset=_asset, amount=depositAmount, shares=newShares)\n    return depositAmount\n\n\n@nonreentrant\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getTellerAddr(), addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n\n    withdrawalAmount: uint256 = 0\n    withdrawalShares: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, withdrawalShares, isDepleted = sharesVault._withdrawTokensFromVault(_user, _asset, _amount, _recipient)\n    log RebaseErc20VaultWithdrawal(user=_user, asset=_asset, amount=withdrawalAmount, isDepleted=isDepleted, shares=withdrawalShares)\n    return withdrawalAmount, isDepleted\n\n\n@nonreentrant\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n\n    transferAmount: uint256 = 0\n    transferShares: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, transferShares, isFromUserDepleted = sharesVault._transferBalanceWithinVault(_asset, _fromUser, _toUser, _transferAmount)\n    log RebaseErc20VaultTransfer(fromUser=_fromUser, toUser=_toUser, asset=_asset, transferAmount=transferAmount, isFromUserDepleted=isFromUserDepleted, transferShares=transferShares)\n    return transferAmount, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return sharesVault._getVaultDataOnDeposit(_user, _asset)\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return sharesVault._getUserLootBoxShare(_user, _asset)\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    return sharesVault._getUserAssetAndAmountAtIndex(_user, _index)\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    return sharesVault._getUserAssetAtIndexAndHasBalance(_user, _index)\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return sharesVault._getTotalAmountForUser(_user, _asset)\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    return sharesVault._getTotalAmountForVault(_asset)\n",
            "sha256sum": "f26a63ce819703b818277c05780af88d274be09f820ff70d54695b15a9252d03"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/RebaseErc20.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "9d10f21d1ba76f475cd71fa6a6134d7528b770e75dc1ee31de3db770874ebe09"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/vaults/RebaseErc20.vy"
    },
    "StabilityPool": {
      "address": "0x73404773A912D2b76A0603295aa5fA4fD22637d0",
      "abi": [
        {
          "name": "StabilityPoolDeposit",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabilityPoolWithdrawal",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabilityPoolTransfer",
          "inputs": [
            {
              "name": "fromUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "toUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "transferAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isFromUserDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "transferShares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetClaimedInStabilityPool",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "stabAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "claimAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "claimAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimUsdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "claimShares",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInVaultAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesUserHaveBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterUserAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesVaultHaveAnyFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumVaultAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfUserAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "valueToShares",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_usdValue",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sharesToValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapForLiquidatedCollateral",
          "inputs": [
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_stabAssetAmount",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            },
            {
              "name": "_liqAmountSent",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_greenToken",
              "type": "address"
            },
            {
              "name": "_savingsGreenToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapWithClaimableGreen",
          "inputs": [
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            },
            {
              "name": "_liqAmountSent",
              "type": "uint256"
            },
            {
              "name": "_greenToken",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalValue",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalUserValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimFromStabilityPool",
          "inputs": [
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_maxUsdValue",
              "type": "uint256"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimFromStabilityPool",
          "inputs": [
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_maxUsdValue",
              "type": "uint256"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimManyFromStabilityPool",
          "inputs": [
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_claims",
              "type": "tuple[]",
              "components": [
                {
                  "name": "stabAsset",
                  "type": "address"
                },
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxUsdValue",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimManyFromStabilityPool",
          "inputs": [
            {
              "name": "_claimer",
              "type": "address"
            },
            {
              "name": "_claims",
              "type": "tuple[]",
              "components": [
                {
                  "name": "stabAsset",
                  "type": "address"
                },
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxUsdValue",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "claimableBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalClaimableBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "claimableAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfClaimableAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numClaimableAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultDataOnDeposit",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasPosition",
                  "type": "bool"
                },
                {
                  "name": "numAssets",
                  "type": "uint256"
                },
                {
                  "name": "userBalance",
                  "type": "uint256"
                },
                {
                  "name": "totalBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserLootBoxShare",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAndAmountAtIndex",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAtIndexAndHasBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/vaults/modules/VaultData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent VaultPauseModified:\n    isPaused: bool\n\nevent VaultFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# balances (may be shares or actual balance)\nuserBalances: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> balance\ntotalBalances: public(HashMap[address, uint256]) # asset -> balance\n\n# user assets (iterable)\nuserAssets: public(HashMap[address, HashMap[uint256, address]]) # user -> index -> asset\nindexOfUserAsset: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> index\nnumUserAssets: public(HashMap[address, uint256]) # user -> num assets\n\n# vault assets (iterable)\nvaultAssets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###################\n# Balance Changes #\n###################\n\n\n# deposit\n\n\n@internal\ndef _addBalanceOnDeposit(\n    _user: address,\n    _asset: address,\n    _depositBal: uint256,\n    _shouldUpdateTotal: bool,\n):\n    # update balances\n    self.userBalances[_user][_asset] += _depositBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] += _depositBal\n\n    # register user asset (if necessary)\n    if self.indexOfUserAsset[_user][_asset] == 0:\n        self._registerUserAsset(_user, _asset)\n\n    # register vault asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerVaultAsset(_asset)\n\n\n# withdrawal\n\n\n@internal\ndef _reduceBalanceOnWithdrawal(\n    _user: address,\n    _asset: address,\n    _withdrawBal: uint256,\n    _shouldUpdateTotal: bool,\n) -> (uint256, bool):\n    assert self.indexOfUserAsset[_user][_asset] != 0 # dev: user does not have this asset\n\n    currentBal: uint256 = self.userBalances[_user][_asset]\n    withdrawBal: uint256 = min(_withdrawBal, currentBal)\n    assert withdrawBal != 0 # dev: nothing to withdraw\n\n    # update balances\n    currentBal -= withdrawBal\n    self.userBalances[_user][_asset] = currentBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] -= withdrawBal\n\n    return withdrawBal, currentBal == 0\n\n\n###############\n# User Assets #\n###############\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    return self.indexOfUserAsset[_user][_asset] != 0\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    return self.userBalances[_user][_asset] != 0\n\n\n@internal\ndef _registerUserAsset(_user: address, _asset: address):\n    aid: uint256 = self.numUserAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.userAssets[_user][aid] = _asset\n    self.indexOfUserAsset[_user][_asset] = aid\n    self.numUserAssets[_user] = aid + 1\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n\n    if self.userBalances[_user][_asset] != 0:\n        return True\n\n    numUserAssets: uint256 = self.numUserAssets[_user]\n    if numUserAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfUserAsset[_user][_asset]\n    if targetIndex == 0:\n        return numUserAssets > 1\n\n    # update data\n    lastIndex: uint256 = numUserAssets - 1\n    self.numUserAssets[_user] = lastIndex\n    self.indexOfUserAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.userAssets[_user][lastIndex]\n        self.userAssets[_user][targetIndex] = lastItem\n        self.indexOfUserAsset[_user][lastItem] = targetIndex\n\n    return lastIndex > 1\n\n\n################\n# Vault Assets #\n################\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@internal\ndef _registerVaultAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.vaultAssets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if self.totalBalances[_asset] != 0:\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.vaultAssets[lastIndex]\n        self.vaultAssets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n##############\n# Data Utils #\n##############\n\n\n# any vault funds\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.vaultAssets[i]\n        if self.totalBalances[asset] != 0:\n            return True\n    return False\n\n\n# num user assets\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    return self._getNumUserAssets(_user)\n\n\n@view\n@internal\ndef _getNumUserAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numUserAssets[_user]\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n# num vault assets\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    return self._getNumVaultAssets()\n\n\n@view\n@internal\ndef _getNumVaultAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log VaultPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    # cannot recover funds from a registered asset with a balance\n    assert self.indexOfAsset[_asset] == 0 and self.totalBalances[_asset] == 0 # dev: invalid recovery\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log VaultFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "a40dbc674354ec85dd7c1ad8573db4995a56c7a58284b9e3357ba5145fc34de5"
          },
          "contracts/vaults/modules/StabVault.vy": {
            "content": "# @version 0.4.1\n\nuses: vaultData\nuses: addys\n\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.modules.Addys as addys\n\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\ninterface MissionControl:\n    def getStabPoolClaimsConfig(_claimAsset: address, _claimer: address, _caller: address) -> StabPoolClaimsConfig: view\n    def getTellerDepositConfig(_vaultId: uint256, _asset: address, _user: address) -> TellerDepositConfig: view\n    def getStabPoolRedemptionsConfig(_asset: address, _recipient: address) -> StabPoolRedemptionsConfig: view\n    def getFirstVaultIdForAsset(_asset: address) -> uint256: view\n\ninterface Teller:\n    def depositFromTrusted(_user: address, _vaultId: uint256, _asset: address, _amount: uint256, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def isUnderscoreWalletOwner(_user: address, _caller: address, _mc: address = empty(address)) -> bool: view\n\ninterface PriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface VaultBook:\n    def mintRipeForStabPoolClaims(_amount: uint256, _ripeToken: address, _ledger: address) -> bool: nonpayable\n\ninterface GreenToken:\n    def burn(_amount: uint256) -> bool: nonpayable\n\ninterface Ledger:\n    def ripeAvailForRewards() -> uint256: view\n\nstruct StabPoolClaim:\n    stabAsset: address\n    claimAsset: address\n    maxUsdValue: uint256\n\nstruct StabPoolRedemption:\n    claimAsset: address\n    maxGreenAmount: uint256\n\nstruct StabPoolClaimsConfig:\n    canClaimInStabPoolGeneral: bool\n    canClaimInStabPoolAsset: bool\n    canClaimFromStabPoolForUser: bool\n    isUserAllowed: bool\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct StabPoolRedemptionsConfig:\n    canRedeemInStabPoolGeneral: bool\n    canRedeemInStabPoolAsset: bool\n    isUserAllowed: bool\n    canAnyoneDeposit: bool\n\nstruct TellerDepositConfig:\n    canDepositGeneral: bool\n    canDepositAsset: bool\n    doesVaultSupportAsset: bool\n    isUserAllowed: bool\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    perUserMaxAssetsPerVault: uint256\n    perUserMaxVaults: uint256\n    canAnyoneDeposit: bool\n\nevent AssetClaimedInStabilityPool:\n    user: indexed(address)\n    stabAsset: indexed(address)\n    claimAsset: indexed(address)\n    claimAmount: uint256\n    claimUsdValue: uint256\n    claimShares: uint256\n    isDepleted: bool\n\n# claimable balances\nclaimableBalances: public(HashMap[address, HashMap[address, uint256]]) # stab asset -> claimable asset -> balance\ntotalClaimableBalances: public(HashMap[address, uint256]) # claimable asset -> balance\n\n# claimable assets (iterable)\nclaimableAssets: public(HashMap[address, HashMap[uint256, address]]) # stab asset -> index -> claimable asset\nindexOfClaimableAsset: public(HashMap[address, HashMap[address, uint256]]) # stab asset -> claimable asset -> index\nnumClaimableAssets: public(HashMap[address, uint256]) # stab asset -> num claimable assets\n\nMAX_STAB_CLAIMS: constant(uint256) = 15\nMAX_STAB_REDEMPTIONS: constant(uint256) = 15\nDECIMAL_OFFSET: constant(uint256) = 10 ** 8\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nRIPE_GOV_VAULT_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__():\n    pass\n\n\n########\n# Core #\n########\n\n\n@internal\ndef _depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset] # dev: invalid user or asset\n    totalAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    depositAmount: uint256 = min(_amount, totalAssetBalance)\n    assert depositAmount != 0 # dev: invalid deposit amount\n\n    # calc usd values\n    totalStabValue: uint256 = self._getUsdValue(_asset, totalAssetBalance, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n    assert totalStabValue != 0 # dev: no price for stab asset\n\n    newUserValue: uint256 = totalStabValue\n    prevStabValue: uint256 = 0\n    if depositAmount != totalAssetBalance:\n        newUserValue = depositAmount * totalStabValue // totalAssetBalance\n        prevStabValue = (totalAssetBalance - depositAmount) * totalStabValue // totalAssetBalance # remove the deposited amount to calc shares accurately\n\n    # calc shares\n    claimableValue: uint256 = self._getValueOfClaimableAssets(_asset, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n    newShares: uint256 = self._valueToShares(newUserValue, vaultData.totalBalances[_asset], prevStabValue + claimableValue, False)\n\n    # add balance on deposit\n    vaultData._addBalanceOnDeposit(_user, _asset, newShares, True)\n\n    return depositAmount, newShares\n\n\n@internal\ndef _withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_user, _asset, _recipient] # dev: invalid user, asset, or recipient\n\n    # calc shares + amount to withdraw\n    withdrawalShares: uint256 = 0\n    withdrawalAmount: uint256 = 0\n    withdrawalShares, withdrawalAmount = self._calcWithdrawalSharesAndAmount(_user, _asset, _amount, _a)\n\n    # reduce balance on withdrawal\n    isDepleted: bool = False\n    withdrawalShares, isDepleted = vaultData._reduceBalanceOnWithdrawal(_user, _asset, withdrawalShares, True)\n\n    assert extcall IERC20(_asset).transfer(_recipient, withdrawalAmount, default_return_value=True) # dev: token transfer failed\n    return withdrawalAmount, withdrawalShares, isDepleted\n\n\n@internal\ndef _transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_fromUser, _toUser, _asset] # dev: invalid users or asset\n\n    # calc shares + amount to transfer\n    transferShares: uint256 = 0\n    transferAmount: uint256 = 0\n    transferShares, transferAmount = self._calcWithdrawalSharesAndAmount(_fromUser, _asset, _transferAmount, _a)\n\n    # transfer shares\n    isFromUserDepleted: bool = False\n    transferShares, isFromUserDepleted = vaultData._reduceBalanceOnWithdrawal(_fromUser, _asset, transferShares, False)\n    vaultData._addBalanceOnDeposit(_toUser, _asset, transferShares, False)\n\n    return transferAmount, transferShares, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@internal\ndef _getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    totalAmount: uint256 = self._getTotalAmountForVault(_asset)\n    return Vault.VaultDataOnDeposit(\n        hasPosition=vaultData.indexOfUserAsset[_user][_asset] != 0,\n        numAssets=vaultData._getNumUserAssets(_user),\n        userBalance=self._getTotalAmountForUserWithTotalBal(_user, _asset, totalAmount),\n        totalBalance=totalAmount,\n    )\n\n\n@view\n@internal\ndef _getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return vaultData.userBalances[_user][_asset] // DECIMAL_OFFSET\n\n\n@view\n@internal\ndef _getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    # NOTE: cannot borrow against stability pool positions, returning empty/0 to ensure this\n    return empty(address), 0\n\n\n@view\n@internal\ndef _getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), False\n    return asset, vaultData.userBalances[_user][asset] != 0\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@internal\ndef _getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    totalAmount: uint256 = self._getTotalAmountForVault(_asset)\n    return self._getTotalAmountForUserWithTotalBal(_user, _asset, totalAmount)\n\n\n@view\n@internal\ndef _getTotalAmountForUserWithTotalBal(_user: address, _asset: address, _totalAmount: uint256) -> uint256:\n    # NOTE: converting usd value to amount, even though vault may not actually have this asset balance!!\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    if totalShares == 0:\n        return 0\n    return vaultData.userBalances[_user][_asset] * _totalAmount // totalShares\n\n\n@view\n@internal\ndef _getTotalAmountForVault(_asset: address) -> uint256:\n    # NOTE: converting usd value to amount, even though vault may not actually have this asset balance!!\n\n    # addys\n    greenToken: address = addys._getGreenToken()\n    savingsGreen: address = addys._getSavingsGreen()\n    priceDesk: address = addys._getPriceDeskAddr()\n\n    # get total value of asset\n    stabAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    totalStabValue: uint256 = self._getUsdValue(_asset, stabAssetBalance, greenToken, savingsGreen, priceDesk)\n    claimableValue: uint256 = self._getValueOfClaimableAssets(_asset, greenToken, savingsGreen, priceDesk)\n\n    # return amount if there is claimable value\n    if claimableValue != 0:\n        return self._getAssetAmount(_asset, totalStabValue + claimableValue, greenToken, savingsGreen, priceDesk)\n\n    return stabAssetBalance\n\n\n@view\n@internal\ndef _getAssetAmount(\n    _asset: address,\n    _targetUsdValue: uint256,\n    _greenToken: address,\n    _savingsGreen: address,\n    _priceDesk: address,\n) -> uint256:\n    amount: uint256 = 0\n    if _asset == _greenToken:\n        amount = _targetUsdValue\n    elif _asset == _savingsGreen:\n        amount = staticcall IERC4626(_savingsGreen).convertToShares(_targetUsdValue)\n    else:\n        amount = staticcall PriceDesk(_priceDesk).getAssetAmount(_asset, _targetUsdValue, True)\n    return amount\n\n\n@view\n@internal\ndef _getUsdValue(\n    _asset: address,\n    _amount: uint256,\n    _greenToken: address,\n    _savingsGreen: address,\n    _priceDesk: address,\n) -> uint256:\n    usdValue: uint256 = 0\n    if _asset == _greenToken:\n        usdValue = _amount\n    elif _asset == _savingsGreen:\n        usdValue = staticcall IERC4626(_savingsGreen).convertToAssets(_amount)\n    else:\n        usdValue = staticcall PriceDesk(_priceDesk).getUsdValue(_asset, _amount, True)\n    return usdValue\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@internal\ndef _calcWithdrawalSharesAndAmount(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    totalStabAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert totalStabAssetBalance != 0 # dev: no stab asset to withdraw\n\n    # user shares\n    withdrawalShares: uint256 = vaultData.userBalances[_user][_asset]\n    assert withdrawalShares != 0 # dev: user has no shares\n\n    # calc usd values\n    totalStabValue: uint256 = self._getUsdValue(_asset, totalStabAssetBalance, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n    assert totalStabValue != 0 # dev: no price for stab asset\n    claimableValue: uint256 = self._getValueOfClaimableAssets(_asset, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n    totalValue: uint256 = totalStabValue + claimableValue\n\n    # max withdraw usd value\n    maxWithdrawUsdValue: uint256 = self._sharesToValue(withdrawalShares, totalShares, totalValue, False)\n    maxWithdrawStabAmount: uint256 = maxWithdrawUsdValue * totalStabAssetBalance // totalStabValue\n    assert maxWithdrawStabAmount != 0 # dev: max withdraw stab amount is 0\n\n    # max amount available to withdraw\n    if _amount >= maxWithdrawStabAmount and maxWithdrawStabAmount <= totalStabAssetBalance:\n        return withdrawalShares, maxWithdrawStabAmount\n\n    # finalize withdrawal amount / shares\n    maxAvailStabAmount: uint256 = min(maxWithdrawStabAmount, totalStabAssetBalance)\n    withdrawalAmount: uint256 = min(_amount, maxAvailStabAmount)\n    assert withdrawalAmount != 0 # dev: no withdrawal amount\n\n    withdrawalUsdValue: uint256 = withdrawalAmount * totalStabValue // totalStabAssetBalance\n    withdrawalShares = min(withdrawalShares, self._valueToShares(withdrawalUsdValue, totalShares, totalValue, True))\n    return withdrawalShares, withdrawalAmount\n\n\n# usd value -> shares\n\n\n@view\n@external\ndef valueToShares(_asset: address, _usdValue: uint256, _shouldRoundUp: bool) -> uint256:\n    greenToken: address = addys._getGreenToken()\n    savingsGreen: address = addys._getSavingsGreen()\n    priceDesk: address = addys._getPriceDeskAddr()\n    totalValue: uint256 = self._getTotalValue(_asset, greenToken, savingsGreen, priceDesk)\n    return self._valueToShares(_usdValue, vaultData.totalBalances[_asset], totalValue, _shouldRoundUp)\n\n\n@view\n@internal\ndef _valueToShares(\n    _usdValue: uint256,\n    _totalShares: uint256,\n    _totalUsdValue: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalUsdValue: uint256 = _totalUsdValue\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalUsdValue += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc shares\n    numerator: uint256 = _usdValue * totalShares\n    shares: uint256 = numerator // totalUsdValue\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalUsdValue != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> usd value\n\n\n@view\n@external\ndef sharesToValue(_asset: address, _shares: uint256, _shouldRoundUp: bool) -> uint256:\n    greenToken: address = addys._getGreenToken()\n    savingsGreen: address = addys._getSavingsGreen()\n    priceDesk: address = addys._getPriceDeskAddr()\n    totalValue: uint256 = self._getTotalValue(_asset, greenToken, savingsGreen, priceDesk)\n    return self._sharesToValue(_shares, vaultData.totalBalances[_asset], totalValue, _shouldRoundUp)\n\n\n@view\n@internal\ndef _sharesToValue(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalUsdValue: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalUsdValue: uint256 = _totalUsdValue\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalUsdValue += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc usd value\n    numerator: uint256 = _shares * totalUsdValue\n    usdValue: uint256 = numerator // totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalShares != 0):\n        usdValue += 1\n\n    return usdValue\n\n\n##################\n# Stability Pool #\n##################\n\n\n@external\ndef swapForLiquidatedCollateral(\n    _stabAsset: address,\n    _stabAssetAmount: uint256,\n    _liqAsset: address,\n    _liqAmountSent: uint256,\n    _recipient: address,\n    _greenToken: address,\n    _savingsGreenToken: address,\n) -> uint256:\n    assert not vaultData.isPaused # dev: contract paused\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n\n    assert vaultData.indexOfAsset[_stabAsset] != 0 # dev: stab asset not supported\n    assert vaultData.indexOfAsset[_liqAsset] == 0 # dev: liq asset cannot be vault asset\n    assert _liqAsset != empty(address) # dev: invalid liq asset\n\n    # add claimable balance\n    self._addClaimableBalance(_stabAsset, _liqAsset, _liqAmountSent)\n\n    # finalize amount\n    amount: uint256 = min(_stabAssetAmount, staticcall IERC20(_stabAsset).balanceOf(self))\n    assert amount != 0 # dev: nothing to transfer\n\n    # burn green token\n    if _recipient == empty(address):\n        assert _stabAsset in [_greenToken, _savingsGreenToken] # dev: must be green or savings green\n        if _stabAsset == _savingsGreenToken:\n            greenAmount: uint256 = extcall IERC4626(_savingsGreenToken).redeem(amount, self, self) # dev: savings green redeem failed\n            assert extcall GreenToken(_greenToken).burn(greenAmount) # dev: failed to burn green\n        else:\n            assert extcall GreenToken(_greenToken).burn(amount) # dev: failed to burn green\n\n    else:\n        assert extcall IERC20(_stabAsset).transfer(_recipient, amount, default_return_value=True) # dev: transfer failed\n\n    return amount\n\n\n@external\ndef swapWithClaimableGreen(\n    _stabAsset: address,\n    _greenAmount: uint256,\n    _liqAsset: address,\n    _liqAmountSent: uint256,\n    _greenToken: address,\n) -> uint256:\n    assert not vaultData.isPaused # dev: contract paused\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only AuctionHouse allowed\n\n    assert vaultData.indexOfAsset[_stabAsset] != 0 # dev: stab asset not supported\n    assert vaultData.indexOfAsset[_liqAsset] == 0 # dev: liq asset cannot be vault asset\n    assert _liqAsset != empty(address) # dev: invalid liq asset\n\n    # add claimable balance\n    self._addClaimableBalance(_stabAsset, _liqAsset, _liqAmountSent)\n\n    # finalize amount\n    maxClaimableGreen: uint256 = self.claimableBalances[_stabAsset][_greenToken]\n    greenAvailable: uint256 = min(maxClaimableGreen, staticcall IERC20(_greenToken).balanceOf(self))\n    amount: uint256 = min(_greenAmount, greenAvailable)\n    assert amount != 0 # dev: no green\n\n    # reduce green from claimable, and burn\n    self._reduceClaimableBalances(_stabAsset, _greenToken, amount, maxClaimableGreen)\n    assert extcall GreenToken(_greenToken).burn(amount) # dev: burn failed\n\n    return amount\n\n\n# utilities\n\n\n@view\n@external\ndef getTotalValue(_asset: address) -> uint256:\n    greenToken: address = addys._getGreenToken()\n    savingsGreen: address = addys._getSavingsGreen()\n    priceDesk: address = addys._getPriceDeskAddr()\n    return self._getTotalValue(_asset, greenToken, savingsGreen, priceDesk)\n\n\n@view\n@external\ndef getTotalUserValue(_user: address, _asset: address) -> uint256:\n    greenToken: address = addys._getGreenToken()\n    savingsGreen: address = addys._getSavingsGreen()\n    priceDesk: address = addys._getPriceDeskAddr()\n    totalValue: uint256 = self._getTotalValue(_asset, greenToken, savingsGreen, priceDesk)\n    return self._sharesToValue(vaultData.userBalances[_user][_asset], vaultData.totalBalances[_asset], totalValue, False)\n\n\n@view\n@internal\ndef _getTotalValue(\n    _asset: address,\n    _greenToken: address,\n    _savingsGreen: address,\n    _priceDesk: address,\n) -> uint256:\n    totalStabValue: uint256 = 0\n    stabAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    if stabAssetBalance != 0:\n        totalStabValue = self._getUsdValue(_asset, stabAssetBalance, _greenToken, _savingsGreen, _priceDesk)\n    claimableValue: uint256 = self._getValueOfClaimableAssets(_asset, _greenToken, _savingsGreen, _priceDesk)\n    return totalStabValue + claimableValue\n\n\n@view\n@internal\ndef _getValueOfClaimableAssets(\n    _stabAsset: address,\n    _greenToken: address,\n    _savingsGreen: address,\n    _priceDesk: address,\n) -> uint256:\n    totalValue: uint256 = 0\n    numClaimableAssets: uint256 = self.numClaimableAssets[_stabAsset]\n    if numClaimableAssets == 0:\n        return 0\n\n    for i: uint256 in range(1, numClaimableAssets, bound=max_value(uint256)):\n        asset: address = self.claimableAssets[_stabAsset][i]\n        if asset == empty(address):\n            continue\n        balance: uint256 = self.claimableBalances[_stabAsset][asset]\n        if balance == 0:\n            continue\n\n        claimValue: uint256 = self._getUsdValue(asset, balance, _greenToken, _savingsGreen, _priceDesk)\n        assert claimValue != 0 # dev: claimable asset has no value\n        totalValue += claimValue\n\n    return totalValue\n\n\n############################\n# Claims (already in pool) #\n############################\n\n\n@external\ndef claimFromStabilityPool(\n    _claimer: address,\n    _stabAsset: address,\n    _claimAsset: address,\n    _maxUsdValue: uint256,\n    _caller: address,\n    _shouldAutoDeposit: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not vaultData.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    config: StabPoolClaimsConfig = staticcall MissionControl(a.missionControl).getStabPoolClaimsConfig(_claimAsset, _claimer, _caller)\n    claimUsdValue: uint256 = self._claimFromStabilityPool(_claimer, _stabAsset, _claimAsset, _maxUsdValue, _caller, _shouldAutoDeposit, config, a)\n    assert claimUsdValue != 0 # dev: nothing claimed\n    self._handleClaimRewards(_claimer, claimUsdValue, config.rewardsLockDuration, config.ripePerDollarClaimed, a)\n    return claimUsdValue\n\n\n@external\ndef claimManyFromStabilityPool(\n    _claimer: address,\n    _claims: DynArray[StabPoolClaim, MAX_STAB_CLAIMS],\n    _caller: address,\n    _shouldAutoDeposit: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not vaultData.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    config: StabPoolClaimsConfig = empty(StabPoolClaimsConfig)\n\n    totalUsdValue: uint256 = 0\n    for c: StabPoolClaim in _claims:\n        config = staticcall MissionControl(a.missionControl).getStabPoolClaimsConfig(c.claimAsset, _claimer, _caller)\n        totalUsdValue += self._claimFromStabilityPool(_claimer, c.stabAsset, c.claimAsset, c.maxUsdValue, _caller, _shouldAutoDeposit, config, a)\n    assert totalUsdValue != 0 # dev: nothing claimed\n    self._handleClaimRewards(_claimer, totalUsdValue, config.rewardsLockDuration, config.ripePerDollarClaimed, a)\n    return totalUsdValue\n\n\n@internal\ndef _claimFromStabilityPool(\n    _claimer: address,\n    _stabAsset: address,\n    _claimAsset: address,\n    _maxUsdValue: uint256,\n    _caller: address,\n    _shouldAutoDeposit: bool,\n    _config: StabPoolClaimsConfig,\n    _a: addys.Addys,\n) -> uint256:\n    if empty(address) in [_claimer, _stabAsset, _claimAsset] or _maxUsdValue == 0:\n        return 0\n\n    # check claims config\n    if not _config.canClaimInStabPoolGeneral or not _config.canClaimInStabPoolAsset or not _config.isUserAllowed:\n        return 0\n\n    # can others claim for user\n    if _claimer != _caller and not _config.canClaimFromStabPoolForUser:\n        assert staticcall Teller(_a.teller).isUnderscoreWalletOwner(_claimer, _caller, _a.missionControl) # dev: cannot claim for user\n\n    # max claimable asset\n    maxClaimableAsset: uint256 = self.claimableBalances[_stabAsset][_claimAsset]\n    if maxClaimableAsset == 0:\n        return 0\n\n    # calc shares + amount to withdraw\n    claimShares: uint256 = 0\n    claimAmount: uint256 = 0\n    claimUsdValue: uint256 = 0\n    claimShares, claimAmount, claimUsdValue = self._calcClaimSharesAndAmount(_claimer, _stabAsset, _claimAsset, _maxUsdValue, maxClaimableAsset, _a)\n    if claimShares == 0:\n        return 0\n\n    # reduce balance on withdrawal\n    isDepleted: bool = False\n    claimShares, isDepleted = vaultData._reduceBalanceOnWithdrawal(_claimer, _stabAsset, claimShares, True)\n\n    # reduce claimable balances\n    self._reduceClaimableBalances(_stabAsset, _claimAsset, claimAmount, maxClaimableAsset)\n\n    # move tokens to recipient\n    self._handleAssetForUser(_claimAsset, claimAmount, _claimer, _shouldAutoDeposit, _a)\n\n    log AssetClaimedInStabilityPool(user=_claimer, stabAsset=_stabAsset, claimAsset=_claimAsset, claimAmount=claimAmount, claimUsdValue=claimUsdValue, claimShares=claimShares, isDepleted=isDepleted)\n    return claimUsdValue\n\n\n@view\n@internal\ndef _calcClaimSharesAndAmount(\n    _claimer: address,\n    _stabAsset: address,\n    _claimAsset: address,\n    _maxUsdValue: uint256,\n    _maxClaimableAsset: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, uint256):\n\n    # NOTE: failing gracefully here, in case of many claims at same time\n\n    # total claimable asset\n    totalClaimAsset: uint256 = min(_maxClaimableAsset, staticcall IERC20(_claimAsset).balanceOf(self))\n    if totalClaimAsset == 0:\n        return 0, 0, 0 # no claimable asset\n\n    # user shares\n    maxUserShares: uint256 = vaultData.userBalances[_claimer][_stabAsset]\n    if maxUserShares == 0:\n        return 0, 0, 0 # no user shares\n\n    # totals\n    totalShares: uint256 = vaultData.totalBalances[_stabAsset]\n    totalValue: uint256 = self._getTotalValue(_stabAsset, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n\n    # max claim values for user\n    maxClaimUsdValue: uint256 = self._sharesToValue(maxUserShares, totalShares, totalValue, False)\n    maxClaimAmount: uint256 = self._getAssetAmount(_claimAsset, maxClaimUsdValue, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n    if maxClaimAmount == 0:\n        return 0, 0, 0 # not getting price for claim asset\n\n    # max amount available to withdraw\n    if _maxUsdValue >= maxClaimUsdValue and maxClaimAmount <= totalClaimAsset:\n        return maxUserShares, maxClaimAmount, maxClaimUsdValue\n\n    # finalize withdrawal amount / shares\n    claimAmount: uint256 = min(maxClaimAmount, totalClaimAsset)\n    if _maxUsdValue != max_value(uint256):\n        claimAmount = min(claimAmount, _maxUsdValue * maxClaimAmount // maxClaimUsdValue)\n\n    # finalize values\n    claimUsdValue: uint256 = claimAmount * maxClaimUsdValue // maxClaimAmount\n    claimShares: uint256 = min(maxUserShares, self._valueToShares(claimUsdValue, totalShares, totalValue, True))\n    return claimShares, claimAmount, claimUsdValue\n\n\n@internal\ndef _handleClaimRewards(\n    _claimer: address,\n    _claimUsdValue: uint256,\n    _lockDuration: uint256,\n    _ripePerDollarClaimed: uint256,\n    _a: addys.Addys,\n):\n    if _ripePerDollarClaimed == 0:\n        return\n\n    ripeClaimRewards: uint256 = _claimUsdValue * _ripePerDollarClaimed // EIGHTEEN_DECIMALS\n    ripeAvailable: uint256 = min(ripeClaimRewards, staticcall Ledger(_a.ledger).ripeAvailForRewards())\n    if ripeAvailable == 0:\n        return\n\n    # mint ripe\n    assert extcall VaultBook(_a.vaultBook).mintRipeForStabPoolClaims(ripeAvailable, _a.ripeToken, _a.ledger) # dev: mint failed\n\n    # deposit into gov vault\n    assert extcall IERC20(_a.ripeToken).approve(_a.teller, ripeAvailable, default_return_value=True) # dev: ripe approval failed\n    extcall Teller(_a.teller).depositFromTrusted(_claimer, RIPE_GOV_VAULT_ID, _a.ripeToken, ripeAvailable, _lockDuration, _a)\n    assert extcall IERC20(_a.ripeToken).approve(_a.teller, 0, default_return_value=True) # dev: ripe approval failed\n\n\n###############\n# Redemptions #\n###############\n\n\n@external\ndef redeemFromStabilityPool(\n    _asset: address,\n    _greenAmount: uint256,\n    _recipient: address,\n    _caller: address,\n    _shouldAutoDeposit: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not vaultData.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    assert self._canRedeemInThisVault(a.greenToken) # dev: redemptions not allowed\n\n    greenAmount: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert greenAmount != 0 # dev: no green to redeem\n    greenSpent: uint256 = self._redeemFromStabilityPool(_recipient, _caller, _asset, max_value(uint256), greenAmount, _shouldAutoDeposit, a)\n    assert greenSpent != 0 # dev: no redemptions occurred\n\n    # handle leftover green\n    if greenAmount > greenSpent:\n        self._handleGreenForUser(_caller, greenAmount - greenSpent, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return greenSpent\n\n\n@external\ndef redeemManyFromStabilityPool(\n    _redemptions: DynArray[StabPoolRedemption, MAX_STAB_REDEMPTIONS],\n    _greenAmount: uint256,\n    _recipient: address,\n    _caller: address,\n    _shouldAutoDeposit: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not vaultData.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    assert self._canRedeemInThisVault(a.greenToken) # dev: redemptions not allowed\n\n    totalGreenSpent: uint256 = 0\n    totalGreenRemaining: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert totalGreenRemaining != 0 # dev: no green to redeem\n\n    for r: StabPoolRedemption in _redemptions:\n        if totalGreenRemaining == 0:\n            break\n        greenSpent: uint256 = self._redeemFromStabilityPool(_recipient, _caller, r.claimAsset, r.maxGreenAmount, totalGreenRemaining, _shouldAutoDeposit, a)\n        totalGreenRemaining -= greenSpent\n        totalGreenSpent += greenSpent\n\n    assert totalGreenSpent != 0 # dev: no redemptions occurred\n\n    # handle leftover green\n    if totalGreenRemaining != 0:\n        self._handleGreenForUser(_caller, totalGreenRemaining, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return totalGreenSpent\n\n\n@view\n@internal\ndef _canRedeemInThisVault(_greenToken: address) -> bool:\n    # if green is a stab asset, then it must be the ONLY asset in the vault\n    if vaultData.indexOfAsset[_greenToken] != 0:\n        return vaultData._getNumVaultAssets() == 1\n    return True\n\n\n@internal\ndef _redeemFromStabilityPool(\n    _recipient: address,\n    _caller: address,\n    _asset: address,\n    _maxGreenForAsset: uint256,\n    _totalGreenRemaining: uint256,\n    _shouldAutoDeposit: bool,\n    _a: addys.Addys,\n) -> uint256:\n\n    # NOTE: failing gracefully here, in case of many redemptions at same time\n\n    # invalid inputs\n    if empty(address) in [_recipient, _asset] or 0 in [_maxGreenForAsset, _totalGreenRemaining]:\n        return 0\n\n    # cannot redeem green token - don't be silly\n    if _asset == _a.greenToken:\n        return 0\n\n    # check redemption config\n    config: StabPoolRedemptionsConfig = staticcall MissionControl(_a.missionControl).getStabPoolRedemptionsConfig(_asset, _recipient)\n    if not config.canRedeemInStabPoolGeneral or not config.canRedeemInStabPoolAsset or not config.isUserAllowed:\n        return 0\n\n    # make sure caller can deposit to recipient\n    if _recipient != _caller and not config.canAnyoneDeposit:\n        assert staticcall Teller(_a.teller).isUnderscoreWalletOwner(_recipient, _caller, _a.missionControl) # dev: not allowed to deposit for user\n\n    # treating green as $1\n    maxGreenAvailable: uint256 = min(_totalGreenRemaining, staticcall IERC20(_a.greenToken).balanceOf(self))\n    maxRedeemValue: uint256 = min(_maxGreenForAsset, maxGreenAvailable)\n    if maxRedeemValue == 0:\n        return 0\n\n    # max claimable amount\n    maxClaimableAmount: uint256 = self._getAssetAmount(_asset, maxRedeemValue, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n    if maxClaimableAmount == 0:\n        return 0\n\n    # total claimable asset\n    actualClaimableAmount: uint256 = min(self.totalClaimableBalances[_asset], staticcall IERC20(_asset).balanceOf(self))\n    if actualClaimableAmount == 0:\n        return 0\n\n    # finalize amounts\n    remainingRedeemValue: uint256 = maxRedeemValue\n    remainingClaimAmount: uint256 = maxClaimableAmount\n    if maxClaimableAmount > actualClaimableAmount:\n        remainingRedeemValue = min(actualClaimableAmount * maxRedeemValue // maxClaimableAmount, maxRedeemValue)\n        remainingClaimAmount = actualClaimableAmount\n\n    greenSpent: uint256 = 0\n    numStabAssets: uint256 = vaultData.numAssets\n    if numStabAssets == 0:\n        return 0\n\n    # iterate thru stab assets\n    for i: uint256 in range(1, numStabAssets, bound=max_value(uint256)):\n        if remainingClaimAmount == 0 or remainingRedeemValue == 0:\n            break\n\n        stabAsset: address = vaultData.vaultAssets[i]\n        if stabAsset == empty(address):\n            continue\n\n        # claimable balance\n        claimableBalance: uint256 = self.claimableBalances[stabAsset][_asset]\n        if claimableBalance == 0:\n            continue\n\n        # reduce claimable balances\n        claimAmount: uint256 = min(remainingClaimAmount, claimableBalance)\n        self._reduceClaimableBalances(stabAsset, _asset, claimAmount, claimableBalance)\n        self._handleAssetForUser(_asset, claimAmount, _recipient, _shouldAutoDeposit, _a)\n        remainingClaimAmount -= claimAmount\n\n        # finalize redeem amount\n        redeemAmount: uint256 = min(claimAmount * maxRedeemValue // maxClaimableAmount, remainingRedeemValue)\n\n        # if stab asset is sGREEN, just convert directly, no need to make green claimable in this case\n        if stabAsset == _a.savingsGreen:\n            assert extcall IERC20(_a.greenToken).approve(_a.savingsGreen, redeemAmount, default_return_value=True) # dev: green approval failed\n            extcall IERC4626(_a.savingsGreen).deposit(redeemAmount, self)\n            assert extcall IERC20(_a.greenToken).approve(_a.savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n        # add green to claimable (i.e. GREEN LP)\n        else:\n            self._addClaimableBalance(stabAsset, _a.greenToken, redeemAmount)\n\n        remainingRedeemValue -= redeemAmount\n        greenSpent += redeemAmount\n\n    return greenSpent\n\n\n##################\n# Green Handling #\n##################\n\n\n@internal\ndef _handleGreenForUser(\n    _recipient: address,\n    _greenAmount: uint256,\n    _wantsSavingsGreen: bool,\n    _greenToken: address,\n    _savingsGreen: address,\n):\n    amount: uint256 = min(_greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n    if amount == 0:\n        return\n\n    if _wantsSavingsGreen and amount > 10 ** 9: # small dust will fail\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, amount, default_return_value=True) # dev: green approval failed\n        extcall IERC4626(_savingsGreen).deposit(amount, _recipient)\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n    else:\n        assert extcall IERC20(_greenToken).transfer(_recipient, amount, default_return_value=True) # dev: green transfer failed\n\n\n##################\n# Asset Handling #\n##################\n\n\n@internal\ndef _handleAssetForUser(\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _shouldAutoDeposit: bool,\n    _a: addys.Addys,\n):\n    vaultId: uint256 = staticcall MissionControl(_a.missionControl).getFirstVaultIdForAsset(_asset)\n\n    # auto-deposit\n    if _shouldAutoDeposit and self._canPerformAutoDeposit(vaultId, _asset, _recipient, _a.missionControl):\n        assert extcall IERC20(_asset).approve(_a.teller, _amount, default_return_value=True) # dev: token approval failed\n        extcall Teller(_a.teller).depositFromTrusted(_recipient, vaultId, _asset, _amount, 0, _a)\n        assert extcall IERC20(_asset).approve(_a.teller, 0, default_return_value=True) # dev: token approval failed\n    else:\n        assert extcall IERC20(_asset).transfer(_recipient, _amount, default_return_value=True) # dev: transfer failed\n\n\n@view\n@internal\ndef _canPerformAutoDeposit(\n    _vaultId: uint256,\n    _asset: address,\n    _recipient: address,\n    _missionControl: address,\n) -> bool:\n    # invalid vault or stability pool (can't deposit right back into it)\n    if _vaultId in [0, 1]:\n        return False\n    config: TellerDepositConfig = staticcall MissionControl(_missionControl).getTellerDepositConfig(_vaultId, _asset, _recipient)\n    return config.canDepositGeneral and config.canDepositAsset\n\n\n##################\n# Claimable Data #\n##################\n\n\n# add claimable\n\n\n@internal\ndef _addClaimableBalance(\n    _stabAsset: address,\n    _claimAsset: address,\n    _claimAmount: uint256,\n):\n    claimAmount: uint256 = min(_claimAmount, staticcall IERC20(_claimAsset).balanceOf(self))\n    assert claimAmount != 0 # dev: nothing received\n\n    # update balances\n    self.claimableBalances[_stabAsset][_claimAsset] += claimAmount\n    self.totalClaimableBalances[_claimAsset] += claimAmount\n\n    # register claimable asset if not already registered\n    if self.indexOfClaimableAsset[_stabAsset][_claimAsset] == 0:\n        self._registerClaimableAsset(_stabAsset, _claimAsset)\n\n\n# register claimable asset\n\n\n@internal\ndef _registerClaimableAsset(_stabAsset: address, _assetReceived: address):\n    cid: uint256 = self.numClaimableAssets[_stabAsset]\n    if cid == 0:\n        cid = 1 # not using 0 index\n    self.claimableAssets[_stabAsset][cid] = _assetReceived\n    self.indexOfClaimableAsset[_stabAsset][_assetReceived] = cid\n    self.numClaimableAssets[_stabAsset] = cid + 1\n\n\n# reduce claimable\n\n\n@internal\ndef _reduceClaimableBalances(\n    _stabAsset: address,\n    _claimAsset: address,\n    _claimAmount: uint256,\n    _prevClaimableBalance: uint256,\n):\n    newClaimableBalance: uint256 = _prevClaimableBalance - _claimAmount\n    self.claimableBalances[_stabAsset][_claimAsset] = newClaimableBalance\n    self.totalClaimableBalances[_claimAsset] -= _claimAmount\n\n    # remove claimable asset if depleted\n    if newClaimableBalance == 0:\n        self._removeClaimableAsset(_stabAsset, _claimAsset)\n\n\n# deregister claimable asset\n\n\n@internal\ndef _removeClaimableAsset(_stabAsset: address, _asset: address):\n    numAssets: uint256 = self.numClaimableAssets[_stabAsset]\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfClaimableAsset[_stabAsset][_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numClaimableAssets[_stabAsset] = lastIndex\n    self.indexOfClaimableAsset[_stabAsset][_asset] = 0\n\n    # shift to replace the one being removed\n    if targetIndex != lastIndex:\n        lastAsset: address = self.claimableAssets[_stabAsset][lastIndex]\n        self.claimableAssets[_stabAsset][targetIndex] = lastAsset\n        self.indexOfClaimableAsset[_stabAsset][lastAsset] = targetIndex",
            "sha256sum": "3f30b7f68732ac74bf43e1cf1ec643c3269a226c404f249bacfc368bc6fa6274"
          },
          "contracts/vaults/StabilityPool.vy": {
            "content": "# @version 0.4.1\n\nimplements: Vault\n\nexports: addys.__interface__\nexports: vaultData.__interface__\nexports: stabVault.__interface__\n\ninitializes: addys\ninitializes: vaultData[addys := addys]\ninitializes: stabVault[addys := addys, vaultData := vaultData]\n\nfrom interfaces import Vault\nimport contracts.modules.Addys as addys\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.vaults.modules.StabVault as stabVault\nfrom ethereum.ercs import IERC20\n\nevent StabilityPoolDeposit:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    shares: uint256\n\nevent StabilityPoolWithdrawal:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    isDepleted: bool\n    shares: uint256\n\nevent StabilityPoolTransfer:\n    fromUser: indexed(address)\n    toUser: indexed(address)\n    asset: indexed(address)\n    transferAmount: uint256\n    isFromUserDepleted: bool\n    transferShares: uint256\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    vaultData.__init__(False)\n    stabVault.__init__()\n\n\n########\n# Core #\n########\n\n\n@nonreentrant\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    a: addys.Addys = addys._getAddys(_a)\n\n    depositAmount: uint256 = 0\n    newShares: uint256 = 0\n    depositAmount, newShares = stabVault._depositTokensInVault(_user, _asset, _amount, a)\n    log StabilityPoolDeposit(user=_user, asset=_asset, amount=depositAmount, shares=newShares)\n    return depositAmount\n\n\n@nonreentrant\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getTellerAddr(), addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n    a: addys.Addys = addys._getAddys(_a)\n\n    withdrawalAmount: uint256 = 0\n    withdrawalShares: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, withdrawalShares, isDepleted = stabVault._withdrawTokensFromVault(_user, _asset, _amount, _recipient, a)\n    log StabilityPoolWithdrawal(user=_user, asset=_asset, amount=withdrawalAmount, isDepleted=isDepleted, shares=withdrawalShares)\n    return withdrawalAmount, isDepleted\n\n\n@nonreentrant\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n    a: addys.Addys = addys._getAddys(_a)\n\n    transferAmount: uint256 = 0\n    transferShares: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, transferShares, isFromUserDepleted = stabVault._transferBalanceWithinVault(_asset, _fromUser, _toUser, _transferAmount, a)\n    log StabilityPoolTransfer(fromUser=_fromUser, toUser=_toUser, asset=_asset, transferAmount=transferAmount, isFromUserDepleted=isFromUserDepleted, transferShares=transferShares)\n    return transferAmount, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return stabVault._getVaultDataOnDeposit(_user, _asset)\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return stabVault._getUserLootBoxShare(_user, _asset)\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    return stabVault._getUserAssetAndAmountAtIndex(_user, _index)\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    return stabVault._getUserAssetAtIndexAndHasBalance(_user, _index)\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return stabVault._getTotalAmountForUser(_user, _asset)\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    return stabVault._getTotalAmountForVault(_asset)\n",
            "sha256sum": "fe244d62443cf84c22f8c997370cb7442f0e21321665be570c2b80f8395bad20"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/StabilityPool.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "606e32edda8e15ed49ba882deb5795715a7fb33caf8bf3eebef4683afb21c72c"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/vaults/StabilityPool.vy"
    },
    "RipeGov": {
      "address": "0xcdfAcc19C48AB52F8a5fed063C35e20Ba24395F5",
      "abi": [
        {
          "name": "RipeGovVaultDeposit",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lockDuration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeGovVaultWithdrawal",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeGovVaultBurnContributorTokens",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeGovVaultTransfer",
          "inputs": [
            {
              "name": "fromUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "toUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "transferAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isFromUserDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "transferShares",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeTokensTransferred",
          "inputs": [
            {
              "name": "fromUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "toUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LockModified",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newLockDuration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "LockReleased",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "exitFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "VaultFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUserInVaultAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesUserHaveBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterUserAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isSupportedVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deregisterVaultAsset",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "doesVaultHaveAnyFunds",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumUserAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getNumVaultAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalBalances",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfUserAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numUserAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "vaultAssets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "amountToShares",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "sharesToAmount",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_shares",
              "type": "uint256"
            },
            {
              "name": "_shouldRoundUp",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensInVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensWithLockDuration",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokensWithLockDuration",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokensFromVault",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawContributorTokensToBurn",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawContributorTokensToBurn",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferBalanceWithinVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_fromUser",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_transferAmount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferContributorRipeTokens",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferContributorRipeTokens",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            },
            {
              "name": "_toUser",
              "type": "address"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getVaultDataOnDeposit",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hasPosition",
                  "type": "bool"
                },
                {
                  "name": "numAssets",
                  "type": "uint256"
                },
                {
                  "name": "userBalance",
                  "type": "uint256"
                },
                {
                  "name": "totalBalance",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserLootBoxShare",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAndAmountAtIndex",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserAssetAtIndexAndHasBalance",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_index",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalAmountForVault",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateUserGovPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateUserGovPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "adjustLock",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newLockDuration",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "adjustLock",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newLockDuration",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "releaseLock",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "releaseLock",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestGovPoints",
          "inputs": [
            {
              "name": "_lastShares",
              "type": "uint256"
            },
            {
              "name": "_lastPointsUpdate",
              "type": "uint256"
            },
            {
              "name": "_unlock",
              "type": "uint256"
            },
            {
              "name": "_terms",
              "type": "tuple",
              "components": [
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockBoost",
                  "type": "uint256"
                },
                {
                  "name": "canExit",
                  "type": "bool"
                },
                {
                  "name": "exitFee",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_weight",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLockBonusPoints",
          "inputs": [
            {
              "name": "_points",
              "type": "uint256"
            },
            {
              "name": "_unlock",
              "type": "uint256"
            },
            {
              "name": "_terms",
              "type": "tuple",
              "components": [
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockBoost",
                  "type": "uint256"
                },
                {
                  "name": "canExit",
                  "type": "bool"
                },
                {
                  "name": "exitFee",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedLockOnTokenDeposit",
          "inputs": [
            {
              "name": "_newShares",
              "type": "uint256"
            },
            {
              "name": "_newLockDuration",
              "type": "uint256"
            },
            {
              "name": "_lockTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockBoost",
                  "type": "uint256"
                },
                {
                  "name": "canExit",
                  "type": "bool"
                },
                {
                  "name": "exitFee",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_prevShares",
              "type": "uint256"
            },
            {
              "name": "_prevUnlock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "areKeyTermsSame",
          "inputs": [
            {
              "name": "_newTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockBoost",
                  "type": "uint256"
                },
                {
                  "name": "canExit",
                  "type": "bool"
                },
                {
                  "name": "exitFee",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_prevTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockBoost",
                  "type": "uint256"
                },
                {
                  "name": "canExit",
                  "type": "bool"
                },
                {
                  "name": "exitFee",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "refreshUnlock",
          "inputs": [
            {
              "name": "_prevUnlock",
              "type": "uint256"
            },
            {
              "name": "_newTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockBoost",
                  "type": "uint256"
                },
                {
                  "name": "canExit",
                  "type": "bool"
                },
                {
                  "name": "exitFee",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_prevTerms",
              "type": "tuple",
              "components": [
                {
                  "name": "minLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockDuration",
                  "type": "uint256"
                },
                {
                  "name": "maxLockBoost",
                  "type": "uint256"
                },
                {
                  "name": "canExit",
                  "type": "bool"
                },
                {
                  "name": "exitFee",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "userGovData",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "govPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastShares",
                  "type": "uint256"
                },
                {
                  "name": "lastPointsUpdate",
                  "type": "uint256"
                },
                {
                  "name": "unlock",
                  "type": "uint256"
                },
                {
                  "name": "lastTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "minLockDuration",
                      "type": "uint256"
                    },
                    {
                      "name": "maxLockDuration",
                      "type": "uint256"
                    },
                    {
                      "name": "maxLockBoost",
                      "type": "uint256"
                    },
                    {
                      "name": "canExit",
                      "type": "bool"
                    },
                    {
                      "name": "exitFee",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalUserGovPoints",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "totalGovPoints",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/vaults/modules/VaultData.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent VaultPauseModified:\n    isPaused: bool\n\nevent VaultFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# balances (may be shares or actual balance)\nuserBalances: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> balance\ntotalBalances: public(HashMap[address, uint256]) # asset -> balance\n\n# user assets (iterable)\nuserAssets: public(HashMap[address, HashMap[uint256, address]]) # user -> index -> asset\nindexOfUserAsset: public(HashMap[address, HashMap[address, uint256]]) # user -> asset -> index\nnumUserAssets: public(HashMap[address, uint256]) # user -> num assets\n\n# vault assets (iterable)\nvaultAssets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # num assets\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n###################\n# Balance Changes #\n###################\n\n\n# deposit\n\n\n@internal\ndef _addBalanceOnDeposit(\n    _user: address,\n    _asset: address,\n    _depositBal: uint256,\n    _shouldUpdateTotal: bool,\n):\n    # update balances\n    self.userBalances[_user][_asset] += _depositBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] += _depositBal\n\n    # register user asset (if necessary)\n    if self.indexOfUserAsset[_user][_asset] == 0:\n        self._registerUserAsset(_user, _asset)\n\n    # register vault asset (if necessary)\n    if self.indexOfAsset[_asset] == 0:\n        self._registerVaultAsset(_asset)\n\n\n# withdrawal\n\n\n@internal\ndef _reduceBalanceOnWithdrawal(\n    _user: address,\n    _asset: address,\n    _withdrawBal: uint256,\n    _shouldUpdateTotal: bool,\n) -> (uint256, bool):\n    assert self.indexOfUserAsset[_user][_asset] != 0 # dev: user does not have this asset\n\n    currentBal: uint256 = self.userBalances[_user][_asset]\n    withdrawBal: uint256 = min(_withdrawBal, currentBal)\n    assert withdrawBal != 0 # dev: nothing to withdraw\n\n    # update balances\n    currentBal -= withdrawBal\n    self.userBalances[_user][_asset] = currentBal\n    if _shouldUpdateTotal:\n        self.totalBalances[_asset] -= withdrawBal\n\n    return withdrawBal, currentBal == 0\n\n\n###############\n# User Assets #\n###############\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    return self.indexOfUserAsset[_user][_asset] != 0\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    return self.userBalances[_user][_asset] != 0\n\n\n@internal\ndef _registerUserAsset(_user: address, _asset: address):\n    aid: uint256 = self.numUserAssets[_user]\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.userAssets[_user][aid] = _asset\n    self.indexOfUserAsset[_user][_asset] = aid\n    self.numUserAssets[_user] = aid + 1\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    assert msg.sender == addys._getLootboxAddr() # dev: only Lootbox allowed\n\n    if self.userBalances[_user][_asset] != 0:\n        return True\n\n    numUserAssets: uint256 = self.numUserAssets[_user]\n    if numUserAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfUserAsset[_user][_asset]\n    if targetIndex == 0:\n        return numUserAssets > 1\n\n    # update data\n    lastIndex: uint256 = numUserAssets - 1\n    self.numUserAssets[_user] = lastIndex\n    self.indexOfUserAsset[_user][_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.userAssets[_user][lastIndex]\n        self.userAssets[_user][targetIndex] = lastItem\n        self.indexOfUserAsset[_user][lastItem] = targetIndex\n\n    return lastIndex > 1\n\n\n################\n# Vault Assets #\n################\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    return self.indexOfAsset[_asset] != 0\n\n\n@internal\ndef _registerVaultAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.vaultAssets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    if self.totalBalances[_asset] != 0:\n        return False\n\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return False\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.vaultAssets[lastIndex]\n        self.vaultAssets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n    return True\n\n\n##############\n# Data Utils #\n##############\n\n\n# any vault funds\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return False\n    for i: uint256 in range(1, numAssets, bound=max_value(uint256)):\n        asset: address = self.vaultAssets[i]\n        if self.totalBalances[asset] != 0:\n            return True\n    return False\n\n\n# num user assets\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    return self._getNumUserAssets(_user)\n\n\n@view\n@internal\ndef _getNumUserAssets(_user: address) -> uint256:\n    numAssets: uint256 = self.numUserAssets[_user]\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n# num vault assets\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    return self._getNumVaultAssets()\n\n\n@view\n@internal\ndef _getNumVaultAssets() -> uint256:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return 0\n    return numAssets - 1\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log VaultPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    # cannot recover funds from a registered asset with a balance\n    assert self.indexOfAsset[_asset] == 0 and self.totalBalances[_asset] == 0 # dev: invalid recovery\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log VaultFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "a40dbc674354ec85dd7c1ad8573db4995a56c7a58284b9e3357ba5145fc34de5"
          },
          "contracts/vaults/modules/SharesVault.vy": {
            "content": "# @version 0.4.1\n\nuses: vaultData\nimport contracts.vaults.modules.VaultData as vaultData\n\nfrom interfaces import Vault\nfrom ethereum.ercs import IERC20\n\nDECIMAL_OFFSET: constant(uint256) = 10 ** 8\n\n\n@deploy\ndef __init__():\n    pass\n\n\n########\n# Core #\n########\n\n\n@internal\ndef _depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n) -> (uint256, uint256):\n    assert not vaultData.isPaused # dev: contract paused\n\n    # validation\n    assert empty(address) not in [_user, _asset] # dev: invalid user or asset\n    totalAssetBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    depositAmount: uint256 = min(_amount, totalAssetBalance)\n    assert depositAmount != 0 # dev: invalid deposit amount\n\n    # calc shares\n    prevTotalBalance: uint256 = totalAssetBalance - depositAmount # remove the deposited amount to calc shares accurately\n    newShares: uint256 = self._amountToShares(depositAmount, vaultData.totalBalances[_asset], prevTotalBalance, False)\n\n    # add balance on deposit\n    vaultData._addBalanceOnDeposit(_user, _asset, newShares, True)\n\n    return depositAmount, newShares\n\n\n@internal\ndef _withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_user, _asset, _recipient] # dev: invalid user, asset, or recipient\n\n    # calc shares + amount to withdraw\n    withdrawalShares: uint256 = 0\n    withdrawalAmount: uint256 = 0\n    withdrawalShares, withdrawalAmount = self._calcWithdrawalSharesAndAmount(_user, _asset, _amount)\n\n    # reduce balance on withdrawal\n    isDepleted: bool = False\n    withdrawalShares, isDepleted = vaultData._reduceBalanceOnWithdrawal(_user, _asset, withdrawalShares, True)\n\n    # move tokens to recipient\n    assert extcall IERC20(_asset).transfer(_recipient, withdrawalAmount, default_return_value=True) # dev: token transfer failed\n    return withdrawalAmount, withdrawalShares, isDepleted\n\n\n@internal\ndef _transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n) -> (uint256, uint256, bool):\n    assert not vaultData.isPaused # dev: contract paused\n    assert empty(address) not in [_fromUser, _toUser, _asset] # dev: invalid users or asset\n\n    # calc shares + amount to transfer\n    transferShares: uint256 = 0\n    transferAmount: uint256 = 0\n    transferShares, transferAmount = self._calcWithdrawalSharesAndAmount(_fromUser, _asset, _transferAmount)\n\n    # transfer shares\n    isFromUserDepleted: bool = False\n    transferShares, isFromUserDepleted = vaultData._reduceBalanceOnWithdrawal(_fromUser, _asset, transferShares, False)\n    vaultData._addBalanceOnDeposit(_toUser, _asset, transferShares, False)\n\n    return transferAmount, transferShares, isFromUserDepleted\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@internal\ndef _getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return Vault.VaultDataOnDeposit(\n        hasPosition=vaultData.indexOfUserAsset[_user][_asset] != 0,\n        numAssets=vaultData._getNumUserAssets(_user),\n        userBalance=self._getTotalAmountForUserWithTotalBal(_user, _asset, totalBalance),\n        totalBalance=totalBalance,\n    )\n\n\n@view\n@internal\ndef _getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    return vaultData.userBalances[_user][_asset] // DECIMAL_OFFSET\n\n\n@view\n@internal\ndef _getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), 0\n    userShares: uint256 = vaultData.userBalances[_user][asset]\n    if userShares == 0:\n        return empty(address), 0\n    return asset, self._sharesToAmount(userShares, vaultData.totalBalances[asset], staticcall IERC20(asset).balanceOf(self), False)\n\n\n@view\n@internal\ndef _getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    asset: address = vaultData.userAssets[_user][_index]\n    if asset == empty(address):\n        return empty(address), False\n    return asset, vaultData.userBalances[_user][asset] != 0\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@internal\ndef _getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return self._getTotalAmountForUserWithTotalBal(_user, _asset, staticcall IERC20(_asset).balanceOf(self))\n\n\n@view\n@internal\ndef _getTotalAmountForUserWithTotalBal(_user: address, _asset: address, _totalBalance: uint256) -> uint256:\n    userShares: uint256 = vaultData.userBalances[_user][_asset]\n    return self._sharesToAmount(userShares, vaultData.totalBalances[_asset], _totalBalance, False)\n\n\n@view\n@internal\ndef _getTotalAmountForVault(_asset: address) -> uint256:\n    return staticcall IERC20(_asset).balanceOf(self)\n\n\n##########\n# Shares #\n##########\n\n\n@view\n@internal\ndef _calcWithdrawalSharesAndAmount(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n) -> (uint256, uint256):\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert totalBalance != 0 # dev: no asset to withdraw\n\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n\n    # user shares\n    withdrawalShares: uint256 = vaultData.userBalances[_user][_asset]\n    assert withdrawalShares != 0 # dev: user has no shares\n\n    # calc amount + shares to withdraw\n    withdrawalAmount: uint256 = min(totalBalance, self._sharesToAmount(withdrawalShares, totalShares, totalBalance, False))\n    if _amount < withdrawalAmount:\n        withdrawalShares = min(withdrawalShares, self._amountToShares(_amount, totalShares, totalBalance, True))\n        withdrawalAmount = _amount\n\n    assert withdrawalAmount != 0 # dev: no withdrawal amount\n    return withdrawalShares, withdrawalAmount\n\n\n# amount -> shares\n\n\n@view\n@external\ndef amountToShares(_asset: address, _amount: uint256, _shouldRoundUp: bool) -> uint256:\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return self._amountToShares(_amount, totalShares, totalBalance, _shouldRoundUp)\n\n\n@view\n@internal\ndef _amountToShares(\n    _amount: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalBalance: uint256 = _totalBalance\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalBalance += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc shares\n    numerator: uint256 = _amount * totalShares\n    shares: uint256 = numerator // totalBalance\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalBalance != 0):\n        shares += 1\n\n    return shares\n\n\n# shares -> amount\n\n\n@view\n@external\ndef sharesToAmount(_asset: address, _shares: uint256, _shouldRoundUp: bool) -> uint256:\n    totalShares: uint256 = vaultData.totalBalances[_asset]\n    totalBalance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    return self._sharesToAmount(_shares, totalShares, totalBalance, _shouldRoundUp)\n\n\n@view\n@internal\ndef _sharesToAmount(\n    _shares: uint256,\n    _totalShares: uint256,\n    _totalBalance: uint256,\n    _shouldRoundUp: bool,\n) -> uint256:\n    totalBalance: uint256 = _totalBalance\n\n    # dead shares / decimal offset -- preventing donation attacks\n    totalBalance += 1\n    totalShares: uint256 = _totalShares + DECIMAL_OFFSET\n\n    # calc amount\n    numerator: uint256 = _shares * totalBalance\n    amount: uint256 = numerator // totalShares\n\n    # rounding\n    if _shouldRoundUp and (numerator % totalShares != 0):\n        amount += 1\n\n    return amount\n",
            "sha256sum": "e5950f837a378ea674587140082327b4113dcd19b9f77b9c86bbedc6ee329860"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "contracts/vaults/RipeGov.vy": {
            "content": "# @version 0.4.1\n\nimplements: Vault\n\nexports: addys.__interface__\nexports: vaultData.__interface__\nexports: sharesVault.__interface__\n\ninitializes: addys\ninitializes: vaultData[addys := addys]\ninitializes: sharesVault[vaultData := vaultData]\n\nfrom interfaces import Vault\nimport contracts.modules.Addys as addys\nimport contracts.vaults.modules.VaultData as vaultData\nimport contracts.vaults.modules.SharesVault as sharesVault\nimport interfaces.ConfigStructs as cs\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Lootbox:\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface BoardRoom:\n    def govPowerDidChangeForUser(_user: address, _userGovPoints: uint256, _totalGovPoints: uint256): nonpayable\n\ninterface MissionControl:\n    def ripeGovVaultConfig(_asset: address) -> cs.RipeGovVaultConfig: view\n\ninterface VaultBook:\n    def getRegId(_vaultAddr: address) -> uint256: view\n\ninterface Ledger:\n    def badDebt() -> uint256: view\n\nstruct GovData:\n    govPoints: uint256\n    lastShares: uint256\n    lastPointsUpdate: uint256\n    unlock: uint256\n    lastTerms: cs.LockTerms\n\nevent RipeGovVaultDeposit:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    shares: uint256\n    lockDuration: uint256\n\nevent RipeGovVaultWithdrawal:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    isDepleted: bool\n    shares: uint256\n\nevent RipeGovVaultBurnContributorTokens:\n    user: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    shares: uint256\n\nevent RipeGovVaultTransfer:\n    fromUser: indexed(address)\n    toUser: indexed(address)\n    asset: indexed(address)\n    transferAmount: uint256\n    isFromUserDepleted: bool\n    transferShares: uint256\n\nevent RipeTokensTransferred:\n    fromUser: indexed(address)\n    toUser: indexed(address)\n    amount: uint256\n\nevent LockModified:\n    user: indexed(address)\n    asset: indexed(address)\n    newLockDuration: uint256\n\nevent LockReleased:\n    user: indexed(address)\n    asset: indexed(address)\n    exitFee: uint256\n\n# user gov data\nuserGovData: public(HashMap[address, HashMap[address, GovData]]) # user -> asset -> GovData\ntotalUserGovPoints: public(HashMap[address, uint256]) # user -> gov points\ntotalGovPoints: public(uint256) # total gov points\n\nPRECISION: constant(uint256) = 10 ** 18 # total should be 10**24 (each asset in this strat is 18 decimals, plus 8 decimal offset for shares)\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    vaultData.__init__(False)\n    sharesVault.__init__()\n\n\n########\n# Core #\n########\n\n\n# deposit\n\n\n@nonreentrant\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    return self._depositTokensInRipeGovVault(_user, _asset, _amount, 0, _a)\n\n\n@nonreentrant\n@external\ndef depositTokensWithLockDuration(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _lockDuration: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    return self._depositTokensInRipeGovVault(_user, _asset, _amount, _lockDuration, _a)\n\n\n@internal\ndef _depositTokensInRipeGovVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _lockDuration: uint256,\n    _a: addys.Addys,\n) -> uint256:\n    a: addys.Addys = addys._getAddys(_a)\n\n    # deposit tokens (using shares module)\n    depositAmount: uint256 = 0\n    newShares: uint256 = 0\n    depositAmount, newShares = sharesVault._depositTokensInVault(_user, _asset, _amount)\n\n    # handle gov data/points\n    config: cs.RipeGovVaultConfig = staticcall MissionControl(a.missionControl).ripeGovVaultConfig(_asset)\n    lockDuration: uint256 = max(config.lockTerms.minLockDuration, _lockDuration)\n    lockDuration = min(lockDuration, config.lockTerms.maxLockDuration)\n    self._handleGovDataOnDeposit(_user, _asset, newShares, lockDuration, 0, config)\n    self._updateUserGovPoints(_user, _asset, a.missionControl, a.boardroom)\n\n    log RipeGovVaultDeposit(user=_user, asset=_asset, amount=depositAmount, shares=newShares, lockDuration=lockDuration)\n    return depositAmount\n\n\n@internal\ndef _handleGovDataOnDeposit(\n    _user: address,\n    _asset: address,\n    _newShares: uint256,\n    _newLockDuration: uint256,\n    _additionalPoints: uint256,\n    _config: cs.RipeGovVaultConfig,\n):\n    userData: GovData = self.userGovData[_user][_asset]\n    newPoints: uint256 = self._getLatestGovPoints(userData.lastShares, userData.lastPointsUpdate, userData.unlock, _config.lockTerms, _config.assetWeight)\n    newPoints += _additionalPoints\n\n    # refresh unlock / terms\n    userData.unlock = self._refreshUnlock(userData.unlock, _config.lockTerms, userData.lastTerms)\n    userData.lastTerms = _config.lockTerms\n    userData.unlock = self._getWeightedLockOnTokenDeposit(_newShares, _newLockDuration, _config.lockTerms, userData.lastShares, userData.unlock)\n\n    # save user data\n    userData.lastShares = vaultData.userBalances[_user][_asset]\n    userData.govPoints += newPoints\n    userData.lastPointsUpdate = block.number\n    self.userGovData[_user][_asset] = userData\n\n    # save total gov points\n    self.totalUserGovPoints[_user] += newPoints\n    self.totalGovPoints += newPoints\n\n\n# withdraw\n\n\n@nonreentrant\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getTellerAddr(), addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n    a: addys.Addys = addys._getAddys(_a)\n    return self._withdrawTokensFromVault(_user, _asset, _amount, _recipient, True, a)\n\n\n@nonreentrant\n@external\ndef withdrawContributorTokensToBurn(_user: address, _a: addys.Addys = empty(addys.Addys)) -> uint256:\n    hr: address = addys._getHumanResourcesAddr()\n    assert msg.sender == hr # dev: not allowed\n    a: addys.Addys = addys._getAddys(_a)\n    if vaultData.userBalances[_user][a.ripeToken] == 0:\n        return 0\n    withdrawalAmount: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, isDepleted = self._withdrawTokensFromVault(_user, a.ripeToken, max_value(uint256), hr, False, a)\n    return withdrawalAmount\n\n\n@internal\ndef _withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _shouldCheckRestrictions: bool,\n    _a: addys.Addys,\n) -> (uint256, bool):\n\n    # withdraw tokens (using shares module)\n    withdrawalAmount: uint256 = 0\n    withdrawalShares: uint256 = 0\n    isDepleted: bool = False\n    withdrawalAmount, withdrawalShares, isDepleted = sharesVault._withdrawTokensFromVault(_user, _asset, _amount, _recipient)\n\n    # handle gov data/points\n    config: cs.RipeGovVaultConfig = staticcall MissionControl(_a.missionControl).ripeGovVaultConfig(_asset)\n    self._handleGovDataOnWithdrawal(_user, _asset, withdrawalShares, _shouldCheckRestrictions, config, _a.ledger)\n    self._updateUserGovPoints(_user, _asset, _a.missionControl, _a.boardroom)\n\n    log RipeGovVaultWithdrawal(user=_user, asset=_asset, amount=withdrawalAmount, isDepleted=isDepleted, shares=withdrawalShares)\n    return withdrawalAmount, isDepleted\n\n\n@internal\ndef _handleGovDataOnWithdrawal(\n    _user: address,\n    _asset: address,\n    _withdrawalShares: uint256,\n    _shouldCheckRestrictions: bool,\n    _config: cs.RipeGovVaultConfig,\n    _ledger: address,\n) -> uint256:\n    userData: GovData = self.userGovData[_user][_asset]\n    newPoints: uint256 = self._getLatestGovPoints(userData.lastShares, userData.lastPointsUpdate, userData.unlock, _config.lockTerms, _config.assetWeight)\n    prevSavedPoints: uint256 = userData.govPoints\n\n    # refresh unlock / terms\n    userData.unlock = self._refreshUnlock(userData.unlock, _config.lockTerms, userData.lastTerms)\n    userData.lastTerms = _config.lockTerms\n    if _shouldCheckRestrictions:\n        assert block.number >= userData.unlock # dev: not reached unlock\n        if _config.shouldFreezeWhenBadDebt:\n            assert staticcall Ledger(_ledger).badDebt() == 0 # dev: cannot withdraw when bad debt\n\n    # handle points penalty for withdrawal\n    newUserPoints: uint256 = userData.govPoints + newPoints\n    pointsToReduce: uint256 = newUserPoints\n    if _withdrawalShares != userData.lastShares:\n        pointsToReduce = min(newUserPoints, newUserPoints * _withdrawalShares // userData.lastShares)\n    newUserPoints -= pointsToReduce\n\n    # save user data\n    userData.lastShares = vaultData.userBalances[_user][_asset]\n    userData.govPoints = newUserPoints\n    userData.lastPointsUpdate = block.number\n    self.userGovData[_user][_asset] = userData\n\n    # update total gov points\n    preTotalUserGovPoints: uint256 = self.totalUserGovPoints[_user]\n    newUserGovPoints: uint256 = preTotalUserGovPoints - prevSavedPoints + newUserPoints\n    self.totalUserGovPoints[_user] = newUserGovPoints\n\n    totalGovPoints: uint256 = self.totalGovPoints\n    totalGovPoints = totalGovPoints - preTotalUserGovPoints + newUserGovPoints\n    self.totalGovPoints = totalGovPoints\n\n    return pointsToReduce\n\n\n# transfer\n\n\n@nonreentrant\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    assert msg.sender in [addys._getAuctionHouseAddr(), addys._getCreditEngineAddr()] # dev: not allowed\n    a: addys.Addys = addys._getAddys(_a)\n\n    # transfer tokens (using shares module)\n    transferAmount: uint256 = 0\n    transferShares: uint256 = 0\n    isFromUserDepleted: bool = False\n    transferAmount, transferShares, isFromUserDepleted = sharesVault._transferBalanceWithinVault(_asset, _fromUser, _toUser, _transferAmount)\n\n    # handle gov data/points\n    config: cs.RipeGovVaultConfig = staticcall MissionControl(a.missionControl).ripeGovVaultConfig(_asset)\n    self._handleGovDataOnTransfer(_fromUser, _toUser, _asset, transferShares, config.lockTerms.minLockDuration, False, config, a.missionControl, a.boardroom, a.ledger)\n\n    log RipeGovVaultTransfer(fromUser=_fromUser, toUser=_toUser, asset=_asset, transferAmount=transferAmount, isFromUserDepleted=isFromUserDepleted, transferShares=transferShares)\n    return transferAmount, isFromUserDepleted\n\n\n@internal\ndef _handleGovDataOnTransfer(\n    _fromUser: address,\n    _toUser: address,\n    _asset: address,\n    _transferShares: uint256,\n    _lockDuration: uint256,\n    _shouldTransferPoints: bool,\n    _config: cs.RipeGovVaultConfig,\n    _missionControl: address,\n    _boardroom: address,\n    _ledger: address,\n):\n    # from user\n    transferPoints: uint256 = self._handleGovDataOnWithdrawal(_fromUser, _asset, _transferShares, False, _config, _ledger)\n    if not _shouldTransferPoints:\n        transferPoints = 0\n\n    # to user\n    self._handleGovDataOnDeposit(_toUser, _asset, _transferShares, _lockDuration, transferPoints, _config)\n\n    # update other gov points / boardroom\n    self._updateUserGovPoints(_fromUser, _asset, _missionControl, _boardroom)\n    self._updateUserGovPoints(_toUser, _asset, _missionControl, _boardroom)\n\n\n# transfer contributor tokens\n\n\n@nonreentrant\n@external\ndef transferContributorRipeTokens(\n    _contributor: address,\n    _toUser: address,\n    _lockDuration: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getHumanResourcesAddr() # dev: not allowed\n    a: addys.Addys = addys._getAddys(_a)\n\n    # config\n    config: cs.RipeGovVaultConfig = staticcall MissionControl(a.missionControl).ripeGovVaultConfig(a.ripeToken)\n\n    # transfer tokens (using shares module)\n    ripeAmount: uint256 = 0\n    transferShares: uint256 = 0\n    na: bool = False\n    ripeAmount, transferShares, na = sharesVault._transferBalanceWithinVault(a.ripeToken, _contributor, _toUser, max_value(uint256))\n\n    # handle gov data/points\n    self._handleGovDataOnTransfer(_contributor, _toUser, a.ripeToken, transferShares, _lockDuration, True, config, a.missionControl, a.boardroom, a.ledger)\n\n    log RipeTokensTransferred(fromUser=_contributor, toUser=_toUser, amount=ripeAmount)\n    return ripeAmount\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> Vault.VaultDataOnDeposit:\n    # used in Teller.vy\n    return sharesVault._getVaultDataOnDeposit(_user, _asset)\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    userData: GovData = self.userGovData[_user][_asset]\n    if userData.lastShares == 0:\n        return 0\n\n    points: uint256 = userData.lastShares // PRECISION\n    if userData.lastTerms.maxLockDuration != 0:\n        points += self._getLockBonusPoints(points, userData.unlock, userData.lastTerms)\n\n    return points\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    return sharesVault._getUserAssetAndAmountAtIndex(_user, _index)\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    return sharesVault._getUserAssetAtIndexAndHasBalance(_user, _index)\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    return sharesVault._getTotalAmountForUser(_user, _asset)\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    return sharesVault._getTotalAmountForVault(_asset)\n\n\n#####################\n# Update Gov Points #\n#####################\n\n\n@external\ndef updateUserGovPoints(_user: address, _a: addys.Addys = empty(addys.Addys)):\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    a: addys.Addys = addys._getAddys(_a)\n    self._updateUserGovPoints(_user, empty(address), a.missionControl, a.boardroom)\n\n\n@internal\ndef _updateUserGovPoints(\n    _user: address,\n    _skipAsset: address,\n    _missionControl: address,\n    _boardroom: address,\n):\n    numUserAssets: uint256 = vaultData.numUserAssets[_user]\n    if numUserAssets != 0:\n        for i: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n            asset: address = vaultData.userAssets[_user][i]\n            if asset == _skipAsset or asset == empty(address):\n                continue\n            self._updateGovPointsForUserAsset(_user, asset, _missionControl)\n\n    # update boardroom\n    if _boardroom != empty(address):\n        extcall BoardRoom(_boardroom).govPowerDidChangeForUser(_user, self.totalUserGovPoints[_user], self.totalGovPoints)\n\n\n@internal\ndef _updateGovPointsForUserAsset(\n    _user: address,\n    _asset: address,\n    _missionControl: address,\n):\n    config: cs.RipeGovVaultConfig = staticcall MissionControl(_missionControl).ripeGovVaultConfig(_asset)\n\n    userData: GovData = self.userGovData[_user][_asset]\n    newPoints: uint256 = self._getLatestGovPoints(userData.lastShares, userData.lastPointsUpdate, userData.unlock, config.lockTerms, config.assetWeight)\n\n    # refresh unlock / terms\n    userData.unlock = self._refreshUnlock(userData.unlock, config.lockTerms, userData.lastTerms)\n    userData.lastTerms = config.lockTerms\n\n    # save user data\n    userData.govPoints += newPoints\n    userData.lastPointsUpdate = block.number\n    self.userGovData[_user][_asset] = userData\n\n    # save total gov points\n    self.totalUserGovPoints[_user] += newPoints\n    self.totalGovPoints += newPoints\n\n\n####################\n# Lock Adjustments #\n####################\n\n\n@external\ndef adjustLock(\n    _user: address,\n    _asset: address,\n    _newLockDuration: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n):\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    a: addys.Addys = addys._getAddys(_a)\n\n    # do a full update first\n    self._updateUserGovPoints(_user, empty(address), a.missionControl, a.boardroom)\n\n    # validation\n    userData: GovData = self.userGovData[_user][_asset]\n    assert userData.lastTerms.maxLockDuration != 0 # dev: no lock terms\n    assert userData.lastShares != 0 # dev: no position\n\n    # update lootbox points\n    vaultId: uint256 = staticcall VaultBook(a.vaultBook).getRegId(self) # dev: invalid vault addr\n    extcall Lootbox(a.lootbox).updateDepositPoints(_user, vaultId, self, _asset, a)\n\n    # update lock duration\n    lockDuration: uint256 = max(_newLockDuration, userData.lastTerms.minLockDuration)\n    lockDuration = min(lockDuration, userData.lastTerms.maxLockDuration)\n    newUnlockBlock: uint256 = block.number + lockDuration\n    assert newUnlockBlock > userData.unlock # dev: new lock cannot be earlier\n    userData.unlock = newUnlockBlock\n    self.userGovData[_user][_asset] = userData\n\n    log LockModified(user=_user, asset=_asset, newLockDuration=lockDuration)\n\n\n@external\ndef releaseLock(\n    _user: address,\n    _asset: address,\n    _a: addys.Addys = empty(addys.Addys),\n):\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    a: addys.Addys = addys._getAddys(_a)\n\n    # they are probably wanting to exit early because of bad debt, crisis of confidence\n    # if they won't be able to withdraw anyway, don't let them exit early (it will cost them for no reason!)\n    config: cs.RipeGovVaultConfig = staticcall MissionControl(a.missionControl).ripeGovVaultConfig(_asset)\n    if staticcall Ledger(a.ledger).badDebt() != 0:\n        assert not config.shouldFreezeWhenBadDebt # dev: saving user money\n\n    # do a full update first\n    self._updateUserGovPoints(_user, empty(address), a.missionControl, a.boardroom)\n\n    # validation\n    userData: GovData = self.userGovData[_user][_asset]\n    assert userData.unlock > block.number # dev: no release needed\n    assert userData.lastTerms.canExit # dev: cannot exit\n    assert userData.lastShares != 0 # dev: no position\n\n    # update lootbox points\n    vaultId: uint256 = staticcall VaultBook(a.vaultBook).getRegId(self) # dev: invalid vault addr\n    extcall Lootbox(a.lootbox).updateDepositPoints(_user, vaultId, self, _asset, a)\n\n    # handle payment\n    exitFee: uint256 = userData.lastTerms.exitFee\n    assert exitFee != 0 # dev: no exit fee\n\n    # remove shares (cost to exit early)\n    userShares: uint256 = vaultData.userBalances[_user][_asset]\n    sharesToRemove: uint256 = min(userShares, userShares * exitFee // HUNDRED_PERCENT)\n    vaultData._reduceBalanceOnWithdrawal(_user, _asset, sharesToRemove, True)\n    userData.lastShares -= sharesToRemove\n\n    # update lock duration\n    userData.unlock = 0\n    self.userGovData[_user][_asset] = userData\n\n    log LockReleased(user=_user, asset=_asset, exitFee=exitFee)\n\n\n################\n# Points Utils #\n################\n\n\n# latest gov points\n\n\n@view\n@external\ndef getLatestGovPoints(\n    _lastShares: uint256,\n    _lastPointsUpdate: uint256,\n    _unlock: uint256,\n    _terms: cs.LockTerms,\n    _weight: uint256,\n) -> uint256:\n    return self._getLatestGovPoints(_lastShares, _lastPointsUpdate, _unlock, _terms, _weight)\n\n\n@view\n@internal\ndef _getLatestGovPoints(\n    _lastShares: uint256,\n    _lastPointsUpdate: uint256,\n    _unlock: uint256,\n    _terms: cs.LockTerms,\n    _weight: uint256,\n) -> uint256:\n    if _lastShares == 0:\n        return 0\n\n    # base points (shares + time deposited)\n    newPoints: uint256 = 0\n    if _lastPointsUpdate != 0 and block.number > _lastPointsUpdate:\n        shares: uint256 = _lastShares // PRECISION\n        newPoints = shares * (block.number - _lastPointsUpdate)\n\n    if newPoints == 0:\n        return 0\n\n    # asset weight\n    if _weight != 0:\n        newPoints = newPoints * _weight // HUNDRED_PERCENT\n\n    # lock boost bonus (only if terms are set)\n    if _terms.maxLockDuration != 0:\n        newPoints += self._getLockBonusPoints(newPoints, _unlock, _terms)\n\n    return newPoints\n\n\n# lock bonus points\n\n\n@view\n@external\ndef getLockBonusPoints(\n    _points: uint256,\n    _unlock: uint256,\n    _terms: cs.LockTerms,\n) -> uint256:\n    return self._getLockBonusPoints(_points, _unlock, _terms)\n\n\n@view\n@internal\ndef _getLockBonusPoints(\n    _points: uint256,\n    _unlock: uint256,\n    _terms: cs.LockTerms,\n) -> uint256:\n    if _points == 0 or _unlock <= block.number:\n        return 0\n\n    remainingLockDuration: uint256 = min(_unlock - block.number, _terms.maxLockDuration) # it is possible that param change caused higher than max, add this check\n    if remainingLockDuration <= _terms.minLockDuration:\n        return 0\n\n    lockBonusRatio: uint256 = _terms.maxLockBoost * (remainingLockDuration - _terms.minLockDuration) // (_terms.maxLockDuration - _terms.minLockDuration)\n    return _points * lockBonusRatio // HUNDRED_PERCENT\n\n\n# weighted lock on token deposit\n\n\n@view\n@external\ndef getWeightedLockOnTokenDeposit(\n    _newShares: uint256,\n    _newLockDuration: uint256,\n    _lockTerms: cs.LockTerms,\n    _prevShares: uint256,\n    _prevUnlock: uint256,\n) -> uint256:\n    return self._getWeightedLockOnTokenDeposit(_newShares, _newLockDuration, _lockTerms, _prevShares, _prevUnlock)\n\n\n@view\n@internal\ndef _getWeightedLockOnTokenDeposit(\n    _newShares: uint256,\n    _newLockDuration: uint256,\n    _lockTerms: cs.LockTerms,\n    _prevShares: uint256,\n    _prevUnlock: uint256,\n) -> uint256:\n    # nothing to do here (no previous balance)\n    if _prevShares < PRECISION:\n        return block.number + _newLockDuration\n    prevNormalized: uint256 = _prevShares // PRECISION \n\n    # previous lock duration\n    prevDuration: uint256 = 1\n    if _prevUnlock > block.number and _lockTerms.maxLockDuration != 0:\n        prevDuration = min(_prevUnlock - block.number, _lockTerms.maxLockDuration)\n\n    # not allowing zero on `newNormalized` or `newLockDuration` -- or else new deposit won't get any weight\n    newNormalized: uint256 = 1\n    if _newShares > PRECISION:\n        newNormalized = _newShares // PRECISION\n    newLockDuration: uint256 = max(_newLockDuration, 1)\n\n    # take weighted average, blending the unlock durations\n    newWeightedDuration: uint256 = ((prevNormalized * prevDuration) + (newNormalized * newLockDuration)) // (prevNormalized + newNormalized)\n    return block.number + newWeightedDuration\n\n\n# same terms\n\n\n@view\n@external\ndef areKeyTermsSame(_newTerms: cs.LockTerms, _prevTerms: cs.LockTerms) -> bool:\n    return self._areKeyTermsSame(_newTerms, _prevTerms)\n\n\n@view\n@internal\ndef _areKeyTermsSame(_newTerms: cs.LockTerms, _prevTerms: cs.LockTerms) -> bool:\n    # can no longer exit!!\n    if _prevTerms.canExit and not _newTerms.canExit:\n        return False\n\n    # boost got worse\n    if _newTerms.maxLockBoost < _prevTerms.maxLockBoost:\n        return False\n\n    # min lock duration improved\n    if _newTerms.minLockDuration < _prevTerms.minLockDuration:\n        return False\n\n    # exit fees got worse\n    if _newTerms.exitFee > _prevTerms.exitFee:\n        return False\n\n    return True\n\n\n# refresh unlock\n\n\n@view\n@external\ndef refreshUnlock(_prevUnlock: uint256, _newTerms: cs.LockTerms, _prevTerms: cs.LockTerms) -> uint256:\n    return self._refreshUnlock(_prevUnlock, _newTerms, _prevTerms)\n\n\n@view\n@internal\ndef _refreshUnlock(_prevUnlock: uint256, _newTerms: cs.LockTerms, _prevTerms: cs.LockTerms) -> uint256:\n    unlock: uint256 = _prevUnlock\n    if not self._areKeyTermsSame(_newTerms, _prevTerms):\n        unlock = 0\n    # will auto-adjust down if max duration improved\n    return min(unlock, block.number + _newTerms.maxLockDuration)\n",
            "sha256sum": "62e6340968cd87b8baafc970e2b5dc801490b2fc7da7dd52db7a1d49e8b2d553"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/vaults/RipeGov.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "4feffd7a1e9422c6f675c8311d5a975fa6dad4e56062da2b9387f93755eef9ed"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/vaults/RipeGov.vy"
    },
    "AuctionHouse": {
      "address": "0x2d2B0799c0Ae174b380EA50B0A19B37045d2811B",
      "abi": [
        {
          "name": "LiquidateUser",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalLiqFees",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "targetRepayAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "didRestoreDebtHealth",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "collateralValueOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqFeesUnpaid",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numAuctionsStarted",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "keeperFee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CollateralSentToEndaoment",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountSent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabAssetBurntAsRepayment",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqStabAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CollateralSwappedWithStabPool",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqVaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "collateralAmountOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "collateralValueOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabVaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetSwapped",
              "type": "address",
              "indexed": false
            },
            {
              "name": "amountSwapped",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "valueSwapped",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FungibleAuctionUpdated",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "startDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxDiscount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "startBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "endBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isNewAuction",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FungibleAuctionPaused",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "FungAuctionPurchased",
          "inputs": [
            {
              "name": "liqUser",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqVaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "greenSpent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": false
            },
            {
              "name": "collateralAmountSent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "collateralUsdValueSent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isPositionDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateUser",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_keeper",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateUser",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_keeper",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateManyUsers",
          "inputs": [
            {
              "name": "_liqUsers",
              "type": "address[]"
            },
            {
              "name": "_keeper",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateManyUsers",
          "inputs": [
            {
              "name": "_liqUsers",
              "type": "address[]"
            },
            {
              "name": "_keeper",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canStartAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_liqVaultId",
              "type": "uint256"
            },
            {
              "name": "_liqAsset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pauseManyAuctions",
          "inputs": [
            {
              "name": "_auctions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                }
              ]
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "calcAmountOfDebtToRepayDuringLiq",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "contracts/core/AuctionHouse.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import Vault\nimport interfaces.ConfigStructs as cs\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\ninterface Ledger:\n    def setFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address, _auc: FungibleAuction) -> bool: nonpayable\n    def getFungibleAuctionDuringPurchase(_liqUser: address, _vaultId: uint256, _asset: address) -> FungibleAuction: view\n    def removeFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address): nonpayable\n    def hasFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address) -> bool: view\n    def isParticipatingInVault(_user: address, _vaultId: uint256) -> bool: view\n    def createNewFungibleAuction(_auc: FungibleAuction) -> uint256: nonpayable\n    def addVaultToUser(_user: address, _vaultId: uint256): nonpayable\n    def userVaults(_user: address, _index: uint256) -> uint256: view\n    def isUserInLiquidation(_user: address) -> bool: view\n    def numUserVaults(_user: address) -> uint256: view\n\ninterface MissionControl:\n    def getAuctionBuyConfig(_asset: address, _recipient: address) -> AuctionBuyConfig: view\n    def getAssetLiqConfig(_asset: address) -> AssetLiqConfig: view\n    def getGenAuctionParams() -> cs.AuctionParams: view\n    def getGenLiqConfig() -> GenLiqConfig: view\n\ninterface StabilityPool:\n    def swapForLiquidatedCollateral(_stabAsset: address, _stabAmountToRemove: uint256, _liqAsset: address, _liqAmountSent: uint256, _recipient: address, _greenToken: address, _savingsGreenToken: address) -> uint256: nonpayable\n    def swapWithClaimableGreen(_stabAsset: address, _greenAmount: uint256, _liqAsset: address, _liqAmountSent: uint256, _greenToken: address) -> uint256: nonpayable\n    def claimableBalances(_stabAsset: address, _greenToken: address) -> uint256: view\n\ninterface CreditEngine:\n    def repayDuringLiquidation(_liqUser: address, _userDebt: UserDebt, _repayAmount: uint256, _newInterest: uint256, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n    def getLatestUserDebtAndTerms(_user: address, _shouldRaise: bool, _a: addys.Addys = empty(addys.Addys)) -> (UserDebt, UserBorrowTerms, uint256): view\n    def repayDuringAuctionPurchase(_liqUser: address, _repayAmount: uint256, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n\ninterface PriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface GreenToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n    def burn(_amount: uint256) -> bool: nonpayable\n\ninterface LootBox:\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface Teller:\n    def isUnderscoreWalletOwner(_user: address, _caller: address, _mc: address = empty(address)) -> bool: view\n\ninterface VaultBook:\n    def getAddr(_vaultId: uint256) -> address: view\n\nstruct AuctionBuyConfig:\n    canBuyInAuctionGeneral: bool\n    canBuyInAuctionAsset: bool\n    isUserAllowed: bool\n    canAnyoneDeposit: bool\n\nstruct UserBorrowTerms:\n    collateralVal: uint256\n    totalMaxDebt: uint256\n    debtTerms: cs.DebtTerms\n\nstruct UserDebt:\n    amount: uint256\n    principal: uint256\n    debtTerms: cs.DebtTerms\n    lastTimestamp: uint256\n    inLiquidation: bool\n\nstruct VaultData:\n    vaultId: uint256\n    vaultAddr: address\n    asset: address\n\nstruct GenLiqConfig:\n    canLiquidate: bool\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    ltvPaybackBuffer: uint256\n    genAuctionParams: cs.AuctionParams\n    priorityLiqAssetVaults: DynArray[VaultData, PRIORITY_LIQ_VAULT_DATA]\n    priorityStabVaults: DynArray[VaultData, MAX_STAB_VAULT_DATA]\n\nstruct AssetLiqConfig:\n    hasConfig: bool\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    customAuctionParams: cs.AuctionParams\n    specialStabPool: VaultData\n\nstruct FungibleAuction:\n    liqUser: address\n    vaultId: uint256\n    asset: address \n    startDiscount: uint256\n    maxDiscount: uint256\n    startBlock: uint256\n    endBlock: uint256\n    isActive: bool\n\nstruct FungAuctionPurchase:\n    liqUser: address\n    vaultId: uint256\n    asset: address\n    maxGreenAmount: uint256\n\nstruct FungAuctionConfig:\n    liqUser: address\n    vaultId: uint256\n    asset: address\n\nevent LiquidateUser:\n    user: indexed(address)\n    totalLiqFees: uint256\n    targetRepayAmount: uint256\n    repayAmount: uint256\n    didRestoreDebtHealth: bool\n    collateralValueOut: uint256\n    liqFeesUnpaid: uint256\n    numAuctionsStarted: uint256\n    keeperFee: uint256\n\nevent CollateralSentToEndaoment:\n    liqUser: indexed(address)\n    vaultId: uint256\n    liqAsset: indexed(address)\n    amountSent: uint256\n    usdValue: uint256\n    isDepleted: bool\n\nevent StabAssetBurntAsRepayment:\n    liqUser: indexed(address)\n    vaultId: uint256\n    liqStabAsset: indexed(address)\n    amountBurned: uint256\n    usdValue: uint256\n    isDepleted: bool\n\nevent CollateralSwappedWithStabPool:\n    liqUser: indexed(address)\n    liqVaultId: uint256\n    liqAsset: indexed(address)\n    collateralAmountOut: uint256\n    collateralValueOut: uint256\n    stabVaultId: uint256\n    stabAsset: indexed(address)\n    assetSwapped: address\n    amountSwapped: uint256\n    valueSwapped: uint256\n\nevent FungibleAuctionUpdated:\n    liqUser: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    startDiscount: uint256\n    maxDiscount: uint256\n    startBlock: uint256\n    endBlock: uint256\n    isNewAuction: bool\n\nevent FungibleAuctionPaused:\n    liqUser: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n\nevent FungAuctionPurchased:\n    liqUser: indexed(address)\n    liqVaultId: uint256\n    liqAsset: indexed(address)\n    greenSpent: uint256\n    recipient: indexed(address)\n    caller: address\n    collateralAmountSent: uint256\n    collateralUsdValueSent: uint256\n    isPositionDepleted: bool\n    hasGoodDebtHealth: bool\n\n# cache\nvaultAddrs: transient(HashMap[uint256, address]) # vaultId -> vaultAddr\nassetLiqConfig: transient(HashMap[address, AssetLiqConfig]) # asset -> config\ndidHandleLiqAsset: transient(HashMap[address, HashMap[uint256, HashMap[address, bool]]]) # user -> vaultId -> asset -> did handle\ndidHandleVaultId: transient(HashMap[address, HashMap[uint256, bool]]) # user -> vaultId -> did handle\nnumUserAssetsForAuction: transient(HashMap[address, uint256]) # user -> num assets\nuserAssetForAuction: transient(HashMap[address, HashMap[uint256, VaultData]]) # user -> index -> asset\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nONE_PERCENT: constant(uint256) = 1_00 # 1%\nMAX_STAB_VAULT_DATA: constant(uint256) = 10\nPRIORITY_LIQ_VAULT_DATA: constant(uint256) = 20\nMAX_LIQ_USERS: constant(uint256) = 50\nMAX_AUCTIONS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, True, False) # can mint green (keeper rewards)\n\n\n###############\n# Liquidation #\n###############\n\n\n@external\ndef liquidateUser(\n    _liqUser: address,\n    _keeper: address,\n    _wantsSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n    assert config.canLiquidate # dev: cannot liquidate\n\n    # liquidate user\n    keeperRewards: uint256 = self._liquidateUser(_liqUser, config, a)\n\n    # handle keeper rewards\n    if keeperRewards != 0:\n        self._handleGreenForUser(_keeper, keeperRewards, True, _wantsSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return keeperRewards\n\n\n@external\ndef liquidateManyUsers(\n    _liqUsers: DynArray[address, MAX_LIQ_USERS],\n    _keeper: address,\n    _wantsSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n    assert config.canLiquidate # dev: cannot liquidate\n\n    totalKeeperRewards: uint256 = 0\n    for liqUser: address in _liqUsers:\n        totalKeeperRewards += self._liquidateUser(liqUser, config, a)\n\n    # handle keeper rewards\n    if totalKeeperRewards != 0:\n        self._handleGreenForUser(_keeper, totalKeeperRewards, True, _wantsSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return totalKeeperRewards\n\n\n@internal\ndef _liquidateUser(\n    _liqUser: address,\n    _config: GenLiqConfig,\n    _a: addys.Addys,\n) -> uint256:\n    if _liqUser == empty(address):\n        return 0\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    newInterest: uint256 = 0\n    userDebt, bt, newInterest = staticcall CreditEngine(_a.creditEngine).getLatestUserDebtAndTerms(_liqUser, True, _a)\n\n    # no debt\n    if userDebt.amount == 0:\n        return 0\n\n    # already in liquidation\n    if userDebt.inLiquidation:\n        return 0\n\n    # user has debt but no liquidation threshold - cannot liquidate\n    if bt.debtTerms.liqThreshold == 0:\n        return 0\n\n    # not reached liquidation threshold\n    collateralLiqThreshold: uint256 = userDebt.amount * HUNDRED_PERCENT // bt.debtTerms.liqThreshold\n    if bt.collateralVal > collateralLiqThreshold:\n        return 0\n\n    # set liquidation mode\n    userDebt.inLiquidation = True\n\n    # liquidation fees\n    totalLiqFees: uint256 = userDebt.amount * bt.debtTerms.liqFee // HUNDRED_PERCENT\n    liqFeeRatio: uint256 = bt.debtTerms.liqFee\n\n    # keeper fee (for liquidator)\n    keeperFee: uint256 = max(_config.minKeeperFee, userDebt.amount * _config.keeperFeeRatio // HUNDRED_PERCENT)\n    if keeperFee != 0 and _config.maxKeeperFee != 0:\n        keeperFee = min(keeperFee, _config.maxKeeperFee)\n\n    if keeperFee != 0:\n        totalLiqFees += keeperFee\n        liqFeeRatio = totalLiqFees * HUNDRED_PERCENT // userDebt.amount\n\n    # how much to achieve safe LTV - use single robust formula for all liquidation types\n    targetLtv: uint256 = bt.debtTerms.ltv * (HUNDRED_PERCENT - _config.ltvPaybackBuffer) // HUNDRED_PERCENT\n    targetRepayAmount: uint256 = self._calcTargetRepayAmount(userDebt.amount, bt.collateralVal, targetLtv, liqFeeRatio)\n\n    # perform liquidation phases\n    repayValueIn: uint256 = 0\n    collateralValueOut: uint256 = 0\n    repayValueIn, collateralValueOut = self._performLiquidationPhases(_liqUser, targetRepayAmount, liqFeeRatio, _config, _a)\n\n    # check if liq fees were already covered (stability pool swaps)\n    liqFeesUnpaid: uint256 = totalLiqFees\n    if collateralValueOut > repayValueIn:\n        paidLiqFees: uint256 = collateralValueOut - repayValueIn\n        liqFeesUnpaid -= min(paidLiqFees, liqFeesUnpaid)\n\n    # repayValueIn may be zero, but need to update debt\n    userDebt.amount += liqFeesUnpaid\n    repayValueIn = min(repayValueIn, userDebt.amount)\n    didRestoreDebtHealth: bool = extcall CreditEngine(_a.creditEngine).repayDuringLiquidation(_liqUser, userDebt, repayValueIn, newInterest, _a)\n\n    # start auctions (if necessary)\n    numAuctionsStarted: uint256 = 0\n    if not didRestoreDebtHealth:\n        numAuctionsStarted = self._startAuctionsDuringLiq(_liqUser, _config.genAuctionParams, _a.missionControl, _a.ledger)\n\n    log LiquidateUser(\n        user=_liqUser,\n        totalLiqFees=totalLiqFees,\n        targetRepayAmount=targetRepayAmount,\n        repayAmount=repayValueIn,\n        didRestoreDebtHealth=didRestoreDebtHealth,\n        collateralValueOut=collateralValueOut,\n        liqFeesUnpaid=liqFeesUnpaid,\n        numAuctionsStarted=numAuctionsStarted,\n        keeperFee=keeperFee,\n    )\n    return keeperFee\n\n\n########################\n# Liquidation - Phases #\n########################\n\n\n@internal\ndef _performLiquidationPhases(\n    _liqUser: address,\n    _targetRepayAmount: uint256,\n    _liqFeeRatio: uint256,\n    _config: GenLiqConfig,\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    remainingToRepay: uint256 = _targetRepayAmount\n    collateralValueOut: uint256 = 0\n\n    # PHASE 1 -- If liq user is in stability pool, use those assets first to pay off debt\n\n    for stabPool: VaultData in _config.priorityStabVaults:\n        if remainingToRepay == 0:\n            break\n\n        if not staticcall Ledger(_a.ledger).isParticipatingInVault(_liqUser, stabPool.vaultId):\n            continue\n\n        remainingToRepay, collateralValueOut = self._iterateThruAssetsWithinVault(_liqUser, stabPool.vaultId, stabPool.vaultAddr, remainingToRepay, collateralValueOut, _liqFeeRatio, [], _a)\n        if self.vaultAddrs[stabPool.vaultId] == empty(address):\n            self.vaultAddrs[stabPool.vaultId] = stabPool.vaultAddr # cache\n\n    # PHASE 2 -- Go thru priority liq assets (set in mission control)\n\n    if remainingToRepay != 0:\n        for pData: VaultData in _config.priorityLiqAssetVaults:\n            if remainingToRepay == 0:\n                break\n\n            if not staticcall Vault(pData.vaultAddr).doesUserHaveBalance(_liqUser, pData.asset):\n                continue\n\n            remainingToRepay, collateralValueOut = self._handleSpecificLiqAsset(_liqUser, pData.vaultId, pData.vaultAddr, pData.asset, remainingToRepay, collateralValueOut, _liqFeeRatio, _config.priorityStabVaults, _a)\n            if self.vaultAddrs[pData.vaultId] == empty(address):\n                self.vaultAddrs[pData.vaultId] = pData.vaultAddr # cache\n\n    # PHASE 3 -- Go thru user's vaults (top to bottom as saved in ledger / vaults)\n\n    if remainingToRepay != 0:\n        remainingToRepay, collateralValueOut = self._iterateThruAllUserVaults(_liqUser, remainingToRepay, collateralValueOut, _liqFeeRatio, _config.priorityStabVaults, _a)\n\n    return _targetRepayAmount - remainingToRepay, collateralValueOut\n\n\n#################################\n# Liquidation - All User Vaults #\n#################################\n\n\n@internal\ndef _iterateThruAllUserVaults(\n    _liqUser: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _liqFeeRatio: uint256,\n    _genStabPools: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # iterate thru each user vault\n    numUserVaults: uint256 = staticcall Ledger(_a.ledger).numUserVaults(_liqUser)\n    for i: uint256 in range(1, numUserVaults, bound=max_value(uint256)):\n        if remainingToRepay == 0:\n            break\n\n        vaultId: uint256 = staticcall Ledger(_a.ledger).userVaults(_liqUser, i)\n\n        # get vault address\n        vaultAddr: address = empty(address)\n        isVaultAddrCached: bool = False\n        vaultAddr, isVaultAddrCached = self._getVaultAddr(vaultId, _a.vaultBook)\n        if vaultAddr == empty(address):\n            continue\n\n        # cache vault addr\n        if not isVaultAddrCached:\n            self.vaultAddrs[vaultId] = vaultAddr\n\n        remainingToRepay, collateralValueOut = self._iterateThruAssetsWithinVault(_liqUser, vaultId, vaultAddr, remainingToRepay, collateralValueOut, _liqFeeRatio, _genStabPools, _a)\n\n    return remainingToRepay, collateralValueOut\n\n\n#####################################\n# Liquidation - Assets Within Vault #\n#####################################\n\n\n@internal\ndef _iterateThruAssetsWithinVault(\n    _liqUser: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _liqFeeRatio: uint256,\n    _genStabPools: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _a: addys.Addys,\n) -> (uint256, uint256):\n\n    # check if we've already handled this vault\n    if self.didHandleVaultId[_liqUser][_vaultId]:\n        return _remainingToRepay, _collateralValueOut\n    self.didHandleVaultId[_liqUser][_vaultId] = True\n\n    # no assets in vault, skip\n    numUserAssets: uint256 = staticcall Vault(_vaultAddr).numUserAssets(_liqUser)\n    if numUserAssets == 0:\n        return _remainingToRepay, _collateralValueOut\n\n    # totals\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n    for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n        if remainingToRepay == 0:\n            break\n\n        # check if user still has balance in this asset\n        liqAsset: address = empty(address)\n        hasBalance: bool = False\n        liqAsset, hasBalance = staticcall Vault(_vaultAddr).getUserAssetAtIndexAndHasBalance(_liqUser, y)\n        if liqAsset == empty(address) or not hasBalance:\n            continue\n\n        # handle specific liq asset\n        remainingToRepay, collateralValueOut = self._handleSpecificLiqAsset(_liqUser, _vaultId, _vaultAddr, liqAsset, remainingToRepay, collateralValueOut, _liqFeeRatio, _genStabPools, _a)\n\n    return remainingToRepay, collateralValueOut\n\n\n################################\n# Liquidation - Specific Asset #\n################################\n\n\n@internal\ndef _handleSpecificLiqAsset(\n    _liqUser: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _liqAsset: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _liqFeeRatio: uint256,\n    _genStabPools: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _a: addys.Addys,\n) -> (uint256, uint256):\n\n    # check if we've already handled this liq asset (cache for next time)\n    if self.didHandleLiqAsset[_liqUser][_vaultId][_liqAsset]:\n        return _remainingToRepay, _collateralValueOut\n    self.didHandleLiqAsset[_liqUser][_vaultId][_liqAsset] = True\n\n    # asset liq config\n    config: AssetLiqConfig = empty(AssetLiqConfig)\n    isConfigCached: bool = False\n    config, isConfigCached = self._getAssetLiqConfig(_liqAsset, _a.missionControl)\n    if not isConfigCached:\n        self.assetLiqConfig[_liqAsset] = config\n\n    # totals\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # burn as payment (GREEN, sGREEN)\n    if config.shouldBurnAsPayment and _liqAsset in [_a.greenToken, _a.savingsGreen]:\n        remainingToRepay, collateralValueOut = self._burnLiqUserStabAsset(_liqUser, _vaultId, _vaultAddr, _liqAsset, remainingToRepay, collateralValueOut, _a)\n        return remainingToRepay, collateralValueOut\n\n    # endaoment wants this asset (other stablecoins)\n    if config.shouldTransferToEndaoment:\n        remainingToRepay, collateralValueOut = self._transferToEndaoment(_liqUser, _vaultId, _vaultAddr, _liqAsset, remainingToRepay, collateralValueOut, _a)\n        return remainingToRepay, collateralValueOut\n\n    # stability pool swaps (eth, btc, etc)\n    isPositionDepleted: bool = False\n    if config.shouldSwapInStabPools:\n        remainingToRepay, collateralValueOut, isPositionDepleted = self._swapWithStabPools(_liqUser, _vaultId, _vaultAddr, _liqAsset, _liqFeeRatio, remainingToRepay, collateralValueOut, config.specialStabPool, _genStabPools, _a)\n\n    # add to auction list if not depleted\n    if config.shouldAuctionInstantly and not isPositionDepleted:\n        self._saveLiqAssetForAuction(_liqUser, _vaultId, _vaultAddr, _liqAsset)\n\n    return remainingToRepay, collateralValueOut\n\n\n####################################\n# Liquidation - Endaoment Transfer #\n####################################\n\n\n@internal\ndef _transferToEndaoment(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    collateralUsdValueSent: uint256 = 0\n    collateralAmountSent: uint256 = 0\n    isPositionDepleted: bool = False\n    na: bool = False\n    collateralUsdValueSent, collateralAmountSent, isPositionDepleted, na = self._transferCollateral(_liqUser, _a.endaoment, _liqVaultId, _liqVaultAddr, _liqAsset, False, remainingToRepay, _a)\n    if collateralUsdValueSent == 0:\n        return remainingToRepay, collateralValueOut\n\n    # update totals\n    remainingToRepay -= min(collateralUsdValueSent, remainingToRepay)\n    collateralValueOut += collateralUsdValueSent\n\n    log CollateralSentToEndaoment(\n        liqUser=_liqUser,\n        vaultId=_liqVaultId,\n        liqAsset=_liqAsset,\n        amountSent=collateralAmountSent,\n        usdValue=collateralUsdValueSent,\n        isDepleted=isPositionDepleted,\n    )\n    return remainingToRepay, collateralValueOut\n\n\n#################################\n# Liquidation - Burn Stab Asset #\n#################################\n\n\n@internal\ndef _burnLiqUserStabAsset(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqStabAsset: address,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    usdValue: uint256 = 0\n    amountReceived: uint256 = 0\n    isPositionDepleted: bool = False\n    na: bool = False\n    usdValue, amountReceived, isPositionDepleted, na = self._transferCollateral(_liqUser, self, _liqVaultId, _liqVaultAddr, _liqStabAsset, False, remainingToRepay, _a)\n    if usdValue == 0:\n        return remainingToRepay, collateralValueOut\n\n    # burn stab asset\n    if _liqStabAsset == _a.savingsGreen:\n        greenAmount: uint256 = extcall IERC4626(_a.savingsGreen).redeem(amountReceived, self, self) # dev: savings green redeem failed\n        assert extcall GreenToken(_a.greenToken).burn(greenAmount) # dev: failed to burn green\n    else:\n        assert extcall GreenToken(_a.greenToken).burn(amountReceived) # dev: failed to burn green\n\n    # update totals\n    remainingToRepay -= min(usdValue, remainingToRepay)\n    collateralValueOut += usdValue\n\n    log StabAssetBurntAsRepayment(\n        liqUser=_liqUser,\n        vaultId=_liqVaultId,\n        liqStabAsset=_liqStabAsset,\n        amountBurned=amountReceived,\n        usdValue=usdValue,\n        isDepleted=isPositionDepleted,\n    )\n    return remainingToRepay, collateralValueOut\n\n\n######################################\n# Liquidation - Stability Pool Swaps #\n######################################\n\n\n# iterate thru stab pools\n\n\n@internal\ndef _swapWithStabPools(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _liqFeeRatio: uint256,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _specialStabPool: VaultData,\n    _genStabPools: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _a: addys.Addys,\n) -> (uint256, uint256, bool):\n\n    # stability pools to use\n    stabPoolsToUse: DynArray[VaultData, MAX_STAB_VAULT_DATA] = _genStabPools\n    if _specialStabPool.vaultAddr != empty(address):\n        stabPoolsToUse = [_specialStabPool]\n\n    # nothing to do here\n    if len(stabPoolsToUse) == 0:\n        return _remainingToRepay, _collateralValueOut, False\n\n    # totals\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # iterate thru each stab pool\n    isPositionDepleted: bool = False\n    for stabPool: VaultData in stabPoolsToUse:\n        if remainingToRepay == 0:\n            break\n\n        # swap with stability pool\n        shouldGoToNextAsset: bool = False\n        remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset = self._swapWithSpecificStabPool(stabPool, _liqUser, _liqVaultId, _liqVaultAddr, _liqAsset, _liqFeeRatio, remainingToRepay, collateralValueOut, _a)\n\n        # nothing else to do here\n        if isPositionDepleted or shouldGoToNextAsset:\n            break\n\n    return remainingToRepay, collateralValueOut, isPositionDepleted\n\n\n# individual stability pool swap\n\n\n@internal\ndef _swapWithSpecificStabPool(\n    _stabPool: VaultData,\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _liqFeeRatio: uint256,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool, bool):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # cannot liquidate asset that is also a stability pool asset in that vault\n    if staticcall Vault(_stabPool.vaultAddr).isSupportedVaultAsset(_liqAsset):\n        return remainingToRepay, collateralValueOut, False, False\n\n    # check for green redemptions for this stab asset\n    isPositionDepleted: bool = False\n    shouldGoToNextAsset: bool = False\n    remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset = self._swapWithGreenRedemptions(_stabPool, _liqUser, _liqVaultId, _liqVaultAddr, _liqAsset, _liqFeeRatio, remainingToRepay, collateralValueOut, _a)\n    if remainingToRepay == 0 or isPositionDepleted or shouldGoToNextAsset:\n        return remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset\n\n    # no balance in stability pool, skip\n    maxAmountInStabPool: uint256 = staticcall IERC20(_stabPool.asset).balanceOf(_stabPool.vaultAddr)\n    if maxAmountInStabPool == 0:\n        return remainingToRepay, collateralValueOut, False, False\n\n    # max usd value in stability pool\n    maxUsdValueInStabPool: uint256 = self._getUsdValue(_stabPool.asset, maxAmountInStabPool, _a.greenToken, _a.savingsGreen, _a.priceDesk)  \n    if maxUsdValueInStabPool == 0:\n        return remainingToRepay, collateralValueOut, False, False # can't get price of stab asset, skip      \n\n    # where to move stab asset\n    stabProceedsAddr: address = _a.endaoment # non-green assets, move to Endaoment\n    if _stabPool.asset in [_a.greenToken, _a.savingsGreen]:\n        stabProceedsAddr = empty(address)\n\n    # swap with stability pool\n    return self._swapAssetsWithStabPool(True, _liqUser, _liqVaultId, _liqVaultAddr, _liqAsset, _liqFeeRatio, maxAmountInStabPool, maxUsdValueInStabPool, remainingToRepay, collateralValueOut, _stabPool, stabProceedsAddr, _a)\n\n\n@view\n@internal\ndef _getUsdValue(\n    _asset: address,\n    _amount: uint256,\n    _greenToken: address,\n    _savingsGreen: address,\n    _priceDesk: address,\n) -> uint256:\n    usdValue: uint256 = 0\n    if _asset == _greenToken:\n        usdValue = _amount\n    elif _asset == _savingsGreen:\n        usdValue = staticcall IERC4626(_savingsGreen).convertToAssets(_amount)\n    else:\n        usdValue = staticcall PriceDesk(_priceDesk).getUsdValue(_asset, _amount, True)\n    return usdValue\n\n\n@internal\ndef _swapWithGreenRedemptions(\n    _stabPool: VaultData,\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _liqFeeRatio: uint256,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool, bool):\n    maxClaimableGreen: uint256 = staticcall StabilityPool(_stabPool.vaultAddr).claimableBalances(_stabPool.asset, _a.greenToken)\n    if maxClaimableGreen == 0:\n        return _remainingToRepay, _collateralValueOut, False, False\n    return self._swapAssetsWithStabPool(False, _liqUser, _liqVaultId, _liqVaultAddr, _liqAsset, _liqFeeRatio, maxClaimableGreen, maxClaimableGreen, _remainingToRepay, _collateralValueOut, _stabPool, empty(address), _a)\n\n\n@internal\ndef _swapAssetsWithStabPool(\n    _isNormalStabSwap: bool,\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqVaultAddr: address,\n    _liqAsset: address,\n    _liqFeeRatio: uint256,\n    _maxAmountInStabPool: uint256,\n    _maxUsdValueInStabPool: uint256,\n    _remainingToRepay: uint256,\n    _collateralValueOut: uint256,\n    _stabPool: VaultData,\n    _stabProceedsAddr: address,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool, bool):\n    remainingToRepay: uint256 = _remainingToRepay\n    collateralValueOut: uint256 = _collateralValueOut\n\n    # max collateral usd value (to take from liq user)\n    maxCollateralUsdValue: uint256 = min(_maxUsdValueInStabPool, remainingToRepay) * HUNDRED_PERCENT // (HUNDRED_PERCENT - _liqFeeRatio)\n\n    # transfer collateral to stability pool\n    collateralUsdValueSent: uint256 = 0\n    collateralAmountSent: uint256 = 0\n    isPositionDepleted: bool = False\n    shouldGoToNextAsset: bool = False\n    collateralUsdValueSent, collateralAmountSent, isPositionDepleted, shouldGoToNextAsset = self._transferCollateral(_liqUser, _stabPool.vaultAddr, _liqVaultId, _liqVaultAddr, _liqAsset, False, maxCollateralUsdValue, _a)\n    if collateralUsdValueSent == 0 or collateralAmountSent == 0:\n        return remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset\n\n    # calc target stab pool values\n    targetStabPoolUsdValue: uint256 = collateralUsdValueSent * (HUNDRED_PERCENT - _liqFeeRatio) // HUNDRED_PERCENT\n    targetStabPoolAmount: uint256 = targetStabPoolUsdValue * _maxAmountInStabPool // _maxUsdValueInStabPool\n\n    # take asset out of stability pool\n    stabPoolAmount: uint256 = 0\n    assetSwapped: address = empty(address)\n    if _isNormalStabSwap:\n        stabPoolAmount = extcall StabilityPool(_stabPool.vaultAddr).swapForLiquidatedCollateral(_stabPool.asset, targetStabPoolAmount, _liqAsset, collateralAmountSent, _stabProceedsAddr, _a.greenToken, _a.savingsGreen)\n        assetSwapped = _stabPool.asset\n    else:\n        stabPoolAmount = extcall StabilityPool(_stabPool.vaultAddr).swapWithClaimableGreen(_stabPool.asset, targetStabPoolAmount, _liqAsset, collateralAmountSent, _a.greenToken)\n        assetSwapped = _a.greenToken\n\n    # verify it's a fair swap\n    assert self._isPaymentCloseEnough(targetStabPoolAmount, stabPoolAmount) # dev: invalid stability pool swap\n\n    # update overall values\n    stabValueSwapped: uint256 = _maxUsdValueInStabPool * stabPoolAmount // _maxAmountInStabPool\n    remainingToRepay -= min(stabValueSwapped, remainingToRepay)\n    collateralValueOut += collateralUsdValueSent\n\n    log CollateralSwappedWithStabPool(\n        liqUser=_liqUser,\n        liqVaultId=_liqVaultId,\n        liqAsset=_liqAsset,\n        collateralAmountOut=collateralAmountSent,\n        collateralValueOut=collateralUsdValueSent,\n        stabVaultId=_stabPool.vaultId,\n        stabAsset=_stabPool.asset,\n        assetSwapped=assetSwapped,\n        amountSwapped=stabPoolAmount,\n        valueSwapped=stabValueSwapped,\n    )\n    return remainingToRepay, collateralValueOut, isPositionDepleted, shouldGoToNextAsset\n\n\n######################\n# Auction Initiation #\n######################\n\n\n# start during liquidation\n\n\n@internal\ndef _startAuctionsDuringLiq(\n    _liqUser: address,\n    _genAuctionParams: cs.AuctionParams,\n    _missionControl: address,\n    _ledger: address,\n) -> uint256:\n    numAssets: uint256 = self.numUserAssetsForAuction[_liqUser]\n    if numAssets == 0:\n        return 0\n\n    numAuctionsStarted: uint256 = 0\n    for i: uint256 in range(numAssets, bound=max_value(uint256)):\n        d: VaultData = self.userAssetForAuction[_liqUser][i]\n        didCreateAuction: bool = self._createOrUpdateFungAuction(_liqUser, d.vaultId, d.asset, False, _genAuctionParams, _missionControl, _ledger)\n        if didCreateAuction:\n            numAuctionsStarted += 1\n\n    return numAuctionsStarted\n\n\n# start / restart (via mission control)\n\n\n@external\ndef startAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    genParams: cs.AuctionParams = staticcall MissionControl(a.missionControl).getGenAuctionParams()\n    return self._startAuction(_liqUser, _liqVaultId, _liqAsset, genParams, a)\n\n\n@external\ndef startManyAuctions(\n    _auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS],\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    genParams: cs.AuctionParams = staticcall MissionControl(a.missionControl).getGenAuctionParams()\n    numAuctionsStarted: uint256 = 0\n    for auc: FungAuctionConfig in _auctions:\n        didStart: bool = self._startAuction(auc.liqUser, auc.vaultId, auc.asset, genParams, a)\n        if didStart:\n            numAuctionsStarted += 1\n\n    return numAuctionsStarted\n\n\n@internal\ndef _startAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _genParams: cs.AuctionParams,\n    _a: addys.Addys,\n) -> bool:\n    if not self._canStartAuction(_liqUser, _liqVaultId, _liqAsset, _a.vaultBook, _a.ledger):\n        return False\n    hasAuction: bool = staticcall Ledger(_a.ledger).hasFungibleAuction(_liqUser, _liqVaultId, _liqAsset)\n    return self._createOrUpdateFungAuction(_liqUser, _liqVaultId, _liqAsset, hasAuction, _genParams, _a.missionControl, _a.ledger)\n\n\n# validation\n\n\n@view\n@external\ndef canStartAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n) -> bool:\n    a: addys.Addys = addys._getAddys()\n    return self._canStartAuction(_liqUser, _liqVaultId, _liqAsset, a.vaultBook, a.ledger)\n\n\n@view\n@internal\ndef _canStartAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _vaultBook: address,\n    _ledger: address,\n) -> bool:\n    vaultAddr: address = staticcall VaultBook(_vaultBook).getAddr(_liqVaultId)\n    if vaultAddr == empty(address):\n        return False\n    if not staticcall Vault(vaultAddr).doesUserHaveBalance(_liqUser, _liqAsset):\n        return False\n    return staticcall Ledger(_ledger).isUserInLiquidation(_liqUser)\n\n\n# create auction\n\n\n@internal\ndef _createOrUpdateFungAuction(\n    _liqUser: address,\n    _vaultId: uint256,\n    _asset: address,\n    _alreadyExists: bool,\n    _genAuctionParams: cs.AuctionParams,\n    _missionControl: address,\n    _ledger: address,\n) -> bool:\n\n    # get asset liq config\n    config: AssetLiqConfig = empty(AssetLiqConfig)\n    isConfigCached: bool = False\n    config, isConfigCached = self._getAssetLiqConfig(_asset, _missionControl)\n    if not isConfigCached:\n        self.assetLiqConfig[_asset] = config # cache\n\n    # finalize auction params\n    params: cs.AuctionParams = _genAuctionParams\n    if config.customAuctionParams.hasParams:\n        params = config.customAuctionParams\n\n    startBlock: uint256 = block.number + params.delay\n    endBlock: uint256 = startBlock + params.duration\n    auctionData: FungibleAuction = FungibleAuction(\n        liqUser=_liqUser,\n        vaultId=_vaultId,\n        asset=_asset,\n        startDiscount=params.startDiscount,\n        maxDiscount=params.maxDiscount,\n        startBlock=startBlock,\n        endBlock=endBlock,\n        isActive=True,\n    )\n\n    # update existing auction data\n    if _alreadyExists:\n        assert extcall Ledger(_ledger).setFungibleAuction(_liqUser, _vaultId, _asset, auctionData) # dev: failed to set auction\n\n    # create new auction\n    else:\n        aid: uint256 = extcall Ledger(_ledger).createNewFungibleAuction(auctionData)\n        if aid == 0:\n            return False # fail gracefully, though this should never happen\n\n    log FungibleAuctionUpdated(\n        liqUser=_liqUser,\n        vaultId=_vaultId,\n        asset=_asset,\n        startDiscount=params.startDiscount,\n        maxDiscount=params.maxDiscount,\n        startBlock=startBlock,\n        endBlock=endBlock,\n        isNewAuction=not _alreadyExists,\n    )\n    return True\n\n\n# pause\n\n\n@external\ndef pauseAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    return self._pauseAuction(_liqUser, _liqVaultId, _liqAsset, a.ledger)\n\n\n@external\ndef pauseManyAuctions(\n    _auctions: DynArray[FungAuctionConfig, MAX_AUCTIONS],\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    numAuctionsPaused: uint256 = 0\n    for auc: FungAuctionConfig in _auctions:\n        didPause: bool = self._pauseAuction(auc.liqUser, auc.vaultId, auc.asset, a.ledger)\n        if didPause:\n            numAuctionsPaused += 1\n\n    return numAuctionsPaused\n\n\n@internal\ndef _pauseAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _ledger: address,\n) -> bool:\n    auc: FungibleAuction = staticcall Ledger(_ledger).getFungibleAuctionDuringPurchase(_liqUser, _liqVaultId, _liqAsset)\n    if not auc.isActive:\n        return False\n\n    auc.isActive = False\n    assert extcall Ledger(_ledger).setFungibleAuction(_liqUser, _liqVaultId, _liqAsset, auc) # dev: failed to set auction\n    log FungibleAuctionPaused(\n        liqUser=_liqUser,\n        vaultId=_liqVaultId,\n        asset=_liqAsset,\n    )\n    return True\n\n\n################\n# Buy Auctions #\n################\n\n\n@external\ndef buyFungibleAuction(\n    _liqUser: address,\n    _vaultId: uint256,\n    _asset: address,\n    _greenAmount: uint256,\n    _recipient: address,\n    _caller: address,\n    _shouldTransferBalance: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    greenAmount: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert greenAmount != 0 # dev: no green to spend\n    greenSpent: uint256 = self._buyFungibleAuction(_liqUser, _vaultId, _asset, max_value(uint256), greenAmount, _recipient, _caller, _shouldTransferBalance, a)\n    assert greenSpent != 0 # dev: no green spent\n\n    # handle leftover green\n    if greenAmount > greenSpent:\n        self._handleGreenForUser(_caller, greenAmount - greenSpent, False, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return greenSpent\n\n\n@external\ndef buyManyFungibleAuctions(\n    _purchases: DynArray[FungAuctionPurchase, MAX_AUCTIONS],\n    _greenAmount: uint256,\n    _recipient: address,\n    _caller: address,\n    _shouldTransferBalance: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    totalGreenSpent: uint256 = 0\n    totalGreenRemaining: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert totalGreenRemaining != 0 # dev: no green to spend\n\n    for p: FungAuctionPurchase in _purchases:\n        if totalGreenRemaining == 0:\n            break\n        greenSpent: uint256 = self._buyFungibleAuction(p.liqUser, p.vaultId, p.asset, p.maxGreenAmount, totalGreenRemaining, _recipient, _caller, _shouldTransferBalance, a)\n        totalGreenRemaining -= greenSpent\n        totalGreenSpent += greenSpent\n\n    assert totalGreenSpent != 0 # dev: no green spent\n\n    # handle leftover green\n    if totalGreenRemaining != 0:\n        self._handleGreenForUser(_caller, totalGreenRemaining, False, _shouldRefundSavingsGreen, a.greenToken, a.savingsGreen)\n\n    return totalGreenSpent\n\n\n@internal\ndef _buyFungibleAuction(\n    _liqUser: address,\n    _liqVaultId: uint256,\n    _liqAsset: address,\n    _maxGreenForAsset: uint256,\n    _totalGreenRemaining: uint256,\n    _recipient: address,\n    _caller: address,\n    _shouldTransferBalance: bool,\n    _a: addys.Addys,\n) -> uint256:\n\n    # NOTE: faililng gracefully in case there are many purchases at same time\n\n    # recipient cannot be user\n    if _liqUser == _recipient:\n        return 0\n\n    # this also verifies that user is in liquidation\n    auc: FungibleAuction = staticcall Ledger(_a.ledger).getFungibleAuctionDuringPurchase(_liqUser, _liqVaultId, _liqAsset)\n    if not auc.isActive:\n        return 0\n\n    # not within time boundaries, skip\n    if block.number < auc.startBlock or block.number >= auc.endBlock:\n        return 0\n\n    # check auction config\n    config: AuctionBuyConfig = staticcall MissionControl(_a.missionControl).getAuctionBuyConfig(_liqAsset, _recipient)\n    if not config.canBuyInAuctionGeneral or not config.canBuyInAuctionAsset or not config.isUserAllowed:\n        return 0\n\n    # make sure caller can deposit to recipient\n    if _recipient != _caller and not config.canAnyoneDeposit:\n        assert staticcall Teller(_a.teller).isUnderscoreWalletOwner(_recipient, _caller, _a.missionControl) # dev: not allowed to deposit for user\n\n    # finalize green amount\n    availGreen: uint256 = min(_totalGreenRemaining, staticcall IERC20(_a.greenToken).balanceOf(self))\n    greenAmount: uint256 = min(_maxGreenForAsset, availGreen)\n    if greenAmount == 0:\n        return 0\n\n    # calculate discount\n    auctionProgress: uint256 = (block.number - auc.startBlock) * HUNDRED_PERCENT // (auc.endBlock - auc.startBlock)\n    discount: uint256 = self._calculateAuctionDiscount(auctionProgress, auc.startDiscount, auc.maxDiscount)\n\n    # get vault addr\n    liqVaultAddr: address = staticcall VaultBook(_a.vaultBook).getAddr(_liqVaultId)\n    if liqVaultAddr == empty(address):\n        return 0\n\n    # max collateral usd value (to take from liq user)\n    maxCollateralUsdValue: uint256 = greenAmount * HUNDRED_PERCENT // (HUNDRED_PERCENT - discount)\n\n    # transfer collateral to buyer\n    collateralUsdValueSent: uint256 = 0\n    collateralAmountSent: uint256 = 0\n    isPositionDepleted: bool = False\n    shouldGoToNextAsset: bool = False\n    collateralUsdValueSent, collateralAmountSent, isPositionDepleted, shouldGoToNextAsset = self._transferCollateral(_liqUser, _recipient, _liqVaultId, liqVaultAddr, _liqAsset, _shouldTransferBalance, maxCollateralUsdValue, _a)\n    if collateralUsdValueSent == 0 or collateralAmountSent == 0:\n        return 0\n\n    # pay green amount, pay back debt\n    greenRequired: uint256 = collateralUsdValueSent * (HUNDRED_PERCENT - discount) // HUNDRED_PERCENT\n    greenSpent: uint256 = min(greenRequired, greenAmount)\n    assert extcall IERC20(_a.greenToken).transfer(_a.creditEngine, greenSpent, default_return_value=True) # dev: could not transfer\n    assert self._isPaymentCloseEnough(greenRequired, greenSpent) # dev: amounts do not match up\n    hasGoodDebtHealth: bool = extcall CreditEngine(_a.creditEngine).repayDuringAuctionPurchase(_liqUser, greenSpent, _a)\n\n    # disable auction (if depleted)\n    if isPositionDepleted and staticcall Ledger(_a.ledger).hasFungibleAuction(_liqUser, _liqVaultId, _liqAsset):\n        extcall Ledger(_a.ledger).removeFungibleAuction(_liqUser, _liqVaultId, _liqAsset)\n\n    log FungAuctionPurchased(\n        liqUser=_liqUser,\n        liqVaultId=_liqVaultId,\n        liqAsset=_liqAsset,\n        greenSpent=greenSpent,\n        recipient=_recipient,\n        caller=_caller,\n        collateralAmountSent=collateralAmountSent,\n        collateralUsdValueSent=collateralUsdValueSent,\n        isPositionDepleted=isPositionDepleted,\n        hasGoodDebtHealth=hasGoodDebtHealth,\n    )\n    return greenSpent\n\n\n@pure\n@internal\ndef _calculateAuctionDiscount(_progress: uint256, _startDiscount: uint256, _maxDiscount: uint256) -> uint256:\n    if _progress == 0 or _startDiscount == _maxDiscount:\n        return _startDiscount\n    discountRange: uint256 = _maxDiscount - _startDiscount\n    adjustment: uint256 =  _progress * discountRange // HUNDRED_PERCENT\n    return _startDiscount + adjustment\n\n\n#############\n# Utilities #\n#############\n\n\n# transfer collateral\n\n\n@internal\ndef _transferCollateral(\n    _fromUser: address,\n    _toUser: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _shouldTransferBalance: bool,\n    _targetUsdValue: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool, bool):\n    maxAssetAmount: uint256 = self._getAssetAmount(_asset, _targetUsdValue, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n    if maxAssetAmount == 0:\n        return 0, 0, False, True # skip if cannot get price for this asset\n\n    amountSent: uint256 = 0\n    isPositionDepleted: bool = False\n\n    # transfer balance within vault\n    if _shouldTransferBalance:\n        amountSent, isPositionDepleted = extcall Vault(_vaultAddr).transferBalanceWithinVault(_asset, _fromUser, _toUser, maxAssetAmount, _a)\n        extcall Ledger(_a.ledger).addVaultToUser(_toUser, _vaultId)\n        extcall LootBox(_a.lootbox).updateDepositPoints(_toUser, _vaultId, _vaultAddr, _asset, _a)\n\n    # withdraw and transfer to recipient\n    else:\n        amountSent, isPositionDepleted = extcall Vault(_vaultAddr).withdrawTokensFromVault(_fromUser, _asset, maxAssetAmount, _toUser, _a)\n\n    usdValue: uint256 = amountSent * _targetUsdValue // maxAssetAmount\n    return usdValue, amountSent, isPositionDepleted, isPositionDepleted\n\n\n@view\n@internal\ndef _getAssetAmount(\n    _asset: address,\n    _targetUsdValue: uint256,\n    _greenToken: address,\n    _savingsGreen: address,\n    _priceDesk: address,\n) -> uint256:\n    amount: uint256 = 0\n    if _asset == _greenToken:\n        amount = _targetUsdValue\n    elif _asset == _savingsGreen:\n        amount = staticcall IERC4626(_savingsGreen).convertToShares(_targetUsdValue)\n    else:\n        amount = staticcall PriceDesk(_priceDesk).getAssetAmount(_asset, _targetUsdValue, True)\n    return amount\n\n\n# green handling\n\n\n@internal\ndef _handleGreenForUser(\n    _recipient: address,\n    _greenAmount: uint256,\n    _needsMint: bool,\n    _wantsSavingsGreen: bool,\n    _greenToken: address,\n    _savingsGreen: address,\n):\n    # mint green\n    if _needsMint:\n        if not _wantsSavingsGreen:\n            extcall GreenToken(_greenToken).mint(_recipient, _greenAmount) # directly to recipient, exit\n            return\n        extcall GreenToken(_greenToken).mint(self, _greenAmount)\n\n    # finalize amount\n    amount: uint256 = min(_greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n    if amount == 0:\n        return\n\n    if _wantsSavingsGreen and amount > 10 ** 9: # small dust will fail\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, amount, default_return_value=True) # dev: green approval failed\n        extcall IERC4626(_savingsGreen).deposit(amount, _recipient)\n        assert extcall IERC20(_greenToken).approve(_savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n    else:\n        assert extcall IERC20(_greenToken).transfer(_recipient, amount, default_return_value=True) # dev: green transfer failed\n\n\n# is payment close enough\n\n\n@pure\n@internal\ndef _isPaymentCloseEnough(_requestedAmount: uint256, _actualAmount: uint256) -> bool:\n    # An extra safety check to make sure what was paid was actually close-ish to what was requested\n    buffer: uint256 = _requestedAmount * ONE_PERCENT // HUNDRED_PERCENT\n    upperBound: uint256 = _requestedAmount + buffer\n    lowerBound: uint256 = _requestedAmount - buffer\n    return upperBound >= _actualAmount and _actualAmount >= lowerBound\n\n\n# calc amount of debt to repay\n\n\n@view\n@external\ndef calcAmountOfDebtToRepayDuringLiq(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n\n    # user debt\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = staticcall CreditEngine(a.creditEngine).getLatestUserDebtAndTerms(_user, True, a)\n\n    # No debt to repay\n    if userDebt.amount == 0:\n        return 0\n\n    # liquidation fees\n    totalLiqFees: uint256 = userDebt.amount * bt.debtTerms.liqFee // HUNDRED_PERCENT\n    liqFeeRatio: uint256 = bt.debtTerms.liqFee\n\n    # keeper fee (for liquidator)\n    keeperFee: uint256 = max(config.minKeeperFee, userDebt.amount * config.keeperFeeRatio // HUNDRED_PERCENT)\n    if keeperFee != 0 and config.maxKeeperFee != 0:\n        keeperFee = min(keeperFee, config.maxKeeperFee)\n    if keeperFee != 0:\n        totalLiqFees += keeperFee\n        liqFeeRatio = totalLiqFees * HUNDRED_PERCENT // userDebt.amount\n\n    # calc amount of debt to repay using unified formula\n    targetLtv: uint256 = bt.debtTerms.ltv * (HUNDRED_PERCENT - config.ltvPaybackBuffer) // HUNDRED_PERCENT\n    return self._calcTargetRepayAmount(userDebt.amount, bt.collateralVal, targetLtv, liqFeeRatio)\n\n\n@pure\n@internal\ndef _calcTargetRepayAmount(\n    _debtAmount: uint256,\n    _collateralValue: uint256,\n    _targetLtv: uint256,\n    _liqFeeRatio: uint256,\n) -> uint256:\n    \"\"\"\n    Calculate the optimal debt repay amount to restore user to target LTV.\n\n    UNIFIED FORMULA FOR ALL LIQUIDATION TYPES\n    This function uses a single mathematical formula that works for both:\n    1. Stability pool swaps (where liquidation fees come from collateral-repay difference)\n    2. Claimable GREEN liquidations (where fees are added to debt)\n\n    MATHEMATICAL DERIVATION:\n    Goal: (newDebt) / (newCollateral) = targetLTV\n\n    For stability pool swaps:\n    - newDebt = originalDebt - repayAmount  \n    - newCollateral = originalCollateral - collateralTaken\n    - repayAmount = collateralTaken * (1 - liqFeeRatio)\n\n    Solving: R = (D - T*C) * (1-F) / (1 - F - T)\n    Where:\n    - R = repayAmount (what we solve for)\n    - D = _debtAmount  \n    - C = _collateralValue\n    - T = _targetLtv\n    - F = _liqFeeRatio\n\n    CONSERVATIVE NATURE:\n    This formula is conservative for claimable GREEN liquidations, meaning it may \n    repay slightly more debt than strictly necessary. This is INTENTIONAL because:\n    - It guarantees debt health restoration in all cases\n    - Over-repayment is safe (just makes user \"too healthy\")\n    - Under-repayment is dangerous (triggers unnecessary auctions)\n\n    TRADE-OFFS:\n    \u2705 Simple: One formula for all liquidation types\n    \u2705 Safe: Guarantees debt health restoration  \n    \u2705 Robust: Works for future liquidation mechanisms\n    \u274c Slightly over-conservative for claimable GREEN edge cases\n\n    PARAMETERS:\n    @param _debtAmount: User's current debt amount\n    @param _collateralValue: User's current collateral value in USD\n    @param _targetLtv: Target LTV to achieve (e.g., 49% for 50% max with 1% buffer)\n    @param _liqFeeRatio: Total liquidation fee ratio (liquidation fee + keeper fee)\n\n    @return: Amount of debt to repay to reach target LTV\n    \"\"\"\n\n    if _targetLtv == 0:\n        return _debtAmount # repay everything to achieve 0% LTV\n\n    # calculate denominator: (1 - F - T)\n    if HUNDRED_PERCENT <= _liqFeeRatio + _targetLtv:\n        return _debtAmount # edge case: F + T >= 100%, need full repayment\n\n    denominator: uint256 = HUNDRED_PERCENT - _liqFeeRatio - _targetLtv\n    if denominator == 0:\n        return _debtAmount\n\n    # calculate numerator: (D - T*C) * (1-F)\n    oneMinusF: uint256 = HUNDRED_PERCENT - _liqFeeRatio\n    debtValue: uint256 = _debtAmount * HUNDRED_PERCENT  \n    targetDebtValue: uint256 = _targetLtv * _collateralValue\n\n    # check if already at target LTV\n    if debtValue <= targetDebtValue:\n        return 0\n\n    # calculate numerator: (D*100% - T*C) * (1-F)\n    numerator: uint256 = (debtValue - targetDebtValue) * oneMinusF\n\n    # calculate repay amount: R = numerator / (denominator * HUNDRED_PERCENT)\n    return numerator // (denominator * HUNDRED_PERCENT)\n\n\n#########\n# Cache #\n#########\n\n\n@view\n@internal\ndef _getAssetLiqConfig(_asset: address, _missionControl: address) -> (AssetLiqConfig, bool):\n    config: AssetLiqConfig = self.assetLiqConfig[_asset]\n    if config.hasConfig:\n        return config, True\n    return staticcall MissionControl(_missionControl).getAssetLiqConfig(_asset), False\n\n\n@view\n@internal\ndef _getVaultAddr(_vaultId: uint256, _vaultBook: address) -> (address, bool):\n    vaultAddr: address = self.vaultAddrs[_vaultId]\n    if vaultAddr != empty(address):\n        return vaultAddr, True\n    return staticcall VaultBook(_vaultBook).getAddr(_vaultId), False\n\n\n@internal\ndef _saveLiqAssetForAuction(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address):\n    nextId: uint256 = self.numUserAssetsForAuction[_user]\n    self.userAssetForAuction[_user][nextId] = VaultData(vaultId=_vaultId, vaultAddr=_vaultAddr, asset=_asset)\n    self.numUserAssetsForAuction[_user] = nextId + 1\n",
            "sha256sum": "8d60efef0027455ee412a927c7e13ebbba562692ea1faec1d2c2dd5cfe0d831f"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AuctionHouse.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "2000e2ae5c7b15c0c6e47857014a71199d1d07fc797410e894d2c65ef8ff9f08"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/core/AuctionHouse.vy"
    },
    "AuctionHouseNFT": {
      "address": "0xeecae2DB32928ACd81Eecf556f32edE63103c320",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/core/AuctionHouseNFT.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n    # NOTE: This is a temporary AuctionHouseNFT contract. Real one coming soon.\n",
            "sha256sum": "ee8c6c80aa2922719a1ce80756a69e1b0e38b1496e521ba7a2e63b95e7da2160"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/AuctionHouseNFT.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "44db2fe8406f08f811430ebcc7833fafab9ff60ba86261da69f39cb3c12c159c"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/core/AuctionHouseNFT.vy"
    },
    "Boardroom": {
      "address": "0xb25bcEC95AAb89300A0Be3B52A1cDe3B15C2Ad20",
      "abi": [
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "govPowerDidChangeForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_userGovPoints",
              "type": "uint256"
            },
            {
              "name": "_totalGovPoints",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/core/Boardroom.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no minting\n\n    # NOTE: This is a temporary Boardroom contract. Real one coming soon.\n\n\n@external\ndef govPowerDidChangeForUser(_user: address, _userGovPoints: uint256, _totalGovPoints: uint256):\n    pass\n",
            "sha256sum": "b2b61b28335d2853218499556f2eb86a78e5b0de4aae32cc2f68eb187bf7d838"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/Boardroom.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "3e44f2578c8b110a7fd9588815ce5591f20d14fa2e9b4e54aa780791ea3ef1b3"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/core/Boardroom.vy"
    },
    "BondRoom": {
      "address": "0xc9A13F74F3a8748D081d86047DdfC001f17572Dd",
      "abi": [
        {
          "name": "RipeBondPurchased",
          "inputs": [
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "paymentAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripePayout",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripeForBadDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "baseRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripePerUnitBonus",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "epochProgress",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "purchaseRipeBond",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "purchaseRipeBond",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRipeBondPayout",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRipeBondPayout",
          "inputs": [
            {
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewRipeBondPayout",
          "inputs": [
            {
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "previewNextEpoch",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startBondEpochAtBlock",
          "inputs": [
            {
              "name": "_block",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "refreshBondEpoch",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestEpochBlockTimes",
          "inputs": [
            {
              "name": "_prevStartBlock",
              "type": "uint256"
            },
            {
              "name": "_prevEndBlock",
              "type": "uint256"
            },
            {
              "name": "_epochLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/core/BondRoom.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setEpochData(_epochStart: uint256, _epochEnd: uint256, _amountAvailInEpoch: uint256): nonpayable\n    def didPurchaseRipeBond(_amountPaid: uint256, _ripePayout: uint256): nonpayable\n    def didClearBadDebt(_amount: uint256, _ripeAmount: uint256): nonpayable\n    def getEpochData() -> (uint256, uint256): view\n    def getRipeBondData() -> RipeBondData: view\n\ninterface Teller:\n    def depositFromTrusted(_user: address, _vaultId: uint256, _asset: address, _amount: uint256, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def isUnderscoreWalletOwner(_user: address, _caller: address, _mc: address = empty(address)) -> bool: view\n\ninterface PriceDesk:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface MissionControl:\n    def getPurchaseRipeBondConfig(_user: address) -> PurchaseRipeBondConfig: view\n\ninterface RipeToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n\nstruct PurchaseRipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    canAnyoneBondForUser: bool\n\nstruct RipeBondData:\n    paymentAmountAvailInEpoch: uint256\n    ripeAvailForBonds: uint256\n    badDebt: uint256\n\nevent RipeBondPurchased:\n    recipient: indexed(address)\n    paymentAsset: indexed(address)\n    paymentAmount: uint256\n    lockDuration: uint256\n    ripePayout: uint256\n    ripeForBadDebt: uint256\n    baseRipePerUnit: uint256\n    ripePerUnitBonus: uint256\n    epochProgress: uint256\n    refundAmount: uint256\n    caller: indexed(address)\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nRIPE_GOV_VAULT_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, True) # can mint ripe only\n\n\n##############\n# Ripe Bonds #\n##############\n\n\n@external\ndef purchaseRipeBond(\n    _recipient: address,\n    _paymentAsset: address,\n    _paymentAmount: uint256,\n    _lockDuration: uint256,\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    assert _recipient != empty(address) # dev: invalid user\n    maxUserAmount: uint256 = min(_paymentAmount, staticcall IERC20(_paymentAsset).balanceOf(self))\n    assert maxUserAmount != 0 # dev: user has no asset balance (or zero specified)\n\n    config: PurchaseRipeBondConfig = staticcall MissionControl(a.missionControl).getPurchaseRipeBondConfig(_recipient)\n    assert config.asset == _paymentAsset # dev: asset mismatch\n    assert config.maxRipePerUnit != 0 # dev: max ripe per unit is zero\n    assert config.canBond # dev: bonds disabled\n\n    # can others bond for user\n    if _recipient != _caller and not config.canAnyoneBondForUser:\n        assert staticcall Teller(a.teller).isUnderscoreWalletOwner(_recipient, _caller, a.missionControl) # dev: cannot bond for user\n\n    # refresh epoch if necessary\n    epochStart: uint256 = 0\n    epochEnd: uint256 = 0\n    epochStart, epochEnd = self._refreshBondEpoch(a.ledger, config.amountPerEpoch, config.epochLength)\n    assert block.number >= epochStart and block.number < epochEnd # dev: not within epoch window\n\n    # check availability - do AFTER epoch refresh!\n    data: RipeBondData = staticcall Ledger(a.ledger).getRipeBondData()\n    assert data.paymentAmountAvailInEpoch != 0 # dev: no more available in epoch\n    paymentAmount: uint256 = min(maxUserAmount, data.paymentAmountAvailInEpoch)\n\n    # base ripe payout\n    epochProgress: uint256 = (block.number - epochStart) * HUNDRED_PERCENT // (epochEnd - epochStart)\n    baseRipePerUnit: uint256 = self._calcRipePerUnit(epochProgress, config.minRipePerUnit, config.maxRipePerUnit)\n\n    # bonus for lock duration\n    ripePerUnitBonus: uint256 = 0\n    lockDuration: uint256 = min(_lockDuration, config.maxLockDuration)\n    if lockDuration >= config.minLockDuration:\n        ripePerUnitBonus = config.maxRipePerUnitLockBonus * (lockDuration - config.minLockDuration) // (config.maxLockDuration - config.minLockDuration)\n    else:\n        lockDuration = 0\n\n    # finalize ripe payout\n    ripePerUnit: uint256 = baseRipePerUnit + ripePerUnitBonus\n    ripePayout: uint256 = ripePerUnit * paymentAmount // (10 ** convert(staticcall IERC20Detailed(_paymentAsset).decimals(), uint256))\n    assert ripePayout != 0 # dev: bad deal, user is not getting fair amount of Ripe\n    assert ripePayout <= data.ripeAvailForBonds # dev: not enough ripe avail\n\n    # handle bad debt (if applicable)\n    ripeForBadDebt: uint256 = 0\n    if data.badDebt != 0:\n        paymentUsdValue: uint256 = staticcall PriceDesk(a.priceDesk).getUsdValue(_paymentAsset, paymentAmount, False)\n        if paymentUsdValue != 0:\n            ripeForBadDebt = ripePayout\n            debtRepaymentValue: uint256 = min(paymentUsdValue, data.badDebt)\n            if debtRepaymentValue < paymentUsdValue:\n                ripeForBadDebt = ripePayout * debtRepaymentValue // paymentUsdValue\n            extcall Ledger(a.ledger).didClearBadDebt(debtRepaymentValue, ripeForBadDebt)\n\n    # update bond data -- amount avail in epoch is reduced even if bad debt is repaid\n    extcall Ledger(a.ledger).didPurchaseRipeBond(paymentAmount, ripePayout - ripeForBadDebt)\n\n    # transfer payment proceeds to endaoment\n    assert extcall IERC20(_paymentAsset).transfer(a.endaoment, paymentAmount, default_return_value=True) # dev: asset transfer failed\n\n    # mint ripe tokens, deposit into gov vault or transfer tokens to user\n    if lockDuration != 0:\n        extcall RipeToken(a.ripeToken).mint(self, ripePayout)\n        assert extcall IERC20(a.ripeToken).approve(a.teller, ripePayout, default_return_value=True) # dev: ripe approval failed\n        extcall Teller(a.teller).depositFromTrusted(_recipient, RIPE_GOV_VAULT_ID, a.ripeToken, ripePayout, lockDuration, a)\n        assert extcall IERC20(a.ripeToken).approve(a.teller, 0, default_return_value=True) # dev: ripe approval failed\n    else:\n        extcall RipeToken(a.ripeToken).mint(_recipient, ripePayout)\n\n    # refund user any extra payment amount\n    refundAmount: uint256 = 0\n    if _paymentAmount > paymentAmount:\n        refundAmount = min(_paymentAmount - paymentAmount, staticcall IERC20(_paymentAsset).balanceOf(self))\n        assert extcall IERC20(_paymentAsset).transfer(_caller, refundAmount, default_return_value=True) # dev: asset transfer failed\n\n    # start next epoch (if applicable)\n    if paymentAmount == data.paymentAmountAvailInEpoch and config.shouldAutoRestart:\n        newStartBlock: uint256 = block.number + config.restartDelayBlocks\n        extcall Ledger(a.ledger).setEpochData(newStartBlock, newStartBlock + config.epochLength, config.amountPerEpoch)\n\n    log RipeBondPurchased(recipient=_recipient, paymentAsset=_paymentAsset, paymentAmount=paymentAmount, lockDuration=lockDuration, ripePayout=ripePayout, ripeForBadDebt=ripeForBadDebt, baseRipePerUnit=baseRipePerUnit, ripePerUnitBonus=ripePerUnitBonus, epochProgress=epochProgress, refundAmount=refundAmount, caller=_caller)\n    return ripePayout\n\n\n@pure\n@internal\ndef _calcRipePerUnit(_ratio: uint256, _minRipePerUnit: uint256, _maxRipePerUnit: uint256) -> uint256:\n    if _ratio == 0 or _minRipePerUnit == _maxRipePerUnit:\n        return _minRipePerUnit\n    valRange: uint256 = _maxRipePerUnit - _minRipePerUnit\n    adjustment: uint256 =  _ratio * valRange // HUNDRED_PERCENT\n    return _minRipePerUnit + adjustment\n\n\n# views / helpers\n\n\n@view\n@external\ndef previewRipeBondPayout(_lockDuration: uint256 = 0, _paymentAmount: uint256 = max_value(uint256)) -> uint256:\n    config: PurchaseRipeBondConfig = staticcall MissionControl(addys._getMissionControlAddr()).getPurchaseRipeBondConfig(empty(address))\n    if config.maxRipePerUnit == 0 or not config.canBond:\n        return 0\n\n    # get epoch data\n    ledger: address = addys._getLedgerAddr()\n    epochStart: uint256 = 0\n    epochEnd: uint256 = 0\n    epochStart, epochEnd = staticcall Ledger(ledger).getEpochData()\n    didChange: bool = False\n    epochStart, epochEnd, didChange = self._getLatestEpochBlockTimes(epochStart, epochEnd, config.epochLength)\n\n    # check availability\n    data: RipeBondData = staticcall Ledger(ledger).getRipeBondData()\n    paymentAmountAvailInEpoch: uint256 = data.paymentAmountAvailInEpoch\n    if didChange:\n        paymentAmountAvailInEpoch = config.amountPerEpoch\n\n    paymentAmount: uint256 = min(_paymentAmount, paymentAmountAvailInEpoch)\n    if paymentAmount == 0:\n        return 0\n\n    # base ripe payout\n    epochProgress: uint256 = (block.number - epochStart) * HUNDRED_PERCENT // (epochEnd - epochStart)\n    baseRipePerUnit: uint256 = self._calcRipePerUnit(epochProgress, config.minRipePerUnit, config.maxRipePerUnit)\n\n    # bonus for lock duration\n    ripePerUnitBonus: uint256 = 0\n    lockDuration: uint256 = min(_lockDuration, config.maxLockDuration)\n    if lockDuration >= config.minLockDuration:\n        ripePerUnitBonus = config.maxRipePerUnitLockBonus * (lockDuration - config.minLockDuration) // (config.maxLockDuration - config.minLockDuration)\n\n    # finalize ripe payout\n    ripePerUnit: uint256 = baseRipePerUnit + ripePerUnitBonus\n    ripePayout: uint256 = ripePerUnit * paymentAmount // (10 ** convert(staticcall IERC20Detailed(config.asset).decimals(), uint256))\n    return ripePayout\n\n\n@view\n@external\ndef previewNextEpoch() -> (uint256, uint256):\n    config: PurchaseRipeBondConfig = staticcall MissionControl(addys._getMissionControlAddr()).getPurchaseRipeBondConfig(empty(address))\n    epochStart: uint256 = 0\n    epochEnd: uint256 = 0\n    epochStart, epochEnd = staticcall Ledger(addys._getLedgerAddr()).getEpochData()\n    na: bool = False\n    epochStart, epochEnd, na = self._getLatestEpochBlockTimes(epochStart, epochEnd, config.epochLength)\n    return epochStart, epochEnd\n\n\n##########\n# Epochs #\n##########\n\n\n# start at block\n\n\n@external\ndef startBondEpochAtBlock(_block: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    config: PurchaseRipeBondConfig = staticcall MissionControl(a.missionControl).getPurchaseRipeBondConfig(empty(address))\n    startBlock: uint256 = max(_block, block.number)\n    extcall Ledger(a.ledger).setEpochData(startBlock, startBlock + config.epochLength, config.amountPerEpoch)\n\n\n# refresh epoch\n\n\n@external \ndef refreshBondEpoch() -> (uint256, uint256):\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    config: PurchaseRipeBondConfig = staticcall MissionControl(a.missionControl).getPurchaseRipeBondConfig(empty(address))\n    return self._refreshBondEpoch(a.ledger, config.amountPerEpoch, config.epochLength)\n\n\n@internal\ndef _refreshBondEpoch(\n    _ledger: address,\n    _amountPerEpoch: uint256,\n    _epochLength: uint256,\n) -> (uint256, uint256):\n    startBlock: uint256 = 0\n    endBlock: uint256 = 0\n    startBlock, endBlock = staticcall Ledger(_ledger).getEpochData()\n\n    didChange: bool = False\n    startBlock, endBlock, didChange = self._getLatestEpochBlockTimes(startBlock, endBlock, _epochLength)\n    if didChange:\n        extcall Ledger(_ledger).setEpochData(startBlock, endBlock, _amountPerEpoch)\n\n    return startBlock, endBlock\n\n\n# get epoch blocks\n\n\n@view\n@external\ndef getLatestEpochBlockTimes(_prevStartBlock: uint256, _prevEndBlock: uint256, _epochLength: uint256) -> (uint256, uint256, bool):\n    return self._getLatestEpochBlockTimes(_prevStartBlock, _prevEndBlock, _epochLength)\n\n\n@view\n@internal\ndef _getLatestEpochBlockTimes(\n    _prevStartBlock: uint256,\n    _prevEndBlock: uint256,\n    _epochLength: uint256,\n) -> (uint256, uint256, bool):\n    startBlock: uint256 = _prevStartBlock\n    endBlock: uint256 = _prevEndBlock\n\n    # nothing to do here (start block is in future, or current block is before end block)\n    if block.number < startBlock or block.number < endBlock:\n        return startBlock, endBlock, False\n\n    # nothing has been set yet, start now\n    if startBlock == 0 or endBlock == 0:\n        return block.number, block.number + _epochLength, True\n\n    # past existing end block, still within next epoch window -- this could set start time in past\n    newStartBlock: uint256 = 0\n    if block.number < (endBlock + _epochLength):\n        newStartBlock = endBlock\n\n    # past next window, past everything\n    else:\n        epochsAhead: uint256 = (block.number - endBlock) // _epochLength\n        newStartBlock = _epochLength * epochsAhead + endBlock\n\n    return newStartBlock, newStartBlock + _epochLength, True\n",
            "sha256sum": "3ed846a291c407791d48b8e3e91866cb7810dadc395fea0aa52cc2031540a933"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/BondRoom.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "37bdde58fe32951fa59d7e9bcf4458ac8c67988017025a5a048cab778ae6ca2f"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/core/BondRoom.vy"
    },
    "CreditEngine": {
      "address": "0x46498Daa24E9A44c116B638347B2df52Bf1Fa21a",
      "abi": [
        {
          "name": "NewBorrow",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newLoan",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "daowry",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "didReceiveSavingsGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "outstandingUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "userCollateralVal",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "globalYieldRealized",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RepayDebt",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "repayValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayType",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundWasSavingsGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "outstandingUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "userCollateralVal",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CollateralRedeemed",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": false
            },
            {
              "name": "repayValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrowForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldEnterStabPool",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrowForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldEnterStabPool",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxBorrowAmount",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringLiquidation",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_newInterest",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringLiquidation",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_newInterest",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringAuctionPurchase",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringAuctionPurchase",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxRedeemValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCollateralValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            },
            {
              "name": "_skipAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            },
            {
              "name": "_skipAsset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestUserDebtAndTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestUserDebtAndTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDynamicBorrowRate",
          "inputs": [
            {
              "name": "_baseRate",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasGoodDebtHealth",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasGoodDebtHealth",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canLiquidateUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canLiquidateUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRedeemUserCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRedeemUserCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLiquidationThreshold",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRedemptionThreshold",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "contracts/core/CreditEngine.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import Vault\nimport interfaces.ConfigStructs as cs\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\ninterface Ledger:\n    def setUserDebt(_user: address, _userDebt: UserDebt, _newInterest: uint256, _interval: IntervalBorrow): nonpayable\n    def getBorrowDataBundle(_user: address) -> BorrowDataBundle: view\n    def addVaultToUser(_user: address, _vaultId: uint256): nonpayable\n    def userVaults(_user: address, _index: uint256) -> uint256: view\n    def getRepayDataBundle(_user: address) -> RepayDataBundle: view\n    def numUserVaults(_user: address) -> uint256: view\n    def flushUnrealizedYield() -> uint256: nonpayable\n\ninterface MissionControl:\n    def getRedeemCollateralConfig(_asset: address, _recipient: address) -> RedeemCollateralConfig: view\n    def getBorrowConfig(_user: address, _caller: address) -> BorrowConfig: view\n    def getDynamicBorrowRateConfig() -> DynamicBorrowRateConfig: view\n    def getRepayConfig(_user: address) -> RepayConfig: view\n    def getDebtTerms(_asset: address) -> cs.DebtTerms: view\n    def getLtvPaybackBuffer() -> uint256: view\n\ninterface PriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool) -> uint256: view\n\ninterface Teller:\n    def depositFromTrusted(_user: address, _vaultId: uint256, _asset: address, _amount: uint256, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def isUnderscoreWalletOwner(_user: address, _caller: address, _mc: address = empty(address)) -> bool: view\n\ninterface LootBox:\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n    def updateBorrowPoints(_user: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface GreenToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n    def burn(_amount: uint256) -> bool: nonpayable\n\ninterface CurvePrices:\n    def getCurrentGreenPoolStatus() -> CurrentGreenPoolStatus: view\n\ninterface AddressRegistry:\n    def getAddr(_regId: uint256) -> address: view\n\nflag RepayType:\n    STANDARD\n    LIQUIDATION\n    AUCTION\n    REDEMPTION\n\nstruct BorrowDataBundle:\n    userDebt: UserDebt\n    userBorrowInterval: IntervalBorrow\n    isUserBorrower: bool\n    numUserVaults: uint256\n    totalDebt: uint256\n    numBorrowers: uint256\n\nstruct UserBorrowTerms:\n    collateralVal: uint256\n    totalMaxDebt: uint256\n    debtTerms: cs.DebtTerms\n\nstruct UserDebt:\n    amount: uint256\n    principal: uint256\n    debtTerms: cs.DebtTerms\n    lastTimestamp: uint256\n    inLiquidation: bool\n\nstruct IntervalBorrow:\n    start: uint256\n    amount: uint256\n\nstruct RepayDataBundle:\n    userDebt: UserDebt\n    numUserVaults: uint256\n\nstruct BorrowConfig:\n    canBorrow: bool\n    canBorrowForUser: bool\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    isDaowryEnabled: bool\n\nstruct RepayConfig:\n    canRepay: bool\n    canAnyoneRepayDebt: bool\n\nstruct RedeemCollateralConfig:\n    canRedeemCollateralGeneral: bool\n    canRedeemCollateralAsset: bool\n    isUserAllowed: bool\n    ltvPaybackBuffer: uint256\n    canAnyoneDeposit: bool\n\nstruct CollateralRedemption:\n    user: address\n    vaultId: uint256\n    asset: address\n    maxGreenAmount: uint256\n\nstruct CurrentGreenPoolStatus:\n    weightedRatio: uint256\n    dangerTrigger: uint256\n    numBlocksInDanger: uint256\n\nstruct DynamicBorrowRateConfig:\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n\nevent NewBorrow:\n    user: indexed(address)\n    newLoan: uint256\n    daowry: uint256\n    didReceiveSavingsGreen: bool\n    outstandingUserDebt: uint256\n    userCollateralVal: uint256\n    maxUserDebt: uint256\n    globalYieldRealized: uint256\n\nevent RepayDebt:\n    user: indexed(address)\n    repayValue: uint256\n    repayType: RepayType\n    refundAmount: uint256\n    refundWasSavingsGreen: bool\n    outstandingUserDebt: uint256\n    userCollateralVal: uint256\n    maxUserDebt: uint256\n    hasGoodDebtHealth: bool\n\nevent CollateralRedeemed:\n    user: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    amount: uint256\n    recipient: indexed(address)\n    caller: address\n    repayValue: uint256\n    hasGoodDebtHealth: bool\n\nONE_YEAR: constant(uint256) = 60 * 60 * 24 * 365\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nDANGER_BLOCKS_DENOMINATOR: constant(uint256) = 100_0000 # 100.0000%\nONE_PERCENT: constant(uint256) = 1_00 # 1.00%\nMAX_DEBT_UPDATES: constant(uint256) = 25\nMAX_COLLATERAL_REDEMPTIONS: constant(uint256) = 20\nSTABILITY_POOL_ID: constant(uint256) = 1\nCURVE_PRICES_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, True, False) # can mint green only\n\n\n##########\n# Borrow #\n##########\n\n\n@external\ndef borrowForUser(\n    _user: address,\n    _greenAmount: uint256,\n    _wantsSavingsGreen: bool,\n    _shouldEnterStabPool: bool,\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    assert _user != empty(address) # dev: cannot borrow for 0x0\n\n    # get borrow data\n    d: BorrowDataBundle = staticcall Ledger(a.ledger).getBorrowDataBundle(_user)\n\n    # get latest user debt\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # get borrow data (debt terms for user)\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, True, 0, empty(address), a)\n\n    # get config\n    config: BorrowConfig = staticcall MissionControl(a.missionControl).getBorrowConfig(_user, _caller)\n\n    # check perms\n    if _user != _caller and not config.canBorrowForUser:\n        assert staticcall Teller(a.teller).isUnderscoreWalletOwner(_user, _caller, a.missionControl) # dev: not allowed to borrow for user\n\n    # validation\n    newBorrowAmount: uint256 = 0\n    isFreshInterval: bool = False\n    newBorrowAmount, isFreshInterval = self._validateOnBorrow(_greenAmount, userDebt, bt.totalMaxDebt, d, config)\n    assert newBorrowAmount != 0 # dev: cannot borrow\n\n    # update borrow interval\n    userBorrowInterval: IntervalBorrow = d.userBorrowInterval\n    if isFreshInterval:\n        userBorrowInterval.start = block.number\n        userBorrowInterval.amount = newBorrowAmount\n    else:\n        userBorrowInterval.amount += newBorrowAmount\n\n    # update user debt\n    userDebt.amount += newBorrowAmount\n    userDebt.principal += newBorrowAmount\n    userDebt.debtTerms = bt.debtTerms\n\n    # check debt health\n    hasGoodDebtHealth: bool = self._hasGoodDebtHealth(userDebt.amount, bt.collateralVal, bt.debtTerms.ltv)\n    assert hasGoodDebtHealth # dev: bad debt health\n    userDebt.inLiquidation = False\n\n    # save debt\n    extcall Ledger(a.ledger).setUserDebt(_user, userDebt, newInterest, userBorrowInterval)\n\n    # update borrow points\n    extcall LootBox(a.lootbox).updateBorrowPoints(_user, a)\n\n    # mint green - piggy back on borrow to flush unrealized yield\n    unrealizedYield: uint256 = extcall Ledger(a.ledger).flushUnrealizedYield()\n    totalGreenMint: uint256 = newBorrowAmount + unrealizedYield\n    extcall GreenToken(a.greenToken).mint(self, totalGreenMint)\n\n    # origination fee\n    daowry: uint256 = 0\n    if config.isDaowryEnabled:\n        daowry = newBorrowAmount * bt.debtTerms.daowry // HUNDRED_PERCENT\n\n    # dao revenue\n    forDao: uint256 = daowry + unrealizedYield\n    if forDao != 0:\n        assert extcall IERC20(a.greenToken).transfer(a.savingsGreen, forDao, default_return_value=True) # dev: could not transfer\n\n    # borrower gets their green now -- do this AFTER sending green to stakers\n    forBorrower: uint256 = newBorrowAmount - daowry\n    self._handleGreenForUser(_user, forBorrower, _wantsSavingsGreen, _shouldEnterStabPool, a)\n\n    log NewBorrow(user=_user, newLoan=forBorrower, daowry=daowry, didReceiveSavingsGreen=_wantsSavingsGreen, outstandingUserDebt=userDebt.amount, userCollateralVal=bt.collateralVal, maxUserDebt=bt.totalMaxDebt, globalYieldRealized=unrealizedYield)\n    return forBorrower\n\n\n# borrow validation\n\n\n@view\n@internal\ndef _validateOnBorrow(\n    _greenAmount: uint256,\n    _userDebt: UserDebt,\n    _maxUserDebt: uint256,\n    _d: BorrowDataBundle,\n    _config: BorrowConfig,\n) -> (uint256, bool):\n    assert not _userDebt.inLiquidation # dev: cannot borrow in liquidation\n    assert _greenAmount != 0 # dev: cannot borrow 0 amount\n\n    # get borrow config\n    assert _config.canBorrow # dev: borrow not enabled\n\n    # check num allowed borrowers\n    if not _d.isUserBorrower:\n        assert _config.numAllowedBorrowers > _d.numBorrowers # dev: max num borrowers reached\n\n    # main var\n    newBorrowAmount: uint256 = _greenAmount\n\n    # avail debt based on collateral value / ltv\n    availDebtPerLtv: uint256 = 0\n    if _maxUserDebt > _userDebt.amount:\n        availDebtPerLtv = _maxUserDebt - _userDebt.amount\n    assert availDebtPerLtv != 0 # dev: no debt available\n    newBorrowAmount = min(newBorrowAmount, availDebtPerLtv)\n\n    # check borrow interval\n    availInInterval: uint256 = 0\n    isFreshInterval: bool = False\n    availInInterval, isFreshInterval = self._getAvailDebtInInterval(_d.userBorrowInterval, _config.maxBorrowPerInterval, _config.numBlocksPerInterval)\n    assert availInInterval != 0 # dev: interval borrow limit reached\n    newBorrowAmount = min(newBorrowAmount, availInInterval)\n\n    # check per user debt limit\n    availPerUser: uint256 = 0\n    if _config.perUserDebtLimit > _userDebt.amount:\n        availPerUser = _config.perUserDebtLimit - _userDebt.amount\n    assert availPerUser != 0 # dev: per user debt limit reached\n    newBorrowAmount = min(newBorrowAmount, availPerUser)\n\n    # check global debt limit\n    availGlobal: uint256 = 0\n    if _config.globalDebtLimit > _d.totalDebt:\n        availGlobal = _config.globalDebtLimit - _d.totalDebt\n    assert availGlobal != 0 # dev: global debt limit reached\n    newBorrowAmount = min(newBorrowAmount, availGlobal)\n\n    # must reach minimum debt threshold\n    assert _userDebt.amount + newBorrowAmount >= _config.minDebtAmount # dev: debt too small\n\n    return newBorrowAmount, isFreshInterval\n\n\n# max available borrow (mostly for front-ends, no exceptions raised)\n\n\n@view\n@external\ndef getMaxBorrowAmount(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt\n    d: BorrowDataBundle = staticcall Ledger(a.ledger).getBorrowDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    na1: uint256 = 0\n    userDebt, na1 = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # cannot borrow in liquidation\n    if userDebt.inLiquidation:\n        return 0\n\n    # get borrow config\n    config: BorrowConfig = staticcall MissionControl(a.missionControl).getBorrowConfig(_user, _user)\n    if not config.canBorrow:\n        return 0\n\n    # check num allowed borrowers\n    if not d.isUserBorrower and config.numAllowedBorrowers <= d.numBorrowers:\n        return 0\n\n    # main var\n    newBorrowAmount: uint256 = max_value(uint256)\n\n    # avail debt based on collateral value / ltv\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, False, 0, empty(address), a)\n    availDebtPerLtv: uint256 = 0\n    if bt.totalMaxDebt > userDebt.amount:\n        availDebtPerLtv = bt.totalMaxDebt - userDebt.amount\n    newBorrowAmount = min(newBorrowAmount, availDebtPerLtv)\n\n    # check borrow interval\n    availInInterval: uint256 = 0\n    na2: bool = False\n    availInInterval, na2 = self._getAvailDebtInInterval(d.userBorrowInterval, config.maxBorrowPerInterval, config.numBlocksPerInterval)\n    newBorrowAmount = min(newBorrowAmount, availInInterval)\n\n    # check per user debt limit\n    availPerUser: uint256 = 0\n    if config.perUserDebtLimit > userDebt.amount:\n        availPerUser = config.perUserDebtLimit - userDebt.amount\n    newBorrowAmount = min(newBorrowAmount, availPerUser)\n\n    # check global debt limit\n    availGlobal: uint256 = 0\n    if config.globalDebtLimit > d.totalDebt:\n        availGlobal = config.globalDebtLimit - d.totalDebt\n    newBorrowAmount = min(newBorrowAmount, availGlobal)\n\n    # must reach minimum debt threshold\n    if userDebt.amount + newBorrowAmount < config.minDebtAmount:\n        return 0\n\n    return newBorrowAmount\n\n\n#########\n# Repay #\n#########\n\n\n@external\ndef repayForUser(\n    _user: address,\n    _greenAmount: uint256,\n    _shouldRefundSavingsGreen: bool,\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # validation\n    repayAmount: uint256 = 0\n    refundAmount: uint256 = 0\n    repayAmount, refundAmount = self._validateOnRepay(_user, _caller, _greenAmount, userDebt.amount, a.missionControl, a.greenToken, a.teller)\n    assert repayAmount != 0 # dev: cannot repay with 0 green\n\n    return self._repayDebt(_user, userDebt, d.numUserVaults, repayAmount, refundAmount, newInterest, True, _shouldRefundSavingsGreen, RepayType.STANDARD, a)\n\n\n# repay during liquidation\n\n\n@external\ndef repayDuringLiquidation(\n    _liqUser: address,\n    _userDebt: UserDebt,\n    _repayValue: uint256,\n    _newInterest: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only auction house allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    numVaults: uint256 = staticcall Ledger(a.ledger).numUserVaults(_liqUser)\n    return self._repayDebt(_liqUser, _userDebt, numVaults, _repayValue, 0, _newInterest, False, False, RepayType.LIQUIDATION, a)\n\n\n# repay during auction purchase\n\n\n@external\ndef repayDuringAuctionPurchase(_liqUser: address, _repayValue: uint256, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only auction house allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_liqUser)\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # finalize amounts\n    repayAmount: uint256 = 0\n    refundAmount: uint256 = 0\n    repayAmount, refundAmount = self._getRepayAmountAndRefundAmount(userDebt.amount, _repayValue, a.greenToken)\n    assert repayAmount != 0 # dev: cannot repay with 0 green\n\n    return self._repayDebt(_liqUser, userDebt, d.numUserVaults, repayAmount, refundAmount, newInterest, True, True, RepayType.AUCTION, a)\n\n\n# shared repay functionality\n\n\n@internal\ndef _repayDebt(\n    _user: address,\n    _userDebt: UserDebt,\n    _numUserVaults: uint256,\n    _repayValue: uint256,\n    _refundAmount: uint256,\n    _newInterest: uint256,\n    _shouldBurnGreen: bool,\n    _wantsSavingsGreen: bool,\n    _repayType: RepayType,\n    _a: addys.Addys,\n) -> bool:\n    userDebt: UserDebt = self._reduceDebtAmount(_userDebt, _repayValue)\n\n    # get latest debt terms\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, _numUserVaults, True, 0, empty(address), _a)\n    userDebt.debtTerms = bt.debtTerms\n\n    # check debt health\n    hasGoodDebtHealth: bool = self._hasGoodDebtHealth(userDebt.amount, bt.collateralVal, bt.debtTerms.ltv)\n    if hasGoodDebtHealth:\n        userDebt.inLiquidation = False\n\n    # update user debt, borrow points\n    extcall Ledger(_a.ledger).setUserDebt(_user, userDebt, _newInterest, empty(IntervalBorrow))\n    extcall LootBox(_a.lootbox).updateBorrowPoints(_user, _a)\n\n    # burn green repayment\n    if _shouldBurnGreen:\n        assert extcall GreenToken(_a.greenToken).burn(_repayValue) # dev: could not burn green\n\n    # handle refund\n    if _refundAmount != 0:\n        self._handleGreenForUser(_user, _refundAmount, _wantsSavingsGreen, False, _a)\n\n    log RepayDebt(user=_user, repayValue=_repayValue, repayType=_repayType, refundAmount=_refundAmount, refundWasSavingsGreen=_wantsSavingsGreen, outstandingUserDebt=userDebt.amount, userCollateralVal=bt.collateralVal, maxUserDebt=bt.totalMaxDebt, hasGoodDebtHealth=hasGoodDebtHealth)\n    return hasGoodDebtHealth\n\n\n# repay validation\n\n\n@view\n@internal\ndef _validateOnRepay(\n    _user: address,\n    _caller: address,\n    _greenAmount: uint256,\n    _userDebtAmount: uint256,\n    _missionControl: address,\n    _greenToken: address,\n    _teller: address,\n) -> (uint256, uint256):\n    assert _userDebtAmount != 0 # dev: no debt outstanding\n\n    # repay config\n    repayConfig: RepayConfig = staticcall MissionControl(_missionControl).getRepayConfig(_user)\n    assert repayConfig.canRepay # dev: repay paused\n\n    # others repaying for user\n    if _user != _caller and not repayConfig.canAnyoneRepayDebt:\n        assert staticcall Teller(_teller).isUnderscoreWalletOwner(_user, _caller, _missionControl) # dev: not allowed to repay for user\n\n    return self._getRepayAmountAndRefundAmount(_userDebtAmount, _greenAmount, _greenToken)\n\n\n# repay amount and refund amount\n\n\n@view\n@internal\ndef _getRepayAmountAndRefundAmount(_userDebtAmount: uint256, _greenAmount: uint256, _greenToken: address) -> (uint256, uint256):\n    availAmount: uint256 = min(_greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n\n    repayAmount: uint256 = min(availAmount, _userDebtAmount)\n    refundAmount: uint256 = 0\n    if repayAmount > availAmount:\n        refundAmount = repayAmount - availAmount\n\n    return repayAmount, refundAmount\n\n\n# reduce debt amount\n\n\n@view\n@internal\ndef _reduceDebtAmount(_userDebt: UserDebt, _repayAmount: uint256) -> UserDebt:\n    userDebt: UserDebt = _userDebt\n    nonPrincipalDebt: uint256 = userDebt.amount - userDebt.principal\n\n    userDebt.amount -= _repayAmount\n    if _repayAmount > nonPrincipalDebt:\n        principalToReduce: uint256 = _repayAmount - nonPrincipalDebt\n        userDebt.principal -= min(principalToReduce, userDebt.principal)\n\n    return userDebt\n\n\n#####################\n# Redeem Collateral #\n#####################\n\n\n@external\ndef redeemCollateralFromMany(\n    _redemptions: DynArray[CollateralRedemption, MAX_COLLATERAL_REDEMPTIONS],\n    _greenAmount: uint256,\n    _recipient: address,\n    _caller: address,\n    _shouldTransferBalance: bool,\n    _shouldRefundSavingsGreen: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only Teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    totalGreenSpent: uint256 = 0\n    totalGreenRemaining: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(self))\n    assert totalGreenRemaining != 0 # dev: no green to redeem\n\n    for r: CollateralRedemption in _redemptions:\n        if totalGreenRemaining == 0:\n            break\n        greenSpent: uint256 = self._redeemCollateral(r.user, r.vaultId, r.asset, r.maxGreenAmount, totalGreenRemaining, _recipient, _caller, _shouldTransferBalance, a)\n        totalGreenRemaining -= greenSpent\n        totalGreenSpent += greenSpent\n\n    assert totalGreenSpent != 0 # dev: no redemptions occurred\n\n    # handle leftover green\n    if totalGreenRemaining != 0:\n        self._handleGreenForUser(_caller, totalGreenRemaining, _shouldRefundSavingsGreen, False, a)\n\n    return totalGreenSpent\n\n\n@internal\ndef _redeemCollateral(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _maxGreenForAsset: uint256,\n    _totalGreenRemaining: uint256,\n    _recipient: address,\n    _caller: address,\n    _shouldTransferBalance: bool,\n    _a: addys.Addys,\n) -> uint256:\n\n    # NOTE: failing gracefully here, in case of many redemptions at same time\n\n    # invalid inputs\n    if empty(address) in [_recipient, _asset, _user] or 0 in [_maxGreenForAsset, _totalGreenRemaining, _vaultId]:\n        return 0\n\n    # recipient cannot be user\n    if _recipient == _user:\n        return 0\n\n    # vault address\n    vaultAddr: address = staticcall AddressRegistry(_a.vaultBook).getAddr(_vaultId)\n    if vaultAddr == empty(address):\n        return 0\n\n    # user must have balance\n    if not staticcall Vault(vaultAddr).doesUserHaveBalance(_user, _asset):\n        return 0\n\n    # redemptions not allowed on asset\n    config: RedeemCollateralConfig = staticcall MissionControl(_a.missionControl).getRedeemCollateralConfig(_asset, _recipient)\n    if not config.canRedeemCollateralGeneral or not config.canRedeemCollateralAsset or not config.isUserAllowed:\n        return 0\n\n    # make sure caller can deposit to recipient\n    if _recipient != _caller and not config.canAnyoneDeposit:\n        assert staticcall Teller(_a.teller).isUnderscoreWalletOwner(_recipient, _caller, _a.missionControl) # dev: not allowed to deposit for user\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(_a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # cannot redeem if no debt or in liquidation\n    if userDebt.amount == 0 or userDebt.inLiquidation:\n        return 0\n\n    # get latest debt terms\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, True, 0, empty(address), _a)\n    if bt.collateralVal == 0:\n        return 0\n\n    # user has not reached redemption threshold\n    if not self._canRedeemUserCollateral(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold):\n        return 0\n\n    # estimated debt to pay back to achieve safe LTV\n    # won't be exact because depends on which collateral is redeemed (LTV changes)\n    targetLtv: uint256 = bt.debtTerms.ltv * (HUNDRED_PERCENT - config.ltvPaybackBuffer) // HUNDRED_PERCENT\n    maxCollateralValue: uint256 = self._calcAmountToPay(userDebt.amount, bt.collateralVal, targetLtv)\n\n    # treating green as $1\n    maxGreenAvailable: uint256 = min(_totalGreenRemaining, staticcall IERC20(_a.greenToken).balanceOf(self))\n    maxGreenForAsset: uint256 = min(_maxGreenForAsset, maxGreenAvailable)\n    maxRedeemValue: uint256 = min(maxCollateralValue, maxGreenForAsset)\n    if maxRedeemValue == 0:\n        return 0\n\n    # max asset amount to take from user\n    maxAssetAmount: uint256 = staticcall PriceDesk(_a.priceDesk).getAssetAmount(_asset, maxRedeemValue, True)\n    if maxAssetAmount == 0:\n        return 0\n\n    # withdraw or transfer balance to redeemer\n    amountSent: uint256 = 0\n    na: bool = False\n    if _shouldTransferBalance:\n        amountSent, na = extcall Vault(vaultAddr).transferBalanceWithinVault(_asset, _user, _recipient, maxAssetAmount, _a)\n        extcall Ledger(_a.ledger).addVaultToUser(_recipient, _vaultId)\n        extcall LootBox(_a.lootbox).updateDepositPoints(_recipient, _vaultId, vaultAddr, _asset, _a)\n\n    else:\n        amountSent, na = extcall Vault(vaultAddr).withdrawTokensFromVault(_user, _asset, maxAssetAmount, _recipient, _a)\n\n    # repay debt\n    repayValue: uint256 = amountSent * maxRedeemValue // maxAssetAmount\n    hasGoodDebtHealth: bool = self._repayDebt(_user, userDebt, d.numUserVaults, min(repayValue, userDebt.amount), 0, newInterest, True, False, RepayType.REDEMPTION, _a)\n\n    log CollateralRedeemed(\n        user=_user,\n        vaultId=_vaultId,\n        asset=_asset,\n        amount=amountSent,\n        recipient=_recipient,\n        caller=_caller,\n        repayValue=repayValue,\n        hasGoodDebtHealth=hasGoodDebtHealth,\n    )\n    return min(repayValue, maxRedeemValue)\n\n\n# utils\n\n\n@view\n@external\ndef getMaxRedeemValue(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = self._getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0 or userDebt.inLiquidation or bt.collateralVal == 0:\n        return 0\n\n    if not self._canRedeemUserCollateral(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold):\n        return 0\n\n    ltvPaybackBuffer: uint256 = staticcall MissionControl(a.missionControl).getLtvPaybackBuffer()\n    targetLtv: uint256 = bt.debtTerms.ltv * (HUNDRED_PERCENT - ltvPaybackBuffer) // HUNDRED_PERCENT\n    return self._calcAmountToPay(userDebt.amount, bt.collateralVal, targetLtv)\n\n\n@view\n@internal\ndef _calcAmountToPay(_debtAmount: uint256, _collateralValue: uint256, _targetLtv: uint256) -> uint256:\n    # goal here is to only reduce the debt necessary to get LTV back to safe position\n    # it will never be perfectly precise because depending on what assets are taken, the LTV might slightly change\n    collValueAdjusted: uint256 =_collateralValue * _targetLtv // HUNDRED_PERCENT\n\n    toPay: uint256 = (_debtAmount - collValueAdjusted) * HUNDRED_PERCENT // (HUNDRED_PERCENT - _targetLtv)\n    return min(toPay, _debtAmount)\n\n\n################\n# Borrow Terms #\n################\n\n\n@view\n@external\ndef getCollateralValue(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, staticcall Ledger(a.ledger).numUserVaults(_user), True, 0, empty(address), a)\n    return bt.collateralVal\n\n\n@view\n@external\ndef getUserBorrowTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _skipVaultId: uint256 = 0,\n    _skipAsset: address = empty(address),\n    _a: addys.Addys = empty(addys.Addys),\n) -> UserBorrowTerms:\n    a: addys.Addys = addys._getAddys(_a)\n    return self._getUserBorrowTerms(_user, staticcall Ledger(a.ledger).numUserVaults(_user), _shouldRaise, _skipVaultId, _skipAsset, a)\n\n\n@view\n@internal\ndef _getUserBorrowTerms(\n    _user: address,\n    _numUserVaults: uint256,\n    _shouldRaise: bool,\n    _skipVaultId: uint256,\n    _skipAsset: address,\n    _a: addys.Addys,\n) -> UserBorrowTerms:\n\n    # nothing to do here\n    if _numUserVaults == 0:\n        return empty(UserBorrowTerms)\n\n    hasSkip: bool = (_skipVaultId != 0 and _skipAsset != empty(address))\n\n    # sum vars\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    ltvSum: uint256 = 0\n    redemptionThresholdSum: uint256 = 0\n    liqThresholdSum: uint256 = 0\n    liqFeeSum: uint256 = 0\n    borrowRateSum: uint256 = 0\n    daowrySum: uint256 = 0\n    totalSum: uint256 = 0\n\n    # iterate thru each user vault\n    for i: uint256 in range(1, _numUserVaults, bound=max_value(uint256)):\n        vaultId: uint256 = staticcall Ledger(_a.ledger).userVaults(_user, i)\n        vaultAddr: address = staticcall AddressRegistry(_a.vaultBook).getAddr(vaultId)\n        if vaultAddr == empty(address):\n            continue\n\n        # iterate thru each user asset\n        numUserAssets: uint256 = staticcall Vault(vaultAddr).numUserAssets(_user)\n        for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n\n            # get user asset and amount\n            asset: address = empty(address)\n            amount: uint256 = 0\n            asset, amount = staticcall Vault(vaultAddr).getUserAssetAndAmountAtIndex(_user, y)\n            if asset == empty(address) or amount == 0:\n                continue\n\n            # debt terms\n            debtTerms: cs.DebtTerms = staticcall MissionControl(_a.missionControl).getDebtTerms(asset)\n\n            # skip if no ltv (staked green, staked ripe, etc)\n            if debtTerms.ltv == 0:\n                continue\n\n            # collateral value, max debt\n            collateralVal: uint256 = staticcall PriceDesk(_a.priceDesk).getUsdValue(asset, amount, _shouldRaise)\n            maxDebt: uint256 = collateralVal * debtTerms.ltv // HUNDRED_PERCENT\n\n            # need to return some debt terms, even if not getting any price\n            debtTermsWeight: uint256 = maxDebt\n            if debtTermsWeight == 0:\n                debtTermsWeight = 1\n\n            # debt terms sums -- weight is based on max debt (ltv)\n            ltvSum += debtTermsWeight * debtTerms.ltv\n            redemptionThresholdSum += debtTermsWeight * debtTerms.redemptionThreshold\n            liqThresholdSum += debtTermsWeight * debtTerms.liqThreshold\n            liqFeeSum += debtTermsWeight * debtTerms.liqFee\n            borrowRateSum += debtTermsWeight * debtTerms.borrowRate\n            daowrySum += debtTermsWeight * debtTerms.daowry\n            totalSum += debtTermsWeight\n\n            # totals\n            if not (hasSkip and asset == _skipAsset and vaultId == _skipVaultId):\n                bt.collateralVal += collateralVal\n                bt.totalMaxDebt += maxDebt\n\n    # finalize debt terms (weighted)\n    if totalSum != 0:\n        bt.debtTerms.ltv = ltvSum // totalSum\n        bt.debtTerms.redemptionThreshold = redemptionThresholdSum // totalSum\n        bt.debtTerms.liqThreshold = liqThresholdSum // totalSum\n        bt.debtTerms.liqFee = liqFeeSum // totalSum\n        bt.debtTerms.borrowRate = borrowRateSum // totalSum\n        bt.debtTerms.daowry = daowrySum // totalSum\n\n    # overwrite ltv if collateral value is available\n    if bt.collateralVal != 0:\n        bt.debtTerms.ltv = bt.totalMaxDebt * HUNDRED_PERCENT // bt.collateralVal\n\n    # ensure liq threshold and liq fee can work together\n    if bt.debtTerms.liqThreshold != 0:\n        liqSum: uint256 = bt.debtTerms.liqThreshold + (bt.debtTerms.liqThreshold * bt.debtTerms.liqFee // HUNDRED_PERCENT)\n        if liqSum > HUNDRED_PERCENT:\n            adjustedLiqFee: uint256 = (HUNDRED_PERCENT - bt.debtTerms.liqThreshold) * HUNDRED_PERCENT // bt.debtTerms.liqThreshold\n            bt.debtTerms.liqFee = adjustedLiqFee\n    else:\n        bt.debtTerms.liqFee = 0\n\n    # dynamic borrow rate\n    bt.debtTerms.borrowRate = self._getDynamicBorrowRate(bt.debtTerms.borrowRate, _a.missionControl, _a.priceDesk)\n    return bt\n\n\n# latest user debt and terms\n\n\n@view\n@external\ndef getLatestUserDebtAndTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (UserDebt, UserBorrowTerms, uint256):\n    return self._getLatestUserDebtAndTerms(_user, _shouldRaise, addys._getAddys(_a))\n\n\n@view\n@internal\ndef _getLatestUserDebtAndTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _a: addys.Addys,\n) -> (UserDebt, UserBorrowTerms, uint256):\n\n    # get data (repay data has the only stuff we need)\n    d: RepayDataBundle = staticcall Ledger(_a.ledger).getRepayDataBundle(_user)\n\n    # accrue interest\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # debt terms for user\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, _shouldRaise, 0, empty(address), _a)\n\n    return userDebt, bt, newInterest\n\n\n# dynamic interest rate adjustments\n\n\n@view\n@external\ndef getDynamicBorrowRate(_baseRate: uint256) -> uint256:\n    return self._getDynamicBorrowRate(_baseRate, addys._getMissionControlAddr(), addys._getPriceDeskAddr())\n\n\n@view\n@internal\ndef _getDynamicBorrowRate(_baseRate: uint256, _missionControl: address, _priceDesk: address) -> uint256:\n    curvePrices: address = staticcall AddressRegistry(_priceDesk).getAddr(CURVE_PRICES_ID)\n    if curvePrices == empty(address):\n        return _baseRate\n\n    status: CurrentGreenPoolStatus = staticcall CurvePrices(curvePrices).getCurrentGreenPoolStatus()\n    if status.weightedRatio == 0 or status.weightedRatio < status.dangerTrigger:\n        return _baseRate\n\n    config: DynamicBorrowRateConfig = staticcall MissionControl(_missionControl).getDynamicBorrowRateConfig()\n\n    # dynamic rate boost (depending on pool health)\n    rateBoost: uint256 = 0\n    if config.maxDynamicRateBoost != 0:\n        dynamicRatio: uint256 = (status.weightedRatio - status.dangerTrigger) * HUNDRED_PERCENT // (HUNDRED_PERCENT - status.dangerTrigger)\n        rateMultiplier: uint256 = self._calcDynamicRateBoost(dynamicRatio, config.minDynamicRateBoost, config.maxDynamicRateBoost)\n        rateBoost = _baseRate * rateMultiplier // HUNDRED_PERCENT\n\n    # danger boost (longer pool health imbalanced, higher rate keeps getting)\n    dangerBoost: uint256 = 0\n    if status.numBlocksInDanger != 0 and config.increasePerDangerBlock != 0:\n        dangerBoost = (config.increasePerDangerBlock * status.numBlocksInDanger) * HUNDRED_PERCENT // DANGER_BLOCKS_DENOMINATOR\n\n    return min(_baseRate + rateBoost + dangerBoost, config.maxBorrowRate)\n\n\n@pure\n@internal\ndef _calcDynamicRateBoost(_ratio: uint256, _minBoost: uint256, _maxBoost: uint256) -> uint256:\n    if _ratio == 0 or _minBoost == _maxBoost:\n        return _minBoost\n    valRange: uint256 = _maxBoost - _minBoost\n    adjustment: uint256 =  _ratio * valRange // HUNDRED_PERCENT\n    return _minBoost + adjustment\n\n\n###############\n# Update Debt #\n###############\n\n\n@external\ndef updateDebtForUser(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    newInterest: uint256 = 0\n    userDebt, bt, newInterest = self._getLatestUserDebtAndTerms(_user, True, a)\n    if userDebt.amount == 0:\n        return True\n\n    # debt health\n    hasGoodDebtHealth: bool = self._hasGoodDebtHealth(userDebt.amount, bt.collateralVal, bt.debtTerms.ltv)\n    if hasGoodDebtHealth:\n        userDebt.inLiquidation = False\n\n    userDebt.debtTerms = bt.debtTerms\n    extcall Ledger(a.ledger).setUserDebt(_user, userDebt, newInterest, empty(IntervalBorrow))\n\n    # update borrow points\n    extcall LootBox(a.lootbox).updateBorrowPoints(_user, a)\n\n    return hasGoodDebtHealth\n\n\n###############\n# Debt Health #\n###############\n\n\n@view\n@external\ndef hasGoodDebtHealth(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 1, _a)\n\n\n@view\n@external\ndef canLiquidateUser(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 2, _a)\n\n\n@view\n@external\ndef canRedeemUserCollateral(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 3, _a)\n\n\n@view\n@internal\ndef _checkDebtHealth(_user: address, _debtType: uint256, _a: addys.Addys) -> bool:\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = self._getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0:\n        return _debtType == 1 # nothing to check\n\n    # in liquidation, can't do anything\n    if userDebt.inLiquidation:\n        return False\n\n    # check debt health\n    if _debtType == 1:\n        return self._hasGoodDebtHealth(userDebt.amount, bt.collateralVal, bt.debtTerms.ltv)\n    elif _debtType == 2:\n        return self._canLiquidateUser(userDebt.amount, bt.collateralVal, bt.debtTerms.liqThreshold)\n    elif _debtType == 3:\n        return self._canRedeemUserCollateral(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold)\n    else:\n        return False\n\n\n@view\n@internal\ndef _hasGoodDebtHealth(_userDebtAmount: uint256, _collateralVal: uint256, _ltv: uint256) -> bool:\n    maxUserDebt: uint256 = _collateralVal * _ltv // HUNDRED_PERCENT\n    return _userDebtAmount <= maxUserDebt\n\n\n@view\n@internal\ndef _canLiquidateUser(_userDebtAmount: uint256, _collateralVal: uint256, _liqThreshold: uint256) -> bool:\n    if _liqThreshold == 0:\n        return False\n\n    # check if collateral value is below (or equal) to liquidation threshold\n    collateralLiqThreshold: uint256 = _userDebtAmount * HUNDRED_PERCENT // _liqThreshold\n    return _collateralVal <= collateralLiqThreshold\n\n\n@view\n@internal\ndef _canRedeemUserCollateral(_userDebtAmount: uint256, _collateralVal: uint256, _redemptionThreshold: uint256) -> bool:\n    if _redemptionThreshold == 0:\n        return False\n\n    # check if collateral value is below (or equal) to redemption threshold\n    redemptionThreshold: uint256 = _userDebtAmount * HUNDRED_PERCENT // _redemptionThreshold\n    return _collateralVal <= redemptionThreshold\n\n\n# thresholds\n\n\n@view\n@external\ndef getLiquidationThreshold(_user: address) -> uint256:\n    return self._getThreshold(_user, 2)\n\n\n@view\n@external\ndef getRedemptionThreshold(_user: address) -> uint256:\n    return self._getThreshold(_user, 3)\n\n\n@view\n@internal\ndef _getThreshold(_user: address, _debtType: uint256) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = self._getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0:\n        return 0\n\n    if _debtType == 2:\n        if bt.debtTerms.liqThreshold == 0:\n            return 0\n        return userDebt.amount * HUNDRED_PERCENT // bt.debtTerms.liqThreshold\n    elif _debtType == 3:\n        if bt.debtTerms.redemptionThreshold == 0:\n            return 0\n        return userDebt.amount * HUNDRED_PERCENT // bt.debtTerms.redemptionThreshold\n    else:\n        return 0\n\n\n##################\n# Green Handling #\n##################\n\n\n@internal\ndef _handleGreenForUser(\n    _recipient: address,\n    _greenAmount: uint256,\n    _wantsSavingsGreen: bool,\n    _shouldEnterStabPool: bool,\n    _a: addys.Addys,\n):\n    amount: uint256 = min(_greenAmount, staticcall IERC20(_a.greenToken).balanceOf(self))\n    if amount == 0:\n        return\n\n    if _wantsSavingsGreen and amount > 10 ** 9: # small dust will fail\n\n        sgreenRecipient: address = _recipient\n        if _shouldEnterStabPool:\n            sgreenRecipient = self\n\n        # put GREEN into sGREEN\n        assert extcall IERC20(_a.greenToken).approve(_a.savingsGreen, amount, default_return_value=True) # dev: green approval failed\n        sGreenAmount: uint256 = extcall IERC4626(_a.savingsGreen).deposit(amount, sgreenRecipient)\n        assert extcall IERC20(_a.greenToken).approve(_a.savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n        # put sGREEN into stability pool\n        if _shouldEnterStabPool:\n            assert extcall IERC20(_a.savingsGreen).approve(_a.teller, sGreenAmount, default_return_value=True) # dev: sgreen approval failed\n            extcall Teller(_a.teller).depositFromTrusted(_recipient, STABILITY_POOL_ID, _a.savingsGreen, sGreenAmount, 0, _a)\n            assert extcall IERC20(_a.savingsGreen).approve(_a.teller, 0, default_return_value=True) # dev: sgreen approval failed\n\n    else:\n        assert extcall IERC20(_a.greenToken).transfer(_recipient, amount, default_return_value=True) # dev: green transfer failed\n\n\n#############\n# Utilities #\n#############\n\n\n# max withdrawable\n\n\n@view\n@external\ndef getMaxWithdrawableForAsset(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    a: addys.Addys = addys._getAddys(_a)\n\n    vaultAddr: address = _vaultAddr\n    if vaultAddr == empty(address):\n        vaultAddr = staticcall AddressRegistry(a.vaultBook).getAddr(_vaultId)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    na: uint256 = 0\n    userDebt, na = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # no debt, can do max withdraw\n    if userDebt.amount == 0:\n        return max_value(uint256)\n\n    # cannot withdraw if in liquidation\n    if userDebt.inLiquidation:\n        return 0\n\n    # get current asset value for user\n    userBalance: uint256 = staticcall Vault(vaultAddr).getTotalAmountForUser(_user, _asset)\n    userUsdValue: uint256 = staticcall PriceDesk(a.priceDesk).getUsdValue(_asset, userBalance, False)\n    if userUsdValue == 0:\n        return 0 # cannot determine value\n\n    # get the asset's debt terms\n    assetDebtTerms: cs.DebtTerms = staticcall MissionControl(a.missionControl).getDebtTerms(_asset)\n    if assetDebtTerms.ltv == 0:\n        return max_value(uint256) # asset doesn't contribute to borrowing power\n\n    # get borrow terms excluding the asset to withdraw\n    btExcluding: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, True, _vaultId, _asset, a)\n\n    # calculate minimum asset value that must remain\n    minAssetValueToRemain: uint256 = 0\n\n    if btExcluding.collateralVal == 0:\n\n        # entire debt must be supported by this asset\n        minAssetValueToRemain = userDebt.amount * (HUNDRED_PERCENT + ONE_PERCENT) // assetDebtTerms.ltv\n\n    # multi-asset case: check if remaining collateral is sufficient\n    else:\n        minCollateralNeeded: uint256 = userDebt.amount * (HUNDRED_PERCENT + ONE_PERCENT) // btExcluding.debtTerms.ltv\n        if btExcluding.collateralVal >= minCollateralNeeded:\n            return max_value(uint256) # remaining collateral is sufficient\n\n        # calculate additional value needed from this asset\n        additionalCollateralNeeded: uint256 = minCollateralNeeded - btExcluding.collateralVal\n        minAssetValueToRemain = additionalCollateralNeeded * HUNDRED_PERCENT // assetDebtTerms.ltv\n\n    # cannot withdraw if user has less than the minimum required\n    if userUsdValue <= minAssetValueToRemain:\n        return 0\n\n    # convert to asset amount\n    maxWithdrawableValue: uint256 = userUsdValue - minAssetValueToRemain\n    return userBalance * maxWithdrawableValue // userUsdValue\n\n\n# accrue interest\n\n\n@view\n@internal\ndef _getLatestUserDebtWithInterest(_userDebt: UserDebt) -> (UserDebt, uint256):\n    userDebt: UserDebt = _userDebt\n\n    # nothing to do here\n    if userDebt.amount == 0 or userDebt.debtTerms.borrowRate == 0 or block.timestamp <= userDebt.lastTimestamp:\n        userDebt.lastTimestamp = block.timestamp\n        return userDebt, 0\n\n    # accrue latest interest\n    timeElapsed: uint256 = block.timestamp - userDebt.lastTimestamp\n\n    # multiply all numerators first, then divide by combined denominators\n    newInterest: uint256 = (userDebt.amount * userDebt.debtTerms.borrowRate * timeElapsed) // (HUNDRED_PERCENT * ONE_YEAR)\n    userDebt.amount += newInterest\n\n    userDebt.lastTimestamp = block.timestamp\n    return userDebt, newInterest\n\n\n# borrow interval\n\n\n@view \n@internal \ndef _getAvailDebtInInterval(\n    _userInterval: IntervalBorrow,\n    _maxBorrowPerInterval: uint256,\n    _numBlocksPerInterval: uint256,\n) -> (uint256, bool):\n    availToBorrow: uint256 = _maxBorrowPerInterval\n    isFreshInterval: bool = True\n    if _userInterval.start != 0 and _userInterval.start + _numBlocksPerInterval > block.number:\n        availToBorrow = _maxBorrowPerInterval - min(_userInterval.amount, _maxBorrowPerInterval)\n        isFreshInterval = False\n    return availToBorrow, isFreshInterval\n",
            "sha256sum": "2530ac7b025106139c91da098cc14b609d9dae08944be45d11be01ea94fe1f43"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/CreditEngine.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "e1d33172ee51bfe3b933d3c3f4650f1f7062fa92db728267639f3057498752db"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/core/CreditEngine.vy"
    },
    "Endaoment": {
      "address": "0xB2845F1633f7E9795D754D208B947B98B75Ed77e",
      "abi": [
        {
          "name": "EndaomentDeposit",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "assetAmountDeposited",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentWithdrawal",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "hasVaultToken",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "assetAmountReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultTokenAmountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundVaultTokenAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentSwap",
          "inputs": [
            {
              "name": "tokenIn",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenOut",
              "type": "address",
              "indexed": true
            },
            {
              "name": "swapAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "toAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "numTokens",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentLiquidityAdded",
          "inputs": [
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": true
            },
            {
              "name": "liqAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liqAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "liquidityAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pool",
              "type": "address",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAssetAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentLiquidityRemoved",
          "inputs": [
            {
              "name": "tokenA",
              "type": "address",
              "indexed": true
            },
            {
              "name": "tokenB",
              "type": "address",
              "indexed": false
            },
            {
              "name": "removedAmountA",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "removedAmountB",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "liquidityRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "refundedLpAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentEthConvertedToWeth",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidEth",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentWethConvertedToEth",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "weth",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentRewardsClaimed",
          "inputs": [
            {
              "name": "market",
              "type": "address",
              "indexed": true
            },
            {
              "name": "rewardToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "rewardAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "proof",
              "type": "bytes32",
              "indexed": false
            },
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "legoAddr",
              "type": "address",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentNftRecovered",
          "inputs": [
            {
              "name": "collection",
              "type": "address",
              "indexed": true
            },
            {
              "name": "nftTokenId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabilizerPoolLiqAdded",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "greenAmountAdded",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "poolDebtAdded",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabilizerPoolLiqRemoved",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "lpBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "greenAmountRemoved",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "debtRepaid",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PoolDebtRepaid",
          "inputs": [
            {
              "name": "pool",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PartnerLiquidityAdded",
          "inputs": [
            {
              "name": "partner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "partnerAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "greenAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "lpBalance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PartnerLiquidityMinted",
          "inputs": [
            {
              "name": "partner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "partnerAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "greenMinted",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "fallback"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "onERC721Received",
          "inputs": [
            {
              "name": "_operator",
              "type": "address"
            },
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_tokenId",
              "type": "uint256"
            },
            {
              "name": "_data",
              "type": "bytes"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bytes4"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vault",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_withdrawAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawTokens",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_withdrawAmount",
              "type": "uint256"
            },
            {
              "name": "_hasVaultToken",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultAddr",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultAddr",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "rebalance",
          "inputs": [
            {
              "name": "_fromLegoId",
              "type": "uint256"
            },
            {
              "name": "_fromAsset",
              "type": "address"
            },
            {
              "name": "_fromVaultAddr",
              "type": "address"
            },
            {
              "name": "_toLegoId",
              "type": "uint256"
            },
            {
              "name": "_toVaultAddr",
              "type": "address"
            },
            {
              "name": "_fromVaultAmount",
              "type": "uint256"
            },
            {
              "name": "_hasFromVaultToken",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapTokens",
          "inputs": [
            {
              "name": "_swapInstructions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "amountIn",
                  "type": "uint256"
                },
                {
                  "name": "minAmountOut",
                  "type": "uint256"
                },
                {
                  "name": "tokenPath",
                  "type": "address[]"
                },
                {
                  "name": "poolPath",
                  "type": "address[]"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_amountA",
              "type": "uint256"
            },
            {
              "name": "_amountB",
              "type": "uint256"
            },
            {
              "name": "_tickLower",
              "type": "int24"
            },
            {
              "name": "_tickUpper",
              "type": "int24"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_nftAddr",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_tokenA",
              "type": "address"
            },
            {
              "name": "_tokenB",
              "type": "address"
            },
            {
              "name": "_liqToRemove",
              "type": "uint256"
            },
            {
              "name": "_minAmountA",
              "type": "uint256"
            },
            {
              "name": "_minAmountB",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "payable",
          "type": "function",
          "name": "convertEthToWeth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_depositLegoId",
              "type": "uint256"
            },
            {
              "name": "_depositVault",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertWethToEth",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_withdrawLegoId",
              "type": "uint256"
            },
            {
              "name": "_withdrawVaultAddr",
              "type": "address"
            },
            {
              "name": "_hasWithdrawVaultToken",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimRewards",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_market",
              "type": "address"
            },
            {
              "name": "_rewardToken",
              "type": "address"
            },
            {
              "name": "_rewardAmount",
              "type": "uint256"
            },
            {
              "name": "_proof",
              "type": "bytes32"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "stabilizeGreenRefPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGreenAmountToAddInStabilizer",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGreenAmountToRemoveInStabilizer",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintPartnerLiquidity",
          "inputs": [
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintPartnerLiquidity",
          "inputs": [
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPartnerLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPartnerLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPartnerLiquidity",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_partner",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_minLpAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayPoolDebt",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayPoolDebt",
          "inputs": [
            {
              "name": "_pool",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverNft",
          "inputs": [
            {
              "name": "_collection",
              "type": "address"
            },
            {
              "name": "_nftTokenId",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_borrowAsset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDebt",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "WETH",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_weth",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/core/Endaoment.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC721\n\ninterface UnderscoreLego:\n    def addLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, uint256, uint256): nonpayable\n    def removeLiquidity(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256, uint256, bool): nonpayable\n    def swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, 5], _poolPath: DynArray[address, 4], _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256): nonpayable\n    def depositTokens(_asset: address, _amount: uint256, _vault: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, address, uint256, uint256, uint256): nonpayable\n    def withdrawTokens(_asset: address, _amount: uint256, _vaultToken: address, _recipient: address, _oracleRegistry: address = empty(address)) -> (uint256, uint256, uint256, uint256): nonpayable\n    def claimRewards(_user: address, _market: address, _rewardToken: address, _rewardAmount: uint256, _proof: bytes32): nonpayable\n    def getAccessForLego(_user: address) -> (address, String[64], uint256): view\n    def getLpToken(_pool: address) -> address: view\n\ninterface CurvePool:\n    def remove_liquidity_imbalance(_amounts: DynArray[uint256, 2], _maxLpBurnAmount: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def add_liquidity(_amounts: DynArray[uint256, 2], _minLpAmountOut: uint256, _recipient: address = msg.sender) -> uint256: nonpayable\n    def get_virtual_price() -> uint256: view\n\ninterface Ledger:\n    def updateGreenPoolDebt(_pool: address, _amount: uint256, _isIncrement: bool): nonpayable\n    def greenPoolDebt(_pool: address) -> uint256: view\n\ninterface PriceDesk:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface GreenToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n    def burn(_amount: uint256) -> bool: nonpayable\n\ninterface WethContract:\n    def withdraw(_amount: uint256): nonpayable\n    def deposit(): payable\n\ninterface CurvePrices:\n    def getGreenStabilizerConfig() -> StabilizerConfig: view\n\ninterface LegoRegistry:\n    def getLegoAddr(_legoId: uint256) -> address: view\n\ninterface UnderscoreRegistry:\n    def getAddy(_id: uint256) -> address: view\n\ninterface MissionControl:\n    def underscoreRegistry() -> address: view\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nstruct StabilizerConfig:\n    pool: address\n    lpToken: address\n    greenBalance: uint256\n    greenRatio: uint256\n    greenIndex: uint256\n    stabilizerAdjustWeight: uint256\n    stabilizerMaxPoolDebt: uint256\n\nevent EndaomentDeposit:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    assetAmountDeposited: uint256\n    vaultTokenAmountReceived: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n\nevent EndaomentWithdrawal:\n    asset: indexed(address)\n    vaultToken: indexed(address)\n    hasVaultToken: bool\n    assetAmountReceived: uint256\n    vaultTokenAmountBurned: uint256\n    refundVaultTokenAmount: uint256\n    usdValue: uint256\n    legoId: uint256\n    legoAddr: address\n\nevent EndaomentSwap:\n    tokenIn: indexed(address)\n    tokenOut: indexed(address)\n    swapAmount: uint256\n    toAmount: uint256\n    refundAssetAmount: uint256\n    usdValue: uint256\n    numTokens: uint256\n    legoId: uint256\n    legoAddr: address\n\nevent EndaomentLiquidityAdded:\n    tokenA: indexed(address)\n    tokenB: indexed(address)\n    liqAmountA: uint256\n    liqAmountB: uint256\n    liquidityAdded: uint256\n    pool: address\n    usdValue: uint256\n    refundAssetAmountA: uint256\n    refundAssetAmountB: uint256\n    nftTokenId: uint256\n    legoId: uint256\n    legoAddr: address\n\nevent EndaomentLiquidityRemoved:\n    tokenA: indexed(address)\n    tokenB: address\n    removedAmountA: uint256\n    removedAmountB: uint256\n    usdValue: uint256\n    isDepleted: bool\n    liquidityRemoved: uint256\n    lpToken: indexed(address)\n    refundedLpAmount: uint256\n    legoId: uint256\n    legoAddr: address\n\nevent EndaomentEthConvertedToWeth:\n    amount: uint256\n    paidEth: uint256\n    weth: indexed(address)\n\nevent EndaomentWethConvertedToEth:\n    amount: uint256\n    weth: indexed(address)\n\nevent EndaomentRewardsClaimed:\n    market: indexed(address)\n    rewardToken: indexed(address)\n    rewardAmount: uint256\n    proof: bytes32\n    legoId: uint256\n    legoAddr: address\n\nevent EndaomentNftRecovered:\n    collection: indexed(address)\n    nftTokenId: uint256\n    recipient: indexed(address)\n\nevent StabilizerPoolLiqAdded:\n    pool: indexed(address)\n    greenAmountAdded: uint256\n    lpReceived: uint256\n    poolDebtAdded: uint256\n\nevent StabilizerPoolLiqRemoved:\n    pool: indexed(address)\n    lpBurned: uint256\n    greenAmountRemoved: uint256\n    debtRepaid: uint256\n\nevent PoolDebtRepaid:\n    pool: indexed(address)\n    amount: uint256\n\nevent PartnerLiquidityAdded:\n    partner: indexed(address)\n    asset: indexed(address)\n    partnerAmount: uint256\n    greenAmount: uint256\n    lpBalance: uint256\n\nevent PartnerLiquidityMinted:\n    partner: indexed(address)\n    asset: indexed(address)\n    partnerAmount: uint256\n    greenMinted: uint256\n\nERC721_RECEIVE_DATA: constant(Bytes[1024]) = b\"UnderscoreErc721\"\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nFIFTY_PERCENT: constant(uint256) = 50_00 # 50.00%\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_SWAP_INSTRUCTIONS: constant(uint256) = 5\nMAX_LEGOS: constant(uint256) = 20\nMAX_TOKEN_PATH: constant(uint256) = 5\nLEGO_REGISTRY_ID: constant(uint256) = 2\nCURVE_PRICES_ID: constant(uint256) = 2\n\nWETH: public(immutable(address))\n\n\n@deploy\ndef __init__(_ripeHq: address, _weth: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, True, False) # can mint green only\n    WETH = _weth\n\n\n@payable\n@external\ndef __default__():\n    pass\n\n\n@view\n@external\ndef onERC721Received(_operator: address, _owner: address, _tokenId: uint256, _data: Bytes[1024]) -> bytes4:\n    # must implement method for safe NFT transfers\n    return method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes4)\n\n\n###########\n# Deposit #\n###########\n\n\n@nonreentrant\n@external\ndef depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256 = max_value(uint256),\n) -> (uint256, address, uint256, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    return self._depositTokens(_legoId, _asset, _vault, _amount)\n\n\n@internal\ndef _depositTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vault: address,\n    _amount: uint256,\n) -> (uint256, address, uint256, uint256):\n    legoAddr: address = self._getLegoAddr(_legoId)\n    amount: uint256 = self._getAmount(_asset, _amount)\n    assert extcall IERC20(_asset).approve(legoAddr, amount, default_return_value=True) # dev: approval failed\n\n    # deposit into lego partner\n    assetAmountDeposited: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    refundAssetAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountDeposited, vaultToken, vaultTokenAmountReceived, refundAssetAmount, usdValue = extcall UnderscoreLego(legoAddr).depositTokens(_asset, amount, _vault, self)\n    assert extcall IERC20(_asset).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log EndaomentDeposit(asset=_asset, vaultToken=vaultToken, assetAmountDeposited=assetAmountDeposited, vaultTokenAmountReceived=vaultTokenAmountReceived, refundAssetAmount=refundAssetAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr)\n    return assetAmountDeposited, vaultToken, vaultTokenAmountReceived, usdValue\n\n\n############\n# Withdraw #\n############\n\n\n@nonreentrant\n@external\ndef withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address,\n    _withdrawAmount: uint256 = max_value(uint256),\n    _hasVaultToken: bool = True,\n) -> (uint256, uint256, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    return self._withdrawTokens(_legoId, _asset, _vaultAddr, _withdrawAmount, _hasVaultToken)\n\n\n@internal\ndef _withdrawTokens(\n    _legoId: uint256,\n    _asset: address,\n    _vaultAddr: address,\n    _withdrawAmount: uint256,\n    _hasVaultToken: bool,\n) -> (uint256, uint256, uint256):\n    legoAddr: address = self._getLegoAddr(_legoId)\n\n    # finalize amount, this will look at vault token balance (not always 1:1 with underlying asset)\n    withdrawAmount: uint256 = _withdrawAmount\n    if _hasVaultToken and _vaultAddr != empty(address):\n        withdrawAmount = self._getAmount(_vaultAddr, _withdrawAmount)\n        # some vault tokens require max value approval (comp v3)\n        assert extcall IERC20(_vaultAddr).approve(legoAddr, max_value(uint256), default_return_value=True) # dev: approval failed\n    assert withdrawAmount != 0 # dev: nothing to withdraw\n\n    # withdraw from lego partner\n    assetAmountReceived: uint256 = 0\n    vaultTokenAmountBurned: uint256 = 0\n    refundVaultTokenAmount: uint256 = 0\n    usdValue: uint256 = 0\n    assetAmountReceived, vaultTokenAmountBurned, refundVaultTokenAmount, usdValue = extcall UnderscoreLego(legoAddr).withdrawTokens(_asset, withdrawAmount, _vaultAddr, self)\n\n    # zero out approvals\n    if _hasVaultToken and _vaultAddr != empty(address):\n        assert extcall IERC20(_vaultAddr).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log EndaomentWithdrawal(asset=_asset, vaultToken=_vaultAddr, hasVaultToken=_hasVaultToken, assetAmountReceived=assetAmountReceived, vaultTokenAmountBurned=vaultTokenAmountBurned, refundVaultTokenAmount=refundVaultTokenAmount, usdValue=usdValue, legoId=_legoId, legoAddr=legoAddr)\n    return assetAmountReceived, vaultTokenAmountBurned, usdValue\n\n\n#############\n# Rebalance #\n#############\n\n\n@nonreentrant\n@external\ndef rebalance(\n    _fromLegoId: uint256,\n    _fromAsset: address,\n    _fromVaultAddr: address,\n    _toLegoId: uint256,\n    _toVaultAddr: address,\n    _fromVaultAmount: uint256 = max_value(uint256),\n    _hasFromVaultToken: bool = True,\n) -> (uint256, address, uint256, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    # withdraw from the first lego\n    assetAmountReceived: uint256 = 0\n    na: uint256 = 0\n    withdrawUsdValue: uint256 = 0\n    assetAmountReceived, na, withdrawUsdValue = self._withdrawTokens(_fromLegoId, _fromAsset, _fromVaultAddr, _fromVaultAmount, _hasFromVaultToken)\n\n    # deposit the received assets into the second lego\n    assetAmountDeposited: uint256 = 0\n    newVaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    depositUsdValue: uint256 = 0\n    assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(_toLegoId, _fromAsset, _toVaultAddr, assetAmountReceived)\n\n    usdValue: uint256 = max(withdrawUsdValue, depositUsdValue)\n    return assetAmountDeposited, newVaultToken, vaultTokenAmountReceived, usdValue\n\n\n########\n# Swap #\n########\n\n\n@nonreentrant\n@external\ndef swapTokens(_swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (uint256, uint256, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    underscoreRegistry: address = staticcall MissionControl(addys._getMissionControlAddr()).underscoreRegistry()\n    legoRegistry: address = staticcall UnderscoreRegistry(underscoreRegistry).getAddy(LEGO_REGISTRY_ID)\n    numSwapInstructions: uint256 = len(_swapInstructions)\n    assert numSwapInstructions != 0 # dev: no swaps\n\n    # get high level swap info\n    tokenIn: address = empty(address)\n    initialAmountIn: uint256 = 0\n    tokenIn, initialAmountIn = self._getHighLevelSwapInfo(numSwapInstructions, _swapInstructions)\n\n    # perform swap instructions\n    amountIn: uint256 = initialAmountIn\n    lastTokenOut: address = empty(address)\n    lastTokenOutAmount: uint256 = 0\n    lastUsdValue: uint256 = 0\n    for j: uint256 in range(numSwapInstructions, bound=MAX_SWAP_INSTRUCTIONS):\n        i: SwapInstruction = _swapInstructions[j]\n\n        # from lego to lego, must follow the same token path\n        if lastTokenOut != empty(address):\n            newTokenIn: address = i.tokenPath[0]\n            assert lastTokenOut == newTokenIn # dev: invalid token path\n            amountIn = min(lastTokenOutAmount, staticcall IERC20(newTokenIn).balanceOf(self))\n\n        lastTokenOut, lastTokenOutAmount, lastUsdValue = self._performSwapInstruction(i.legoId, amountIn, i.minAmountOut, i.tokenPath, i.poolPath, legoRegistry)\n\n    return initialAmountIn, lastTokenOutAmount, lastUsdValue\n\n\n@internal\ndef _performSwapInstruction(\n    _legoId: uint256,\n    _amountIn: uint256,\n    _minAmountOut: uint256,\n    _tokenPath: DynArray[address, MAX_TOKEN_PATH],\n    _poolPath: DynArray[address, MAX_TOKEN_PATH - 1],\n    _legoRegistry: address,\n) -> (address, uint256, uint256):\n    legoAddr: address = staticcall LegoRegistry(_legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n\n    # get token in and token out\n    tokenIn: address = _tokenPath[0]\n    tokenOut: address = _tokenPath[len(_tokenPath) - 1]\n\n    # approve token in\n    assert extcall IERC20(tokenIn).approve(legoAddr, _amountIn, default_return_value=True) # dev: approval failed\n\n    # swap assets via lego partner\n    tokenInAmount: uint256 = 0\n    tokenOutAmount: uint256 = 0\n    refundTokenInAmount: uint256 = 0\n    usdValue: uint256 = 0\n    tokenInAmount, tokenOutAmount, refundTokenInAmount, usdValue = extcall UnderscoreLego(legoAddr).swapTokens(_amountIn, _minAmountOut, _tokenPath, _poolPath, self)\n\n    # reset approvals\n    assert extcall IERC20(tokenIn).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log EndaomentSwap(tokenIn=tokenIn, tokenOut=tokenOut, swapAmount=tokenInAmount, toAmount=tokenOutAmount, refundAssetAmount=refundTokenInAmount, usdValue=usdValue, numTokens=len(_tokenPath), legoId=_legoId, legoAddr=legoAddr)\n    return tokenOut, tokenOutAmount, usdValue\n\n\n@view\n@internal\ndef _getHighLevelSwapInfo(_numSwapInstructions: uint256, _swapInstructions: DynArray[SwapInstruction, MAX_SWAP_INSTRUCTIONS]) -> (address, uint256):   \n    firstRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[0].tokenPath\n    firstRouteNumTokens: uint256 = len(firstRoutePath)\n    assert firstRouteNumTokens >= 2 # dev: invalid token path\n\n    # finalize token in and token out\n    tokenIn: address = firstRoutePath[0]\n    tokenOut: address = empty(address)\n    if _numSwapInstructions == 1:\n        tokenOut = firstRoutePath[firstRouteNumTokens - 1]\n    else:\n        lastRoutePath: DynArray[address, MAX_TOKEN_PATH] = _swapInstructions[_numSwapInstructions - 1].tokenPath\n        lastRouteNumTokens: uint256 = len(lastRoutePath)\n        assert lastRouteNumTokens >= 2 # dev: invalid token path\n        tokenOut = lastRoutePath[lastRouteNumTokens - 1]\n\n    assert empty(address) not in [tokenIn, tokenOut] # dev: invalid token path\n\n    # finalize amount in\n    amountIn: uint256 = self._getAmount(tokenIn, _swapInstructions[0].amountIn)\n    return tokenIn, amountIn\n\n\n#################\n# Add Liquidity #\n#################\n\n\n@nonreentrant\n@external\ndef addLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    legoAddr: address = self._getLegoAddr(_legoId)\n    return self._addLiquidity(_legoId, legoAddr, _nftAddr, _nftTokenId, _pool, _tokenA, _tokenB, _amountA, _amountB, _tickLower, _tickUpper, _minAmountA, _minAmountB, _minLpAmount)\n\n\n@internal\ndef _addLiquidity(\n    _legoId: uint256,\n    _legoAddr: address,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _amountA: uint256 = max_value(uint256),\n    _amountB: uint256 = max_value(uint256),\n    _tickLower: int24 = min_value(int24),\n    _tickUpper: int24 = max_value(int24),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256, uint256, uint256):\n\n    # token a\n    amountA: uint256 = 0\n    if _amountA != 0:\n        amountA = self._getAmount(_tokenA, _amountA)\n        assert extcall IERC20(_tokenA).approve(_legoAddr, amountA, default_return_value=True) # dev: approval failed\n\n    # token b\n    amountB: uint256 = 0\n    if _amountB != 0:\n        amountB = self._getAmount(_tokenB, _amountB)\n        assert extcall IERC20(_tokenB).approve(_legoAddr, amountB, default_return_value=True) # dev: approval failed\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, _legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # add liquidity via lego partner\n    liquidityAdded: uint256 = 0\n    liqAmountA: uint256 = 0\n    liqAmountB: uint256 = 0\n    usdValue: uint256 = 0\n    refundAssetAmountA: uint256 = 0\n    refundAssetAmountB: uint256 = 0\n    nftTokenId: uint256 = 0\n    liquidityAdded, liqAmountA, liqAmountB, usdValue, refundAssetAmountA, refundAssetAmountB, nftTokenId = extcall UnderscoreLego(_legoAddr).addLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, _tickLower, _tickUpper, amountA, amountB, _minAmountA, _minAmountB, _minLpAmount, self)\n\n    # validate the nft came back\n    if hasNftLiqPosition:\n        assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n\n    # token a\n    if amountA != 0:\n        assert extcall IERC20(_tokenA).approve(_legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    # token b\n    if amountB != 0:\n        assert extcall IERC20(_tokenB).approve(_legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log EndaomentLiquidityAdded(tokenA=_tokenA, tokenB=_tokenB, liqAmountA=liqAmountA, liqAmountB=liqAmountB, liquidityAdded=liquidityAdded, pool=_pool, usdValue=usdValue, refundAssetAmountA=refundAssetAmountA, refundAssetAmountB=refundAssetAmountB, nftTokenId=nftTokenId, legoId=_legoId, legoAddr=_legoAddr)\n    return liquidityAdded, liqAmountA, liqAmountB, usdValue, nftTokenId\n\n\n####################\n# Remove Liquidity #\n####################\n\n\n@nonreentrant\n@external\ndef removeLiquidity(\n    _legoId: uint256,\n    _nftAddr: address,\n    _nftTokenId: uint256,\n    _pool: address,\n    _tokenA: address,\n    _tokenB: address,\n    _liqToRemove: uint256 = max_value(uint256),\n    _minAmountA: uint256 = 0,\n    _minAmountB: uint256 = 0,\n) -> (uint256, uint256, uint256, bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    legoAddr: address = self._getLegoAddr(_legoId)\n    lpToken: address = empty(address)\n    liqToRemove: uint256 = _liqToRemove\n\n    # transfer nft to lego (if applicable)\n    hasNftLiqPosition: bool = _nftAddr != empty(address) and _nftTokenId != 0\n    if hasNftLiqPosition:\n        extcall IERC721(_nftAddr).safeTransferFrom(self, legoAddr, _nftTokenId, ERC721_RECEIVE_DATA)\n\n    # handle lp token\n    else:\n        lpToken = staticcall UnderscoreLego(legoAddr).getLpToken(_pool)\n        liqToRemove = self._getAmount(lpToken, liqToRemove)\n        assert extcall IERC20(lpToken).approve(legoAddr, liqToRemove, default_return_value=True) # dev: approval failed\n\n    # remove liquidity via lego partner\n    amountA: uint256 = 0\n    amountB: uint256 = 0\n    usdValue: uint256 = 0\n    liquidityRemoved: uint256 = 0\n    refundedLpAmount: uint256 = 0\n    isDepleted: bool = False\n    amountA, amountB, usdValue, liquidityRemoved, refundedLpAmount, isDepleted = extcall UnderscoreLego(legoAddr).removeLiquidity(_nftTokenId, _pool, _tokenA, _tokenB, lpToken, liqToRemove, _minAmountA, _minAmountB, self)\n\n    # validate the nft came back, reset lp token approvals\n    if hasNftLiqPosition:\n        if not isDepleted:\n            assert staticcall IERC721(_nftAddr).ownerOf(_nftTokenId) == self # dev: nft not returned\n    else:\n        assert extcall IERC20(lpToken).approve(legoAddr, 0, default_return_value=True) # dev: approval failed\n\n    log EndaomentLiquidityRemoved(tokenA=_tokenA, tokenB=_tokenB, removedAmountA=amountA, removedAmountB=amountB, usdValue=usdValue, isDepleted=isDepleted, liquidityRemoved=liquidityRemoved, lpToken=lpToken, refundedLpAmount=refundedLpAmount, legoId=_legoId, legoAddr=legoAddr)\n    return amountA, amountB, usdValue, isDepleted\n\n\n################\n# Wrapped ETH #\n################\n\n\n# eth -> weth\n\n\n@nonreentrant\n@payable\n@external\ndef convertEthToWeth(\n    _amount: uint256 = max_value(uint256),\n    _depositLegoId: uint256 = 0,\n    _depositVault: address = empty(address),\n) -> (uint256, address, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    weth: address = WETH\n\n    # convert eth to weth\n    amount: uint256 = min(_amount, self.balance)\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).deposit(value=amount)\n    log EndaomentEthConvertedToWeth(amount=amount, paidEth=msg.value, weth=weth)\n\n    # deposit weth into lego partner\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    if _depositLegoId != 0:\n        depositUsdValue: uint256 = 0\n        amount, vaultToken, vaultTokenAmountReceived, depositUsdValue = self._depositTokens(_depositLegoId, weth, _depositVault, amount)\n\n    return amount, vaultToken, vaultTokenAmountReceived\n\n\n# weth -> eth\n\n\n@nonreentrant\n@external\ndef convertWethToEth(\n    _amount: uint256 = max_value(uint256),\n    _recipient: address = empty(address),\n    _withdrawLegoId: uint256 = 0,\n    _withdrawVaultAddr: address = empty(address),\n    _hasWithdrawVaultToken: bool = True,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    weth: address = WETH\n\n    # withdraw weth from lego partner (if applicable)\n    amount: uint256 = _amount\n    usdValue: uint256 = 0\n    if _withdrawLegoId != 0:\n        _na: uint256 = 0\n        amount, _na, usdValue = self._withdrawTokens(_withdrawLegoId, weth, _withdrawVaultAddr, _amount, _hasWithdrawVaultToken)\n\n    # convert weth to eth\n    amount = min(amount, staticcall IERC20(weth).balanceOf(self))\n    assert amount != 0 # dev: nothing to convert\n    extcall WethContract(weth).withdraw(amount)\n    log EndaomentWethConvertedToEth(amount=amount, weth=weth)\n\n    # ignoring `_recipient` in this context\n    return amount\n\n\n#################\n# Claim Rewards #\n#################\n\n\n@nonreentrant\n@external\ndef claimRewards(\n    _legoId: uint256,\n    _market: address = empty(address),\n    _rewardToken: address = empty(address),\n    _rewardAmount: uint256 = max_value(uint256),\n    _proof: bytes32 = empty(bytes32),\n):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    # make sure lego has access to claim rewards\n    legoAddr: address = self._getLegoAddr(_legoId)\n    self._checkLegoAccessForAction(legoAddr)\n\n    # pre reward balance\n    preRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        preRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n\n    # claim rewards\n    extcall UnderscoreLego(legoAddr).claimRewards(self, _market, _rewardToken, _rewardAmount, _proof)\n\n    # post reward balance\n    postRewardBalance: uint256 = 0\n    if _rewardToken != empty(address):\n        postRewardBalance = staticcall IERC20(_rewardToken).balanceOf(self)\n    rewardAmount: uint256 = postRewardBalance - preRewardBalance\n\n    log EndaomentRewardsClaimed(market=_market, rewardToken=_rewardToken, rewardAmount=rewardAmount, proof=_proof, legoId=_legoId, legoAddr=legoAddr)\n\n\n####################\n# Green Stabilizer #\n####################\n\n\n@external\ndef stabilizeGreenRefPool() -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    a: addys.Addys = addys._getAddys()\n\n    curvePrices: address = staticcall PriceDesk(a.priceDesk).getAddr(CURVE_PRICES_ID)\n    data: StabilizerConfig = staticcall CurvePrices(curvePrices).getGreenStabilizerConfig()\n    if data.pool == empty(address) or data.greenBalance == 0:\n        return False\n\n    # current profits\n    lpBalance: uint256 = staticcall IERC20(data.lpToken).balanceOf(self)\n    leftoverGreen: uint256 = staticcall IERC20(a.greenToken).balanceOf(self)\n    poolDebt: uint256 = staticcall Ledger(a.ledger).greenPoolDebt(data.pool)\n    initialProfit: uint256 = self._calcProfitForStabilizer(data.pool, lpBalance, leftoverGreen, poolDebt)\n\n    # add/remove Green to pool (50% ratio is fully balanced)\n    didAdjust: bool = False\n    if data.greenRatio < FIFTY_PERCENT:\n        didAdjust = self._addStabilizerGreenLiquidity(poolDebt, leftoverGreen, data, a.greenToken, a.ledger)\n    else:\n        didAdjust = self._removeStabilizerGreenLiquidity(lpBalance, poolDebt, data, a.greenToken, a.ledger)\n\n    # calc new profits\n    lpBalance = staticcall IERC20(data.lpToken).balanceOf(self)\n    leftoverGreen = staticcall IERC20(a.greenToken).balanceOf(self)\n    poolDebt = staticcall Ledger(a.ledger).greenPoolDebt(data.pool)\n    newProfit: uint256 = self._calcProfitForStabilizer(data.pool, lpBalance, leftoverGreen, poolDebt)\n    assert newProfit >= initialProfit # dev: stabilizer was not profitable\n\n    return didAdjust\n\n\n# add green liq\n\n\n@internal\ndef _addStabilizerGreenLiquidity(\n    _poolDebt: uint256,\n    _leftoverGreen: uint256,\n    _data: StabilizerConfig,\n    _greenToken: address,\n    _ledger: address,\n) -> bool:\n    greenAmountToAdd: uint256 = self._getGreenAmountToAdd(_poolDebt, _leftoverGreen, _data)\n    if greenAmountToAdd == 0:\n        return False # debt max reached\n\n    # mint green, save debt\n    newDebt: uint256 = 0\n    if greenAmountToAdd > _leftoverGreen:\n        newDebt = greenAmountToAdd - _leftoverGreen\n        self._addPoolDebt(_data.pool, newDebt, _greenToken, _ledger)\n\n    # add liquidity\n    assert extcall IERC20(_greenToken).approve(_data.pool, greenAmountToAdd, default_return_value=True) # dev: approval failed\n    amounts: DynArray[uint256, 2] = [0, 0]\n    amounts[_data.greenIndex] = greenAmountToAdd\n    lpReceived: uint256 = extcall CurvePool(_data.pool).add_liquidity(amounts, 0, self)\n    assert extcall IERC20(_greenToken).approve(_data.pool, 0, default_return_value=True) # dev: approval failed\n\n    log StabilizerPoolLiqAdded(pool=_data.pool, greenAmountAdded=greenAmountToAdd, lpReceived=lpReceived, poolDebtAdded=newDebt)\n    return lpReceived != 0\n\n\n@view\n@internal\ndef _getGreenAmountToAdd(\n    _poolDebt: uint256,\n    _leftoverGreen: uint256,\n    _data: StabilizerConfig,\n) -> uint256:\n    # only add green when green ratio < 50% (pool has excess other asset)\n    if _data.greenRatio >= FIFTY_PERCENT:\n        return 0\n\n    totalPoolBalance: uint256 = _data.greenBalance * HUNDRED_PERCENT // _data.greenRatio\n    targetBalance: uint256 = totalPoolBalance // 2\n\n    # safe subtraction: only proceed if targetBalance > greenBalance\n    if targetBalance <= _data.greenBalance:\n        return 0\n\n    greenAdjustFull: uint256 = (targetBalance - _data.greenBalance) * 2\n    greenAdjustWeighted: uint256 = greenAdjustFull * _data.stabilizerAdjustWeight // HUNDRED_PERCENT\n\n    debtAvail: uint256 = 0 \n    if _data.stabilizerMaxPoolDebt > _poolDebt:\n        debtAvail = _data.stabilizerMaxPoolDebt - _poolDebt\n\n    return min(greenAdjustWeighted, debtAvail + _leftoverGreen)\n\n\n@view\n@external\ndef getGreenAmountToAddInStabilizer() -> uint256:\n    curvePrices: address = staticcall PriceDesk(addys._getPriceDeskAddr()).getAddr(CURVE_PRICES_ID)\n    data: StabilizerConfig = staticcall CurvePrices(curvePrices).getGreenStabilizerConfig()\n    if data.pool == empty(address) or data.greenBalance == 0:\n        return 0\n    poolDebt: uint256 = staticcall Ledger(addys._getLedgerAddr()).greenPoolDebt(data.pool)\n    leftoverGreen: uint256 = staticcall IERC20(addys._getGreenToken()).balanceOf(self)\n    return self._getGreenAmountToAdd(poolDebt, leftoverGreen, data)\n\n\n# remove green liq\n\n\n@internal\ndef _removeStabilizerGreenLiquidity(\n    _lpBalance: uint256,\n    _poolDebt: uint256,\n    _data: StabilizerConfig,\n    _greenToken: address,\n    _ledger: address,\n) -> bool:\n    greenAmount: uint256 = self._getGreenAmountToRemove(_lpBalance, _poolDebt, _data)\n    if greenAmount == 0:\n        return False # nothing to remove \n\n    # remove liquidity\n    assert extcall IERC20(_data.lpToken).approve(_data.pool, _lpBalance, default_return_value=True) # dev: approval failed\n    amounts: DynArray[uint256, 2] = [0, 0]\n    amounts[_data.greenIndex] = greenAmount\n    lpBurned: uint256 = extcall CurvePool(_data.pool).remove_liquidity_imbalance(amounts, max_value(uint256), self)\n    assert extcall IERC20(_data.lpToken).approve(_data.pool, 0, default_return_value=True) # dev: approval failed\n\n    # update pool debt\n    greenAmount = min(greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n    debtToRepay: uint256 = min(greenAmount, _poolDebt)\n    if debtToRepay != 0:\n        self._repayPoolDebt(_data.pool, debtToRepay, _greenToken, _ledger)\n\n    log StabilizerPoolLiqRemoved(pool=_data.pool, lpBurned=lpBurned, greenAmountRemoved=greenAmount, debtRepaid=debtToRepay)\n    return lpBurned != 0 and greenAmount != 0\n\n\n@view\n@internal\ndef _getGreenAmountToRemove(\n    _lpBalance: uint256,\n    _poolDebt: uint256,\n    _data: StabilizerConfig,\n) -> uint256:\n    # only remove green when green ratio > 50% (pool has excess green)\n    if _data.greenRatio <= FIFTY_PERCENT:\n        return 0\n\n    totalPoolBalance: uint256 = _data.greenBalance * HUNDRED_PERCENT // _data.greenRatio\n    targetBalance: uint256 = totalPoolBalance // 2\n\n    # safe subtraction: only proceed if greenBalance > targetBalance\n    if _data.greenBalance <= targetBalance:\n        return 0\n\n    greenAdjustFull: uint256 = (_data.greenBalance - targetBalance) * 2\n    greenAdjustWeighted: uint256 = greenAdjustFull * _data.stabilizerAdjustWeight // HUNDRED_PERCENT\n    maxGreenToRemove: uint256 = max(_poolDebt, _data.greenBalance * _lpBalance // staticcall IERC20(_data.lpToken).totalSupply())\n    return min(greenAdjustWeighted, maxGreenToRemove)\n\n\n@view\n@external\ndef getGreenAmountToRemoveInStabilizer() -> uint256:\n    curvePrices: address = staticcall PriceDesk(addys._getPriceDeskAddr()).getAddr(CURVE_PRICES_ID)\n    data: StabilizerConfig = staticcall CurvePrices(curvePrices).getGreenStabilizerConfig()\n    if data.pool == empty(address) or data.greenBalance == 0:\n        return 0\n    lpBalance: uint256 = staticcall IERC20(data.lpToken).balanceOf(self)\n    poolDebt: uint256 = staticcall Ledger(addys._getLedgerAddr()).greenPoolDebt(data.pool)\n    return self._getGreenAmountToRemove(lpBalance, poolDebt, data)\n\n\n# utilities\n\n\n@view\n@internal\ndef _calcProfitForStabilizer(\n    _pool: address,\n    _lpBalance: uint256,\n    _greenBalance: uint256,\n    _poolDebt: uint256,\n) -> uint256:\n    netGreenBal: uint256 = 0\n    netGreenDebt: uint256 = 0\n    if _poolDebt > _greenBalance:\n        netGreenDebt = _poolDebt - _greenBalance\n        netGreenBal = 0\n    else:\n        netGreenBal = _greenBalance - _poolDebt\n\n    virtualPrice: uint256 = staticcall CurvePool(_pool).get_virtual_price()\n\n    lpDebt: uint256 = 0\n    if netGreenDebt != 0:\n        lpDebt = netGreenDebt * EIGHTEEN_DECIMALS // virtualPrice\n\n    if _lpBalance <= lpDebt:\n        return 0\n    else:\n        netGreenBalInLp: uint256 = netGreenBal * EIGHTEEN_DECIMALS // virtualPrice\n        return (_lpBalance - lpDebt) + netGreenBalInLp\n\n\n#####################\n# Partner Liquidity #\n#####################\n\n\n@external\ndef mintPartnerLiquidity(_partner: address, _asset: address, _amount: uint256 = max_value(uint256)) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    a: addys.Addys = addys._getAddys()\n    partnerAmount: uint256 = 0\n    greenMinted: uint256 = 0\n    partnerAmount, greenMinted = self._mintPartnerLiquidity(_partner, _asset, _amount, a.priceDesk, a.greenToken)\n    log PartnerLiquidityMinted(partner=_partner, asset=_asset, partnerAmount=partnerAmount, greenMinted=greenMinted)\n    return greenMinted\n\n\n@external\ndef addPartnerLiquidity(\n    _legoId: uint256,\n    _pool: address,\n    _partner: address,\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _minLpAmount: uint256 = 0,\n) -> (uint256, uint256, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    a: addys.Addys = addys._getAddys()\n\n    # mint green\n    partnerAmount: uint256 = 0\n    greenAmount: uint256 = 0\n    partnerAmount, greenAmount = self._mintPartnerLiquidity(_partner, _asset, _amount, a.priceDesk, a.greenToken)\n\n    # add liquidity\n    legoAddr: address = self._getLegoAddr(_legoId)\n    liquidityAdded: uint256 = 0\n    liqAmountA: uint256 = 0\n    liqAmountB: uint256 = 0\n    usdValue: uint256 = 0\n    nftTokenId: uint256 = 0\n    liquidityAdded, liqAmountA, liqAmountB, usdValue, nftTokenId = self._addLiquidity(_legoId, legoAddr, empty(address), 0, _pool, _asset, a.greenToken, partnerAmount, greenAmount, 0, 0, 0, 0, _minLpAmount)\n\n    # share lp balance with partner\n    lpToken: address = staticcall UnderscoreLego(legoAddr).getLpToken(_pool)\n    lpBalance: uint256 = staticcall IERC20(lpToken).balanceOf(self)\n    assert lpBalance != 0 # dev: no liquidity added\n    assert extcall IERC20(lpToken).transfer(_partner, lpBalance // 2, default_return_value=True) # dev: could not transfer\n\n    # add pool debt\n    extcall Ledger(a.ledger).updateGreenPoolDebt(_pool, greenAmount, True)\n\n    log PartnerLiquidityAdded(partner=_partner, asset=_asset, partnerAmount=partnerAmount, greenAmount=greenAmount, lpBalance=lpBalance)\n    return liquidityAdded, liqAmountA, liqAmountB\n\n\n# utils\n\n\n@internal\ndef _mintPartnerLiquidity(\n    _partner: address,\n    _asset: address,\n    _amount: uint256,\n    _priceDesk: address,\n    _greenToken: address,\n) -> (uint256, uint256):\n    partnerAmount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(_partner))\n    assert partnerAmount != 0 # dev: no asset to add\n    assert extcall IERC20(_asset).transferFrom(_partner, self, partnerAmount, default_return_value=True) # dev: transfer failed\n\n    usdValue: uint256 = staticcall PriceDesk(_priceDesk).getUsdValue(_asset, partnerAmount, True)\n    assert usdValue != 0 # dev: invalid asset\n\n    # mint green\n    extcall GreenToken(_greenToken).mint(self, usdValue)\n    return partnerAmount, usdValue\n\n\n#############\n# Pool Debt #\n#############\n\n\n@external\ndef repayPoolDebt(_pool: address, _amount: uint256 = max_value(uint256)) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    a: addys.Addys = addys._getAddys()\n\n    greenAvail: uint256 = min(_amount, staticcall IERC20(a.greenToken).balanceOf(self))\n    repayAmount: uint256 = min(greenAvail, staticcall Ledger(a.ledger).greenPoolDebt(_pool))\n    assert repayAmount != 0 # dev: no debt to repay\n\n    self._repayPoolDebt(_pool, repayAmount, a.greenToken, a.ledger)\n    log PoolDebtRepaid(pool=_pool, amount=repayAmount)\n    return True\n\n\n#############\n# Utilities #\n#############\n\n\n# lego addr\n\n\n@view\n@internal\ndef _getLegoAddr(_legoId: uint256) -> address:\n    underscoreRegistry: address = staticcall MissionControl(addys._getMissionControlAddr()).underscoreRegistry()\n    legoRegistry: address = staticcall UnderscoreRegistry(underscoreRegistry).getAddy(LEGO_REGISTRY_ID)\n    legoAddr: address = staticcall LegoRegistry(legoRegistry).getLegoAddr(_legoId)\n    assert legoAddr != empty(address) # dev: invalid lego\n    return legoAddr\n\n\n# amount\n\n\n@view\n@internal\ndef _getAmount(_asset: address, _amount: uint256) -> uint256:\n    amount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(self))\n    assert amount != 0 # dev: no funds available\n    return amount\n\n\n# recover nft\n\n\n@external\ndef recoverNft(_collection: address, _nftTokenId: uint256, _recipient: address) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    if staticcall IERC721(_collection).ownerOf(_nftTokenId) != self:\n        return False\n\n    extcall IERC721(_collection).safeTransferFrom(self, _recipient, _nftTokenId)\n    log EndaomentNftRecovered(collection=_collection, nftTokenId=_nftTokenId, recipient=_recipient)\n    return True\n\n\n# pool debt\n\n\n@internal\ndef _repayPoolDebt(\n    _pool: address,\n    _amount: uint256,\n    _greenToken: address,\n    _ledger: address,\n):\n    assert extcall GreenToken(_greenToken).burn(_amount) # dev: could not burn green\n    extcall Ledger(_ledger).updateGreenPoolDebt(_pool, _amount, False)\n\n\n@internal\ndef _addPoolDebt(\n    _pool: address,\n    _amount: uint256,\n    _greenToken: address,\n    _ledger: address,\n):\n    extcall GreenToken(_greenToken).mint(self, _amount)\n    extcall Ledger(_ledger).updateGreenPoolDebt(_pool, _amount, True)\n\n\n# allow lego to perform action\n\n\n@internal\ndef _checkLegoAccessForAction(_legoAddr: address):\n    targetAddr: address = empty(address)\n    accessAbi: String[64] = empty(String[64])\n    numInputs: uint256 = 0\n    targetAddr, accessAbi, numInputs = staticcall UnderscoreLego(_legoAddr).getAccessForLego(self)\n\n    # nothing to do here\n    if targetAddr == empty(address):\n        return\n\n    method_abi: bytes4 = convert(slice(keccak256(accessAbi), 0, 4), bytes4)\n    success: bool = False\n    response: Bytes[32] = b\"\"\n\n    # assumes input is: lego addr (operator)\n    if numInputs == 1:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator)\n    elif numInputs == 2:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    # assumes input (and order) is: user addr (owner), lego addr (operator), allowed bool\n    elif numInputs == 3:\n        success, response = raw_call(\n            targetAddr,\n            concat(\n                method_abi,\n                convert(self, bytes32),\n                convert(_legoAddr, bytes32),\n                convert(True, bytes32),\n            ),\n            revert_on_failure=False,\n            max_outsize=32,\n        )\n\n    assert success # dev: failed to set operator\n\n\n####################\n# Other Underscore #\n####################\n\n\n@nonreentrant\n@external\ndef borrow(\n    _legoId: uint256,\n    _borrowAsset: address = empty(address),\n    _amount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256):\n    return empty(address), 0, 0\n\n\n@nonreentrant\n@external\ndef repayDebt(\n    _legoId: uint256,\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n) -> (address, uint256, uint256, uint256):\n    return empty(address), 0, 0, 0\n\n\n@nonreentrant\n@external\ndef transferFunds(\n    _recipient: address,\n    _amount: uint256 = max_value(uint256),\n    _asset: address = empty(address),\n) -> (uint256, uint256):\n    # NOTE: use `recoverFunds()` from DeptBasics module instead\n    return 0, 0",
            "sha256sum": "79d8bf2cfbce6298539b240d9b2a2d256e1154997954747f30603c31cbe567bb"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/Endaoment.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "cc64f0355f0993c7095d888dbe1ffa1f1d7591a0de71efe4063d0c6c5b353e99"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a030000000000000000000000004200000000000000000000000000000000000006",
      "file": "contracts/core/Endaoment.vy"
    },
    "HumanResources": {
      "address": "0xC57a8671191f18dB46221289391f6a6389F7B4E9",
      "abi": [
        {
          "name": "NewContributorInitiated",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "manager",
              "type": "address",
              "indexed": true
            },
            {
              "name": "compensation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "startDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "cliffLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "unlockLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "depositLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewContributorConfirmed",
          "inputs": [
            {
              "name": "contributorAddr",
              "type": "address",
              "indexed": true
            },
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "manager",
              "type": "address",
              "indexed": true
            },
            {
              "name": "compensation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "startDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "cliffLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "unlockLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "depositLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewContributorCancelled",
          "inputs": [
            {
              "name": "owner",
              "type": "address",
              "indexed": true
            },
            {
              "name": "manager",
              "type": "address",
              "indexed": true
            },
            {
              "name": "compensation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "startDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "cliffLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "unlockLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "depositLockDuration",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "initiateNewContributor",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_manager",
              "type": "address"
            },
            {
              "name": "_compensation",
              "type": "uint256"
            },
            {
              "name": "_startDelay",
              "type": "uint256"
            },
            {
              "name": "_vestingLength",
              "type": "uint256"
            },
            {
              "name": "_cliffLength",
              "type": "uint256"
            },
            {
              "name": "_unlockLength",
              "type": "uint256"
            },
            {
              "name": "_depositLockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewContributor",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewContributor",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "areValidContributorTerms",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_manager",
              "type": "address"
            },
            {
              "name": "_compensation",
              "type": "uint256"
            },
            {
              "name": "_startDelay",
              "type": "uint256"
            },
            {
              "name": "_vestingLength",
              "type": "uint256"
            },
            {
              "name": "_cliffLength",
              "type": "uint256"
            },
            {
              "name": "_unlockLength",
              "type": "uint256"
            },
            {
              "name": "_depositLockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canModifyHrContributor",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasRipeBalance",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferContributorRipeTokens",
          "inputs": [
            {
              "name": "_owner",
              "type": "address"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cashRipeCheck",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "refundAfterCancelPaycheck",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldBurnPosition",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalClaimed",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getTotalCompensation",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingContributor",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "owner",
                  "type": "address"
                },
                {
                  "name": "manager",
                  "type": "address"
                },
                {
                  "name": "compensation",
                  "type": "uint256"
                },
                {
                  "name": "startDelay",
                  "type": "uint256"
                },
                {
                  "name": "vestingLength",
                  "type": "uint256"
                },
                {
                  "name": "cliffLength",
                  "type": "uint256"
                },
                {
                  "name": "unlockLength",
                  "type": "uint256"
                },
                {
                  "name": "depositLockDuration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "contracts/modules/LocalGov.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "c5fc8cc15c29232eac82b0ad2919828f13b3c5d343dee552e4643d010405c20d"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# @version 0.4.1\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "d3cc46c981ea30e6cd26b22d4c6b6a72250055331934280527b5eb6de8ad8189"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "contracts/core/HumanResources.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\nimport interfaces.ConfigStructs as cs\n\nfrom interfaces import Vault\nfrom interfaces import Department\nfrom ethereum.ercs import IERC20\n\ninterface Ledger:\n    def addHrContributor(_contributor: address, _compensation: uint256): nonpayable\n    def addVaultToUser(_user: address, _vaultId: uint256): nonpayable\n    def isHrContributor(_contributor: address) -> bool: view\n    def setRipeAvailForHr(_amount: uint256): nonpayable\n    def contributors(i: uint256) -> address: view\n    def numContributors() -> uint256: view\n    def ripeAvailForHr() -> uint256: view\n\ninterface RipeGovVault:\n    def transferContributorRipeTokens(_contributor: address, _toUser: address, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def withdrawContributorTokensToBurn(_user: address, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n\ninterface RipeToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n    def burn(_amount: uint256) -> bool: nonpayable\n\ninterface HrContributor:\n    def totalClaimed() -> uint256: view\n    def compensation() -> uint256: view\n\ninterface Teller:\n    def depositFromTrusted(_user: address, _vaultId: uint256, _asset: address, _amount: uint256, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n\ninterface Lootbox:\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface VaultBook:\n    def getAddr(_vaultId: uint256) -> address: view\n\ninterface MissionControl:\n    def hrConfig() -> cs.HrConfig: view\n\nstruct ContributorTerms:\n    owner: address\n    manager: address\n    compensation: uint256\n    startDelay: uint256\n    vestingLength: uint256\n    cliffLength: uint256\n    unlockLength: uint256\n    depositLockDuration: uint256\n\nevent NewContributorInitiated:\n    owner: indexed(address)\n    manager: indexed(address)\n    compensation: uint256\n    startDelay: uint256\n    vestingLength: uint256\n    cliffLength: uint256\n    unlockLength: uint256\n    depositLockDuration: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent NewContributorConfirmed:\n    contributorAddr: indexed(address)\n    owner: indexed(address)\n    manager: indexed(address)\n    compensation: uint256\n    startDelay: uint256\n    vestingLength: uint256\n    cliffLength: uint256\n    unlockLength: uint256\n    depositLockDuration: uint256\n    actionId: uint256\n\nevent NewContributorCancelled:\n    owner: indexed(address)\n    manager: indexed(address)\n    compensation: uint256\n    startDelay: uint256\n    vestingLength: uint256\n    cliffLength: uint256\n    unlockLength: uint256\n    depositLockDuration: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\n# pending\npendingContributor: public(HashMap[uint256, ContributorTerms]) # aid -> terms\n\nRIPE_GOV_VAULT_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, True) # can mint ripe only\n    gov.__init__(_ripeHq, empty(address), 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n####################\n# New Contributors #\n####################\n\n\n# initiate new contributor\n\n\n@external\ndef initiateNewContributor(\n    _owner: address,\n    _manager: address,\n    _compensation: uint256,\n    _startDelay: uint256,\n    _vestingLength: uint256,\n    _cliffLength: uint256,\n    _unlockLength: uint256,\n    _depositLockDuration: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    terms: ContributorTerms = ContributorTerms(\n        owner=_owner,\n        manager=_manager,\n        compensation=_compensation,\n        startDelay=_startDelay,\n        vestingLength=_vestingLength,\n        cliffLength=_cliffLength,\n        unlockLength=_unlockLength,\n        depositLockDuration=_depositLockDuration,\n    )\n    hrConfig: cs.HrConfig = staticcall MissionControl(a.missionControl).hrConfig()\n    assert self._areValidContributorTerms(terms, hrConfig, a.ledger) # dev: invalid terms\n\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingContributor[aid] = terms\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log NewContributorInitiated(\n        owner=_owner,\n        manager=_manager,\n        compensation=_compensation,\n        startDelay=_startDelay,\n        vestingLength=_vestingLength,\n        cliffLength=_cliffLength,\n        unlockLength=_unlockLength,\n        depositLockDuration=_depositLockDuration,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n# confirm new contributor\n\n\n@external\ndef confirmNewContributor(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    terms: ContributorTerms = self.pendingContributor[_aid]\n    assert terms.owner != empty(address) # dev: no pending contributor\n\n    hrConfig: cs.HrConfig = staticcall MissionControl(a.missionControl).hrConfig()\n    if not self._areValidContributorTerms(terms, hrConfig, a.ledger):\n        self._cancelNewPendingContributor(_aid)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(_aid) # dev: time lock not reached\n\n    # deploy new contributor\n    contributorAddr: address = create_from_blueprint(\n        hrConfig.contribTemplate,\n        a.hq,\n        terms.owner,\n        terms.manager,\n        terms.compensation,\n        terms.startDelay,\n        terms.vestingLength,\n        terms.cliffLength,\n        terms.unlockLength,\n        terms.depositLockDuration,\n        timeLock.MIN_ACTION_TIMELOCK,\n        timeLock.MAX_ACTION_TIMELOCK,\n    )\n    assert contributorAddr != empty(address) # dev: could not deploy\n\n    # update ledger\n    extcall Ledger(a.ledger).addHrContributor(contributorAddr, terms.compensation)\n\n    self.pendingContributor[_aid] = empty(ContributorTerms)\n    log NewContributorConfirmed(\n        contributorAddr=contributorAddr,\n        owner=terms.owner,\n        manager=terms.manager,\n        compensation=terms.compensation,\n        startDelay=terms.startDelay,\n        vestingLength=terms.vestingLength,\n        cliffLength=terms.cliffLength,\n        unlockLength=terms.unlockLength,\n        depositLockDuration=terms.depositLockDuration,\n        actionId=_aid,\n    )\n    return True\n\n\n# cancel contributor\n\n\n@external\ndef cancelNewContributor(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n\n    terms: ContributorTerms = self.pendingContributor[_aid]\n    assert terms.owner != empty(address) # dev: no pending contributor\n    self._cancelNewPendingContributor(_aid)\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(_aid)\n    log NewContributorCancelled(\n        owner=terms.owner,\n        manager=terms.manager,\n        compensation=terms.compensation,\n        startDelay=terms.startDelay,\n        vestingLength=terms.vestingLength,\n        cliffLength=terms.cliffLength,\n        unlockLength=terms.unlockLength,\n        depositLockDuration=terms.depositLockDuration,\n        confirmationBlock=confirmationBlock,\n        actionId=_aid,\n    )\n    return True\n\n\n@internal\ndef _cancelNewPendingContributor(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingContributor[_aid] = empty(ContributorTerms)\n\n\n####################\n# Terms Validation #\n####################\n\n\n@view\n@external\ndef areValidContributorTerms(\n    _owner: address,\n    _manager: address,\n    _compensation: uint256,\n    _startDelay: uint256,\n    _vestingLength: uint256,\n    _cliffLength: uint256,\n    _unlockLength: uint256,\n    _depositLockDuration: uint256,\n) -> bool:\n    a: addys.Addys = addys._getAddys()\n    terms: ContributorTerms = ContributorTerms(\n        owner=_owner,\n        manager=_manager,\n        compensation=_compensation,\n        startDelay=_startDelay,\n        vestingLength=_vestingLength,\n        cliffLength=_cliffLength,\n        unlockLength=_unlockLength,\n        depositLockDuration=_depositLockDuration,\n    )\n    hrConfig: cs.HrConfig = staticcall MissionControl(a.missionControl).hrConfig()\n    return self._areValidContributorTerms(terms, hrConfig, a.ledger)\n\n\n@view\n@internal\ndef _areValidContributorTerms(_terms: ContributorTerms, _hrConfig: cs.HrConfig, _ledger: address) -> bool:\n\n    # must have a template\n    if _hrConfig.contribTemplate == empty(address):\n        return False\n\n    # compensation check\n    if _terms.compensation == 0:\n        return False\n\n    # check what's available for HR\n    if _terms.compensation > staticcall Ledger(_ledger).ripeAvailForHr():\n        return False\n\n    if _hrConfig.maxCompensation != 0 and _terms.compensation > _hrConfig.maxCompensation:\n        return False\n\n    # cliff check\n    if _terms.cliffLength == 0:\n        return False\n\n    if _hrConfig.minCliffLength != 0 and _terms.cliffLength < _hrConfig.minCliffLength:\n        return False\n\n    # vesting check\n    if _terms.vestingLength == 0:\n        return False\n\n    if _hrConfig.minVestingLength != 0 and _terms.vestingLength < _hrConfig.minVestingLength:\n        return False\n\n    if _hrConfig.maxVestingLength != 0 and _terms.vestingLength > _hrConfig.maxVestingLength:\n        return False\n\n    if _hrConfig.maxStartDelay != 0 and _terms.startDelay > _hrConfig.maxStartDelay:\n        return False\n\n    # unlock cannot be greater than vesting\n    if _terms.unlockLength > _terms.vestingLength:\n        return False\n\n    # cliff can never be greater than unlock\n    if _terms.cliffLength > _terms.unlockLength:\n        return False\n\n    if empty(address) in [_terms.owner, _terms.manager]:\n        return False\n\n    return True\n\n\n####################\n# From Contributor #\n####################\n\n\n# views\n\n\n@view\n@external\ndef canModifyHrContributor(_addr: address) -> bool:\n    return addys._isSwitchboardAddr(_addr)\n\n\n@view\n@external\ndef hasRipeBalance(_contributor: address) -> bool:\n    a: addys.Addys = addys._getAddys()\n    ripeGovVaultAddr: address = staticcall VaultBook(a.vaultBook).getAddr(RIPE_GOV_VAULT_ID) \n    return staticcall Vault(ripeGovVaultAddr).doesUserHaveBalance(_contributor, a.ripeToken)\n\n\n# transfer ripe tokens\n\n\n@external\ndef transferContributorRipeTokens(_owner: address, _lockDuration: uint256) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    assert staticcall Ledger(a.ledger).isHrContributor(msg.sender) # dev: not a contributor\n\n    # transfer tokens in ripe gov vault\n    vaultId: uint256 = RIPE_GOV_VAULT_ID\n    ripeGovVaultAddr: address = staticcall VaultBook(a.vaultBook).getAddr(vaultId) \n    amount: uint256 = extcall RipeGovVault(ripeGovVaultAddr).transferContributorRipeTokens(msg.sender, _owner, _lockDuration, a)\n\n    extcall Ledger(a.ledger).addVaultToUser(_owner, vaultId)\n    extcall Lootbox(a.lootbox).updateDepositPoints(_owner, vaultId, ripeGovVaultAddr, a.ripeToken, a)\n    return amount\n\n\n# cash ripe check\n\n\n@external\ndef cashRipeCheck(_amount: uint256, _lockDuration: uint256) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    assert staticcall Ledger(a.ledger).isHrContributor(msg.sender) # dev: not a contributor\n\n    # mint ripe tokens here\n    extcall RipeToken(a.ripeToken).mint(self, _amount)\n\n    # deposit into gov vault\n    assert extcall IERC20(a.ripeToken).approve(a.teller, _amount, default_return_value=True) # dev: ripe approval failed\n    extcall Teller(a.teller).depositFromTrusted(msg.sender, RIPE_GOV_VAULT_ID, a.ripeToken, _amount, _lockDuration, a)\n    assert extcall IERC20(a.ripeToken).approve(a.teller, 0, default_return_value=True) # dev: ripe approval failed\n    return True\n\n\n# refund after cancel paycheck\n\n\n@external\ndef refundAfterCancelPaycheck(_amount: uint256, _shouldBurnPosition: bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    assert staticcall Ledger(a.ledger).isHrContributor(msg.sender) # dev: not a contributor\n\n    # refund ledger \n    currentRipeAvail: uint256 = staticcall Ledger(a.ledger).ripeAvailForHr()\n    extcall Ledger(a.ledger).setRipeAvailForHr(currentRipeAvail + _amount)\n\n    if not _shouldBurnPosition:\n        return\n\n    # withdraw and burn position\n    ripeGovVaultAddr: address = staticcall VaultBook(a.vaultBook).getAddr(RIPE_GOV_VAULT_ID)\n    withdrawalAmount: uint256 = extcall RipeGovVault(ripeGovVaultAddr).withdrawContributorTokensToBurn(msg.sender, a)\n    burnAmount: uint256 = min(withdrawalAmount, staticcall IERC20(a.ripeToken).balanceOf(self))\n    if burnAmount != 0:\n        extcall RipeToken(a.ripeToken).burn(burnAmount)\n\n\n#########\n# Other #\n#########\n\n\n@view\n@external\ndef getTotalClaimed() -> uint256:\n    ledger: address = addys._getLedgerAddr()\n\n    numContributors: uint256 = staticcall Ledger(ledger).numContributors()\n    if numContributors == 0:\n        return 0\n\n    totalClaimed: uint256 = 0\n    for i: uint256 in range(1, numContributors, bound=max_value(uint256)):\n        contributorAddr: address = staticcall Ledger(ledger).contributors(i)\n        if contributorAddr == empty(address):\n            continue\n        totalClaimed += staticcall HrContributor(contributorAddr).totalClaimed()\n\n    return totalClaimed\n\n\n@view\n@external\ndef getTotalCompensation() -> uint256:\n    ledger: address = addys._getLedgerAddr()\n\n    numContributors: uint256 = staticcall Ledger(ledger).numContributors()\n    if numContributors == 0:\n        return 0\n\n    totalCompensation: uint256 = 0\n    for i: uint256 in range(1, numContributors, bound=max_value(uint256)):\n        contributorAddr: address = staticcall Ledger(ledger).contributors(i)\n        if contributorAddr == empty(address):\n            continue\n        totalCompensation += staticcall HrContributor(contributorAddr).compensation()\n\n    return totalCompensation",
            "sha256sum": "0bd7d18756b0a69dc7a67f544a50b1dd82b8a56361a127889cf617b7b24eb5c0"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/HumanResources.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "7819606d5662f4b1ea1b715f65b6d7b377e4b21e7932e46f55965ea25619a45c"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/core/HumanResources.vy"
    },
    "Lootbox": {
      "address": "0x3e55C61c58F3d051ee39b47929089B918ADd9040",
      "abi": [
        {
          "name": "DepositLootClaimed",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ripeStakerLoot",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripeVoteLoot",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "ripeGenLoot",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BorrowLootClaimed",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "ripeAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldStake",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldStake",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldStake",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_shouldStake",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimableLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimDepositLootForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimableDepositLootForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDepositPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestDepositPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                },
                {
                  "name": "precision",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestDepositPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "balancePoints",
                  "type": "uint256"
                },
                {
                  "name": "lastBalance",
                  "type": "uint256"
                },
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                },
                {
                  "name": "precision",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "lastUsdValue",
                  "type": "uint256"
                },
                {
                  "name": "ripeStakerPoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeVotePoints",
                  "type": "uint256"
                },
                {
                  "name": "ripeGenPoints",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateBorrowPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateBorrowPoints",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimBorrowLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getClaimableBorrowLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateRipeRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateRipeRewards",
          "inputs": [
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestGlobalRipeRewards",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "borrowers",
                  "type": "uint256"
                },
                {
                  "name": "stakers",
                  "type": "uint256"
                },
                {
                  "name": "voters",
                  "type": "uint256"
                },
                {
                  "name": "genDepositors",
                  "type": "uint256"
                },
                {
                  "name": "newRipeRewards",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "contracts/core/Lootbox.vy": {
            "content": "# @version 0.4.1\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import Vault\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface Ledger:\n    def setDepositPointsAndRipeRewards(_user: address, _vaultId: uint256, _asset: address, _userPoints: UserDepositPoints, _assetPoints: AssetDepositPoints, _globalPoints: GlobalDepositPoints, _ripeRewards: RipeRewards): nonpayable\n    def setBorrowPointsAndRipeRewards(_user: address, _userPoints: BorrowPoints, _globalPoints: BorrowPoints, _ripeRewards: RipeRewards): nonpayable\n    def getDepositPointsBundle(_user: address, _vaultId: uint256, _asset: address) -> DepositPointsBundle: view\n    def removeVaultFromUser(_user: address, _vaultId: uint256): nonpayable\n    def getBorrowPointsBundle(_user: address) -> BorrowPointsBundle: view\n    def userVaults(_user: address, _index: uint256) -> uint256: view\n    def setRipeRewards(_ripeRewards: RipeRewards): nonpayable\n    def getRipeRewardsBundle() -> RipeRewardsBundle: view\n    def numUserVaults(_user: address) -> uint256: view\n\ninterface MissionControl:\n    def getClaimLootConfig(_user: address, _caller: address, _ripeToken: address) -> ClaimLootConfig: view\n    def getDepositPointsConfig(_asset: address) -> DepositPointsConfig: view\n    def getRewardsConfig() -> RewardsConfig: view\n\ninterface Teller:\n    def depositFromTrusted(_user: address, _vaultId: uint256, _asset: address, _amount: uint256, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def isUnderscoreWalletOwner(_user: address, _caller: address, _mc: address = empty(address)) -> bool: view\n\ninterface PriceDesk:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface RipeToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n\ninterface VaultBook:\n    def getAddr(_vaultId: uint256) -> address: view\n\nstruct RipeRewards:\n    borrowers: uint256\n    stakers: uint256\n    voters: uint256\n    genDepositors: uint256\n    newRipeRewards: uint256\n    lastUpdate: uint256\n\nstruct GlobalDepositPoints:\n    lastUsdValue: uint256\n    ripeStakerPoints: uint256\n    ripeVotePoints: uint256\n    ripeGenPoints: uint256\n    lastUpdate: uint256\n\nstruct AssetDepositPoints:\n    balancePoints: uint256\n    lastBalance: uint256\n    lastUsdValue: uint256\n    ripeStakerPoints: uint256\n    ripeVotePoints: uint256\n    ripeGenPoints: uint256\n    lastUpdate: uint256\n    precision: uint256\n\nstruct UserDepositPoints:\n    balancePoints: uint256\n    lastBalance: uint256\n    lastUpdate: uint256\n\nstruct BorrowPoints:\n    lastPrincipal: uint256\n    points: uint256\n    lastUpdate: uint256\n\nstruct BorrowPointsBundle:\n    userPoints: BorrowPoints\n    globalPoints: BorrowPoints\n    userDebtPrincipal: uint256\n\nstruct DepositPointsBundle:\n    userPoints: UserDepositPoints\n    assetPoints: AssetDepositPoints\n    globalPoints: GlobalDepositPoints\n\nstruct RipeRewardsBundle:\n    ripeRewards: RipeRewards\n    ripeAvailForRewards: uint256\n\nstruct UserDepositLoot:\n    ripeStakerLoot: uint256\n    ripeVoteLoot: uint256\n    ripeGenLoot: uint256\n\nstruct RewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    stakersPointsAllocTotal: uint256\n    voterPointsAllocTotal: uint256\n\nstruct DepositPointsConfig:\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    isNft: bool\n\nstruct ClaimLootConfig:\n    canClaimLoot: bool\n    canClaimLootForUser: bool\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n    minLockDuration: uint256\n    maxLockDuration: uint256\n\nevent DepositLootClaimed:\n    user: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    ripeStakerLoot: uint256\n    ripeVoteLoot: uint256\n    ripeGenLoot: uint256\n\nevent BorrowLootClaimed:\n    user: indexed(address)\n    ripeAmount: uint256\n\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nMAX_ASSETS_TO_CLEAN: constant(uint256) = 20\nMAX_VAULTS_TO_CLEAN: constant(uint256) = 10\nMAX_CLAIM_USERS: constant(uint256) = 25\nRIPE_GOV_VAULT_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, True) # can mint ripe only\n\n\n##############\n# Claim Loot #\n##############\n\n\n@external\ndef claimLootForUser(\n    _user: address,\n    _caller: address,\n    _shouldStake: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    isSwitchboard: bool = addys._isSwitchboardAddr(msg.sender)\n    return self._claimLoot(_user, _caller, _shouldStake, not isSwitchboard, a)\n\n\n@external\ndef claimLootForManyUsers(\n    _users: DynArray[address, MAX_CLAIM_USERS],\n    _caller: address,\n    _shouldStake: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    isSwitchboard: bool = addys._isSwitchboardAddr(msg.sender)\n\n    totalRipeForUsers: uint256 = 0\n    for u: address in _users:\n        totalRipeForUsers += self._claimLoot(u, _caller, _shouldStake, not isSwitchboard, a)\n    return totalRipeForUsers\n\n\n# core -- gets borrow loot AND deposit loot\n\n\n@internal\ndef _claimLoot(\n    _user: address,\n    _caller: address,\n    _shouldStake: bool,\n    _shouldCheckCaller: bool,\n    _a: addys.Addys,\n) -> uint256:\n\n    # nothing to do here\n    if _user == empty(address):\n        return 0\n\n    # check if caller can claim for user\n    config: ClaimLootConfig = staticcall MissionControl(_a.missionControl).getClaimLootConfig(_user, _caller, _a.ripeToken)\n    assert config.canClaimLoot # dev: loot claims disabled\n\n    # can others claim for user\n    if _shouldCheckCaller:\n        if _user != _caller and not config.canClaimLootForUser:\n            assert staticcall Teller(_a.teller).isUnderscoreWalletOwner(_user, _caller, _a.missionControl) # dev: cannot claim for user\n\n    # total loot -- start with borrow loot\n    totalRipeForUser: uint256 = self._claimBorrowLoot(_user, _a)\n\n    # now look at deposit loot\n    vaultsToRemove: DynArray[uint256, MAX_VAULTS_TO_CLEAN] = []\n    numUserVaults: uint256 = staticcall Ledger(_a.ledger).numUserVaults(_user)\n\n    # if no vaults, return 0\n    if numUserVaults == 0:\n        return totalRipeForUser\n\n    for i: uint256 in range(1, numUserVaults, bound=max_value(uint256)):\n        vaultId: uint256 = staticcall Ledger(_a.ledger).userVaults(_user, i)\n        vaultAddr: address = staticcall VaultBook(_a.vaultBook).getAddr(vaultId)\n        if vaultAddr == empty(address):\n            continue\n\n        assetsToRemove: DynArray[address, MAX_ASSETS_TO_CLEAN] = []\n        numUserAssets: uint256 = staticcall Vault(vaultAddr).numUserAssets(_user)\n        for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n            asset: address = empty(address)\n            hasBalance: bool = False\n            asset, hasBalance = staticcall Vault(vaultAddr).getUserAssetAtIndexAndHasBalance(_user, y)\n            if asset == empty(address):\n                continue\n\n            # save to clean up later\n            if not hasBalance and len(assetsToRemove) < MAX_ASSETS_TO_CLEAN:\n                assetsToRemove.append(asset)\n\n            # claim loot\n            totalRipeForUser += self._claimDepositLoot(_user, vaultId, vaultAddr, asset, not hasBalance, _a)\n\n        # clean up user assets (storage optimization)\n        stillInVault: bool = self._cleanUpUserAssets(_user, vaultAddr, assetsToRemove)\n        if not stillInVault and len(vaultsToRemove) < MAX_VAULTS_TO_CLEAN:\n            vaultsToRemove.append(vaultId)\n\n    # clean up user vaults (storage optimization)\n    self._cleanUpUserVaults(_user, vaultsToRemove, _a.ledger)\n\n    # mint ripe, then stake or transfer to user\n    if totalRipeForUser != 0:\n        self._handleRipeMint(_user, totalRipeForUser, _shouldStake, config, _a)\n\n    return totalRipeForUser\n\n\n# view / helper\n\n\n@view\n@external\ndef getClaimableLoot(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # total loot -- start with borrow loot\n    totalRipeForUser: uint256 = self._getClaimableBorrowLoot(_user, a)\n\n    # now look at deposit loot\n    numUserVaults: uint256 = staticcall Ledger(a.ledger).numUserVaults(_user)\n    if numUserVaults == 0:\n        return totalRipeForUser\n\n    for i: uint256 in range(1, numUserVaults, bound=max_value(uint256)):\n        vaultId: uint256 = staticcall Ledger(a.ledger).userVaults(_user, i)\n        vaultAddr: address = staticcall VaultBook(a.vaultBook).getAddr(vaultId)\n        if vaultAddr == empty(address):\n            continue\n        numUserAssets: uint256 = staticcall Vault(vaultAddr).numUserAssets(_user)\n        for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n            asset: address = staticcall Vault(vaultAddr).userAssets(_user, y)\n            if asset == empty(address):\n                continue\n            totalRipeForUser += self._getClaimableDepositLootForAsset(_user, vaultId, vaultAddr, asset, a)\n\n    return totalRipeForUser\n\n\n##############################\n# Claim Loot - Deposit Asset #\n##############################\n\n\n# claims\n\n\n@external\ndef claimDepositLootForAsset(_user: address, _vaultId: uint256, _asset: address) -> uint256:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    vaultAddr: address = staticcall VaultBook(a.vaultBook).getAddr(_vaultId)\n    totalRipeForUser: uint256 = self._claimDepositLoot(_user, _vaultId, vaultAddr, _asset, False, a)\n    if totalRipeForUser != 0:\n        config: ClaimLootConfig = staticcall MissionControl(a.missionControl).getClaimLootConfig(_user, _user, a.ripeToken)\n        self._handleRipeMint(_user, totalRipeForUser, False, config, a)\n    return totalRipeForUser\n\n\n@internal\ndef _claimDepositLoot(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _shouldFlush: bool,\n    _a: addys.Addys,\n) -> uint256:\n    userRipeRewards: UserDepositLoot = empty(UserDepositLoot)\n    up: UserDepositPoints = empty(UserDepositPoints)\n    ap: AssetDepositPoints = empty(AssetDepositPoints)\n    gp: GlobalDepositPoints = empty(GlobalDepositPoints)\n    globalRipeRewards: RipeRewards = empty(RipeRewards)\n    userRipeRewards, up, ap, gp, globalRipeRewards = self._getDepositLootData(_user, _vaultId, _vaultAddr, _asset, _shouldFlush, _a)\n\n    totalRipeForUser: uint256 = userRipeRewards.ripeStakerLoot + userRipeRewards.ripeVoteLoot + userRipeRewards.ripeGenLoot\n    extcall Ledger(_a.ledger).setDepositPointsAndRipeRewards(_user, _vaultId, _asset, up, ap, gp, globalRipeRewards)\n    if totalRipeForUser != 0:\n        log DepositLootClaimed(user=_user, vaultId=_vaultId, asset=_asset, ripeStakerLoot=userRipeRewards.ripeStakerLoot, ripeVoteLoot=userRipeRewards.ripeVoteLoot, ripeGenLoot=userRipeRewards.ripeGenLoot)\n    return totalRipeForUser\n\n\n# core logic (claimable loot for asset)\n\n\n@view\n@internal\ndef _getDepositLootData(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _shouldFlush: bool,\n    _a: addys.Addys,\n) -> (UserDepositLoot, UserDepositPoints, AssetDepositPoints, GlobalDepositPoints, RipeRewards):\n\n    # need to get this with each iteration because state may have changed (during claim)\n    config: RewardsConfig = staticcall MissionControl(_a.missionControl).getRewardsConfig()\n    globalRewards: RipeRewards = self._getLatestGlobalRipeRewards(config, _a)\n\n    # get latest deposit points\n    up: UserDepositPoints = empty(UserDepositPoints)\n    ap: AssetDepositPoints = empty(AssetDepositPoints)\n    gp: GlobalDepositPoints = empty(GlobalDepositPoints)\n    up, ap, gp = self._getLatestDepositPoints(_user, _vaultId, _vaultAddr, _asset, config, _a)\n\n    # user has no points\n    if up.balancePoints == 0:\n        return empty(UserDepositLoot), up, ap, gp, globalRewards\n\n    # calc user's share\n    userShareOfAsset: uint256 = 0\n    if ap.balancePoints != 0:\n        userShareOfAsset = min(up.balancePoints * HUNDRED_PERCENT // ap.balancePoints, HUNDRED_PERCENT)\n\n    # insufficient user share, may need to wait longer to claim\n    if userShareOfAsset == 0:\n        if _shouldFlush:\n            up, ap = self._flushDepositPoints(up, ap)\n        return empty(UserDepositLoot), up, ap, gp, globalRewards\n\n    # calc user's share of loot, per category\n    userLoot: UserDepositLoot = empty(UserDepositLoot)\n    ap.ripeStakerPoints, gp.ripeStakerPoints, globalRewards.stakers, userLoot.ripeStakerLoot = self._calcSpecificLoot(userShareOfAsset, ap.ripeStakerPoints, gp.ripeStakerPoints, globalRewards.stakers)\n    ap.ripeVotePoints, gp.ripeVotePoints, globalRewards.voters, userLoot.ripeVoteLoot = self._calcSpecificLoot(userShareOfAsset, ap.ripeVotePoints, gp.ripeVotePoints, globalRewards.voters)\n    ap.ripeGenPoints, gp.ripeGenPoints, globalRewards.genDepositors, userLoot.ripeGenLoot = self._calcSpecificLoot(userShareOfAsset, ap.ripeGenPoints, gp.ripeGenPoints, globalRewards.genDepositors)\n\n    # only zero out points if they actually received loot -- asset or user may not always have sufficient points (yet) to get loot\n    didReceiveLoot: bool = (\n        userLoot.ripeStakerLoot != 0 or\n        userLoot.ripeVoteLoot != 0 or\n        userLoot.ripeGenLoot != 0\n    )\n    if didReceiveLoot:\n        ap.balancePoints -= up.balancePoints # do first\n        up.balancePoints = 0\n\n    return userLoot, up, ap, gp, globalRewards\n\n\n# helper / views\n\n\n@view\n@external\ndef getClaimableDepositLootForAsset(_user: address, _vaultId: uint256, _asset: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    vaultAddr: address = staticcall VaultBook(a.vaultBook).getAddr(_vaultId)\n    return self._getClaimableDepositLootForAsset(_user, _vaultId, vaultAddr, _asset, a)\n\n\n@view\n@internal\ndef _getClaimableDepositLootForAsset(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _a: addys.Addys,\n) -> uint256:\n    userRipeRewards: UserDepositLoot = empty(UserDepositLoot)\n    up: UserDepositPoints = empty(UserDepositPoints)\n    ap: AssetDepositPoints = empty(AssetDepositPoints)\n    gp: GlobalDepositPoints = empty(GlobalDepositPoints)\n    globalRipeRewards: RipeRewards = empty(RipeRewards)\n    userRipeRewards, up, ap, gp, globalRipeRewards = self._getDepositLootData(_user, _vaultId, _vaultAddr, _asset, False, _a)\n    return userRipeRewards.ripeStakerLoot + userRipeRewards.ripeVoteLoot + userRipeRewards.ripeGenLoot\n\n\n# claim utils\n\n\n@view\n@internal\ndef _calcSpecificLoot(\n    _userShareOfAsset: uint256,\n    _assetPoints: uint256,\n    _globalPoints: uint256,\n    _rewardsAvailable: uint256,\n) -> (uint256, uint256, uint256, uint256):\n\n    # nothing to do here\n    if _assetPoints == 0 or _globalPoints == 0 or _rewardsAvailable == 0:\n        return _assetPoints, _globalPoints, _rewardsAvailable, 0\n\n    # calc asset rewards\n    assetRewards: uint256 = 0\n    if _assetPoints * HUNDRED_PERCENT > _globalPoints:\n        assetShareOfGlobal: uint256 = min(_assetPoints * HUNDRED_PERCENT // _globalPoints, HUNDRED_PERCENT)\n        assetRewards = _rewardsAvailable * assetShareOfGlobal // HUNDRED_PERCENT\n    else:\n        assetRewards = _rewardsAvailable * _assetPoints // _globalPoints\n\n    # calc user rewards (for asset)\n    userRewards: uint256 = assetRewards * _userShareOfAsset // HUNDRED_PERCENT\n    if userRewards == 0:\n        return _assetPoints, _globalPoints, _rewardsAvailable, 0\n\n    # calc how many points to reduce (from asset and global)\n    pointsToReduce: uint256 = 0\n    if _assetPoints * _userShareOfAsset > HUNDRED_PERCENT:\n        pointsToReduce = _assetPoints * _userShareOfAsset // HUNDRED_PERCENT\n    else:\n        remainingRewards: uint256 = assetRewards - userRewards\n        pointsRemaining: uint256 = _assetPoints\n        if _assetPoints * remainingRewards > assetRewards:\n            pointsRemaining = _assetPoints * remainingRewards // assetRewards\n        pointsToReduce = _assetPoints - pointsRemaining\n\n    if pointsToReduce == 0:\n        return _assetPoints, _globalPoints, _rewardsAvailable, 0\n\n    # updated data\n    newAssetPoints: uint256 = _assetPoints - pointsToReduce\n    newGlobalPoints: uint256 = _globalPoints - pointsToReduce\n    newRewardsAvail: uint256 = _rewardsAvailable - userRewards\n    return newAssetPoints, newGlobalPoints, newRewardsAvail, userRewards\n\n\n@view\n@internal\ndef _flushDepositPoints(_userPoints: UserDepositPoints, _assetPoints: AssetDepositPoints) -> (UserDepositPoints, AssetDepositPoints):\n    up: UserDepositPoints = _userPoints\n    ap: AssetDepositPoints = _assetPoints\n    ap.balancePoints -= up.balancePoints\n    up.balancePoints = 0\n    return up, ap\n\n\n##################\n# Deposit Points #\n##################\n\n\n# update points\n\n\n@external\ndef updateDepositPoints(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _a: addys.Addys = empty(addys.Addys),\n):\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest global rewards\n    config: RewardsConfig = staticcall MissionControl(a.missionControl).getRewardsConfig()\n    globalRewards: RipeRewards = self._getLatestGlobalRipeRewards(config, a)\n\n    # get latest deposit points\n    up: UserDepositPoints = empty(UserDepositPoints)\n    ap: AssetDepositPoints = empty(AssetDepositPoints)\n    gp: GlobalDepositPoints = empty(GlobalDepositPoints)\n    up, ap, gp = self._getLatestDepositPoints(_user, _vaultId, _vaultAddr, _asset, config, a)\n\n    # update points\n    extcall Ledger(a.ledger).setDepositPointsAndRipeRewards(_user, _vaultId, _asset, up, ap, gp, globalRewards)\n\n\n# global deposit points\n\n\n@view\n@internal\ndef _getLatestGlobalDepositPoints(\n    _globalPoints: GlobalDepositPoints,\n    _arePointsEnabled: bool,\n    _stakersTotalAlloc: uint256,\n    _voteDepositorTotalAlloc: uint256,\n) -> GlobalDepositPoints:\n    globalPoints: GlobalDepositPoints = _globalPoints\n\n    # elapsed blocks\n    elapsedBlocks: uint256 = 0\n    if globalPoints.lastUpdate != 0 and block.number > globalPoints.lastUpdate:\n        elapsedBlocks = block.number - globalPoints.lastUpdate\n\n    # update last update\n    globalPoints.lastUpdate = block.number\n\n    # nothing to do here\n    if not _arePointsEnabled or elapsedBlocks == 0:\n        return globalPoints\n\n    # update ripe rewards points\n    globalPoints.ripeStakerPoints += _stakersTotalAlloc * elapsedBlocks\n    globalPoints.ripeVotePoints += _voteDepositorTotalAlloc * elapsedBlocks\n    globalPoints.ripeGenPoints += globalPoints.lastUsdValue * elapsedBlocks\n\n    # Note: will update `lastUsdValue` later in flow (after knowing AssetDepositPoints changes in usd value)\n\n    return globalPoints\n\n\n# asset deposit points\n\n\n@view\n@internal\ndef _getLatestAssetDepositPoints(\n    _assetPoints: AssetDepositPoints,\n    _arePointsEnabled: bool,\n    _stakersAlloc: uint256,\n    _voteDepositorAlloc: uint256,\n) -> AssetDepositPoints:\n    assetPoints: AssetDepositPoints = _assetPoints\n\n    # elapsed blocks\n    elapsedBlocks: uint256 = 0\n    if assetPoints.lastUpdate != 0 and block.number > assetPoints.lastUpdate:\n        elapsedBlocks = block.number - assetPoints.lastUpdate\n\n    # update last update\n    assetPoints.lastUpdate = block.number\n\n    # nothing to do here\n    if not _arePointsEnabled or elapsedBlocks == 0:\n        return assetPoints\n\n    # update ripe rewards points\n    assetPoints.ripeStakerPoints += _stakersAlloc * elapsedBlocks\n    assetPoints.ripeVotePoints += _voteDepositorAlloc * elapsedBlocks\n    assetPoints.ripeGenPoints += assetPoints.lastUsdValue * elapsedBlocks\n\n    # balance points - how each user will split rewards for this vault/asset\n    assetPoints.balancePoints += assetPoints.lastBalance * elapsedBlocks\n\n    # Note: will update `lastUsdValue` later in flow\n\n    return assetPoints\n\n\n# user deposit points\n\n\n@view\n@internal\ndef _getLatestUserDepositPoints(\n    _userPoints: UserDepositPoints,\n    _arePointsEnabled: bool,\n) -> UserDepositPoints:\n    userPoints: UserDepositPoints = _userPoints\n\n    # elapsed blocks\n    elapsedBlocks: uint256 = 0\n    if userPoints.lastUpdate != 0 and block.number > userPoints.lastUpdate:\n        elapsedBlocks = block.number - userPoints.lastUpdate\n\n    # update last update\n    userPoints.lastUpdate = block.number\n\n    # nothing to do here\n    if not _arePointsEnabled or elapsedBlocks == 0:\n        return userPoints\n\n    # add user balance points\n    userPoints.balancePoints += userPoints.lastBalance * elapsedBlocks\n\n    # Note: will update `lastBalance` later in flow (if necessary)\n\n    return userPoints\n\n\n# combined points\n\n\n@view\n@external\ndef getLatestDepositPoints(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (UserDepositPoints, AssetDepositPoints, GlobalDepositPoints):\n    a: addys.Addys = addys._getAddys(_a)\n    c: RewardsConfig = staticcall MissionControl(a.missionControl).getRewardsConfig()\n    vaultAddr: address = staticcall VaultBook(a.vaultBook).getAddr(_vaultId)\n    return self._getLatestDepositPoints(_user, _vaultId, vaultAddr, _asset, c, a)\n\n\n@view\n@internal\ndef _getLatestDepositPoints(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _c: RewardsConfig,\n    _a: addys.Addys,\n) -> (UserDepositPoints, AssetDepositPoints, GlobalDepositPoints):\n    p: DepositPointsBundle = staticcall Ledger(_a.ledger).getDepositPointsBundle(_user, _vaultId, _asset)\n\n    # latest global points\n    globalPoints: GlobalDepositPoints = self._getLatestGlobalDepositPoints(p.globalPoints, _c.arePointsEnabled, _c.stakersPointsAllocTotal, _c.voterPointsAllocTotal)\n\n    # latest asset points\n    assetConfig: DepositPointsConfig = staticcall MissionControl(_a.missionControl).getDepositPointsConfig(_asset) \n    assetPoints: AssetDepositPoints = self._getLatestAssetDepositPoints(p.assetPoints, _c.arePointsEnabled, assetConfig.stakersPointsAlloc, assetConfig.voterPointsAlloc)\n    if assetPoints.precision == 0:\n        assetPoints.precision = self._getAssetPrecision(assetConfig.isNft, _asset)\n\n    # latest asset value (staked assets not eligible for gen deposit rewards)\n    newAssetUsdValue: uint256 = 0\n    if assetConfig.stakersPointsAlloc == 0:\n        newAssetUsdValue = self._refreshAssetUsdValue(_asset, _vaultAddr, _a.priceDesk)\n\n    # update `lastUsdValue` for global + asset\n    if newAssetUsdValue != assetPoints.lastUsdValue:\n        globalPoints.lastUsdValue -= assetPoints.lastUsdValue\n        globalPoints.lastUsdValue += newAssetUsdValue\n        assetPoints.lastUsdValue = newAssetUsdValue\n\n    # nothing else to do here\n    if _user == empty(address):\n        return empty(UserDepositPoints), assetPoints, globalPoints\n\n    # latest user points\n    userPoints: UserDepositPoints = self._getLatestUserDepositPoints(p.userPoints, _c.arePointsEnabled)\n\n    # get user loot share\n    userLootShare: uint256 = staticcall Vault(_vaultAddr).getUserLootBoxShare(_user, _asset)\n    if userLootShare != 0:\n        userLootShare = userLootShare // assetPoints.precision\n\n    # update `lastBalance`\n    assetPoints.lastBalance -= userPoints.lastBalance\n    assetPoints.lastBalance += userLootShare\n    userPoints.lastBalance = userLootShare\n\n    return userPoints, assetPoints, globalPoints\n\n\n# utils\n\n\n@view\n@internal\ndef _refreshAssetUsdValue(_asset: address, _vaultAddr: address, _priceDesk: address) -> uint256:\n    assetAmount: uint256 = staticcall Vault(_vaultAddr).getTotalAmountForVault(_asset)\n    if assetAmount == 0:\n        return 0\n    newUsdValue: uint256 = staticcall PriceDesk(_priceDesk).getUsdValue(_asset, assetAmount)\n    if newUsdValue != 0:\n        newUsdValue = newUsdValue // EIGHTEEN_DECIMALS # reduce risk of integer overflow\n    return newUsdValue\n\n\n@view\n@internal\ndef _getAssetPrecision(_isNft: bool, _asset: address) -> uint256:\n    if _isNft:\n        return 1\n    decimals: uint256 = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n    if decimals >= 8: # wbtc has 8 decimals\n        return 10 ** (decimals // 2)\n    return 10 ** decimals\n\n\n##########################\n# Borrower Loot - Points #\n##########################\n\n\n# update borrow points\n\n\n@external\ndef updateBorrowPoints(_user: address, _a: addys.Addys = empty(addys.Addys)):\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    config: RewardsConfig = staticcall MissionControl(a.missionControl).getRewardsConfig()\n    globalRewards: RipeRewards = self._getLatestGlobalRipeRewards(config, a)\n    up: BorrowPoints = empty(BorrowPoints)\n    gp: BorrowPoints = empty(BorrowPoints)\n    up, gp = self._getLatestBorrowPoints(_user, config.arePointsEnabled, a.ledger)\n    extcall Ledger(a.ledger).setBorrowPointsAndRipeRewards(_user, up, gp, globalRewards)\n\n\n# borrow points\n\n\n@view \n@internal \ndef _getLatestGlobalBorrowPoints(_globalPoints: BorrowPoints, _arePointsEnabled: bool) -> BorrowPoints:\n    globalPoints: BorrowPoints = _globalPoints\n\n    # elapsed blocks\n    elapsedBlocks: uint256 = 0\n    if globalPoints.lastUpdate != 0 and block.number > globalPoints.lastUpdate:\n        elapsedBlocks = block.number - globalPoints.lastUpdate\n\n    # update last update\n    globalPoints.lastUpdate = block.number\n\n    # nothing to do here\n    if not _arePointsEnabled or elapsedBlocks == 0:\n        return globalPoints\n\n    # update borrow points\n    globalPoints.points += globalPoints.lastPrincipal * elapsedBlocks\n\n    # Note: will update `lastPrincipal` later in flow\n\n    return globalPoints\n\n\n@view \n@internal \ndef _getLatestUserBorrowPoints(_userPoints: BorrowPoints, _arePointsEnabled: bool) -> BorrowPoints:\n    userPoints: BorrowPoints = _userPoints\n\n    # elapsed blocks\n    elapsedBlocks: uint256 = 0\n    if userPoints.lastUpdate != 0 and block.number > userPoints.lastUpdate:\n        elapsedBlocks = block.number - userPoints.lastUpdate\n\n    # update last update\n    userPoints.lastUpdate = block.number\n\n    # nothing to do here\n    if not _arePointsEnabled or elapsedBlocks == 0:\n        return userPoints\n\n    # update borrow points\n    userPoints.points += userPoints.lastPrincipal * elapsedBlocks\n\n    # Note: will update `lastPrincipal` later in flow (if necessary)\n\n    return userPoints\n\n\n@view \n@internal \ndef _getLatestBorrowPoints(\n    _user: address,\n    _arePointsEnabled: bool,\n    _ledger: address,\n) -> (BorrowPoints, BorrowPoints):\n    p: BorrowPointsBundle = staticcall Ledger(_ledger).getBorrowPointsBundle(_user)\n\n    # global points\n    globalPoints: BorrowPoints = self._getLatestGlobalBorrowPoints(p.globalPoints, _arePointsEnabled)\n\n    # if no user, return global points\n    if _user == empty(address):\n        return empty(BorrowPoints), globalPoints\n\n    # user points\n    userPoints: BorrowPoints = self._getLatestUserBorrowPoints(p.userPoints, _arePointsEnabled)\n\n    # normalize user debt -- reduce risk of integer overflow\n    userDebt: uint256 = p.userDebtPrincipal\n    if userDebt != 0:\n        userDebt = userDebt // EIGHTEEN_DECIMALS\n\n    # update `lastPrincipal`\n    globalPoints.lastPrincipal -= userPoints.lastPrincipal\n    globalPoints.lastPrincipal += userDebt\n    userPoints.lastPrincipal = userDebt\n\n    return userPoints, globalPoints\n\n\n##########################\n# Borrower Loot - Claims #\n##########################\n\n\n@external\ndef claimBorrowLoot(_user: address) -> uint256:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    totalRipeForUser: uint256 = self._claimBorrowLoot(_user, a)\n    if totalRipeForUser != 0:\n        config: ClaimLootConfig = staticcall MissionControl(a.missionControl).getClaimLootConfig(_user, _user, a.ripeToken)\n        self._handleRipeMint(_user, totalRipeForUser, False, config, a)\n    return totalRipeForUser\n\n\n@internal \ndef _claimBorrowLoot(_user: address, _a: addys.Addys) -> uint256:\n    userRipeRewards: uint256 = 0\n    up: BorrowPoints = empty(BorrowPoints)\n    gp: BorrowPoints = empty(BorrowPoints)\n    globalRipeRewards: RipeRewards = empty(RipeRewards)\n    userRipeRewards, up, gp, globalRipeRewards = self._getClaimableBorrowLootData(_user, _a)\n    extcall Ledger(_a.ledger).setBorrowPointsAndRipeRewards(_user, up, gp, globalRipeRewards)\n    if userRipeRewards != 0:\n        log BorrowLootClaimed(user=_user, ripeAmount=userRipeRewards)\n    return userRipeRewards\n\n\n# claimable loot\n\n\n@view \n@internal \ndef _getClaimableBorrowLootData(_user: address, _a: addys.Addys) -> (uint256, BorrowPoints, BorrowPoints, RipeRewards):\n    config: RewardsConfig = staticcall MissionControl(_a.missionControl).getRewardsConfig()\n    globalRewards: RipeRewards = self._getLatestGlobalRipeRewards(config, _a)\n\n    # latest borrow points\n    up: BorrowPoints = empty(BorrowPoints)\n    gp: BorrowPoints = empty(BorrowPoints)\n    up, gp = self._getLatestBorrowPoints(_user, config.arePointsEnabled, _a.ledger)\n\n    # calc user's share\n    userShare: uint256 = 0\n    if gp.points != 0:\n        userShare = min(up.points * HUNDRED_PERCENT // gp.points, HUNDRED_PERCENT)\n\n    # calc borrower rewards\n    userRipeRewards: uint256 = globalRewards.borrowers * userShare // HUNDRED_PERCENT\n\n    # update structs\n    if userRipeRewards != 0:\n        globalRewards.borrowers -= userRipeRewards\n        gp.points -= up.points # do first\n        up.points = 0\n\n    return userRipeRewards, up, gp, globalRewards\n\n\n@view\n@internal \ndef _getClaimableBorrowLoot(_user: address, _a: addys.Addys) -> uint256:\n    userRipeRewards: uint256 = 0\n    up: BorrowPoints = empty(BorrowPoints)\n    gp: BorrowPoints = empty(BorrowPoints)\n    globalRipeRewards: RipeRewards = empty(RipeRewards)\n    userRipeRewards, up, gp, globalRipeRewards = self._getClaimableBorrowLootData(_user, _a)\n    return userRipeRewards\n\n\n@view\n@external \ndef getClaimableBorrowLoot(_user: address) -> uint256:\n    return self._getClaimableBorrowLoot(_user, addys._getAddys())\n\n\n################\n# Ripe Rewards #\n################\n\n\n# update ripe rewards\n\n\n@external\ndef updateRipeRewards(_a: addys.Addys = empty(addys.Addys)) -> RipeRewards:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    config: RewardsConfig = staticcall MissionControl(a.missionControl).getRewardsConfig()\n    ripeRewards: RipeRewards = self._getLatestGlobalRipeRewards(config, a)\n    extcall Ledger(a.ledger).setRipeRewards(ripeRewards)\n    return ripeRewards\n\n\n# get latest global ripe rewards\n\n\n@view\n@external\ndef getLatestGlobalRipeRewards() -> RipeRewards:\n    a: addys.Addys = addys._getAddys()\n    config: RewardsConfig = staticcall MissionControl(a.missionControl).getRewardsConfig()\n    return self._getLatestGlobalRipeRewards(config, a)\n\n\n@view\n@internal\ndef _getLatestGlobalRipeRewards(_config: RewardsConfig, _a: addys.Addys) -> RipeRewards:\n    b: RipeRewardsBundle = staticcall Ledger(_a.ledger).getRipeRewardsBundle()\n    rewards: RipeRewards = b.ripeRewards\n    rewards.newRipeRewards = 0 # important to reset!\n\n    # elapsed blocks\n    elapsedBlocks: uint256 = 0\n    if rewards.lastUpdate != 0 and block.number > rewards.lastUpdate:\n        elapsedBlocks = block.number - rewards.lastUpdate\n\n    # update last update\n    rewards.lastUpdate = block.number\n\n    # nothing to do here\n    if elapsedBlocks == 0 or _config.ripePerBlock == 0 or b.ripeAvailForRewards == 0:\n        return rewards\n\n    # new Ripe rewards\n    newRipeDistro: uint256 = min(elapsedBlocks * _config.ripePerBlock, b.ripeAvailForRewards)\n\n    # allocate ripe rewards to global buckets\n    total: uint256 = _config.borrowersAlloc + _config.stakersAlloc + _config.votersAlloc + _config.genDepositorsAlloc\n    if total != 0:\n        rewards.borrowers += newRipeDistro * _config.borrowersAlloc // total\n        rewards.stakers += newRipeDistro * _config.stakersAlloc // total\n        rewards.voters += newRipeDistro * _config.votersAlloc // total\n        rewards.genDepositors += newRipeDistro * _config.genDepositorsAlloc // total\n\n        # rewards were distro'd, save important data\n        rewards.newRipeRewards = newRipeDistro\n\n    return rewards\n\n\n#########\n# Utils #\n#########\n\n\n# handle ripe mint\n\n\n@internal\ndef _handleRipeMint(\n    _user: address,\n    _amount: uint256,\n    _shouldStake: bool,\n    _config: ClaimLootConfig,\n    _a: addys.Addys,\n):\n    # if no auto stake, just mint to user\n    if not _shouldStake and _config.autoStakeRatio == 0:\n        extcall RipeToken(_a.ripeToken).mint(_user, _amount)\n        return\n\n    # mint ripe tokens here\n    extcall RipeToken(_a.ripeToken).mint(self, _amount)\n\n    # finalize amounts\n    amountToStake: uint256 = _amount\n    amountToSend: uint256 = 0\n    if not _shouldStake:\n        amountToStake = min(_amount * _config.autoStakeRatio // HUNDRED_PERCENT, _amount)\n        amountToSend = _amount - amountToStake\n\n    # finalize lock duration\n    lockDuration: uint256 = 0\n    if _config.maxLockDuration > _config.minLockDuration:\n        durationRange: uint256 = _config.maxLockDuration - _config.minLockDuration\n        lockDuration = durationRange * _config.autoStakeDurationRatio // HUNDRED_PERCENT\n\n    # stake ripe tokens\n    if amountToStake != 0:\n        assert extcall IERC20(_a.ripeToken).approve(_a.teller, amountToStake, default_return_value=True) # dev: ripe approval failed\n        extcall Teller(_a.teller).depositFromTrusted(_user, RIPE_GOV_VAULT_ID, _a.ripeToken, amountToStake, lockDuration, _a)\n        assert extcall IERC20(_a.ripeToken).approve(_a.teller, 0, default_return_value=True) # dev: ripe approval failed\n\n    # transfer ripe to user\n    if amountToSend != 0:\n        amount: uint256 = min(amountToSend, staticcall IERC20(_a.ripeToken).balanceOf(self))\n        assert extcall IERC20(_a.ripeToken).transfer(_user, amount, default_return_value=True) # dev: ripe transfer failed\n\n\n# storage clean up\n\n\n@internal\ndef _cleanUpUserAssets(\n    _user: address,\n    _vaultAddr: address,\n    _assetsToClean: DynArray[address, MAX_ASSETS_TO_CLEAN],\n) -> bool:\n    if len(_assetsToClean) == 0:\n        return True\n    stillInVault: bool = True\n    for a: address in _assetsToClean:\n        stillInVault = extcall Vault(_vaultAddr).deregisterUserAsset(_user, a)\n    return stillInVault\n\n\n@internal\ndef _cleanUpUserVaults(\n    _user: address,\n    _vaultsToClean: DynArray[uint256, MAX_VAULTS_TO_CLEAN],\n    _ledger: address,\n):\n    if len(_vaultsToClean) == 0:\n        return\n    for vid: uint256 in _vaultsToClean:\n        extcall Ledger(_ledger).removeVaultFromUser(_user, vid)",
            "sha256sum": "227400bfafeff4d36a704a73401d52fe39fa5a4b67bffc760601e1342c324cc0"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/Lootbox.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "93fb3d28904f261f317f244af36815cecd6069e665d2bbe75d1adc239fdeca65"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a03",
      "file": "contracts/core/Lootbox.vy"
    },
    "Teller": {
      "address": "0x35eA71Aba2ce1A3e1fa1761e98DbcaBA05A307B2",
      "abi": [
        {
          "name": "TellerDeposit",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "depositor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "TellerWithdrawal",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultAddr",
              "type": "address",
              "indexed": false
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserConfigSet",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canAnyoneDeposit",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canAnyoneRepayDebt",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canAnyoneBondForUser",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserDelegationSet",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "delegate",
              "type": "address",
              "indexed": true
            },
            {
              "name": "canWithdraw",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canBorrow",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimFromStabPool",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "canClaimLoot",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deposit",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositMany",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_deposits",
              "type": "tuple[]",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "vaultAddr",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositFromTrusted",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositFromTrusted",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdraw",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawMany",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_withdrawals",
              "type": "tuple[]",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "vaultAddr",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_greenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrow",
          "inputs": [
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldEnterStabPool",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repay",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repay",
          "inputs": [
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repay",
          "inputs": [
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repay",
          "inputs": [
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repay",
          "inputs": [
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemCollateralFromMany",
          "inputs": [
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateUser",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateUser",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateManyUsers",
          "inputs": [
            {
              "name": "_liqUsers",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "liquidateManyUsers",
          "inputs": [
            {
              "name": "_liqUsers",
              "type": "address[]"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyFungibleAuction",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "buyManyFungibleAuctions",
          "inputs": [
            {
              "name": "_purchases",
              "type": "tuple[]",
              "components": [
                {
                  "name": "liqUser",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertToSavingsGreenAndDepositIntoStabPool",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertToSavingsGreenAndDepositIntoStabPool",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "convertToSavingsGreenAndDepositIntoStabPool",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_maxUsdValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_maxUsdValue",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_stabAsset",
              "type": "address"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_maxUsdValue",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claims",
              "type": "tuple[]",
              "components": [
                {
                  "name": "stabAsset",
                  "type": "address"
                },
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxUsdValue",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claims",
              "type": "tuple[]",
              "components": [
                {
                  "name": "stabAsset",
                  "type": "address"
                },
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxUsdValue",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claims",
              "type": "tuple[]",
              "components": [
                {
                  "name": "stabAsset",
                  "type": "address"
                },
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxUsdValue",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_claimAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemManyFromStabilityPool",
          "inputs": [
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_redemptions",
              "type": "tuple[]",
              "components": [
                {
                  "name": "claimAsset",
                  "type": "address"
                },
                {
                  "name": "maxGreenAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLoot",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLoot",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldStake",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "claimLootForManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            },
            {
              "name": "_shouldStake",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "adjustLock",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newLockDuration",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "adjustLock",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_newLockDuration",
              "type": "uint256"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "releaseLock",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "releaseLock",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "purchaseRipeBond",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "purchaseRipeBond",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "purchaseRipeBond",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "purchaseRipeBond",
          "inputs": [
            {
              "name": "_paymentAsset",
              "type": "address"
            },
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_lockDuration",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canAnyoneDeposit",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canAnyoneDeposit",
              "type": "bool"
            },
            {
              "name": "_canAnyoneRepayDebt",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserConfig",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canAnyoneDeposit",
              "type": "bool"
            },
            {
              "name": "_canAnyoneRepayDebt",
              "type": "bool"
            },
            {
              "name": "_canAnyoneBondForUser",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_delegate",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_delegate",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_delegate",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_delegate",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canBorrow",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_delegate",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canBorrow",
              "type": "bool"
            },
            {
              "name": "_canClaimFromStabPool",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUserDelegation",
          "inputs": [
            {
              "name": "_delegate",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_canWithdraw",
              "type": "bool"
            },
            {
              "name": "_canBorrow",
              "type": "bool"
            },
            {
              "name": "_canClaimFromStabPool",
              "type": "bool"
            },
            {
              "name": "_canClaimLoot",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUndyLegoAccess",
          "inputs": [
            {
              "name": "_legoAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUnderscoreWalletOwner",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isUnderscoreWalletOwner",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_mc",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# @version 0.4.1\n\ninterface RipeHq:\n    def canModifyMissionControl(_addr: address) -> bool: view\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n",
            "sha256sum": "b38221d30f321e01b01ff830477474d005cf2063c23b8d06e88cc51e09f01208"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# @version 0.4.1\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "b1fa12f29ec93430bc5589d35706081a6ea4459ba2fd535de9099b03abeee63b"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.1\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "23bcd020a90f5839bdf5eff3040e8256d601bedbfd6e021fb8755416e5026422"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.1\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "93e905dad1766b488e4dc1dcc16ca4846e627f0e73d3589a5bd5efe1091c1084"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.1\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct StabClaimRewardsConfig:\n    rewardsLockDuration: uint256\n    ripePerDollarClaimed: uint256\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
            "sha256sum": "33be9599629425b9f481e61ad244791c115213342cb215b42f2addcb2d6278c2"
          },
          "contracts/core/Teller.vy": {
            "content": "# @version 0.4.1\n# pragma optimize codesize\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import Vault\nimport interfaces.ConfigStructs as cs\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface CreditEngine:\n    def redeemCollateralFromMany(_redemptions: DynArray[CollateralRedemption, MAX_COLLATERAL_REDEMPTIONS], _greenAmount: uint256, _recipient: address, _caller: address, _shouldTransferBalance: bool, _shouldRefundSavingsGreen: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def redeemCollateral(_user: address, _vaultId: uint256, _asset: address, _greenAmount: uint256, _recipient: address, _caller: address, _shouldTransferBalance: bool, _shouldRefundSavingsGreen: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def getMaxWithdrawableForAsset(_user: address, _vaultId: uint256, _asset: address, _vaultAddr: address = empty(address), _a: addys.Addys = empty(addys.Addys)) -> uint256: view\n    def repayForUser(_user: address, _greenAmount: uint256, _shouldRefundSavingsGreen: bool, _caller: address, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n    def borrowForUser(_user: address, _greenAmount: uint256, _wantsSavingsGreen: bool, _shouldEnterStabPool: bool, _caller: address, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def updateDebtForUser(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n\ninterface MissionControl:\n    def getTellerWithdrawConfig(_asset: address, _user: address, _caller: address) -> TellerWithdrawConfig: view\n    def getTellerDepositConfig(_vaultId: uint256, _asset: address, _user: address) -> TellerDepositConfig: view\n    def setUserDelegation(_user: address, _delegate: address, _config: cs.ActionDelegation): nonpayable\n    def setUserConfig(_user: address, _config: cs.UserConfig): nonpayable\n    def getFirstVaultIdForAsset(_asset: address) -> uint256: view\n    def underscoreRegistry() -> address: view\n    def shouldCheckLastTouch() -> bool: view\n\ninterface AuctionHouse:\n    def buyManyFungibleAuctions(_purchases: DynArray[FungAuctionPurchase, MAX_AUCTION_PURCHASES], _greenAmount: uint256, _recipient: address, _caller: address, _shouldTransferBalance: bool, _shouldRefundSavingsGreen: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def buyFungibleAuction(_liqUser: address, _vaultId: uint256, _asset: address, _greenAmount: uint256, _recipient: address, _caller: address, _shouldTransferBalance: bool, _shouldRefundSavingsGreen: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def liquidateManyUsers(_liqUsers: DynArray[address, MAX_LIQ_USERS], _keeper: address, _wantsSavingsGreen: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def liquidateUser(_liqUser: address, _keeper: address, _wantsSavingsGreen: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n\ninterface StabVault:\n    def redeemManyFromStabilityPool(_redemptions: DynArray[StabPoolRedemption, MAX_STAB_REDEMPTIONS], _greenAmount: uint256, _recipient: address, _caller: address, _shouldAutoDeposit: bool, _shouldRefundSavingsGreen: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def redeemFromStabilityPool(_claimAsset: address, _greenAmount: uint256, _recipient: address, _caller: address, _shouldAutoDeposit: bool, _shouldRefundSavingsGreen: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def claimFromStabilityPool(_claimer: address, _stabAsset: address, _claimAsset: address, _maxUsdValue: uint256, _caller: address, _shouldAutoDeposit: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def claimManyFromStabilityPool(_claimer: address, _claims: DynArray[StabPoolClaim, MAX_STAB_CLAIMS], _caller: address, _shouldAutoDeposit: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n\ninterface Lootbox:\n    def claimLootForManyUsers(_users: DynArray[address, MAX_CLAIM_USERS], _caller: address, _shouldStake: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n    def claimLootForUser(_user: address, _caller: address, _shouldStake: bool, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n\ninterface RipeGovVault:\n    def depositTokensWithLockDuration(_user: address, _asset: address, _amount: uint256, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def adjustLock(_user: address, _asset: address, _newLockDuration: uint256, _a: addys.Addys = empty(addys.Addys)): nonpayable\n    def releaseLock(_user: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface Ledger:\n    def getDepositLedgerData(_user: address, _vaultId: uint256) -> DepositLedgerData: view\n    def checkAndUpdateLastTouch(_user: address, _shouldCheck: bool): nonpayable\n    def addVaultToUser(_user: address, _vaultId: uint256): nonpayable\n\ninterface AddressRegistry:\n    def getRegId(_addr: address) -> uint256: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface BondRoom:\n    def purchaseRipeBond(_recipient: address, _paymentAsset: address, _paymentAmount: uint256, _lockDuration: uint256, _caller: address, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n\ninterface CurvePrices:\n    def addGreenRefPoolSnapshot() -> bool: nonpayable\n\ninterface UnderscoreAgentFactory:\n    def isUserWallet(_addr: address) -> bool: view\n\ninterface UnderscoreRegistry:\n    def getAddy(_addyId: uint256) -> address: view\n\ninterface UnderscoreWallet:\n    def walletConfig() -> address: view\n\ninterface UnderscoreWalletConfig:\n    def owner() -> address: view\n\nstruct DepositLedgerData:\n    isParticipatingInVault: bool\n    numUserVaults: uint256\n\nstruct TellerDepositConfig:\n    canDepositGeneral: bool\n    canDepositAsset: bool\n    doesVaultSupportAsset: bool\n    isUserAllowed: bool\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    perUserMaxAssetsPerVault: uint256\n    perUserMaxVaults: uint256\n    canAnyoneDeposit: bool\n    minDepositBalance: uint256\n\nstruct DepositAction:\n    asset: address\n    amount: uint256\n    vaultAddr: address\n    vaultId: uint256\n\nstruct TellerWithdrawConfig:\n    canWithdrawGeneral: bool\n    canWithdrawAsset: bool\n    isUserAllowed: bool\n    canWithdrawForUser: bool\n    minDepositBalance: uint256\n\nstruct WithdrawalAction:\n    asset: address\n    amount: uint256\n    vaultAddr: address\n    vaultId: uint256\n\nstruct CollateralRedemption:\n    user: address\n    vaultId: uint256\n    asset: address\n    maxGreenAmount: uint256\n\nstruct FungAuctionPurchase:\n    liqUser: address\n    vaultId: uint256\n    asset: address\n    maxGreenAmount: uint256\n\nstruct StabPoolClaim:\n    stabAsset: address\n    claimAsset: address\n    maxUsdValue: uint256\n\nstruct StabPoolRedemption:\n    claimAsset: address\n    maxGreenAmount: uint256\n\nevent TellerDeposit:\n    user: indexed(address)\n    depositor: indexed(address)\n    asset: indexed(address)\n    amount: uint256\n    vaultAddr: address\n    vaultId: uint256\n\nevent TellerWithdrawal:\n    user: indexed(address)\n    asset: indexed(address)\n    caller: indexed(address)\n    amount: uint256\n    vaultAddr: address\n    vaultId: uint256\n    isDepleted: bool\n\nevent UserConfigSet:\n    user: indexed(address)\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n    caller: indexed(address)\n\nevent UserDelegationSet:\n    user: indexed(address) \n    delegate: indexed(address)\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool \n    canClaimLoot: bool\n    caller: indexed(address)\n\nMAX_BALANCE_ACTION: constant(uint256) = 20\nMAX_CLAIM_USERS: constant(uint256) = 25\nMAX_COLLATERAL_REDEMPTIONS: constant(uint256) = 20\nMAX_AUCTION_PURCHASES: constant(uint256) = 20\nMAX_LIQ_USERS: constant(uint256) = 50\nMAX_STAB_CLAIMS: constant(uint256) = 15\nMAX_STAB_REDEMPTIONS: constant(uint256) = 15\n\nSTABILITY_POOL_ID: constant(uint256) = 1\nRIPE_GOV_VAULT_ID: constant(uint256) = 2\nUNDERSCORE_AGENT_FACTORY_ID: constant(uint256) = 1\nCURVE_PRICES_ID: constant(uint256) = 2\n\n\n@deploy\ndef __init__(_ripeHq: address, _shouldPause: bool):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(_shouldPause, False, False) # no minting\n\n\n############\n# Deposits #\n############\n\n\n@nonreentrant\n@external\ndef deposit(\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _user: address = msg.sender,\n    _vaultAddr: address = empty(address),\n    _vaultId: uint256 = 0,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    return self._deposit(_asset, _amount, _user, _vaultAddr, _vaultId, msg.sender, 0, False, True, a)\n\n\n@nonreentrant\n@external\ndef depositMany(_user: address, _deposits: DynArray[DepositAction, MAX_BALANCE_ACTION]) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    for d: DepositAction in _deposits:\n        self._deposit(d.asset, d.amount, _user, d.vaultAddr, d.vaultId, msg.sender, 0, False, False, a)\n    self._performHousekeeping(False, _user, msg.sender, True, a)\n    return len(_deposits)\n\n\n@external\ndef depositFromTrusted(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _amount: uint256,\n    _lockDuration: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    a: addys.Addys = addys._getAddys(_a)\n    return self._deposit(_asset, _amount, _user, empty(address), _vaultId, msg.sender, _lockDuration, False, False, a)\n\n\n# core logic\n\n\n@internal\ndef _deposit(\n    _asset: address,\n    _amount: uint256,\n    _user: address,\n    _vaultAddr: address,\n    _vaultId: uint256,\n    _depositor: address,\n    _lockDuration: uint256,\n    _areFundsHereAlready: bool,\n    _shouldPerformHouseKeeping: bool,\n    _a: addys.Addys,\n) -> uint256:\n    vaultAddr: address = empty(address)\n    vaultId: uint256 = 0\n    vaultAddr, vaultId = self._getVaultAddrAndId(_asset, _vaultAddr, _vaultId, _a.vaultBook, _a.missionControl)\n\n    # get ledger data\n    d: DepositLedgerData = staticcall Ledger(_a.ledger).getDepositLedgerData(_user, vaultId)\n    amount: uint256 = self._validateOnDeposit(_asset, _amount, _user, vaultId, vaultAddr, _depositor, _areFundsHereAlready, d, _a.missionControl)\n\n    # transfer tokens\n    if _areFundsHereAlready:\n        assert extcall IERC20(_asset).transfer(vaultAddr, amount, default_return_value=True) # dev: could not transfer\n    else:\n        assert extcall IERC20(_asset).transferFrom(_depositor, vaultAddr, amount, default_return_value=True) # dev: token transfer failed\n\n    # deposit tokens\n    if _lockDuration != 0:\n        amount = extcall RipeGovVault(vaultAddr).depositTokensWithLockDuration(_user, _asset, amount, _lockDuration, _a)\n    else:\n        amount = extcall Vault(vaultAddr).depositTokensInVault(_user, _asset, amount, _a)\n\n    # register vault participation\n    if not d.isParticipatingInVault:\n        extcall Ledger(_a.ledger).addVaultToUser(_user, vaultId)\n\n    # update lootbox points\n    extcall Lootbox(_a.lootbox).updateDepositPoints(_user, vaultId, vaultAddr, _asset, _a)\n\n    # perform house keeping\n    if _shouldPerformHouseKeeping:\n        self._performHousekeeping(False, _user, msg.sender, True, _a)\n\n    log TellerDeposit(user=_user, depositor=_depositor, asset=_asset, amount=amount, vaultAddr=vaultAddr, vaultId=vaultId)\n    return amount\n\n\n# validation\n\n\n@view\n@internal\ndef _validateOnDeposit(\n    _asset: address,\n    _amount: uint256,\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _depositor: address,\n    _areFundsHereAlready: bool,\n    _d: DepositLedgerData,\n    _missionControl: address,\n) -> uint256:\n    config: TellerDepositConfig = staticcall MissionControl(_missionControl).getTellerDepositConfig(_vaultId, _asset, _user)\n    assert config.canDepositGeneral # dev: protocol deposits disabled\n    assert config.canDepositAsset # dev: asset deposits disabled\n    assert config.doesVaultSupportAsset # dev: vault does not support asset\n    assert config.isUserAllowed # dev: user not on whitelist\n\n    # trusted depositor\n    isRipeDepartment: bool = addys._isValidRipeAddr(_depositor)\n\n    # make sure depositor is allowed to deposit for user\n    if _user != _depositor and not config.canAnyoneDeposit:\n        assert isRipeDepartment or self._isUnderscoreWalletOwner(_user, _depositor, _missionControl) # dev: cannot deposit for user\n\n    # avail amount\n    holder: address = _depositor\n    if _areFundsHereAlready:\n        holder = self\n    amount: uint256 = min(_amount, staticcall IERC20(_asset).balanceOf(holder))\n    assert amount != 0 # dev: cannot deposit 0\n\n    # if depositing from ripe dept, skip these limits\n    if isRipeDepartment:\n        return amount\n\n    # vault data\n    vd: Vault.VaultDataOnDeposit = staticcall Vault(_vaultAddr).getVaultDataOnDeposit(_user, _asset)\n\n    # check max vaults, max assets per vault\n    if not _d.isParticipatingInVault:\n        assert _d.numUserVaults < config.perUserMaxVaults # dev: reached max vaults\n\n    elif not vd.hasPosition:\n        assert vd.numAssets < config.perUserMaxAssetsPerVault # dev: reached max assets per vault\n\n    # per user deposit limit\n    availPerUserDeposit: uint256 = self._getAvailPerUserDepositLimit(vd.userBalance, config.perUserDepositLimit)\n    assert availPerUserDeposit != 0 # dev: cannot deposit, reached user limit\n    amount = min(amount, availPerUserDeposit)\n\n    # global deposit limit\n    availGlobalDeposit: uint256 = self._getAvailGlobalDepositLimit(vd.totalBalance, config.globalDepositLimit)\n    assert availGlobalDeposit != 0 # dev: cannot deposit, reached global limit\n    amount = min(amount, availGlobalDeposit)\n\n    # min balance\n    assert amount + vd.userBalance >= config.minDepositBalance # dev: too small a balance\n\n    return amount\n\n\n# per user deposit limit\n\n\n@view \n@internal \ndef _getAvailPerUserDepositLimit(_userDepositBal: uint256, _perUserDepositLimit: uint256) -> uint256:\n    if _perUserDepositLimit == max_value(uint256):\n        return max_value(uint256)\n    availDeposits: uint256 = 0\n    if _perUserDepositLimit > _userDepositBal:\n        availDeposits = _perUserDepositLimit - _userDepositBal\n    return availDeposits\n\n\n# global deposit limit\n\n\n@view \n@internal \ndef _getAvailGlobalDepositLimit(_totalDepositBal: uint256, _globalDepositLimit: uint256) -> uint256:\n    availDeposits: uint256 = 0\n    if _globalDepositLimit > _totalDepositBal:\n        availDeposits = _globalDepositLimit - _totalDepositBal\n    return availDeposits\n\n\n###############\n# Withdrawals #\n###############\n\n\n@nonreentrant\n@external\ndef withdraw(\n    _asset: address,\n    _amount: uint256 = max_value(uint256),\n    _user: address = msg.sender,\n    _vaultAddr: address = empty(address),\n    _vaultId: uint256 = 0,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    amount: uint256 = self._withdraw(_asset, _amount, _user, _vaultAddr, _vaultId, msg.sender, a)\n    self._performHousekeeping(True, _user, msg.sender, True, a)\n    return amount\n\n\n@nonreentrant\n@external\ndef withdrawMany(_user: address, _withdrawals: DynArray[WithdrawalAction, MAX_BALANCE_ACTION]) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    for w: WithdrawalAction in _withdrawals:\n        self._withdraw(w.asset, w.amount, _user, w.vaultAddr, w.vaultId, msg.sender, a)\n    self._performHousekeeping(True, _user, msg.sender, True, a)\n    return len(_withdrawals)\n\n\n@internal\ndef _withdraw(\n    _asset: address,\n    _amount: uint256,\n    _user: address,\n    _vaultAddr: address,\n    _vaultId: uint256,\n    _caller: address,\n    _a: addys.Addys,\n) -> uint256:\n    vaultAddr: address = empty(address)\n    vaultId: uint256 = 0\n    vaultAddr, vaultId = self._getVaultAddrAndId(_asset, _vaultAddr, _vaultId, _a.vaultBook, _a.missionControl)\n\n    # validation\n    config: TellerWithdrawConfig = staticcall MissionControl(_a.missionControl).getTellerWithdrawConfig(_asset, _user, _caller)\n    amount: uint256 = self._validateOnWithdrawal(_asset, _amount, _user, vaultAddr, vaultId, _caller, config, _a)\n\n    # withdraw tokens\n    isDepleted: bool = False\n    amount, isDepleted = extcall Vault(vaultAddr).withdrawTokensFromVault(_user, _asset, amount, _user, _a)\n\n    # check min balance\n    if not isDepleted:\n        userBalance: uint256 = staticcall Vault(vaultAddr).getTotalAmountForUser(_user, _asset)\n        assert userBalance >= config.minDepositBalance # dev: too small a balance\n\n    # update lootbox points\n    extcall Lootbox(_a.lootbox).updateDepositPoints(_user, vaultId, vaultAddr, _asset, _a)\n\n    log TellerWithdrawal(user=_user, asset=_asset, caller=_caller, amount=amount, vaultAddr=vaultAddr, vaultId=vaultId, isDepleted=isDepleted)\n    return amount\n\n\n# validation\n\n\n@view\n@internal\ndef _validateOnWithdrawal(\n    _asset: address,\n    _amount: uint256,\n    _user: address,\n    _vaultAddr: address,\n    _vaultId: uint256,\n    _caller: address,\n    _config: TellerWithdrawConfig,\n    _a: addys.Addys,\n) -> uint256:\n    assert _amount != 0 # dev: cannot withdraw 0\n\n    assert _config.canWithdrawGeneral # dev: protocol withdrawals disabled\n    assert _config.canWithdrawAsset # dev: asset withdrawals disabled\n    assert _config.isUserAllowed # dev: user not on whitelist\n\n    # make sure caller is allowed to withdraw for user\n    if _user != _caller and not _config.canWithdrawForUser:\n        assert self._isUnderscoreWalletOwner(_user, _caller, _a.missionControl) # dev: not allowed to withdraw for user\n\n    # max withdrawable\n    maxWithdrawable: uint256 = staticcall CreditEngine(_a.creditEngine).getMaxWithdrawableForAsset(_user, _vaultId, _asset, _vaultAddr, _a)\n    assert maxWithdrawable != 0 # dev: cannot withdraw anything\n\n    return min(_amount, maxWithdrawable)\n\n\n########\n# Debt #\n########\n\n\n# borrow\n\n\n@nonreentrant\n@external\ndef borrow(\n    _greenAmount: uint256 = max_value(uint256),\n    _user: address = msg.sender,\n    _wantsSavingsGreen: bool = True,\n    _shouldEnterStabPool: bool = False,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    self._performHousekeeping(True, _user, msg.sender, False, a)\n    return extcall CreditEngine(a.creditEngine).borrowForUser(_user, _greenAmount, _wantsSavingsGreen, _shouldEnterStabPool, msg.sender, a)\n\n\n# repay\n\n\n@nonreentrant\n@external\ndef repay(\n    _paymentAmount: uint256 = max_value(uint256),\n    _user: address = msg.sender,\n    _isPaymentSavingsGreen: bool = False,\n    _shouldRefundSavingsGreen: bool = True,\n) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    self._performHousekeeping(False, _user, msg.sender, False, a)\n    greenAmount: uint256 = self._handleGreenPayment(_isPaymentSavingsGreen, _paymentAmount, a.creditEngine, a.greenToken, a.savingsGreen)\n    return extcall CreditEngine(a.creditEngine).repayForUser(_user, greenAmount, _shouldRefundSavingsGreen, msg.sender, a)\n\n\n# redeem collateral\n\n\n@nonreentrant\n@external\ndef redeemCollateral(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _isPaymentSavingsGreen: bool = False,\n    _shouldTransferBalance: bool = False,\n    _shouldRefundSavingsGreen: bool = True,\n    _recipient: address = msg.sender,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    greenAmount: uint256 = self._handleGreenPayment(_isPaymentSavingsGreen, _paymentAmount, a.creditEngine, a.greenToken, a.savingsGreen)\n    redemptions: DynArray[CollateralRedemption, MAX_COLLATERAL_REDEMPTIONS] = [CollateralRedemption(user=_user, vaultId=_vaultId, asset=_asset, maxGreenAmount=greenAmount)]\n    greenSpent: uint256 = extcall CreditEngine(a.creditEngine).redeemCollateralFromMany(redemptions, max_value(uint256), _recipient, msg.sender, _shouldTransferBalance, _shouldRefundSavingsGreen, a)\n    self._performHousekeeping(False, _recipient, msg.sender, True, a)\n    return greenSpent\n\n\n@nonreentrant\n@external\ndef redeemCollateralFromMany(\n    _redemptions: DynArray[CollateralRedemption, MAX_COLLATERAL_REDEMPTIONS],\n    _paymentAmount: uint256 = max_value(uint256),\n    _isPaymentSavingsGreen: bool = False,\n    _shouldTransferBalance: bool = False,\n    _shouldRefundSavingsGreen: bool = True,\n    _recipient: address = msg.sender,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    greenAmount: uint256 = self._handleGreenPayment(_isPaymentSavingsGreen, _paymentAmount, a.creditEngine, a.greenToken, a.savingsGreen)\n    greenSpent: uint256 = extcall CreditEngine(a.creditEngine).redeemCollateralFromMany(_redemptions, greenAmount, _recipient, msg.sender, _shouldTransferBalance, _shouldRefundSavingsGreen, a)\n    self._performHousekeeping(False, _recipient, msg.sender, True, a)\n    return greenSpent\n\n\n################\n# Liquidations #\n################\n\n\n# liquidate users\n\n\n@nonreentrant\n@external\ndef liquidateUser(\n    _liqUser: address,\n    _wantsSavingsGreen: bool = True,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    keeperRewards: uint256 = extcall AuctionHouse(a.auctionHouse).liquidateUser(_liqUser, msg.sender, _wantsSavingsGreen, a)\n    self._performHousekeeping(False, msg.sender, msg.sender, True, a)\n    return keeperRewards\n\n\n@nonreentrant\n@external\ndef liquidateManyUsers(\n    _liqUsers: DynArray[address, MAX_LIQ_USERS],\n    _wantsSavingsGreen: bool = True,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    keeperRewards: uint256 = extcall AuctionHouse(a.auctionHouse).liquidateManyUsers(_liqUsers, msg.sender, _wantsSavingsGreen, a)\n    self._performHousekeeping(False, msg.sender, msg.sender, True, a)\n    return keeperRewards\n\n\n# buy fungible auctions\n\n\n@nonreentrant\n@external\ndef buyFungibleAuction(\n    _liqUser: address,\n    _vaultId: uint256,\n    _asset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _isPaymentSavingsGreen: bool = False,\n    _shouldTransferBalance: bool = False,\n    _shouldRefundSavingsGreen: bool = True,\n    _recipient: address = msg.sender,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    greenAmount: uint256 = self._handleGreenPayment(_isPaymentSavingsGreen, _paymentAmount, a.auctionHouse, a.greenToken, a.savingsGreen)\n    greenSpent: uint256 = extcall AuctionHouse(a.auctionHouse).buyFungibleAuction(_liqUser, _vaultId, _asset, greenAmount, _recipient, msg.sender, _shouldTransferBalance, _shouldRefundSavingsGreen, a)\n    self._performHousekeeping(False, _recipient, msg.sender, True, a)\n    return greenSpent\n\n\n@nonreentrant\n@external\ndef buyManyFungibleAuctions(\n    _purchases: DynArray[FungAuctionPurchase, MAX_AUCTION_PURCHASES],\n    _paymentAmount: uint256 = max_value(uint256),\n    _isPaymentSavingsGreen: bool = False,\n    _shouldTransferBalance: bool = False,\n    _shouldRefundSavingsGreen: bool = True,\n    _recipient: address = msg.sender,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    greenAmount: uint256 = self._handleGreenPayment(_isPaymentSavingsGreen, _paymentAmount, a.auctionHouse, a.greenToken, a.savingsGreen)\n    greenSpent: uint256 = extcall AuctionHouse(a.auctionHouse).buyManyFungibleAuctions(_purchases, greenAmount, _recipient, msg.sender, _shouldTransferBalance, _shouldRefundSavingsGreen, a)\n    self._performHousekeeping(False, _recipient, msg.sender, True, a)\n    return greenSpent\n\n\n###################\n# Stability Pools #\n###################\n\n\n# deposit green into stab pool\n\n\n@nonreentrant\n@external\ndef convertToSavingsGreenAndDepositIntoStabPool(_user: address = msg.sender, _greenAmount: uint256 = max_value(uint256)) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    # transfer GREEN to this contract\n    greenAmount: uint256 = min(_greenAmount, staticcall IERC20(a.greenToken).balanceOf(msg.sender))\n    assert greenAmount != 0 # dev: cannot deposit 0 green\n    assert extcall IERC20(a.greenToken).transferFrom(msg.sender, self, greenAmount, default_return_value=True) # dev: token transfer failed\n\n    # put GREEN into sGREEN\n    assert extcall IERC20(a.greenToken).approve(a.savingsGreen, greenAmount, default_return_value=True) # dev: green approval failed\n    sGreenAmount: uint256 = extcall IERC4626(a.savingsGreen).deposit(greenAmount, self)\n    assert extcall IERC20(a.greenToken).approve(a.savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n    return self._deposit(a.savingsGreen, sGreenAmount, _user, empty(address), STABILITY_POOL_ID, msg.sender, 0, True, True, a)\n\n\n# claims\n\n\n@nonreentrant\n@external\ndef claimFromStabilityPool(\n    _vaultId: uint256,\n    _stabAsset: address,\n    _claimAsset: address,\n    _maxUsdValue: uint256 = max_value(uint256),\n    _user: address = msg.sender,\n    _shouldAutoDeposit: bool = False,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    vaultAddr: address = staticcall AddressRegistry(a.vaultBook).getAddr(_vaultId)\n    claimUsdValue: uint256 = extcall StabVault(vaultAddr).claimFromStabilityPool(_user, _stabAsset, _claimAsset, _maxUsdValue, msg.sender, _shouldAutoDeposit, a)\n    self._performHousekeeping(True, _user, msg.sender, True, a)\n    return claimUsdValue\n\n\n@nonreentrant\n@external\ndef claimManyFromStabilityPool(\n    _vaultId: uint256,\n    _claims: DynArray[StabPoolClaim, MAX_STAB_CLAIMS],\n    _user: address = msg.sender,\n    _shouldAutoDeposit: bool = False,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    vaultAddr: address = staticcall AddressRegistry(a.vaultBook).getAddr(_vaultId)\n    claimUsdValue: uint256 = extcall StabVault(vaultAddr).claimManyFromStabilityPool(_user, _claims, msg.sender, _shouldAutoDeposit, a)\n    self._performHousekeeping(True, _user, msg.sender, True, a)\n    return claimUsdValue\n\n\n# redemptions\n\n\n@nonreentrant\n@external\ndef redeemFromStabilityPool(\n    _vaultId: uint256,\n    _claimAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _recipient: address = msg.sender,\n    _shouldAutoDeposit: bool = False,\n    _isPaymentSavingsGreen: bool = False,\n    _shouldRefundSavingsGreen: bool = True,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    vaultAddr: address = staticcall AddressRegistry(a.vaultBook).getAddr(_vaultId)\n    greenAmount: uint256 = self._handleGreenPayment(_isPaymentSavingsGreen, _paymentAmount, vaultAddr, a.greenToken, a.savingsGreen)\n    greenSpent: uint256 = extcall StabVault(vaultAddr).redeemFromStabilityPool(_claimAsset, greenAmount, _recipient, msg.sender, _shouldAutoDeposit, _shouldRefundSavingsGreen, a)\n    self._performHousekeeping(False, _recipient, msg.sender, True, a)\n    return greenSpent\n\n\n@nonreentrant\n@external\ndef redeemManyFromStabilityPool(\n    _vaultId: uint256,\n    _redemptions: DynArray[StabPoolRedemption, MAX_STAB_REDEMPTIONS],\n    _paymentAmount: uint256 = max_value(uint256),\n    _recipient: address = msg.sender,\n    _shouldAutoDeposit: bool = False,\n    _isPaymentSavingsGreen: bool = False,\n    _shouldRefundSavingsGreen: bool = True,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    vaultAddr: address = staticcall AddressRegistry(a.vaultBook).getAddr(_vaultId)\n    greenAmount: uint256 = self._handleGreenPayment(_isPaymentSavingsGreen, _paymentAmount, vaultAddr, a.greenToken, a.savingsGreen)\n    greenSpent: uint256 = extcall StabVault(vaultAddr).redeemManyFromStabilityPool(_redemptions, greenAmount, _recipient, msg.sender, _shouldAutoDeposit, _shouldRefundSavingsGreen, a)\n    self._performHousekeeping(False, _recipient, msg.sender, True, a)\n    return greenSpent\n\n\n###########\n# Rewards #\n###########\n\n\n# claim loot\n\n\n@nonreentrant\n@external\ndef claimLoot(_user: address = msg.sender, _shouldStake: bool = True) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    totalRipe: uint256 = extcall Lootbox(a.lootbox).claimLootForUser(_user, msg.sender, _shouldStake, a)\n    self._performHousekeeping(False, _user, msg.sender, True, a)\n    return totalRipe\n\n\n# claim for many users\n\n\n@nonreentrant\n@external\ndef claimLootForManyUsers(_users: DynArray[address, MAX_CLAIM_USERS], _shouldStake: bool = True) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    totalRipe: uint256 = extcall Lootbox(a.lootbox).claimLootForManyUsers(_users, msg.sender, _shouldStake, a)\n    self._performHousekeeping(False, msg.sender, msg.sender, True, a)\n    return totalRipe\n\n\n##################\n# Ripe Gov Vault #\n##################\n\n\n@nonreentrant\n@external\ndef adjustLock(_asset: address, _newLockDuration: uint256, _user: address = msg.sender):\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    vaultAddr: address = staticcall AddressRegistry(a.vaultBook).getAddr(RIPE_GOV_VAULT_ID)\n\n    # validate underscore wallet\n    if _user != msg.sender:\n        assert self._isUnderscoreWalletOwner(_user, msg.sender, a.missionControl) # dev: not owner of underscore wallet\n\n    extcall RipeGovVault(vaultAddr).adjustLock(_user, _asset, _newLockDuration, a)\n    self._performHousekeeping(False, _user, msg.sender, True, a)\n\n\n@nonreentrant\n@external\ndef releaseLock(_asset: address, _user: address = msg.sender):\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    vaultAddr: address = staticcall AddressRegistry(a.vaultBook).getAddr(RIPE_GOV_VAULT_ID)\n\n    # validate underscore wallet\n    if _user != msg.sender:\n        assert self._isUnderscoreWalletOwner(_user, msg.sender, a.missionControl) # dev: not owner of underscore wallet\n\n    extcall RipeGovVault(vaultAddr).releaseLock(_user, _asset, a)\n    self._performHousekeeping(False, _user, msg.sender, True, a)\n\n\n##################\n# Bond Purchases #\n##################\n\n\n@nonreentrant\n@external\ndef purchaseRipeBond(\n    _paymentAsset: address,\n    _paymentAmount: uint256 = max_value(uint256),\n    _lockDuration: uint256 = 0,\n    _recipient: address = msg.sender,\n) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    paymentAmount: uint256 = min(_paymentAmount, staticcall IERC20(_paymentAsset).balanceOf(msg.sender))\n    assert extcall IERC20(_paymentAsset).transferFrom(msg.sender, a.bondRoom, paymentAmount, default_return_value=True) # dev: token transfer failed\n    ripePayout: uint256 = extcall BondRoom(a.bondRoom).purchaseRipeBond(_recipient, _paymentAsset, paymentAmount, _lockDuration, msg.sender, a)\n    self._performHousekeeping(False, _recipient, msg.sender, True, a)\n    return ripePayout\n\n\n###############\n# User Config #\n###############\n\n\n@external\ndef setUserConfig(\n    _user: address = msg.sender,\n    _canAnyoneDeposit: bool = True,\n    _canAnyoneRepayDebt: bool = True,\n    _canAnyoneBondForUser: bool = True,\n) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    mc: address = addys._getMissionControlAddr()\n\n    # validate underscore wallet\n    if _user != msg.sender:\n        assert self._isUnderscoreWalletOwner(_user, msg.sender, mc) # dev: not owner of underscore wallet\n\n    return self._setUserConfig(_user, _canAnyoneDeposit, _canAnyoneRepayDebt, _canAnyoneBondForUser, mc)\n\n\n@internal\ndef _setUserConfig(\n    _user: address,\n    _canAnyoneDeposit: bool,\n    _canAnyoneRepayDebt: bool,\n    _canAnyoneBondForUser: bool,\n    _mc: address\n) -> bool:\n    userConfig: cs.UserConfig = cs.UserConfig(\n        canAnyoneDeposit=_canAnyoneDeposit,\n        canAnyoneRepayDebt=_canAnyoneRepayDebt,\n        canAnyoneBondForUser=_canAnyoneBondForUser,\n    )\n    extcall MissionControl(_mc).setUserConfig(_user, userConfig)\n    log UserConfigSet(user=_user, canAnyoneDeposit=_canAnyoneDeposit, canAnyoneRepayDebt=_canAnyoneRepayDebt, canAnyoneBondForUser=_canAnyoneBondForUser, caller=msg.sender)\n    return True\n\n\n# delegation\n\n\n@external\ndef setUserDelegation(\n    _delegate: address,\n    _user: address = msg.sender,\n    _canWithdraw: bool = True,\n    _canBorrow: bool = True,\n    _canClaimFromStabPool: bool = True,\n    _canClaimLoot: bool = True,\n) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert _delegate != empty(address) # dev: invalid delegate\n    assert _delegate != _user # dev: cannot delegate to self\n\n    # validate underscore wallet\n    mc: address = addys._getMissionControlAddr()\n    if _user != msg.sender:\n        assert self._isUnderscoreWalletOwner(_user, msg.sender, mc) # dev: not owner of underscore wallet\n        assert _delegate != msg.sender # dev: cannot delegate to owner\n\n    return self._setUserDelegation(_delegate, _user, _canWithdraw, _canBorrow, _canClaimFromStabPool, _canClaimLoot, mc)\n\n\n@internal\ndef _setUserDelegation(\n    _delegate: address,\n    _user: address,\n    _canWithdraw: bool,\n    _canBorrow: bool,\n    _canClaimFromStabPool: bool,\n    _canClaimLoot: bool,\n    _mc: address\n) -> bool:\n    config: cs.ActionDelegation = cs.ActionDelegation(\n        canWithdraw=_canWithdraw,\n        canBorrow=_canBorrow,\n        canClaimFromStabPool=_canClaimFromStabPool,\n        canClaimLoot=_canClaimLoot,\n    )\n    extcall MissionControl(_mc).setUserDelegation(_user, _delegate, config)\n    log UserDelegationSet(user=_user, delegate=_delegate, canWithdraw=_canWithdraw, canBorrow=_canBorrow, canClaimFromStabPool=_canClaimFromStabPool, canClaimLoot=_canClaimLoot, caller=msg.sender)\n    return True\n\n\n# underscore helpers\n\n\n@external\ndef setUndyLegoAccess(_legoAddr: address) -> bool:\n    # NOTE: failing gracefully here to not brick underscore wallets\n\n    mc: address = addys._getMissionControlAddr()\n    if mc == empty(address):\n        return False\n\n    if _legoAddr == empty(address):\n        return False\n\n    if not self._isUnderscoreWallet(msg.sender, mc):\n        return False\n\n    # set config\n    self._setUserConfig(msg.sender, True, True, True, mc)\n    self._setUserDelegation(_legoAddr, msg.sender, True, True, True, True, mc)\n    return True\n\n\n#############\n# Utilities #\n#############\n\n\n# housekeeping\n\n\n@internal\ndef _performHousekeeping(\n    _isHigherRisk: bool,\n    _user: address,\n    _caller: address,\n    _shouldUpdateDebt: bool,\n    _a: addys.Addys,\n):\n    # one action per block\n    shouldCheckLastTouch: bool = False\n    if staticcall MissionControl(_a.missionControl).shouldCheckLastTouch():\n        shouldCheckLastTouch = _isHigherRisk and not self._isUnderscoreWallet(_caller, _a.missionControl)\n    extcall Ledger(_a.ledger).checkAndUpdateLastTouch(_user, shouldCheckLastTouch)\n\n    # update green ref pool snapshot\n    curvePrices: address = staticcall AddressRegistry(_a.priceDesk).getAddr(CURVE_PRICES_ID)\n    if curvePrices != empty(address):\n        extcall CurvePrices(curvePrices).addGreenRefPoolSnapshot()\n\n    # update debt\n    if _shouldUpdateDebt:\n        if _isHigherRisk:\n            assert extcall CreditEngine(_a.creditEngine).updateDebtForUser(_user, _a) # dev: bad debt health\n        else:\n            extcall CreditEngine(_a.creditEngine).updateDebtForUser(_user, _a)\n\n\n# vault info \n\n\n@view\n@internal\ndef _getVaultAddrAndId(\n    _asset: address,\n    _vaultAddr: address,\n    _vaultId: uint256,\n    _vaultBook: address,\n    _missionControl: address,\n) -> (address, uint256):\n    vaultAddr: address = empty(address)\n    vaultId: uint256 = 0\n\n    # if no vault data specified, get first vault id for asset\n    if _vaultAddr == empty(address) and _vaultId == 0:\n        vaultId = staticcall MissionControl(_missionControl).getFirstVaultIdForAsset(_asset)\n        assert vaultId != 0 # dev: invalid asset\n        vaultAddr = staticcall AddressRegistry(_vaultBook).getAddr(vaultId)\n        assert vaultAddr != empty(address) # dev: invalid vault id\n\n    # vault id\n    elif _vaultId != 0:\n        vaultAddr = staticcall AddressRegistry(_vaultBook).getAddr(_vaultId)\n        assert vaultAddr != empty(address) # dev: invalid vault id\n        vaultId = _vaultId\n        if _vaultAddr != empty(address):\n            assert vaultAddr == _vaultAddr # dev: vault id and vault addr mismatch\n\n    # vault addr\n    elif _vaultAddr != empty(address):\n        vaultId = staticcall AddressRegistry(_vaultBook).getRegId(_vaultAddr) # dev: invalid vault addr\n        assert vaultId != 0 # dev: invalid vault addr\n        vaultAddr = _vaultAddr\n\n    return vaultAddr, vaultId\n\n\n# green payments\n\n\n@internal\ndef _handleGreenPayment(\n    _isPaymentSavingsGreen: bool,\n    _amount: uint256,\n    _recipient: address,\n    _greenToken: address,\n    _savingsGreen: address,\n) -> uint256:\n    asset: address = _greenToken\n    if _isPaymentSavingsGreen:\n        asset = _savingsGreen\n\n    amount: uint256 = min(_amount, staticcall IERC20(asset).balanceOf(msg.sender))\n    assert amount != 0 # dev: cannot transfer 0 amount\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    # savings green - unwrap it and transfer to recipient\n    if _isPaymentSavingsGreen:\n        assert extcall IERC20(_savingsGreen).transferFrom(msg.sender, self, amount, default_return_value=True) # dev: token transfer failed\n        amount = extcall IERC4626(_savingsGreen).redeem(amount, _recipient, self) # dev: savings green redeem failed\n\n    # normal green - transfer directly to recipient\n    else:\n        assert extcall IERC20(_greenToken).transferFrom(msg.sender, _recipient, amount, default_return_value=True) # dev: token transfer failed\n\n    return amount\n\n\n# underscore ownership check\n\n\n@view\n@external\ndef isUnderscoreWalletOwner(_user: address, _caller: address, _mc: address = empty(address)) -> bool:\n    missionControl: address = _mc\n    if _mc == empty(address):\n        missionControl = addys._getMissionControlAddr()\n    return self._isUnderscoreWalletOwner(_user, _caller, missionControl)\n\n\n@view\n@internal\ndef _isUnderscoreWallet(_user: address, _mc: address) -> bool:\n    underscore: address = staticcall MissionControl(_mc).underscoreRegistry()\n    if underscore == empty(address):\n        return False\n\n    agentFactory: address = staticcall UnderscoreRegistry(underscore).getAddy(UNDERSCORE_AGENT_FACTORY_ID)\n    if agentFactory == empty(address):\n        return False\n\n    # check if user is underscore wallet\n    return staticcall UnderscoreAgentFactory(agentFactory).isUserWallet(_user)\n\n\n@view\n@internal\ndef _isUnderscoreWalletOwner(_user: address, _caller: address, _mc: address) -> bool:\n    if not self._isUnderscoreWallet(_user, _mc):\n        return False\n\n    walletConfig: address = staticcall UnderscoreWallet(_user).walletConfig()\n    if walletConfig == empty(address):\n        return False\n\n    # check if caller is owner\n    return staticcall UnderscoreWalletConfig(walletConfig).owner() == _caller",
            "sha256sum": "5b73a989af2895771265a779a3bad89788625c8a1f9e2b122e46a6978d4a60ee"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/Teller.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.1+commit.8a93dd27",
        "integrity": "d504d69cf74a66d12d3a937eb2779c79736e11e994a1de8ef29665382c26a217"
      },
      "args": "0000000000000000000000002a85046e01a0b3e32370dc840cdf950efe954a030000000000000000000000000000000000000000000000000000000000000000",
      "file": "contracts/core/Teller.vy"
    }
  }
}