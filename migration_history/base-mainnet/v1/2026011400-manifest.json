{
  "contracts": {
    "EndaomentPSM": {
      "address": "0x58Eed464070BF2249DF6273157367041394527D4",
      "abi": [
        {
          "name": "MintGreen",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "usdcIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "greenOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdcFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "receivedSavingsGreen",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RedeemGreen",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "sender",
              "type": "address",
              "indexed": true
            },
            {
              "name": "greenIn",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdcOut",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdcFee",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "paidWithSavingsGreen",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentPSMYieldDeposit",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultTokenReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentPSMYieldWithdrawal",
          "inputs": [
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultTokenBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdcReceived",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanMintUpdated",
          "inputs": [
            {
              "name": "canMint",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanRedeemUpdated",
          "inputs": [
            {
              "name": "canRedeem",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MintFeeUpdated",
          "inputs": [
            {
              "name": "fee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RedeemFeeUpdated",
          "inputs": [
            {
              "name": "fee",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MaxIntervalMintUpdated",
          "inputs": [
            {
              "name": "maxAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MaxIntervalRedeemUpdated",
          "inputs": [
            {
              "name": "maxAmount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NumBlocksPerIntervalUpdated",
          "inputs": [
            {
              "name": "blocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldEnforceMintAllowlistUpdated",
          "inputs": [
            {
              "name": "shouldEnforce",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldEnforceRedeemAllowlistUpdated",
          "inputs": [
            {
              "name": "shouldEnforce",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MintAllowlistUpdated",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isAllowed",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RedeemAllowlistUpdated",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "isAllowed",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UsdcYieldPositionUpdated",
          "inputs": [
            {
              "name": "legoId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "vaultToken",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldAutoDepositUpdated",
          "inputs": [
            {
              "name": "shouldAutoDeposit",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintGreen",
          "inputs": [
            {
              "name": "_usdcAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintGreen",
          "inputs": [
            {
              "name": "_usdcAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "mintGreen",
          "inputs": [
            {
              "name": "_usdcAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxUsdcAmountForMint",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxUsdcAmountForMint",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxUsdcAmountForMint",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_isUnderscoreVault",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailIntervalMint",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemGreen",
          "inputs": [
            {
              "name": "_paymentAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemGreen",
          "inputs": [
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "redeemGreen",
          "inputs": [
            {
              "name": "_paymentAmount",
              "type": "uint256"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_isPaymentSavingsGreen",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxRedeemableGreenAmount",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxRedeemableGreenAmount",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxRedeemableGreenAmount",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_isUnderscoreVault",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailIntervalRedemptions",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUsdcYieldPositionVaultToken",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "depositToYield",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldTransferToEndaoFunds",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "withdrawFromYield",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_shouldTransferToEndaoFunds",
              "type": "bool"
            },
            {
              "name": "_shouldFullSweep",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUnderlyingYieldAmount",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferUsdcToEndaomentFunds",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAvailableUsdc",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanMint",
          "inputs": [
            {
              "name": "_canMint",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMintFee",
          "inputs": [
            {
              "name": "_fee",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxIntervalMint",
          "inputs": [
            {
              "name": "_maxGreenAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldEnforceMintAllowlist",
          "inputs": [
            {
              "name": "_shouldEnforce",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateMintAllowlist",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_isAllowed",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanRedeem",
          "inputs": [
            {
              "name": "_canRedeem",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRedeemFee",
          "inputs": [
            {
              "name": "_fee",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxIntervalRedeem",
          "inputs": [
            {
              "name": "_maxGreenAmount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldEnforceRedeemAllowlist",
          "inputs": [
            {
              "name": "_shouldEnforce",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateRedeemAllowlist",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_isAllowed",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUsdcYieldPosition",
          "inputs": [
            {
              "name": "_legoId",
              "type": "uint256"
            },
            {
              "name": "_vaultToken",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setNumBlocksPerInterval",
          "inputs": [
            {
              "name": "_blocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldAutoDeposit",
          "inputs": [
            {
              "name": "_shouldAutoDeposit",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numBlocksPerInterval",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "usdcYieldPosition",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "legoId",
                  "type": "uint256"
                },
                {
                  "name": "vaultToken",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldAutoDeposit",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMint",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "mintFee",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxIntervalMint",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "mintAllowlist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldEnforceMintAllowlist",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalMintInterval",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "start",
                  "type": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRedeem",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "redeemFee",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxIntervalRedeem",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "redeemAllowlist",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "shouldEnforceRedeemAllowlist",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "globalRedeemInterval",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "start",
                  "type": "uint256"
                },
                {
                  "name": "amount",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "USDC",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_numBlocksPerInterval",
              "type": "uint256"
            },
            {
              "name": "_mintFee",
              "type": "uint256"
            },
            {
              "name": "_maxIntervalMint",
              "type": "uint256"
            },
            {
              "name": "_redeemFee",
              "type": "uint256"
            },
            {
              "name": "_maxIntervalRedeem",
              "type": "uint256"
            },
            {
              "name": "_usdc",
              "type": "address"
            },
            {
              "name": "_usdcYieldLegoId",
              "type": "uint256"
            },
            {
              "name": "_usdcYieldVaultToken",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\ninterface RipeHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\nDELEVERAGE_ID: constant(uint256) = 18\nCREDIT_REDEEM_ID: constant(uint256) = 19\nTELLER_UTILS_ID: constant(uint256) = 20\nENDAOMENT_FUNDS_ID: constant(uint256) = 21\nENDAOMENT_PSM_ID: constant(uint256) = 22\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# deleverage\n\n\n@view\n@internal\ndef _getDeleverageId() -> uint256:\n    return DELEVERAGE_ID\n\n\n@view\n@internal\ndef _getDeleverageAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(DELEVERAGE_ID)\n\n\n# creditRedeem\n\n\n@view\n@internal\ndef _getCreditRedeemId() -> uint256:\n    return CREDIT_REDEEM_ID\n\n\n@view\n@internal\ndef _getCreditRedeemAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_REDEEM_ID)\n\n\n# teller utils\n\n\n@view\n@internal\ndef _getTellerUtilsId() -> uint256:\n    return TELLER_UTILS_ID\n\n\n@view\n@internal\ndef _getTellerUtilsAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_UTILS_ID)\n\n\n# endaoment funds\n\n\n@view\n@internal\ndef _getEndaomentFundsId() -> uint256:\n    return ENDAOMENT_FUNDS_ID\n\n\n@view\n@internal\ndef _getEndaomentFundsAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_FUNDS_ID)\n\n\n# endaoment psm\n\n\n@view\n@internal\ndef _getEndaomentPsmId() -> uint256:\n    return ENDAOMENT_PSM_ID\n\n\n@view\n@internal\ndef _getEndaomentPsmAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_PSM_ID)",
            "sha256sum": "2a46a2fbb26fed9ed5d59414833fb6c2f85a7ddf72e82ffc2d6e122296e1d4e6"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "4022e08f4321cf2a061b4e6b15820958c96ff499d4fa72fcf789ed97dc234ed8"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "9a59ebe09a5c42dc943976e0cd48bc28ca56b7209a516514f11bf9162114043f"
          },
          "interfaces/UndyLego.vyi": {
            "content": "# @version 0.4.3\n\nflag ActionType:\n    TRANSFER\n    EARN_DEPOSIT\n    EARN_WITHDRAW\n    EARN_REBALANCE\n    SWAP\n    MINT_REDEEM\n    CONFIRM_MINT_REDEEM\n    ADD_COLLATERAL\n    REMOVE_COLLATERAL\n    BORROW\n    REPAY_DEBT\n    REWARDS\n    ETH_TO_WETH\n    WETH_TO_ETH\n    ADD_LIQ\n    REMOVE_LIQ\n    ADD_LIQ_CONC\n    REMOVE_LIQ_CONC\n    PAY_CHEQUE\n\nstruct MiniAddys:\n    ledger: address\n    missionControl: address\n    legoBook: address\n    appraiser: address\n\nstruct SwapInstruction:\n    legoId: uint256\n    amountIn: uint256\n    minAmountOut: uint256\n    tokenPath: DynArray[address, MAX_TOKEN_PATH]\n    poolPath: DynArray[address, MAX_TOKEN_PATH - 1]\n\nMAX_TOKEN_PATH: constant(uint256) = 5\nMAX_PROOFS: constant(uint256) = 25\n\n\n@external\ndef addLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _tickLower: int24, _tickUpper: int24, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef addLiquidity(_pool: address, _tokenA: address, _tokenB: address, _amountA: uint256, _amountB: uint256, _minAmountA: uint256, _minAmountB: uint256, _minLpAmount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (address, uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef removeLiquidityConcentrated(_nftTokenId: uint256, _pool: address, _tokenA: address, _tokenB: address, _liqToRemove: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef removeLiquidity(_pool: address, _tokenA: address, _tokenB: address, _lpToken: address, _lpAmount: uint256, _minAmountA: uint256, _minAmountB: uint256, _extraData: bytes32, _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, uint256, uint256, uint256):\n    ...\n\n@external\ndef mintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _tokenInAmount: uint256, _minAmountOut: uint256, _extraData: bytes32, _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, uint256, bool, uint256):\n    ...\n\n@external\ndef swapTokens(_amountIn: uint256, _minAmountOut: uint256, _tokenPath: DynArray[address, MAX_TOKEN_PATH], _poolPath: DynArray[address, MAX_TOKEN_PATH - 1], _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, uint256, uint256):\n    ...\n\n@external\ndef depositForYield(_asset: address, _amount: uint256, _vaultAddr: address, _extraData: bytes32, _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef withdrawFromYield(_vaultToken: address, _amount: uint256, _extraData: bytes32, _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, address, uint256, uint256):\n    ...\n\n@external\ndef confirmMintOrRedeemAsset(_tokenIn: address, _tokenOut: address, _extraData: bytes32, _recipient: address, _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, uint256):\n    ...\n\n@external\ndef claimIncentives(_user: address, _rewardToken: address, _rewardAmount: uint256, _proofs: DynArray[bytes32, MAX_PROOFS], _miniAddys: MiniAddys = empty(MiniAddys)) -> (uint256, uint256):\n    ...\n\n@view\n@external\ndef getAccessForLego(_user: address, _action: ActionType) -> (address, String[64], uint256):\n    ...\n\n@view\n@external\ndef getUnderlyingAmountSafe(_vaultToken: address, _vaultTokenBalance: uint256) -> uint256:\n    ...\n\n@view\n@external\ndef getVaultTokenAmount(_asset: address, _assetAmount: uint256, _vaultToken: address) -> uint256:\n    ...",
            "sha256sum": "e6887eb4b6121ed2c1474056160e2b89740b4f78466bb0f7747077c661049c3d"
          },
          "contracts/core/EndaomentPSM.vy": {
            "content": "#            ___          ___                       ___          ___          ___          ___          ___                 \n#           /\\__\\        /\\  \\        _____        /\\  \\        /\\  \\        /\\  \\        /\\__\\        /\\  \\                \n#          /:/ _/_       \\:\\  \\      /::\\  \\      /::\\  \\      /::\\  \\      |::\\  \\      /:/ _/_       \\:\\  \\       ___     \n#         /:/ /\\__\\       \\:\\  \\    /:/\\:\\  \\    /:/\\:\\  \\    /:/\\:\\  \\     |:|:\\  \\    /:/ /\\__\\       \\:\\  \\     /\\__\\    \n#        /:/ /:/ _/_  _____\\:\\  \\  /:/  \\:\\__\\  /:/ /::\\  \\  /:/  \\:\\  \\  __|:|\\:\\  \\  /:/ /:/ _/_  _____\\:\\  \\   /:/  /    \n#       /:/_/:/ /\\__\\/::::::::\\__\\/:/__/ \\:|__|/:/_/:/\\:\\__\\/:/__/ \\:\\__\\/::::|_\\:\\__\\/:/_/:/ /\\__\\/::::::::\\__\\ /:/__/     \n#       \\:\\/:/ /:/  /\\:\\~~\\~~\\/__/\\:\\  \\ /:/  /\\:\\/:/  \\/__/\\:\\  \\ /:/  /\\:\\~~\\  \\/__/\\:\\/:/ /:/  /\\:\\~~\\~~\\/__//::\\  \\     \n#        \\::/_/:/  /  \\:\\  \\       \\:\\  /:/  /  \\::/__/      \\:\\  /:/  /  \\:\\  \\       \\::/_/:/  /  \\:\\  \\     /:/\\:\\  \\    \n#         \\:\\/:/  /    \\:\\  \\       \\:\\/:/  /    \\:\\  \\       \\:\\/:/  /    \\:\\  \\       \\:\\/:/  /    \\:\\  \\    \\/__\\:\\  \\   \n#          \\::/  /      \\:\\__\\       \\::/  /      \\:\\__\\       \\::/  /      \\:\\__\\       \\::/  /      \\:\\__\\        \\:\\__\\  \n#           \\/__/        \\/__/        \\/__/        \\/__/        \\/__/        \\/__/        \\/__/        \\/__/         \\/__/  \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Endaoment PSM **                               \u2551\n#     \u2551  Allows minting / redeeming of GREEN <--> USDC     \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n#     Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\n\nfrom interfaces import Department\nfrom interfaces import UndyLego\n\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC4626\n\ninterface PriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface GreenToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n    def burn(_amount: uint256) -> bool: nonpayable\n\ninterface Registry:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_id: uint256) -> address: view\n\ninterface VaultRegistry:\n    def isEarnVault(_addr: address) -> bool: view\n\ninterface MissionControl:\n    def underscoreRegistry() -> address: view\n\nstruct PsmInterval:\n    start: uint256\n    amount: uint256\n\nstruct UsdcYieldPosition:\n    legoId: uint256\n    vaultToken: address\n\nevent MintGreen:\n    user: indexed(address)\n    sender: indexed(address)\n    usdcIn: uint256\n    greenOut: uint256\n    usdcFee: uint256\n    receivedSavingsGreen: bool\n\nevent RedeemGreen:\n    user: indexed(address)\n    sender: indexed(address)\n    greenIn: uint256\n    usdcOut: uint256\n    usdcFee: uint256\n    paidWithSavingsGreen: bool\n\nevent EndaomentPSMYieldDeposit:\n    amount: uint256\n    vaultToken: indexed(address)\n    vaultTokenReceived: uint256\n    usdValue: uint256\n\nevent EndaomentPSMYieldWithdrawal:\n    vaultToken: indexed(address)\n    vaultTokenBurned: uint256\n    usdcReceived: uint256\n    usdValue: uint256\n\nevent CanMintUpdated:\n    canMint: bool\n\nevent CanRedeemUpdated:\n    canRedeem: bool\n\nevent MintFeeUpdated:\n    fee: uint256\n\nevent RedeemFeeUpdated:\n    fee: uint256\n\nevent MaxIntervalMintUpdated:\n    maxAmount: uint256\n\nevent MaxIntervalRedeemUpdated:\n    maxAmount: uint256\n\nevent NumBlocksPerIntervalUpdated:\n    blocks: uint256\n\nevent ShouldEnforceMintAllowlistUpdated:\n    shouldEnforce: bool\n\nevent ShouldEnforceRedeemAllowlistUpdated:\n    shouldEnforce: bool\n\nevent MintAllowlistUpdated:\n    user: indexed(address)\n    isAllowed: bool\n\nevent RedeemAllowlistUpdated:\n    user: indexed(address)\n    isAllowed: bool\n\nevent UsdcYieldPositionUpdated:\n    legoId: uint256\n    vaultToken: indexed(address)\n\nevent ShouldAutoDepositUpdated:\n    shouldAutoDeposit: bool\n\n# general config\nnumBlocksPerInterval: public(uint256) # shared interval duration\nusdcYieldPosition: public(UsdcYieldPosition)\nshouldAutoDeposit: public(bool)\n\n# mint config\ncanMint: public(bool)\nmintFee: public(uint256) # basis points\nmaxIntervalMint: public(uint256) # max GREEN mintable per interval\nmintAllowlist: public(HashMap[address, bool])\nshouldEnforceMintAllowlist: public(bool)\nglobalMintInterval: public(PsmInterval)\n\n# redeem config\ncanRedeem: public(bool)\nredeemFee: public(uint256) # basis points\nmaxIntervalRedeem: public(uint256) # max GREEN redeemable per interval\nredeemAllowlist: public(HashMap[address, bool])\nshouldEnforceRedeemAllowlist: public(bool)\nglobalRedeemInterval: public(PsmInterval)\n\nUNDERSCORE_LEGOBOOK_ID: constant(uint256) = 3\nUNDERSCORE_VAULT_REGISTRY_ID: constant(uint256) = 10\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nONE_USDC: constant(uint256) = 10 ** 6\nONE_GREEN: constant(uint256) = 10 ** 18\n\nUSDC: public(immutable(address))\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _numBlocksPerInterval: uint256,\n    _mintFee: uint256,\n    _maxIntervalMint: uint256,\n    _redeemFee: uint256,\n    _maxIntervalRedeem: uint256,\n    _usdc: address,\n    _usdcYieldLegoId: uint256,\n    _usdcYieldVaultToken: address,\n):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, True, False) # (isPaused, canMintGreen, canMintRipe)\n\n    assert _numBlocksPerInterval != 0 # dev: invalid interval\n    self.numBlocksPerInterval = _numBlocksPerInterval\n    self.shouldAutoDeposit = True\n\n    # mint config\n    self.canMint = False\n    assert _mintFee <= HUNDRED_PERCENT # dev: invalid fee\n    self.mintFee = _mintFee\n    assert _maxIntervalMint != 0 and _maxIntervalMint != max_value(uint256) # dev: invalid max\n    self.maxIntervalMint = _maxIntervalMint\n    self.shouldEnforceMintAllowlist = False\n\n    # redeem config\n    self.canRedeem = False\n    assert _redeemFee <= HUNDRED_PERCENT # dev: invalid fee\n    self.redeemFee = _redeemFee\n    assert _maxIntervalRedeem != 0 and _maxIntervalRedeem != max_value(uint256) # dev: invalid max\n    self.maxIntervalRedeem = _maxIntervalRedeem\n    self.shouldEnforceRedeemAllowlist = False\n\n    assert _usdc != empty(address) # dev: invalid USDC address\n    USDC = _usdc\n\n    # yield config\n    if _usdcYieldLegoId != 0 and _usdcYieldVaultToken != empty(address):\n        self.usdcYieldPosition = UsdcYieldPosition(legoId=_usdcYieldLegoId, vaultToken=_usdcYieldVaultToken)\n\n\n##############\n# GREEN Mint #\n##############\n\n\n# mint - USDC -> GREEN\n\n\n@nonreentrant\n@external\ndef mintGreen(_usdcAmount: uint256 = max_value(uint256), _recipient: address = msg.sender, _wantsSavingsGreen: bool = False) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert self.canMint # dev: minting disabled\n    a: addys.Addys = addys._getAddys()\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    # check if recipient is underscore vault (only vaults get favorable treatment)\n    isUnderscoreVault: bool = self._isUnderscoreVault(_recipient, a.missionControl)\n    if not isUnderscoreVault and self.shouldEnforceMintAllowlist:\n        assert self.mintAllowlist[msg.sender] # dev: not on mint allowlist\n\n    # usdc amount to transfer (cap by user balance and interval limit)\n    usdc: address = USDC\n    maxUsdcAmount: uint256 = min(self._calculateMaxUsdcForMint(isUnderscoreVault, usdc, a.priceDesk), staticcall IERC20(usdc).balanceOf(msg.sender))\n    usdcAmount: uint256 = min(_usdcAmount, maxUsdcAmount)\n    assert usdcAmount != 0 # dev: zero amount\n\n    # transfer usdc from user\n    assert extcall IERC20(usdc).transferFrom(msg.sender, self, usdcAmount, default_return_value=True) # dev: transfer failed\n\n    # mint fee\n    feeAmount: uint256 = 0\n    usdcAfterFee: uint256 = usdcAmount\n\n    # apply fee only for non-underscore vaults\n    if not isUnderscoreVault:\n        feeAmount = usdcAmount * self.mintFee // HUNDRED_PERCENT\n        usdcAfterFee = usdcAmount - feeAmount\n\n    # green to mint (conservative for all users: USDC maxed at $1)\n    usdValue: uint256 = staticcall PriceDesk(a.priceDesk).getUsdValue(usdc, usdcAfterFee, True)\n    usdcInGreenDecimals: uint256 = usdcAfterFee * ONE_GREEN // ONE_USDC\n    greenToMint: uint256 = min(usdValue, usdcInGreenDecimals)\n    assert greenToMint != 0 # dev: zero mint amount\n\n    # update interval storage (underscore vaults bypass)\n    if not isUnderscoreVault:\n        self._updateMintInterval(greenToMint)\n\n    receivedSavingsGreen: bool = False\n\n    # mint GREEN to self, then deposit to Savings Green for recipient\n    if _wantsSavingsGreen and greenToMint > ONE_GREEN:\n        extcall GreenToken(a.greenToken).mint(self, greenToMint)\n        assert extcall IERC20(a.greenToken).approve(a.savingsGreen, greenToMint, default_return_value=True)\n        extcall IERC4626(a.savingsGreen).deposit(greenToMint, _recipient)\n        assert extcall IERC20(a.greenToken).approve(a.savingsGreen, 0, default_return_value=True)\n        receivedSavingsGreen = True\n\n    # mint GREEN directly to recipient\n    else:\n        extcall GreenToken(a.greenToken).mint(_recipient, greenToMint)\n\n    # deposit usdc into yield\n    if self.shouldAutoDeposit:\n        self._depositToYield(usdc, a.missionControl)\n\n    log MintGreen(user=_recipient, sender=msg.sender, usdcIn=usdcAmount, greenOut=greenToMint, usdcFee=feeAmount, receivedSavingsGreen=receivedSavingsGreen)\n    return greenToMint\n\n\n# max mintable (internal helper)\n\n\n@view\n@internal\ndef _calculateMaxUsdcForMint(_isUnderscoreVault: bool, _usdc: address, _priceDesk: address) -> uint256:\n    if _isUnderscoreVault:\n        return max_value(uint256) # underscore vaults have unlimited capacity\n\n    # convert interval capacity (GREEN) back to USDC needed\n    intervalCapacity: uint256 = self._getAvailIntervalMint()\n\n    # properly account for USDC price (may need more USDC if below peg)\n    usdcFromPriceDesk: uint256 = staticcall PriceDesk(_priceDesk).getAssetAmount(_usdc, intervalCapacity, False)\n    usdcInGreenDecimals: uint256 = intervalCapacity * ONE_USDC // ONE_GREEN\n    usdcAmount: uint256 = max(usdcFromPriceDesk, usdcInGreenDecimals)\n\n    # account for mint fee: usdcAfterFee = usdcInput * (1 - fee)\n    # reverse: usdcInput = usdcAfterFee * HUNDRED_PERCENT / (HUNDRED_PERCENT - fee)\n    mintFee: uint256 = self.mintFee\n    if mintFee != 0:\n        feeMultiplier: uint256 = HUNDRED_PERCENT - mintFee\n        if feeMultiplier == 0:\n            return 0 # cannot divide by zero\n        usdcAmount = usdcAmount * HUNDRED_PERCENT // feeMultiplier\n\n    return usdcAmount\n\n\n# max mintable (front-end can use this to get max USDC amount)\n\n\n@view\n@external\ndef getMaxUsdcAmountForMint(_user: address = empty(address), _isUnderscoreVault: bool = False) -> uint256:\n    usdc: address = USDC\n    usdcAmount: uint256 = self._calculateMaxUsdcForMint(_isUnderscoreVault, usdc, addys._getPriceDeskAddr())\n\n    # if user provided, also consider their usdc balance\n    if _user != empty(address):\n        usdcBalance: uint256 = staticcall IERC20(usdc).balanceOf(_user)\n        usdcAmount = min(usdcBalance, usdcAmount)\n\n    return usdcAmount\n\n\n# check interval availability\n\n\n@view\n@external\ndef getAvailIntervalMint() -> uint256:\n    return self._getAvailIntervalMint()\n\n\n@view\n@internal\ndef _getAvailIntervalMint() -> uint256:\n    data: PsmInterval = self.globalMintInterval\n    maxIntervalMint: uint256 = self.maxIntervalMint\n    if data.start != 0 and data.start + self.numBlocksPerInterval > block.number:\n        maxIntervalMint -= min(data.amount, maxIntervalMint)\n    return maxIntervalMint\n\n\n# update mint interval\n\n\n@internal\ndef _updateMintInterval(_amount: uint256):\n    data: PsmInterval = self.globalMintInterval\n\n    # existing interval - accumulate amount\n    if data.start != 0 and data.start + self.numBlocksPerInterval > block.number:\n        data.amount += _amount\n\n    # new interval - reset with current block and amount\n    else:\n        data.start = block.number\n        data.amount = _amount\n\n    self.globalMintInterval = data\n\n\n#####################\n# GREEN Redemptions #\n#####################\n\n\n# redeem - GREEN -> USDC\n\n\n@nonreentrant\n@external\ndef redeemGreen(_paymentAmount: uint256 = max_value(uint256), _recipient: address = msg.sender, _isPaymentSavingsGreen: bool = False) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert self.canRedeem # dev: redemption disabled\n    a: addys.Addys = addys._getAddys()\n    assert _recipient != empty(address) # dev: invalid recipient\n\n    # check if recipient is underscore vault (only vaults get favorable treatment)\n    isUnderscoreVault: bool = self._isUnderscoreVault(_recipient, a.missionControl)\n    if not isUnderscoreVault and self.shouldEnforceRedeemAllowlist:\n        assert self.redeemAllowlist[msg.sender] # dev: not on redeem allowlist\n\n    # calculate max allowed to redeem (cap by interval and USDC availability)\n    usdc: address = USDC\n    usdcYieldPosition: UsdcYieldPosition = self.usdcYieldPosition\n    maxGreenAllowed: uint256 = self._calculateMaxRedeemableGreen(isUnderscoreVault, usdcYieldPosition.legoId, usdcYieldPosition.vaultToken, usdc, a.priceDesk, a.missionControl)\n\n    # transfer sGREEN from user and redeem to GREEN (cap by max allowed)\n    greenAmount: uint256 = 0\n    if _isPaymentSavingsGreen:\n        maxSavingsGreenAmount: uint256 = min(staticcall IERC4626(a.savingsGreen).convertToShares(maxGreenAllowed), staticcall IERC20(a.savingsGreen).balanceOf(msg.sender))\n        savingsGreenAmount: uint256 = min(_paymentAmount, maxSavingsGreenAmount)\n        assert savingsGreenAmount != 0 # dev: zero amount\n        assert extcall IERC20(a.savingsGreen).transferFrom(msg.sender, self, savingsGreenAmount, default_return_value=True) # dev: transfer failed\n        greenAmount = extcall IERC4626(a.savingsGreen).redeem(savingsGreenAmount, self, self)\n\n    # transfer GREEN directly from user (cap by max allowed)\n    else:\n        maxGreenAmount: uint256 = min(maxGreenAllowed, staticcall IERC20(a.greenToken).balanceOf(msg.sender))\n        greenAmount = min(_paymentAmount, maxGreenAmount)\n        assert greenAmount != 0 # dev: zero amount\n        assert extcall IERC20(a.greenToken).transferFrom(msg.sender, self, greenAmount, default_return_value=True) # dev: transfer failed\n\n    # usdc to give\n    usdcFromPriceDesk: uint256 = staticcall PriceDesk(a.priceDesk).getAssetAmount(usdc, greenAmount, True)\n    greenInUsdcDecimals: uint256 = greenAmount * ONE_USDC // ONE_GREEN\n\n    usdcToGive: uint256 = 0\n    if isUnderscoreVault:\n        usdcToGive = max(usdcFromPriceDesk, greenInUsdcDecimals) # vault gets favorable rate: max of priceDesk and 1:1\n    else:\n        usdcToGive = min(usdcFromPriceDesk, greenInUsdcDecimals) # regular users: conservative (cannot get more than 1:1)\n    assert usdcToGive != 0 # dev: zero redeem amount\n\n    feeAmount: uint256 = 0\n    usdcAfterFee: uint256 = usdcToGive\n\n    # update interval storage (underscore vaults bypass)\n    if not isUnderscoreVault:\n        self._updateRedeemInterval(greenAmount)\n\n        # redeem fee\n        feeAmount = usdcToGive * self.redeemFee // HUNDRED_PERCENT\n        usdcAfterFee = usdcToGive - feeAmount\n\n    # ensure usdc liquidity (withdraw from yield if needed)\n    usdcBalance: uint256 = staticcall IERC20(usdc).balanceOf(self)\n    if usdcBalance < usdcAfterFee:\n        usdcBalance += self._withdrawFromYield(usdcYieldPosition.legoId, usdcYieldPosition.vaultToken, usdcAfterFee - usdcBalance, a.missionControl, usdc)\n        assert usdcBalance >= usdcAfterFee # dev: insufficient USDC\n\n    # transfer usdc to recipient\n    assert usdcAfterFee != 0 # dev: zero amount\n    assert extcall IERC20(usdc).transfer(_recipient, usdcAfterFee, default_return_value=True) # dev: transfer failed\n\n    # burn green\n    assert extcall GreenToken(a.greenToken).burn(greenAmount) # dev: burn failed\n\n    log RedeemGreen(user=_recipient, sender=msg.sender, greenIn=greenAmount, usdcOut=usdcAfterFee, usdcFee=feeAmount, paidWithSavingsGreen=_isPaymentSavingsGreen)\n    return usdcAfterFee\n\n\n# max redeemable (internal helper)\n\n\n@view\n@internal\ndef _calculateMaxRedeemableGreen(_isUnderscoreVault: bool, _legoId: uint256, _vaultToken: address, _usdc: address, _priceDesk: address, _missionControl: address) -> uint256:\n    # usdc available (idle + yield) - always limited by this\n    usdcAvailable: uint256 = self._getAvailableUsdc(_usdc, _legoId, _vaultToken, _missionControl)\n\n    # convert usdc to max green\n    usdValue: uint256 = staticcall PriceDesk(_priceDesk).getUsdValue(_usdc, usdcAvailable, False)\n    usdcInGreenDecimals: uint256 = usdcAvailable * ONE_GREEN // ONE_USDC\n    maxGreenFromUsdc: uint256 = min(usdValue, usdcInGreenDecimals)\n\n    # underscore vaults bypass interval limits and fees, but still limited by USDC\n    if _isUnderscoreVault:\n        return maxGreenFromUsdc\n\n    # account for redeem fee: usdcAfterFee = usdcToGive * (1 - fee)\n    # reverse: greenAmount = greenBeforeFee / (1 - fee)\n    redeemFee: uint256 = self.redeemFee\n    if redeemFee != 0:\n        feeMultiplier: uint256 = HUNDRED_PERCENT - redeemFee\n        if feeMultiplier == 0:\n            return 0 # cannot divide by zero\n        maxGreenFromUsdc = maxGreenFromUsdc * HUNDRED_PERCENT // feeMultiplier\n\n    # interval capacity\n    intervalCapacity: uint256 = self._getAvailIntervalRedemptions()\n\n    # get limiting factor from interval and usdc\n    return min(intervalCapacity, maxGreenFromUsdc)\n\n\n# max redeemable (front-end can use this to get max GREEN amount)\n\n\n@view\n@external\ndef getMaxRedeemableGreenAmount(_user: address = empty(address), _isUnderscoreVault: bool = False) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    usdc: address = USDC\n    usdcYieldPosition: UsdcYieldPosition = self.usdcYieldPosition\n    maxRedeemable: uint256 = self._calculateMaxRedeemableGreen(_isUnderscoreVault, usdcYieldPosition.legoId, usdcYieldPosition.vaultToken, usdc, a.priceDesk, a.missionControl)\n\n    # if user provided, also consider their green balance\n    if _user != empty(address):\n        greenBalance: uint256 = staticcall IERC20(a.greenToken).balanceOf(_user)\n        maxRedeemable = min(maxRedeemable, greenBalance)\n\n    return maxRedeemable\n\n\n# available interval redemptions\n\n\n@view\n@external\ndef getAvailIntervalRedemptions() -> uint256:\n    return self._getAvailIntervalRedemptions()\n\n\n@view\n@internal\ndef _getAvailIntervalRedemptions() -> uint256:\n    data: PsmInterval = self.globalRedeemInterval\n    maxIntervalRedeem: uint256 = self.maxIntervalRedeem\n    if data.start != 0 and data.start + self.numBlocksPerInterval > block.number:\n        maxIntervalRedeem -= min(data.amount, maxIntervalRedeem)\n    return maxIntervalRedeem\n\n\n# update redeem interval\n\n\n@internal\ndef _updateRedeemInterval(_amount: uint256):\n    data: PsmInterval = self.globalRedeemInterval\n\n    # existing interval - accumulate amount\n    if data.start != 0 and data.start + self.numBlocksPerInterval > block.number:\n        data.amount += _amount\n\n    # new interval - reset with current block and amount\n    else:\n        data.start = block.number\n        data.amount = _amount\n\n    self.globalRedeemInterval = data\n\n\n##################\n# Yield Position #\n##################\n\n\n@view\n@external\ndef getUsdcYieldPositionVaultToken() -> address:\n    return self.usdcYieldPosition.vaultToken\n\n\n# deposit to yield\n\n\n@nonreentrant\n@external\ndef depositToYield() -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    return self._depositToYield(USDC, addys._getMissionControlAddr())\n\n\n@internal\ndef _depositToYield(_usdc: address, _missionControl: address) -> uint256:\n    usdcYieldPosition: UsdcYieldPosition = self.usdcYieldPosition\n    if usdcYieldPosition.legoId == 0 or usdcYieldPosition.vaultToken == empty(address):\n        return 0\n\n    # get idle usdc balance\n    usdcBalance: uint256 = staticcall IERC20(_usdc).balanceOf(self)\n    if usdcBalance == 0:\n        return 0\n\n    # get lego address\n    legoAddr: address = self._getLegoAddr(usdcYieldPosition.legoId, _missionControl)\n    if legoAddr == empty(address):\n        return 0\n\n    # deposit into yield position\n    assert extcall IERC20(_usdc).approve(legoAddr, usdcBalance, default_return_value=True)\n    assetAmount: uint256 = 0\n    vaultToken: address = empty(address)\n    vaultTokenAmountReceived: uint256 = 0\n    txUsdValue: uint256 = 0\n    assetAmount, vaultToken, vaultTokenAmountReceived, txUsdValue = extcall UndyLego(legoAddr).depositForYield(_usdc, usdcBalance, usdcYieldPosition.vaultToken, empty(bytes32), self)\n    assert extcall IERC20(_usdc).approve(legoAddr, 0, default_return_value=True)\n\n    log EndaomentPSMYieldDeposit(amount=assetAmount, vaultToken=vaultToken, vaultTokenReceived=vaultTokenAmountReceived, usdValue=txUsdValue)\n    return assetAmount\n\n\n# withdraw from yield\n\n\n@external\ndef withdrawFromYield(_amount: uint256 = max_value(uint256), _shouldTransferToEndaoFunds: bool = False, _shouldFullSweep: bool = False) -> (uint256, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    usdc: address = USDC\n\n    # withdraw from yield\n    usdcYieldPosition: UsdcYieldPosition = self.usdcYieldPosition\n    withdrawnAmount: uint256 = self._withdrawFromYield(usdcYieldPosition.legoId, usdcYieldPosition.vaultToken, _amount, addys._getMissionControlAddr(), usdc)\n    assert withdrawnAmount != 0 # dev: zero amount\n\n    # transfer to endaoment funds\n    transferAmount: uint256 = 0\n    if _shouldTransferToEndaoFunds:\n        transferAmount = max_value(uint256) if _shouldFullSweep else _amount\n        transferAmount = self._transferUsdcToEndaomentFunds(transferAmount, usdc)\n        assert transferAmount != 0 # dev: zero amount to transfer\n\n    return withdrawnAmount, transferAmount\n\n\n@internal\ndef _withdrawFromYield(_legoId: uint256, _vaultToken: address, _amount: uint256, _missionControl: address, _usdc: address) -> uint256:\n    if _legoId == 0 or _vaultToken == empty(address) or _amount == 0:\n        return 0\n\n    # check vault token balance\n    vaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if vaultTokenBalance == 0:\n        return 0\n\n    # get lego address\n    legoAddr: address = self._getLegoAddr(_legoId, _missionControl)\n    if legoAddr == empty(address):\n        return 0\n\n    # calc vault tokens needed to withdraw\n    vaultTokensNeeded: uint256 = max_value(uint256)\n    if _amount != max_value(uint256):\n        amountNeeded: uint256 = _amount * 102_00 // HUNDRED_PERCENT # remove extra to ensure enough liquidity\n        vaultTokensNeeded = staticcall UndyLego(legoAddr).getVaultTokenAmount(_usdc, amountNeeded, _vaultToken)\n    vaultTokenBalance = min(vaultTokenBalance, vaultTokensNeeded)\n\n    # withdraw from yield position\n    assert extcall IERC20(_vaultToken).approve(legoAddr, vaultTokenBalance, default_return_value=True)\n    vaultTokenBurned: uint256 = 0\n    underlyingAsset: address = empty(address)\n    underlyingAmount: uint256 = 0\n    txUsdValue: uint256 = 0\n    vaultTokenBurned, underlyingAsset, underlyingAmount, txUsdValue = extcall UndyLego(legoAddr).withdrawFromYield(_vaultToken, vaultTokenBalance, empty(bytes32), self)\n    assert extcall IERC20(_vaultToken).approve(legoAddr, 0, default_return_value=True)\n\n    log EndaomentPSMYieldWithdrawal(vaultToken=_vaultToken, vaultTokenBurned=vaultTokenBurned, usdcReceived=underlyingAmount, usdValue=txUsdValue)\n    return underlyingAmount\n\n\n# underlying amount\n\n\n@view\n@external\ndef getUnderlyingYieldAmount() -> uint256:\n    usdcYieldPosition: UsdcYieldPosition = self.usdcYieldPosition\n    return self._getUnderlyingYieldAmount(usdcYieldPosition.legoId, usdcYieldPosition.vaultToken, addys._getMissionControlAddr())\n\n\n@view\n@internal\ndef _getUnderlyingYieldAmount(_legoId: uint256, _vaultToken: address, _missionControl: address) -> uint256:\n    if _legoId == 0 or _vaultToken == empty(address):\n        return 0\n    vaultTokenBalance: uint256 = staticcall IERC20(_vaultToken).balanceOf(self)\n    if vaultTokenBalance == 0:\n        return 0\n    legoAddr: address = self._getLegoAddr(_legoId, _missionControl)\n    if legoAddr == empty(address):\n        return 0\n    return staticcall UndyLego(legoAddr).getUnderlyingAmountSafe(_vaultToken, vaultTokenBalance)\n\n\n######################\n# Endaoment Transfer #\n######################\n\n\n@external\ndef transferUsdcToEndaomentFunds(_amount: uint256) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    return self._transferUsdcToEndaomentFunds(_amount, USDC)\n\n\n@internal\ndef _transferUsdcToEndaomentFunds(_amount: uint256, _usdc: address) -> uint256:\n    endaoFunds: address = addys._getEndaomentFundsAddr()\n    assert endaoFunds != empty(address) # dev: no endaoment funds\n\n    # finalize amount\n    currentBalance: uint256 = staticcall IERC20(_usdc).balanceOf(self)\n    transferAmount: uint256 = min(_amount, currentBalance)\n    assert transferAmount != 0 # dev: zero amount to transfer\n\n    # transfer to endaoment funds\n    assert extcall IERC20(_usdc).transfer(endaoFunds, transferAmount, default_return_value=True) # dev: xfer failed\n    return transferAmount\n\n\n#############\n# Utilities #\n#############\n\n\n# lego addr\n\n\n@view\n@internal\ndef _getLegoAddr(_legoId: uint256, _missionControl: address) -> address:\n    underscoreRegistry: address = staticcall MissionControl(_missionControl).underscoreRegistry()\n    if underscoreRegistry == empty(address):\n        return empty(address)\n    legoBook: address = staticcall Registry(underscoreRegistry).getAddr(UNDERSCORE_LEGOBOOK_ID)\n    if legoBook == empty(address):\n        return empty(address)\n    legoAddr: address = staticcall Registry(legoBook).getAddr(_legoId)\n    return legoAddr\n\n\n# is underscore vault\n\n\n@view\n@internal\ndef _isUnderscoreVault(_addr: address, _missionControl: address) -> bool:\n    underscore: address = staticcall MissionControl(_missionControl).underscoreRegistry()\n    if underscore == empty(address):\n        return False\n\n    vaultRegistry: address = staticcall Registry(underscore).getAddr(UNDERSCORE_VAULT_REGISTRY_ID)\n    if vaultRegistry == empty(address):\n        return False\n\n    return staticcall VaultRegistry(vaultRegistry).isEarnVault(_addr)\n\n\n# max usdc available\n\n\n@view\n@external\ndef getAvailableUsdc() -> uint256:\n    usdcYieldPosition: UsdcYieldPosition = self.usdcYieldPosition\n    return self._getAvailableUsdc(USDC, usdcYieldPosition.legoId, usdcYieldPosition.vaultToken, addys._getMissionControlAddr())\n\n\n@view\n@internal\ndef _getAvailableUsdc(_usdc: address, _legoId: uint256, _vaultToken: address, _missionControl: address) -> uint256:\n    underlyingAmount: uint256 = self._getUnderlyingYieldAmount(_legoId, _vaultToken, _missionControl)\n    return underlyingAmount + staticcall IERC20(_usdc).balanceOf(self)\n\n\n###############\n# Mint Config #\n###############\n\n\n# can mint\n\n\n@external\ndef setCanMint(_canMint: bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _canMint != self.canMint # dev: no change\n    self.canMint = _canMint\n    log CanMintUpdated(canMint=_canMint)\n\n\n# mint fee\n\n\n@external\ndef setMintFee(_fee: uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _fee <= HUNDRED_PERCENT # dev: fee too high\n    assert _fee != self.mintFee # dev: no change\n    self.mintFee = _fee\n    log MintFeeUpdated(fee=_fee)\n\n\n# max interval mint\n\n\n@external\ndef setMaxIntervalMint(_maxGreenAmount: uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _maxGreenAmount != self.maxIntervalMint # dev: no change\n    assert _maxGreenAmount != 0 and _maxGreenAmount != max_value(uint256) # dev: invalid max\n    self.maxIntervalMint = _maxGreenAmount\n    log MaxIntervalMintUpdated(maxAmount=_maxGreenAmount)\n\n\n# enforce mint allowlist\n\n\n@external\ndef setShouldEnforceMintAllowlist(_shouldEnforce: bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldEnforce != self.shouldEnforceMintAllowlist # dev: no change\n    self.shouldEnforceMintAllowlist = _shouldEnforce\n    log ShouldEnforceMintAllowlistUpdated(shouldEnforce=_shouldEnforce)\n\n\n# update mint allowlist\n\n\n@external\ndef updateMintAllowlist(_user: address, _isAllowed: bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _isAllowed != self.mintAllowlist[_user] # dev: no change\n    self.mintAllowlist[_user] = _isAllowed\n    log MintAllowlistUpdated(user=_user, isAllowed=_isAllowed)\n\n\n#################\n# Redeem Config #\n#################\n\n\n# can redeem\n\n\n@external\ndef setCanRedeem(_canRedeem: bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _canRedeem != self.canRedeem # dev: no change\n    self.canRedeem = _canRedeem\n    log CanRedeemUpdated(canRedeem=_canRedeem)\n\n\n# redeem fee\n\n\n@external\ndef setRedeemFee(_fee: uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _fee <= HUNDRED_PERCENT # dev: fee too high\n    assert _fee != self.redeemFee # dev: no change\n    self.redeemFee = _fee\n    log RedeemFeeUpdated(fee=_fee)\n\n\n# max interval redeem\n\n\n@external\ndef setMaxIntervalRedeem(_maxGreenAmount: uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _maxGreenAmount != self.maxIntervalRedeem # dev: no change\n    assert _maxGreenAmount != 0 and _maxGreenAmount != max_value(uint256) # dev: invalid max\n    self.maxIntervalRedeem = _maxGreenAmount\n    log MaxIntervalRedeemUpdated(maxAmount=_maxGreenAmount)\n\n\n# enforce redeem allowlist\n\n\n@external\ndef setShouldEnforceRedeemAllowlist(_shouldEnforce: bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldEnforce != self.shouldEnforceRedeemAllowlist # dev: no change\n    self.shouldEnforceRedeemAllowlist = _shouldEnforce\n    log ShouldEnforceRedeemAllowlistUpdated(shouldEnforce=_shouldEnforce)\n\n\n# update redeem allowlist\n\n\n@external\ndef updateRedeemAllowlist(_user: address, _isAllowed: bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _isAllowed != self.redeemAllowlist[_user] # dev: no change\n    self.redeemAllowlist[_user] = _isAllowed\n    log RedeemAllowlistUpdated(user=_user, isAllowed=_isAllowed)\n\n\n##################\n# General Config #\n##################\n\n\n# set yield position\n\n\n@external\ndef setUsdcYieldPosition(_legoId: uint256, _vaultToken: address):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    currentPosition: UsdcYieldPosition = self.usdcYieldPosition\n    if currentPosition.vaultToken != empty(address):\n        assert staticcall IERC20(currentPosition.vaultToken).balanceOf(self) == 0 # dev: vault token balance not zero\n    assert _legoId != currentPosition.legoId or _vaultToken != currentPosition.vaultToken # dev: no change\n    self.usdcYieldPosition = UsdcYieldPosition(legoId=_legoId, vaultToken=_vaultToken)\n    log UsdcYieldPositionUpdated(legoId=_legoId, vaultToken=_vaultToken)\n\n\n# num blocks per interval\n\n\n@external\ndef setNumBlocksPerInterval(_blocks: uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _blocks != self.numBlocksPerInterval # dev: no change\n    assert _blocks != 0 and _blocks != max_value(uint256) # dev: invalid interval\n    self.numBlocksPerInterval = _blocks\n    log NumBlocksPerIntervalUpdated(blocks=_blocks)\n\n\n# should auto deposit\n\n\n@external\ndef setShouldAutoDeposit(_shouldAutoDeposit: bool):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldAutoDeposit != self.shouldAutoDeposit # dev: no change\n    self.shouldAutoDeposit = _shouldAutoDeposit\n    log ShouldAutoDepositUpdated(shouldAutoDeposit=_shouldAutoDeposit)",
            "sha256sum": "4214765eb300670d33462b0f715e64b1bd3255581b63495bbed04b59fc9d5da0"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/EndaomentPSM.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "5f386961ee0a42144d5e0ac6d851a0aa6f3fabd5cf239d9d33810991005a1693"
      },
      "args": "0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b000000000000000000000000000000000000000000000000000000000000a8c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda02913000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000b33852cfd0c22647aac501a6af59bc4210a686bf",
      "file": "contracts/core/EndaomentPSM.vy"
    }
  }
}