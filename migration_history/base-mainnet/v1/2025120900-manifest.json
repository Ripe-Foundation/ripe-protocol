{
  "contracts": {
    "CreditEngine": {
      "address": "0xEdd0563D06CC52fb5F264A2366A31d9776f6dcC7",
      "abi": [
        {
          "name": "NewBorrow",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newLoan",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "daowry",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "didReceiveSavingsGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "outstandingUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "userCollateralVal",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "globalYieldRealized",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RepayDebt",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "repayValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repayType",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "refundWasSavingsGreen",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "outstandingUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "userCollateralVal",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUserDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UnderscoreVaultDiscountSet",
          "inputs": [
            {
              "name": "discount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BuybackRatioSet",
          "inputs": [
            {
              "name": "ratio",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrowForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldEnterStabPool",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "borrowForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_wantsSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_shouldEnterStabPool",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxBorrowAmount",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_greenAmount",
              "type": "uint256"
            },
            {
              "name": "_shouldRefundSavingsGreen",
              "type": "bool"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringAuctionPurchase",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayDuringAuctionPurchase",
          "inputs": [
            {
              "name": "_liqUser",
              "type": "address"
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayFromDept",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_newInterest",
              "type": "uint256"
            },
            {
              "name": "_numUserVaults",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "repayFromDept",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "_repayValue",
              "type": "uint256"
            },
            {
              "name": "_newInterest",
              "type": "uint256"
            },
            {
              "name": "_numUserVaults",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            },
            {
              "name": "_skipAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            },
            {
              "name": "_skipAsset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTermsWithNumVaults",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_numUserVaults",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTermsWithNumVaults",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_numUserVaults",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTermsWithNumVaults",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_numUserVaults",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            },
            {
              "name": "_skipAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserBorrowTermsWithNumVaults",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_numUserVaults",
              "type": "uint256"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_skipVaultId",
              "type": "uint256"
            },
            {
              "name": "_skipAsset",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getBorrowRate",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserCollateralValueAndDebtAmount",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getCollateralValue",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getUserDebtAmount",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestUserDebtAndTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestUserDebtAndTerms",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_shouldRaise",
              "type": "bool"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "collateralVal",
                  "type": "uint256"
                },
                {
                  "name": "totalMaxDebt",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lowestLtv",
                  "type": "uint256"
                },
                {
                  "name": "highestLtv",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestUserDebtWithInterest",
          "inputs": [
            {
              "name": "_userDebt",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "name": "principal",
                  "type": "uint256"
                },
                {
                  "name": "debtTerms",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "ltv",
                      "type": "uint256"
                    },
                    {
                      "name": "redemptionThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqThreshold",
                      "type": "uint256"
                    },
                    {
                      "name": "liqFee",
                      "type": "uint256"
                    },
                    {
                      "name": "borrowRate",
                      "type": "uint256"
                    },
                    {
                      "name": "daowry",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "lastTimestamp",
                  "type": "uint256"
                },
                {
                  "name": "inLiquidation",
                  "type": "bool"
                }
              ]
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasGoodDebtHealth",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasGoodDebtHealth",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canLiquidateUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canLiquidateUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRedeemUserCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canRedeemUserCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLiquidationThreshold",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRedemptionThreshold",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDynamicBorrowRate",
          "inputs": [
            {
              "name": "_baseRate",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUnderscoreVaultDiscount",
          "inputs": [
            {
              "name": "_discount",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updateDebtForUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "transferOrWithdrawViaRedemption",
          "inputs": [
            {
              "name": "_shouldTransferBalance",
              "type": "bool"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxWithdrawableForAsset",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_vaultAddr",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBuybackRatio",
          "inputs": [
            {
              "name": "_ratio",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "undyVaulDiscount",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "buybackRatio",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\ninterface RipeHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\nDELEVERAGE_ID: constant(uint256) = 18\nCREDIT_REDEEM_ID: constant(uint256) = 19\nTELLER_UTILS_ID: constant(uint256) = 20\nENDAOMENT_FUNDS_ID: constant(uint256) = 21\nENDAOMENT_PSM_ID: constant(uint256) = 22\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# deleverage\n\n\n@view\n@internal\ndef _getDeleverageId() -> uint256:\n    return DELEVERAGE_ID\n\n\n@view\n@internal\ndef _getDeleverageAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(DELEVERAGE_ID)\n\n\n# creditRedeem\n\n\n@view\n@internal\ndef _getCreditRedeemId() -> uint256:\n    return CREDIT_REDEEM_ID\n\n\n@view\n@internal\ndef _getCreditRedeemAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_REDEEM_ID)\n\n\n# teller utils\n\n\n@view\n@internal\ndef _getTellerUtilsId() -> uint256:\n    return TELLER_UTILS_ID\n\n\n@view\n@internal\ndef _getTellerUtilsAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_UTILS_ID)\n\n\n# endaoment funds\n\n\n@view\n@internal\ndef _getEndaomentFundsId() -> uint256:\n    return ENDAOMENT_FUNDS_ID\n\n\n@view\n@internal\ndef _getEndaomentFundsAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_FUNDS_ID)\n\n\n# endaoment psm\n\n\n@view\n@internal\ndef _getEndaomentPsmId() -> uint256:\n    return ENDAOMENT_PSM_ID\n\n\n@view\n@internal\ndef _getEndaomentPsmAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_PSM_ID)",
            "sha256sum": "2a46a2fbb26fed9ed5d59414833fb6c2f85a7ddf72e82ffc2d6e122296e1d4e6"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "4022e08f4321cf2a061b4e6b15820958c96ff499d4fa72fcf789ed97dc234ed8"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "9a59ebe09a5c42dc943976e0cd48bc28ca56b7209a516514f11bf9162114043f"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.3\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "6769283fa780a63e1b2e2fc56b8ef51f3ff9b5883f4f1c4af8905fd0b20ffde7"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n    stabPoolRipePerDollarClaimed: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address\n\nstruct AssetConfigEntry:\n    asset: address\n    config: AssetConfig\n\nstruct RipeGovVaultConfigEntry:\n    asset: address\n    config: RipeGovVaultConfig",
            "sha256sum": "def6208cd81de43d0d33656f9d05b5394d3a74c695fdc27ffe3c9711ccd67c2c"
          },
          "contracts/core/CreditEngine.vy": {
            "content": "#           _             _           _          _             _        _                _            _             _               _          _             _      \n#         /\\ \\           /\\ \\        /\\ \\       /\\ \\          /\\ \\     /\\ \\             /\\ \\         /\\ \\     _    /\\ \\            /\\ \\       /\\ \\     _    /\\ \\    \n#        /  \\ \\         /  \\ \\      /  \\ \\     /  \\ \\____     \\ \\ \\    \\_\\ \\           /  \\ \\       /  \\ \\   /\\_\\ /  \\ \\           \\ \\ \\     /  \\ \\   /\\_\\ /  \\ \\   \n#       / /\\ \\ \\       / /\\ \\ \\    / /\\ \\ \\   / /\\ \\_____\\    /\\ \\_\\   /\\__ \\         / /\\ \\ \\     / /\\ \\ \\_/ / // /\\ \\_\\          /\\ \\_\\   / /\\ \\ \\_/ / // /\\ \\ \\  \n#      / / /\\ \\ \\     / / /\\ \\_\\  / / /\\ \\_\\ / / /\\/___  /   / /\\/_/  / /_ \\ \\       / / /\\ \\_\\   / / /\\ \\___/ // / /\\/_/         / /\\/_/  / / /\\ \\___/ // / /\\ \\_\\ \n#     / / /  \\ \\_\\   / / /_/ / / / /_/_ \\/_// / /   / / /   / / /    / / /\\ \\ \\     / /_/_ \\/_/  / / /  \\/____// / / ______      / / /    / / /  \\/____// /_/_ \\/_/ \n#    / / /    \\/_/  / / /__\\/ / / /____/\\  / / /   / / /   / / /    / / /  \\/_/    / /____/\\    / / /    / / // / / /\\_____\\    / / /    / / /    / / // /____/\\    \n#   / / /          / / /_____/ / /\\____\\/ / / /   / / /   / / /    / / /          / /\\____\\/   / / /    / / // / /  \\/____ /   / / /    / / /    / / // /\\____\\/    \n#  / / /________  / / /\\ \\ \\  / / /______ \\ \\ \\__/ / /___/ / /__  / / /          / / /______  / / /    / / // / /_____/ / /___/ / /__  / / /    / / // / /______    \n# / / /_________\\/ / /  \\ \\ \\/ / /_______\\ \\ \\___\\/ //\\__\\/_/___\\/_/ /          / / /_______\\/ / /    / / // / /______\\/ //\\__\\/_/___\\/ / /    / / // / /_______\\   \n# \\/____________/\\/_/    \\_\\/\\/__________/  \\/_____/ \\/_________/\\_\\/           \\/__________/\\/_/     \\/_/ \\/___________/ \\/_________/\\/_/     \\/_/ \\/__________/   \n#\n#     \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n#     \u2551  ** Credit Engine **                                         \u2551\n#     \u2551  Handles all credit-related actions (borrow, repay, redeem)  \u2551\n#     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n#\n#     Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n#     Ripe Foundation (C) 2025\n\n# @version 0.4.3\n# pragma optimize codesize\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import Vault\nimport interfaces.ConfigStructs as cs\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\ninterface Ledger:\n    def setUserDebt(_user: address, _userDebt: UserDebt, _newInterest: uint256, _interval: IntervalBorrow): nonpayable\n    def getBorrowDataBundle(_user: address) -> BorrowDataBundle: view\n    def addVaultToUser(_user: address, _vaultId: uint256): nonpayable\n    def userVaults(_user: address, _index: uint256) -> uint256: view\n    def getRepayDataBundle(_user: address) -> RepayDataBundle: view\n    def numUserVaults(_user: address) -> uint256: view\n    def flushUnrealizedYield() -> uint256: nonpayable\n\ninterface MissionControl:\n    def getBorrowConfig(_user: address, _caller: address) -> BorrowConfig: view\n    def getDynamicBorrowRateConfig() -> DynamicBorrowRateConfig: view\n    def getRepayConfig(_user: address) -> RepayConfig: view\n    def getDebtTerms(_asset: address) -> cs.DebtTerms: view\n    def underscoreRegistry() -> address: view\n\ninterface Teller:\n    def depositFromTrusted(_user: address, _vaultId: uint256, _asset: address, _amount: uint256, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def isUnderscoreWalletOwner(_user: address, _caller: address, _mc: address = empty(address)) -> bool: view\n\ninterface LootBox:\n    def updateDepositPoints(_user: address, _vaultId: uint256, _vaultAddr: address, _asset: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n    def updateBorrowPoints(_user: address, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface GreenToken:\n    def mint(_to: address, _amount: uint256): nonpayable\n    def burn(_amount: uint256) -> bool: nonpayable\n\ninterface PriceDesk:\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool) -> uint256: view\n\ninterface CurvePrices:\n    def getCurrentGreenPoolStatus() -> CurrentGreenPoolStatus: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface AddressRegistry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface RipeHq:\n    def governance() -> address: view\n\nflag RepayType:\n    STANDARD\n    LIQUIDATION\n    AUCTION\n    REDEMPTION\n    DELEVERAGE\n\nstruct BorrowDataBundle:\n    userDebt: UserDebt\n    userBorrowInterval: IntervalBorrow\n    isUserBorrower: bool\n    numUserVaults: uint256\n    totalDebt: uint256\n    numBorrowers: uint256\n\nstruct UserBorrowTerms:\n    collateralVal: uint256\n    totalMaxDebt: uint256\n    debtTerms: cs.DebtTerms\n    lowestLtv: uint256\n    highestLtv: uint256\n\nstruct UserDebt:\n    amount: uint256\n    principal: uint256\n    debtTerms: cs.DebtTerms\n    lastTimestamp: uint256\n    inLiquidation: bool\n\nstruct IntervalBorrow:\n    start: uint256\n    amount: uint256\n\nstruct RepayDataBundle:\n    userDebt: UserDebt\n    numUserVaults: uint256\n\nstruct BorrowConfig:\n    canBorrow: bool\n    canBorrowForUser: bool\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    isDaowryEnabled: bool\n\nstruct RepayConfig:\n    canRepay: bool\n    canAnyoneRepayDebt: bool\n\nstruct CurrentGreenPoolStatus:\n    weightedRatio: uint256\n    dangerTrigger: uint256\n    numBlocksInDanger: uint256\n\nstruct DynamicBorrowRateConfig:\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n\nevent NewBorrow:\n    user: indexed(address)\n    newLoan: uint256\n    daowry: uint256\n    didReceiveSavingsGreen: bool\n    outstandingUserDebt: uint256\n    userCollateralVal: uint256\n    maxUserDebt: uint256\n    globalYieldRealized: uint256\n\nevent RepayDebt:\n    user: indexed(address)\n    repayValue: uint256\n    repayType: RepayType\n    refundAmount: uint256\n    refundWasSavingsGreen: bool\n    outstandingUserDebt: uint256\n    userCollateralVal: uint256\n    maxUserDebt: uint256\n    hasGoodDebtHealth: bool\n\nevent UnderscoreVaultDiscountSet:\n    discount: uint256\n\nevent BuybackRatioSet:\n    ratio: uint256\n\n# borrow rate discount\nundyVaulDiscount: public(uint256)\n\n# buyback ratio for revenue split\nbuybackRatio: public(uint256)\n\nONE_YEAR: constant(uint256) = 60 * 60 * 24 * 365\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nDANGER_BLOCKS_DENOMINATOR: constant(uint256) = 100_0000 # 100.0000%\nONE_PERCENT: constant(uint256) = 1_00 # 1.00%\nSTABILITY_POOL_ID: constant(uint256) = 1\nCURVE_PRICES_ID: constant(uint256) = 2\nUNDERSCORE_VAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, True, False) # can mint green only\n\n    # default discount for underscore vaults\n    self.undyVaulDiscount = 50_00 # 50.00%\n\n    # default buyback ratio (disabled)\n    self.buybackRatio = 0\n\n\n##########\n# Borrow #\n##########\n\n\n@external\ndef borrowForUser(\n    _user: address,\n    _greenAmount: uint256,\n    _wantsSavingsGreen: bool,\n    _shouldEnterStabPool: bool,\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    assert _user != empty(address) # dev: cannot borrow for 0x0\n\n    # get borrow data\n    d: BorrowDataBundle = staticcall Ledger(a.ledger).getBorrowDataBundle(_user)\n\n    # get latest user debt\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # check if underscore vault (used for daowry, borrow rate discount)\n    isUndyVault: bool = self._isUnderscoreVault(_user, a.missionControl)\n\n    # get borrow data (debt terms for user)\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, True, 0, empty(address), isUndyVault, a)\n\n    # get config\n    config: BorrowConfig = staticcall MissionControl(a.missionControl).getBorrowConfig(_user, _caller)\n\n    # check perms\n    if _user != _caller and not config.canBorrowForUser:\n        assert staticcall Teller(a.teller).isUnderscoreWalletOwner(_user, _caller, a.missionControl) # dev: not allowed to borrow for user\n\n    # validation\n    newBorrowAmount: uint256 = 0\n    isFreshInterval: bool = False\n    newBorrowAmount, isFreshInterval = self._validateOnBorrow(_greenAmount, userDebt, bt.totalMaxDebt, d, config)\n    assert newBorrowAmount != 0 # dev: cannot borrow\n\n    # update borrow interval\n    userBorrowInterval: IntervalBorrow = d.userBorrowInterval\n    if isFreshInterval:\n        userBorrowInterval.start = block.number\n        userBorrowInterval.amount = newBorrowAmount\n    else:\n        userBorrowInterval.amount += newBorrowAmount\n\n    # update user debt\n    userDebt.amount += newBorrowAmount\n    userDebt.principal += newBorrowAmount\n    userDebt.debtTerms = bt.debtTerms\n\n    # check debt health (use bt.totalMaxDebt directly to avoid rounding discrepancy)\n    assert userDebt.amount <= bt.totalMaxDebt # dev: bad debt health\n    userDebt.inLiquidation = False\n\n    # save debt\n    extcall Ledger(a.ledger).setUserDebt(_user, userDebt, newInterest, userBorrowInterval)\n\n    # update borrow points\n    extcall LootBox(a.lootbox).updateBorrowPoints(_user, a)\n\n    # mint green - piggy back on borrow to flush unrealized yield\n    unrealizedYield: uint256 = extcall Ledger(a.ledger).flushUnrealizedYield()\n    totalGreenMint: uint256 = newBorrowAmount + unrealizedYield\n    extcall GreenToken(a.greenToken).mint(self, totalGreenMint)\n\n    # origination fee\n    daowry: uint256 = 0\n    if config.isDaowryEnabled and not isUndyVault:\n        daowry = newBorrowAmount * bt.debtTerms.daowry // HUNDRED_PERCENT\n\n    # dao revenue\n    forDao: uint256 = daowry + unrealizedYield\n    if forDao != 0:\n\n        # split revenue between governance (for buyback) and savings green\n        forBuyback: uint256 = 0\n        buybackRatio: uint256 = self.buybackRatio\n        if buybackRatio != 0:\n            forBuyback = forDao * buybackRatio // HUNDRED_PERCENT\n\n        # transfer to governance for buyback\n        if forBuyback != 0:\n            govWallet: address = staticcall RipeHq(a.hq).governance()\n            assert extcall IERC20(a.greenToken).transfer(govWallet, forBuyback, default_return_value=True) # dev: could not transfer to gov\n\n        # transfer to savings green\n        forSavingsGreen: uint256 = forDao - forBuyback\n        if forSavingsGreen != 0:\n            assert extcall IERC20(a.greenToken).transfer(a.savingsGreen, forSavingsGreen, default_return_value=True) # dev: could not transfer\n\n    # borrower gets their green now -- do this AFTER sending green to stakers\n    forBorrower: uint256 = newBorrowAmount - daowry\n    self._handleGreenForUser(_user, forBorrower, _wantsSavingsGreen, _shouldEnterStabPool, a)\n\n    log NewBorrow(user=_user, newLoan=forBorrower, daowry=daowry, didReceiveSavingsGreen=_wantsSavingsGreen, outstandingUserDebt=userDebt.amount, userCollateralVal=bt.collateralVal, maxUserDebt=bt.totalMaxDebt, globalYieldRealized=unrealizedYield)\n    return forBorrower\n\n\n# borrow validation\n\n\n@view\n@internal\ndef _validateOnBorrow(\n    _greenAmount: uint256,\n    _userDebt: UserDebt,\n    _maxUserDebt: uint256,\n    _d: BorrowDataBundle,\n    _config: BorrowConfig,\n) -> (uint256, bool):\n    assert not _userDebt.inLiquidation # dev: cannot borrow in liquidation\n    assert _greenAmount != 0 # dev: cannot borrow 0 amount\n\n    # get borrow config\n    assert _config.canBorrow # dev: borrow not enabled\n\n    # check num allowed borrowers\n    if not _d.isUserBorrower:\n        assert _config.numAllowedBorrowers > _d.numBorrowers # dev: max num borrowers reached\n\n    # main var\n    newBorrowAmount: uint256 = _greenAmount\n\n    # avail debt based on collateral value / ltv\n    availDebtPerLtv: uint256 = 0\n    if _maxUserDebt > _userDebt.amount:\n        availDebtPerLtv = _maxUserDebt - _userDebt.amount\n    assert availDebtPerLtv != 0 # dev: no debt available\n    newBorrowAmount = min(newBorrowAmount, availDebtPerLtv)\n\n    # check borrow interval\n    availInInterval: uint256 = 0\n    isFreshInterval: bool = False\n    availInInterval, isFreshInterval = self._getAvailDebtInInterval(_d.userBorrowInterval, _config.maxBorrowPerInterval, _config.numBlocksPerInterval)\n    assert availInInterval != 0 # dev: interval borrow limit reached\n    newBorrowAmount = min(newBorrowAmount, availInInterval)\n\n    # check per user debt limit\n    availPerUser: uint256 = 0\n    if _config.perUserDebtLimit > _userDebt.amount:\n        availPerUser = _config.perUserDebtLimit - _userDebt.amount\n    assert availPerUser != 0 # dev: per user debt limit reached\n    newBorrowAmount = min(newBorrowAmount, availPerUser)\n\n    # check global debt limit\n    availGlobal: uint256 = 0\n    if _config.globalDebtLimit > _d.totalDebt:\n        availGlobal = _config.globalDebtLimit - _d.totalDebt\n    assert availGlobal != 0 # dev: global debt limit reached\n    newBorrowAmount = min(newBorrowAmount, availGlobal)\n\n    # must reach minimum debt threshold\n    assert _userDebt.amount + newBorrowAmount >= _config.minDebtAmount # dev: debt too small\n\n    return newBorrowAmount, isFreshInterval\n\n\n# max available borrow (mostly for front-ends, no exceptions raised)\n\n\n@view\n@external\ndef getMaxBorrowAmount(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt\n    d: BorrowDataBundle = staticcall Ledger(a.ledger).getBorrowDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    na1: uint256 = 0\n    userDebt, na1 = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # cannot borrow in liquidation\n    if userDebt.inLiquidation:\n        return 0\n\n    # get borrow config\n    config: BorrowConfig = staticcall MissionControl(a.missionControl).getBorrowConfig(_user, _user)\n    if not config.canBorrow:\n        return 0\n\n    # check num allowed borrowers\n    if not d.isUserBorrower and config.numAllowedBorrowers <= d.numBorrowers:\n        return 0\n\n    # main var\n    newBorrowAmount: uint256 = max_value(uint256)\n    isUndyVault: bool = self._isUnderscoreVault(_user, a.missionControl)\n\n    # avail debt based on collateral value / ltv\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, False, 0, empty(address), isUndyVault, a)\n    availDebtPerLtv: uint256 = 0\n    if bt.totalMaxDebt > userDebt.amount:\n        availDebtPerLtv = bt.totalMaxDebt - userDebt.amount\n    newBorrowAmount = min(newBorrowAmount, availDebtPerLtv)\n\n    # check borrow interval\n    availInInterval: uint256 = 0\n    na2: bool = False\n    availInInterval, na2 = self._getAvailDebtInInterval(d.userBorrowInterval, config.maxBorrowPerInterval, config.numBlocksPerInterval)\n    newBorrowAmount = min(newBorrowAmount, availInInterval)\n\n    # check per user debt limit\n    availPerUser: uint256 = 0\n    if config.perUserDebtLimit > userDebt.amount:\n        availPerUser = config.perUserDebtLimit - userDebt.amount\n    newBorrowAmount = min(newBorrowAmount, availPerUser)\n\n    # check global debt limit\n    availGlobal: uint256 = 0\n    if config.globalDebtLimit > d.totalDebt:\n        availGlobal = config.globalDebtLimit - d.totalDebt\n    newBorrowAmount = min(newBorrowAmount, availGlobal)\n\n    # must reach minimum debt threshold\n    if userDebt.amount + newBorrowAmount < config.minDebtAmount:\n        return 0\n\n    return newBorrowAmount\n\n\n# borrow interval\n\n\n@view \n@internal \ndef _getAvailDebtInInterval(\n    _userInterval: IntervalBorrow,\n    _maxBorrowPerInterval: uint256,\n    _numBlocksPerInterval: uint256,\n) -> (uint256, bool):\n    availToBorrow: uint256 = _maxBorrowPerInterval\n    isFreshInterval: bool = True\n    if _userInterval.start != 0 and _userInterval.start + _numBlocksPerInterval > block.number:\n        availToBorrow = _maxBorrowPerInterval - min(_userInterval.amount, _maxBorrowPerInterval)\n        isFreshInterval = False\n    return availToBorrow, isFreshInterval\n\n\n#########\n# Repay #\n#########\n\n\n@external\ndef repayForUser(\n    _user: address,\n    _greenAmount: uint256,\n    _shouldRefundSavingsGreen: bool,\n    _caller: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # validation\n    repayAmount: uint256 = 0\n    refundAmount: uint256 = 0\n    repayAmount, refundAmount = self._validateOnRepay(_user, _caller, _greenAmount, userDebt.amount, a.missionControl, a.greenToken, a.teller)\n    assert repayAmount != 0 # dev: cannot repay with 0 green\n\n    return self._repayDebt(_user, userDebt, d.numUserVaults, repayAmount, refundAmount, newInterest, True, _shouldRefundSavingsGreen, RepayType.STANDARD, a)\n\n\n# repay during auction purchase\n\n\n@external\ndef repayDuringAuctionPurchase(_liqUser: address, _repayValue: uint256, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    assert msg.sender == addys._getAuctionHouseAddr() # dev: only auction house allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_liqUser)\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # finalize amounts\n    repayAmount: uint256 = 0\n    refundAmount: uint256 = 0\n    repayAmount, refundAmount = self._getRepayAmountAndRefundAmount(userDebt.amount, _repayValue, a.greenToken)\n    assert repayAmount != 0 # dev: cannot repay with 0 green\n\n    return self._repayDebt(_liqUser, userDebt, d.numUserVaults, repayAmount, refundAmount, newInterest, True, True, RepayType.AUCTION, a)\n\n\n# generic repay (liquidation, deleverage, redemption)\n\n\n@external\ndef repayFromDept(\n    _user: address,\n    _userDebt: UserDebt,\n    _repayValue: uint256,\n    _newInterest: uint256,\n    _numUserVaults: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> bool:\n    deleverage: address = addys._getDeleverageAddr()\n    auctionHouse: address = addys._getAuctionHouseAddr()\n    creditRedeem: address = addys._getCreditRedeemAddr()\n    assert msg.sender in [deleverage, auctionHouse, creditRedeem] # dev: not allowed\n    assert not deptBasics.isPaused # dev: contract paused\n\n    repayType: RepayType = empty(RepayType)\n    if msg.sender == deleverage:\n        repayType = RepayType.DELEVERAGE\n    elif msg.sender == auctionHouse:\n        repayType = RepayType.LIQUIDATION\n    elif msg.sender == creditRedeem:\n        repayType = RepayType.REDEMPTION\n\n    a: addys.Addys = addys._getAddys(_a)\n    numUserVaults: uint256 = _numUserVaults\n    if numUserVaults == 0:\n        numUserVaults = staticcall Ledger(a.ledger).numUserVaults(_user)\n    return self._repayDebt(_user, _userDebt, numUserVaults, _repayValue, 0, _newInterest, False, False, repayType, a)\n\n\n# shared repay functionality\n\n\n@internal\ndef _repayDebt(\n    _user: address,\n    _userDebt: UserDebt,\n    _numUserVaults: uint256,\n    _repayValue: uint256,\n    _refundAmount: uint256,\n    _newInterest: uint256,\n    _shouldBurnGreen: bool,\n    _wantsSavingsGreen: bool,\n    _repayType: RepayType,\n    _a: addys.Addys,\n) -> bool:\n    userDebt: UserDebt = self._reduceDebtAmount(_userDebt, _repayValue)\n    isUndyVault: bool = self._isUnderscoreVault(_user, _a.missionControl)\n\n    # get latest debt terms\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, _numUserVaults, True, 0, empty(address), isUndyVault, _a)\n    userDebt.debtTerms = bt.debtTerms\n\n    # check debt health (use bt.totalMaxDebt directly to avoid rounding discrepancy)\n    hasGoodDebtHealth: bool = userDebt.amount <= bt.totalMaxDebt\n    if hasGoodDebtHealth:\n        userDebt.inLiquidation = False\n\n    # update user debt, borrow points\n    extcall Ledger(_a.ledger).setUserDebt(_user, userDebt, _newInterest, empty(IntervalBorrow))\n    extcall LootBox(_a.lootbox).updateBorrowPoints(_user, _a)\n\n    # burn green repayment\n    if _shouldBurnGreen:\n        assert extcall GreenToken(_a.greenToken).burn(_repayValue) # dev: could not burn green\n\n    # handle refund\n    if _refundAmount != 0:\n        self._handleGreenForUser(_user, _refundAmount, _wantsSavingsGreen, False, _a)\n\n    log RepayDebt(user=_user, repayValue=_repayValue, repayType=_repayType, refundAmount=_refundAmount, refundWasSavingsGreen=_wantsSavingsGreen, outstandingUserDebt=userDebt.amount, userCollateralVal=bt.collateralVal, maxUserDebt=bt.totalMaxDebt, hasGoodDebtHealth=hasGoodDebtHealth)\n    return hasGoodDebtHealth\n\n\n# repay validation\n\n\n@view\n@internal\ndef _validateOnRepay(\n    _user: address,\n    _caller: address,\n    _greenAmount: uint256,\n    _userDebtAmount: uint256,\n    _missionControl: address,\n    _greenToken: address,\n    _teller: address,\n) -> (uint256, uint256):\n    assert _userDebtAmount != 0 # dev: no debt outstanding\n\n    # repay config\n    repayConfig: RepayConfig = staticcall MissionControl(_missionControl).getRepayConfig(_user)\n    assert repayConfig.canRepay # dev: repay paused\n\n    # others repaying for user\n    if _user != _caller and not repayConfig.canAnyoneRepayDebt:\n        assert staticcall Teller(_teller).isUnderscoreWalletOwner(_user, _caller, _missionControl) # dev: not allowed to repay for user\n\n    return self._getRepayAmountAndRefundAmount(_userDebtAmount, _greenAmount, _greenToken)\n\n\n# repay amount and refund amount\n\n\n@view\n@internal\ndef _getRepayAmountAndRefundAmount(_userDebtAmount: uint256, _greenAmount: uint256, _greenToken: address) -> (uint256, uint256):\n    availAmount: uint256 = min(_greenAmount, staticcall IERC20(_greenToken).balanceOf(self))\n\n    repayAmount: uint256 = min(availAmount, _userDebtAmount)\n    refundAmount: uint256 = 0\n    if availAmount > _userDebtAmount:\n        refundAmount = availAmount - _userDebtAmount\n\n    return repayAmount, refundAmount\n\n\n# reduce debt amount\n\n\n@view\n@internal\ndef _reduceDebtAmount(_userDebt: UserDebt, _repayAmount: uint256) -> UserDebt:\n    userDebt: UserDebt = _userDebt\n    nonPrincipalDebt: uint256 = userDebt.amount - userDebt.principal\n\n    userDebt.amount -= _repayAmount\n    if _repayAmount > nonPrincipalDebt:\n        principalToReduce: uint256 = _repayAmount - nonPrincipalDebt\n        userDebt.principal -= min(principalToReduce, userDebt.principal)\n\n    return userDebt\n\n\n################\n# Borrow Terms #\n################\n\n\n@view\n@external\ndef getUserBorrowTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _skipVaultId: uint256 = 0,\n    _skipAsset: address = empty(address),\n    _a: addys.Addys = empty(addys.Addys),\n) -> UserBorrowTerms:\n    a: addys.Addys = addys._getAddys(_a)\n    isUndyVault: bool = self._isUnderscoreVault(_user, a.missionControl)\n    return self._getUserBorrowTerms(_user, staticcall Ledger(a.ledger).numUserVaults(_user), _shouldRaise, _skipVaultId, _skipAsset, isUndyVault, a)\n\n\n@view\n@external\ndef getUserBorrowTermsWithNumVaults(\n    _user: address,\n    _numUserVaults: uint256,\n    _shouldRaise: bool,\n    _skipVaultId: uint256 = 0,\n    _skipAsset: address = empty(address),\n    _a: addys.Addys = empty(addys.Addys),\n) -> UserBorrowTerms:\n    a: addys.Addys = addys._getAddys(_a)\n    isUndyVault: bool = self._isUnderscoreVault(_user, a.missionControl)\n    return self._getUserBorrowTerms(_user, _numUserVaults, _shouldRaise, _skipVaultId, _skipAsset, isUndyVault, a)\n\n\n@view\n@external\ndef getBorrowRate(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    isUndyVault: bool = self._isUnderscoreVault(_user, a.missionControl)\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, staticcall Ledger(a.ledger).numUserVaults(_user), False, 0, empty(address), isUndyVault, a)\n    return bt.debtTerms.borrowRate\n\n\n@view\n@internal\ndef _getUserBorrowTerms(\n    _user: address,\n    _numUserVaults: uint256,\n    _shouldRaise: bool,\n    _skipVaultId: uint256,\n    _skipAsset: address,\n    _isUndyVault: bool,\n    _a: addys.Addys,\n) -> UserBorrowTerms:\n\n    # nothing to do here\n    if _numUserVaults == 0:\n        return empty(UserBorrowTerms)\n\n    hasSkip: bool = (_skipVaultId != 0 and _skipAsset != empty(address))\n\n    # sum vars\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    bt.lowestLtv = max_value(uint256)\n    bt.highestLtv = 0\n    ltvSum: uint256 = 0\n    redemptionThresholdSum: uint256 = 0\n    liqThresholdSum: uint256 = 0\n    liqFeeSum: uint256 = 0\n    borrowRateSum: uint256 = 0\n    daowrySum: uint256 = 0\n    totalSum: uint256 = 0\n\n    # iterate thru each user vault\n    for i: uint256 in range(1, _numUserVaults, bound=max_value(uint256)):\n        vaultId: uint256 = staticcall Ledger(_a.ledger).userVaults(_user, i)\n        vaultAddr: address = staticcall AddressRegistry(_a.vaultBook).getAddr(vaultId)\n        if vaultAddr == empty(address):\n            continue\n\n        # iterate thru each user asset\n        numUserAssets: uint256 = staticcall Vault(vaultAddr).numUserAssets(_user)\n        for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n\n            # get user asset and amount\n            asset: address = empty(address)\n            amount: uint256 = 0\n            asset, amount = staticcall Vault(vaultAddr).getUserAssetAndAmountAtIndex(_user, y)\n            if asset == empty(address) or amount == 0:\n                continue\n\n            # debt terms\n            debtTerms: cs.DebtTerms = staticcall MissionControl(_a.missionControl).getDebtTerms(asset)\n\n            # skip if no ltv (staked green, staked ripe, etc)\n            if debtTerms.ltv == 0:\n                continue\n\n            # collateral value, max debt\n            collateralVal: uint256 = staticcall PriceDesk(_a.priceDesk).getUsdValue(asset, amount, _shouldRaise)\n            maxDebt: uint256 = collateralVal * debtTerms.ltv // HUNDRED_PERCENT\n\n            # need to return some debt terms, even if not getting any price\n            debtTermsWeight: uint256 = maxDebt\n            if debtTermsWeight == 0:\n                debtTermsWeight = 1\n\n            # debt terms sums -- weight is based on max debt (ltv)\n            ltvSum += debtTermsWeight * debtTerms.ltv\n            redemptionThresholdSum += debtTermsWeight * debtTerms.redemptionThreshold\n            liqThresholdSum += debtTermsWeight * debtTerms.liqThreshold\n            liqFeeSum += debtTermsWeight * debtTerms.liqFee\n            borrowRateSum += debtTermsWeight * debtTerms.borrowRate\n            daowrySum += debtTermsWeight * debtTerms.daowry\n            totalSum += debtTermsWeight\n\n            # lowest ltv\n            if debtTerms.ltv != 0 and debtTerms.ltv < bt.lowestLtv:\n                bt.lowestLtv = debtTerms.ltv\n\n            # highest ltv\n            if debtTerms.ltv > bt.highestLtv:\n                bt.highestLtv = debtTerms.ltv\n\n            # totals\n            if not (hasSkip and asset == _skipAsset and vaultId == _skipVaultId):\n                bt.collateralVal += collateralVal\n                bt.totalMaxDebt += maxDebt\n\n    # edge case -- but safer to use\n    if bt.lowestLtv == max_value(uint256):\n        bt.lowestLtv = 0\n\n    # finalize debt terms (weighted)\n    if totalSum != 0:\n        bt.debtTerms.ltv = ltvSum // totalSum\n        bt.debtTerms.redemptionThreshold = redemptionThresholdSum // totalSum\n        bt.debtTerms.liqThreshold = liqThresholdSum // totalSum\n        bt.debtTerms.liqFee = liqFeeSum // totalSum\n        bt.debtTerms.borrowRate = borrowRateSum // totalSum\n        bt.debtTerms.daowry = daowrySum // totalSum\n\n    # overwrite ltv if collateral value is available\n    if bt.collateralVal != 0:\n        bt.debtTerms.ltv = bt.totalMaxDebt * HUNDRED_PERCENT // bt.collateralVal\n\n    # ensure liq threshold and liq fee can work together\n    if bt.debtTerms.liqThreshold != 0:\n        liqSum: uint256 = bt.debtTerms.liqThreshold + (bt.debtTerms.liqThreshold * bt.debtTerms.liqFee // HUNDRED_PERCENT)\n        if liqSum > HUNDRED_PERCENT:\n            adjustedLiqFee: uint256 = (HUNDRED_PERCENT - bt.debtTerms.liqThreshold) * HUNDRED_PERCENT // bt.debtTerms.liqThreshold\n            bt.debtTerms.liqFee = adjustedLiqFee\n    else:\n        bt.debtTerms.liqFee = 0\n\n    # apply discount for underscore vaults\n    if _isUndyVault:\n        undyVaulDiscount: uint256 = self.undyVaulDiscount\n        if undyVaulDiscount != 0:\n            bt.debtTerms.borrowRate = bt.debtTerms.borrowRate * (HUNDRED_PERCENT - undyVaulDiscount) // HUNDRED_PERCENT\n\n    # dynamic borrow rate (for normal users)\n    else:\n        bt.debtTerms.borrowRate = self._getDynamicBorrowRate(bt.debtTerms.borrowRate, _a.missionControl, _a.priceDesk)\n\n    return bt\n\n\n# collateral value\n\n\n@view\n@external\ndef getUserCollateralValueAndDebtAmount(_user: address) -> (uint256, uint256):\n    a: addys.Addys = addys._getAddys()\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    na: uint256 = 0\n    userDebt, na = self._getLatestUserDebtWithInterest(d.userDebt)\n    isUndyVault: bool = self._isUnderscoreVault(_user, a.missionControl)\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, False, 0, empty(address), isUndyVault, a)\n    return bt.collateralVal, userDebt.amount\n\n\n@view\n@external\ndef getCollateralValue(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n    isUndyVault: bool = self._isUnderscoreVault(_user, a.missionControl)\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, staticcall Ledger(a.ledger).numUserVaults(_user), True, 0, empty(address), isUndyVault, a)\n    return bt.collateralVal\n\n\n####################\n# Latest User Debt #\n####################\n\n\n@view\n@external\ndef getUserDebtAmount(_user: address) -> uint256:\n    d: RepayDataBundle = staticcall Ledger(addys._getLedgerAddr()).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    na: uint256 = 0\n    userDebt, na = self._getLatestUserDebtWithInterest(d.userDebt)\n    return userDebt.amount\n\n\n@view\n@external\ndef getLatestUserDebtAndTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (UserDebt, UserBorrowTerms, uint256):\n    return self._getLatestUserDebtAndTerms(_user, _shouldRaise, addys._getAddys(_a))\n\n\n@view\n@internal\ndef _getLatestUserDebtAndTerms(\n    _user: address,\n    _shouldRaise: bool,\n    _a: addys.Addys,\n) -> (UserDebt, UserBorrowTerms, uint256):\n\n    # get data (repay data has the only stuff we need)\n    d: RepayDataBundle = staticcall Ledger(_a.ledger).getRepayDataBundle(_user)\n\n    # accrue interest\n    userDebt: UserDebt = empty(UserDebt)\n    newInterest: uint256 = 0\n    userDebt, newInterest = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # debt terms for user\n    isUndyVault: bool = self._isUnderscoreVault(_user, _a.missionControl)\n    bt: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, _shouldRaise, 0, empty(address), isUndyVault, _a)\n\n    return userDebt, bt, newInterest\n\n\n# accrue interest\n\n\n@view\n@external\ndef getLatestUserDebtWithInterest(_userDebt: UserDebt) -> (UserDebt, uint256):\n    return self._getLatestUserDebtWithInterest(_userDebt)\n\n\n@view\n@internal\ndef _getLatestUserDebtWithInterest(_userDebt: UserDebt) -> (UserDebt, uint256):\n    userDebt: UserDebt = _userDebt\n\n    # nothing to do here\n    if userDebt.amount == 0 or userDebt.debtTerms.borrowRate == 0 or block.timestamp <= userDebt.lastTimestamp:\n        userDebt.lastTimestamp = block.timestamp\n        return userDebt, 0\n\n    # accrue latest interest\n    timeElapsed: uint256 = block.timestamp - userDebt.lastTimestamp\n\n    # multiply all numerators first, then divide by combined denominators\n    newInterest: uint256 = (userDebt.amount * userDebt.debtTerms.borrowRate * timeElapsed) // (HUNDRED_PERCENT * ONE_YEAR)\n    userDebt.amount += newInterest\n\n    userDebt.lastTimestamp = block.timestamp\n    return userDebt, newInterest\n\n\n###############\n# Debt Health #\n###############\n\n\n@view\n@external\ndef hasGoodDebtHealth(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 1, _a)\n\n\n@view\n@external\ndef canLiquidateUser(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 2, _a)\n\n\n@view\n@external\ndef canRedeemUserCollateral(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    return self._checkDebtHealth(_user, 3, _a)\n\n\n@view\n@internal\ndef _checkDebtHealth(_user: address, _debtType: uint256, _a: addys.Addys) -> bool:\n    a: addys.Addys = addys._getAddys(_a)\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = self._getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0:\n        return _debtType == 1 # nothing to check\n\n    # in liquidation, can't do anything\n    if userDebt.inLiquidation:\n        return False\n\n    # check debt health (use bt.totalMaxDebt directly to avoid rounding discrepancy)\n    if _debtType == 1:\n        return userDebt.amount <= bt.totalMaxDebt\n    elif _debtType == 2:\n        return self._canLiquidateUser(userDebt.amount, bt.collateralVal, bt.debtTerms.liqThreshold)\n    elif _debtType == 3:\n        return self._canRedeemUserCollateral(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold)\n    else:\n        return False\n\n\n@view\n@internal\ndef _hasGoodDebtHealth(_userDebtAmount: uint256, _collateralVal: uint256, _ltv: uint256) -> bool:\n    maxUserDebt: uint256 = _collateralVal * _ltv // HUNDRED_PERCENT\n    return _userDebtAmount <= maxUserDebt\n\n\n@view\n@internal\ndef _canLiquidateUser(_userDebtAmount: uint256, _collateralVal: uint256, _liqThreshold: uint256) -> bool:\n    if _liqThreshold == 0:\n        return False\n\n    # check if collateral value is below (or equal) to liquidation threshold\n    collateralLiqThreshold: uint256 = _userDebtAmount * HUNDRED_PERCENT // _liqThreshold\n    return _collateralVal <= collateralLiqThreshold\n\n\n@view\n@internal\ndef _canRedeemUserCollateral(_userDebtAmount: uint256, _collateralVal: uint256, _redemptionThreshold: uint256) -> bool:\n    if _redemptionThreshold == 0:\n        return False\n\n    # check if collateral value is below (or equal) to redemption threshold\n    redemptionThreshold: uint256 = _userDebtAmount * HUNDRED_PERCENT // _redemptionThreshold\n    return _collateralVal <= redemptionThreshold\n\n\n# thresholds\n\n\n@view\n@external\ndef getLiquidationThreshold(_user: address) -> uint256:\n    return self._getThreshold(_user, 2)\n\n\n@view\n@external\ndef getRedemptionThreshold(_user: address) -> uint256:\n    return self._getThreshold(_user, 3)\n\n\n@view\n@internal\ndef _getThreshold(_user: address, _debtType: uint256) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = self._getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0:\n        return 0\n\n    if _debtType == 2:\n        if bt.debtTerms.liqThreshold == 0:\n            return 0\n        return userDebt.amount * HUNDRED_PERCENT // bt.debtTerms.liqThreshold\n    elif _debtType == 3:\n        if bt.debtTerms.redemptionThreshold == 0:\n            return 0\n        return userDebt.amount * HUNDRED_PERCENT // bt.debtTerms.redemptionThreshold\n    else:\n        return 0\n\n\n################\n# Dynamic Rate #\n################\n\n\n@view\n@external\ndef getDynamicBorrowRate(_baseRate: uint256) -> uint256:\n    return self._getDynamicBorrowRate(_baseRate, addys._getMissionControlAddr(), addys._getPriceDeskAddr())\n\n\n@view\n@internal\ndef _getDynamicBorrowRate(_baseRate: uint256, _missionControl: address, _priceDesk: address) -> uint256:\n    curvePrices: address = staticcall AddressRegistry(_priceDesk).getAddr(CURVE_PRICES_ID)\n    if curvePrices == empty(address):\n        return _baseRate\n\n    status: CurrentGreenPoolStatus = staticcall CurvePrices(curvePrices).getCurrentGreenPoolStatus()\n    if status.weightedRatio == 0 or status.weightedRatio < status.dangerTrigger:\n        return _baseRate\n\n    config: DynamicBorrowRateConfig = staticcall MissionControl(_missionControl).getDynamicBorrowRateConfig()\n\n    # dynamic rate boost (depending on pool health)\n    rateBoost: uint256 = 0\n    if config.maxDynamicRateBoost != 0:\n        dynamicRatio: uint256 = (status.weightedRatio - status.dangerTrigger) * HUNDRED_PERCENT // (HUNDRED_PERCENT - status.dangerTrigger)\n        rateMultiplier: uint256 = self._calcDynamicRateBoost(dynamicRatio, config.minDynamicRateBoost, config.maxDynamicRateBoost)\n        rateBoost = _baseRate * rateMultiplier // HUNDRED_PERCENT\n\n    # danger boost (longer pool health imbalanced, higher rate keeps getting)\n    dangerBoost: uint256 = 0\n    if status.numBlocksInDanger != 0 and config.increasePerDangerBlock != 0:\n        dangerBoost = (config.increasePerDangerBlock * status.numBlocksInDanger) * HUNDRED_PERCENT // DANGER_BLOCKS_DENOMINATOR\n\n    return min(_baseRate + rateBoost + dangerBoost, config.maxBorrowRate)\n\n\n@pure\n@internal\ndef _calcDynamicRateBoost(_ratio: uint256, _minBoost: uint256, _maxBoost: uint256) -> uint256:\n    if _ratio == 0 or _minBoost == _maxBoost:\n        return _minBoost\n    valRange: uint256 = _maxBoost - _minBoost\n    adjustment: uint256 =  _ratio * valRange // HUNDRED_PERCENT\n    return _minBoost + adjustment\n\n\n##############\n# Underscore #\n##############\n\n\n# set undy vault discount\n\n\n@external\ndef setUnderscoreVaultDiscount(_discount: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: only switchboard allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    assert _discount <= HUNDRED_PERCENT # dev: invalid discount\n    self.undyVaulDiscount = _discount\n    log UnderscoreVaultDiscountSet(discount=_discount)\n\n\n# underscore vault\n\n\n@view\n@internal\ndef _isUnderscoreVault(_addr: address, _mc: address) -> bool:\n    underscore: address = staticcall MissionControl(_mc).underscoreRegistry()\n    if underscore == empty(address):\n        return False\n    vaultRegistry: address = staticcall AddressRegistry(underscore).getAddr(UNDERSCORE_VAULT_REGISTRY_ID)\n    if vaultRegistry == empty(address):\n        return False\n    return staticcall VaultRegistry(vaultRegistry).isEarnVault(_addr)\n\n\n#############\n# Utilities #\n#############\n\n\n# update debt\n\n\n@external\ndef updateDebtForUser(_user: address, _a: addys.Addys = empty(addys.Addys)) -> bool:\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    newInterest: uint256 = 0\n    userDebt, bt, newInterest = self._getLatestUserDebtAndTerms(_user, True, a)\n    if userDebt.amount == 0:\n        return True\n\n    # debt health (use bt.totalMaxDebt directly to avoid rounding discrepancy)\n    hasGoodDebtHealth: bool = userDebt.amount <= bt.totalMaxDebt\n    if hasGoodDebtHealth:\n        userDebt.inLiquidation = False\n\n    userDebt.debtTerms = bt.debtTerms\n\n    extcall Ledger(a.ledger).setUserDebt(_user, userDebt, newInterest, empty(IntervalBorrow))\n\n    # update borrow points\n    extcall LootBox(a.lootbox).updateBorrowPoints(_user, a)\n\n    return hasGoodDebtHealth\n\n\n# credit redeem wrappers\n\n\n@external\ndef transferOrWithdrawViaRedemption(\n    _shouldTransferBalance: bool,\n    _asset: address,\n    _user: address,\n    _recipient: address,\n    _amount: uint256,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _a: addys.Addys,\n) -> uint256:\n    assert msg.sender == addys._getCreditRedeemAddr() # dev: only credit redeem allowed\n\n    amountSent: uint256 = 0\n    na: bool = False\n    if _shouldTransferBalance:\n        amountSent, na = extcall Vault(_vaultAddr).transferBalanceWithinVault(_asset, _user, _recipient, _amount, _a)\n        extcall Ledger(_a.ledger).addVaultToUser(_recipient, _vaultId)\n        extcall LootBox(_a.lootbox).updateDepositPoints(_recipient, _vaultId, _vaultAddr, _asset, _a)\n\n    else:\n        amountSent, na = extcall Vault(_vaultAddr).withdrawTokensFromVault(_user, _asset, _amount, _recipient, _a)\n    return amountSent\n\n\n# handle green\n\n\n@internal\ndef _handleGreenForUser(\n    _recipient: address,\n    _greenAmount: uint256,\n    _wantsSavingsGreen: bool,\n    _shouldEnterStabPool: bool,\n    _a: addys.Addys,\n):\n    amount: uint256 = min(_greenAmount, staticcall IERC20(_a.greenToken).balanceOf(self))\n    if amount == 0:\n        return\n\n    if _wantsSavingsGreen and amount > 10 ** 9: # small dust will fail\n\n        sgreenRecipient: address = _recipient\n        if _shouldEnterStabPool:\n            sgreenRecipient = self\n\n        # put GREEN into sGREEN\n        assert extcall IERC20(_a.greenToken).approve(_a.savingsGreen, amount, default_return_value=True) # dev: green approval failed\n        sGreenAmount: uint256 = extcall IERC4626(_a.savingsGreen).deposit(amount, sgreenRecipient)\n        assert extcall IERC20(_a.greenToken).approve(_a.savingsGreen, 0, default_return_value=True) # dev: green approval failed\n\n        # put sGREEN into stability pool\n        if _shouldEnterStabPool:\n            assert extcall IERC20(_a.savingsGreen).approve(_a.teller, sGreenAmount, default_return_value=True) # dev: sgreen approval failed\n            extcall Teller(_a.teller).depositFromTrusted(_recipient, STABILITY_POOL_ID, _a.savingsGreen, sGreenAmount, 0, _a)\n            assert extcall IERC20(_a.savingsGreen).approve(_a.teller, 0, default_return_value=True) # dev: sgreen approval failed\n\n    else:\n        assert extcall IERC20(_a.greenToken).transfer(_recipient, amount, default_return_value=True) # dev: green transfer failed\n\n\n# max withdrawable\n\n\n@view\n@external\ndef getMaxWithdrawableForAsset(\n    _user: address,\n    _vaultId: uint256,\n    _asset: address,\n    _vaultAddr: address = empty(address),\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    a: addys.Addys = addys._getAddys(_a)\n\n    vaultAddr: address = _vaultAddr\n    if vaultAddr == empty(address):\n        vaultAddr = staticcall AddressRegistry(a.vaultBook).getAddr(_vaultId)\n\n    # get latest user debt\n    d: RepayDataBundle = staticcall Ledger(a.ledger).getRepayDataBundle(_user)\n    userDebt: UserDebt = empty(UserDebt)\n    na: uint256 = 0\n    userDebt, na = self._getLatestUserDebtWithInterest(d.userDebt)\n\n    # no debt, can do max withdraw\n    if userDebt.amount == 0:\n        return max_value(uint256)\n\n    # cannot withdraw if in liquidation\n    if userDebt.inLiquidation:\n        return 0\n\n    # get the asset's debt terms\n    assetDebtTerms: cs.DebtTerms = staticcall MissionControl(a.missionControl).getDebtTerms(_asset)\n    if assetDebtTerms.ltv == 0:\n        return max_value(uint256) # asset doesn't contribute to borrowing power\n\n    # get current asset value for user\n    userBalance: uint256 = staticcall Vault(vaultAddr).getTotalAmountForUser(_user, _asset)\n    userUsdValue: uint256 = staticcall PriceDesk(a.priceDesk).getUsdValue(_asset, userBalance, False)\n    if userUsdValue == 0:\n        return 0 # cannot determine value\n\n    # get borrow terms excluding the asset to withdraw\n    isUndyVault: bool = self._isUnderscoreVault(_user, a.missionControl)\n    btExcluding: UserBorrowTerms = self._getUserBorrowTerms(_user, d.numUserVaults, True, _vaultId, _asset, isUndyVault, a)\n\n    # calculate minimum asset value that must remain\n    minAssetValueToRemain: uint256 = 0\n\n    if btExcluding.collateralVal == 0:\n\n        # entire debt must be supported by this asset\n        minAssetValueToRemain = userDebt.amount * (HUNDRED_PERCENT + ONE_PERCENT) // assetDebtTerms.ltv\n\n    # multi-asset case: use capacity-based calculation\n    else:\n        # Calculate how much debt the remaining assets can support\n        remainingMaxDebt: uint256 = btExcluding.totalMaxDebt\n\n        # Calculate total debt that needs to be supported (with 1% buffer)\n        totalDebtNeeded: uint256 = userDebt.amount * (HUNDRED_PERCENT + ONE_PERCENT) // HUNDRED_PERCENT\n\n        # If remaining assets can support all debt, can withdraw everything\n        if remainingMaxDebt >= totalDebtNeeded:\n            return max_value(uint256)\n\n        # Calculate how much debt must be covered by this asset\n        debtNeedingAssetSupport: uint256 = totalDebtNeeded - remainingMaxDebt\n\n        # Calculate minimum collateral value needed from this asset\n        # minCollateral = debtNeeded / assetLTV\n        minAssetValueToRemain = debtNeedingAssetSupport * HUNDRED_PERCENT // assetDebtTerms.ltv\n\n    # cannot withdraw if user has less than the minimum required\n    if userUsdValue <= minAssetValueToRemain:\n        return 0\n\n    # convert to asset amount\n    maxWithdrawableValue: uint256 = userUsdValue - minAssetValueToRemain\n    return userBalance * maxWithdrawableValue // userUsdValue\n\n\n# set buyback ratio\n\n\n@external\ndef setBuybackRatio(_ratio: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: only switchboard allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    assert _ratio <= HUNDRED_PERCENT # dev: invalid ratio\n    self.buybackRatio = _ratio\n    log BuybackRatioSet(ratio=_ratio)\n\n\n########   #######  ########  ########   #######  ##      ## \n##     ## ##     ## ##     ## ##     ## ##     ## ##  ##  ## \n##     ## ##     ## ##     ## ##     ## ##     ## ##  ##  ## \n########  ##     ## ########  ########  ##     ## ##  ##  ## \n##     ## ##     ## ##   ##   ##   ##   ##     ## ##  ##  ## \n##     ## ##     ## ##    ##  ##    ##  ##     ## ##  ##  ## \n########   #######  ##     ## ##     ##  #######   ###  ###  ",
            "sha256sum": "06915fd61a3547fd7ea2954d282d6e87be10f431ddd140ccdd8e9c6310235cd4"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/CreditEngine.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "a2e04951265c52a8661ade3655c11c82d60d1e6393ffc56ac25d58a747f72bdb"
      },
      "args": "0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/core/CreditEngine.vy"
    }
  }
}