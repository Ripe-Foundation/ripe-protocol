{
  "language": "Vyper",
  "sources": {
    "contracts/modules/LocalGov.vy": {
      "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isRipeHqGov() # dev: ripe hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
      "sha256sum": "4ffcc0fe78019515e484beb8bd5d700dce92d785b6bf26af25f52ea1289a5950"
    },
    "contracts/modules/TimeLock.vy": {
      "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
      "sha256sum": "2c45da650f92c6891ed37a165a365934d31ed144b03e13c79f4f4fc68f2b7851"
    },
    "interfaces/ConfigStructs.vyi": {
      "content": "# @version 0.4.3\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n    stabPoolRipePerDollarClaimed: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address",
      "sha256sum": "6038cdbf454c788457d8fbf20919042656ddfbf13335c079ec2c50280b07b94b"
    },
    "contracts/config/SwitchboardBravo.vy": {
      "content": "#        ______   __     __   __   ______  ______   __  __   ______   ______   ______   ______   _____    \n#       /\\  ___\\ /\\ \\  _ \\ \\ /\\ \\ /\\__  _\\/\\  ___\\ /\\ \\_\\ \\ /\\  == \\ /\\  __ \\ /\\  __ \\ /\\  == \\ /\\  __-.  \n#       \\ \\___  \\\\ \\ \\/ \".\\ \\\\ \\ \\\\/_/\\ \\/\\ \\ \\____\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\ \n#        \\/\\_____\\\\ \\__/\".~\\_\\\\ \\_\\  \\ \\_\\ \\ \\_____\\\\ \\_\\ \\_\\\\ \\_____\\\\ \\_____\\\\ \\_\\ \\_\\\\ \\_\\ \\_\\\\ \\____- \n#         \\/_____/ \\/_/   \\/_/ \\/_/   \\/_/  \\/_____/ \\/_/\\/_/ \\/_____/ \\/_____/ \\/_/\\/_/ \\/_/ /_/ \\/____/ \n#                                                   \u2533\u2513        \n#                                                   \u2523\u252b\u250f\u2513\u250f\u2513\u2513\u250f\u250f\u2513\n#                                                   \u253b\u251b\u251b \u2517\u253b\u2517\u251b\u2517\u251b\n#\n#      Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n#      Ripe Foundation (C) 2025 \n\n# @version 0.4.3\n# pragma optimize codesize\n\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\nimport interfaces.ConfigStructs as cs\n\ninterface MissionControl:\n    def setAssetConfig(_asset: address, _assetConfig: cs.AssetConfig): nonpayable\n    def canPerformLiteAction(_user: address) -> bool: view\n    def assetConfig(_asset: address) -> cs.AssetConfig: view\n    def isSupportedAsset(_asset: address) -> bool: view\n    def maxLtvDeviation() -> uint256: view\n    def trainingWheels() -> address: view\n\ninterface SwitchboardAlpha:\n    def areValidAuctionParams(_params: cs.AuctionParams) -> bool: view\n\ninterface Whitelist:\n    def isUserAllowed(_user: address, _asset: address) -> bool: view\n\ninterface VaultBook:\n    def isValidRegId(_regId: uint256) -> bool: view\n\ninterface RipeHq:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def getAddr(_regId: uint256) -> address: view\n\nflag ActionType:\n    ASSET_ADD_NEW\n    ASSET_DEPOSIT_PARAMS\n    ASSET_LIQ_CONFIG\n    ASSET_DEBT_TERMS\n    ASSET_WHITELIST\n\nflag AssetFlag:\n    CAN_DEPOSIT\n    CAN_WITHDRAW\n    CAN_REDEEM_IN_STAB_POOL\n    CAN_BUY_IN_AUCTION\n    CAN_CLAIM_IN_STAB_POOL\n    CAN_REDEEM_COLLATERAL\n\nstruct AssetUpdate:\n    asset: address\n    config: cs.AssetConfig\n\nevent NewAssetPending:\n    asset: indexed(address)\n    numVaults: uint256\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTermsLtv: uint256\n    debtTermsRedemptionThreshold: uint256\n    debtTermsLiqThreshold: uint256\n    debtTermsLiqFee: uint256\n    debtTermsBorrowRate: uint256\n    debtTermsDaowry: uint256\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    auctionStartDiscount: uint256\n    auctionMaxDiscount: uint256\n    auctionDelay: uint256\n    auctionDuration: uint256\n    whitelist: address\n    isNft: bool\n\nevent PendingAssetDepositParamsChange:\n    asset: indexed(address)\n    numVaultIds: uint256\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingAssetLiqConfigChange:\n    asset: indexed(address)\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    specialStabPoolId: uint256\n    auctionStartDiscount: uint256\n    auctionMaxDiscount: uint256\n    auctionDelay: uint256\n    auctionDuration: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingAssetDebtTermsChange:\n    asset: indexed(address)\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingAssetWhitelistChange:\n    asset: indexed(address)\n    whitelist: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CanDepositAssetSet:\n    asset: indexed(address)\n    canDeposit: bool\n    caller: indexed(address)\n\nevent CanWithdrawAssetSet:\n    asset: indexed(address)\n    canWithdraw: bool\n    caller: indexed(address)\n\nevent CanRedeemInStabPoolAssetSet:\n    asset: indexed(address)\n    canRedeemInStabPool: bool\n    caller: indexed(address)\n\nevent CanBuyInAuctionAssetSet:\n    asset: indexed(address)\n    canBuyInAuction: bool\n    caller: indexed(address)\n\nevent CanClaimInStabPoolAssetSet:\n    asset: indexed(address)\n    canClaimInStabPool: bool\n    caller: indexed(address)\n\nevent CanRedeemCollateralAssetSet:\n    asset: indexed(address)\n    canRedeemCollateral: bool\n    caller: indexed(address)\n\nevent AssetAdded:\n    asset: indexed(address)\n\nevent AssetDepositParamsSet:\n    asset: indexed(address)\n    numVaultIds: uint256\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n\nevent AssetLiqConfigSet:\n    asset: indexed(address)\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    specialStabPoolId: uint256\n    auctionStartDiscount: uint256\n    auctionMaxDiscount: uint256\n    auctionDelay: uint256\n    auctionDuration: uint256\n\nevent AssetDebtTermsSet:\n    asset: indexed(address)\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nevent WhitelistAssetSet:\n    asset: indexed(address)\n    whitelist: indexed(address)\n\n# pending config changes\nactionType: public(HashMap[uint256, ActionType]) # aid -> type\npendingAssetConfig: public(HashMap[uint256, AssetUpdate]) # aid -> asset\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\n\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nMISSION_CONTROL_ID: constant(uint256) = 5\nVAULT_BOOK_ID: constant(uint256) = 8\nSWITCHBOARD_ID: constant(uint256) = 6\nSWITCHBOARD_ALPHA_ID: constant(uint256) = 1\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _tempGov: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, _tempGov, 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPermsToEnable(_caller: address, _shouldEnable: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if not _shouldEnable:\n        return staticcall MissionControl(self._getMissionControlAddr()).canPerformLiteAction(_caller)\n    return False\n\n\n# addys lite\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(MISSION_CONTROL_ID)\n\n\n#############\n# Add Asset #\n#############\n\n\n@external\ndef addAsset(\n    _asset: address,\n    _vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET],\n    _stakersPointsAlloc: uint256,\n    _voterPointsAlloc: uint256,\n    _perUserDepositLimit: uint256,\n    _globalDepositLimit: uint256,\n    _minDepositBalance: uint256 = 0,\n    _debtTerms: cs.DebtTerms = empty(cs.DebtTerms),\n    _shouldBurnAsPayment: bool = False,\n    _shouldTransferToEndaoment: bool = False,\n    _shouldSwapInStabPools: bool = True,\n    _shouldAuctionInstantly: bool = True,\n    _canDeposit: bool = True,\n    _canWithdraw: bool = True,\n    _canRedeemCollateral: bool = True,\n    _canRedeemInStabPool: bool = True,\n    _canBuyInAuction: bool = True,\n    _canClaimInStabPool: bool = True,\n    _specialStabPoolId: uint256 = 0,\n    _customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams),\n    _whitelist: address = empty(address),\n    _isNft: bool = False,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not staticcall MissionControl(self._getMissionControlAddr()).isSupportedAsset(_asset) # dev: must be new asset\n\n    customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams)\n    if _customAuctionParams.hasParams:\n        customAuctionParams = _customAuctionParams\n\n    config: cs.AssetConfig = cs.AssetConfig(\n        vaultIds=_vaultIds,\n        stakersPointsAlloc=_stakersPointsAlloc,\n        voterPointsAlloc=_voterPointsAlloc,\n        perUserDepositLimit=_perUserDepositLimit,\n        globalDepositLimit=_globalDepositLimit,\n        minDepositBalance=_minDepositBalance,\n        debtTerms=_debtTerms,\n        shouldBurnAsPayment=_shouldBurnAsPayment,\n        shouldTransferToEndaoment=_shouldTransferToEndaoment,\n        shouldSwapInStabPools=_shouldSwapInStabPools,\n        shouldAuctionInstantly=_shouldAuctionInstantly,\n        canDeposit=_canDeposit,\n        canWithdraw=_canWithdraw,\n        canRedeemCollateral=_canRedeemCollateral,\n        canRedeemInStabPool=_canRedeemInStabPool,\n        canBuyInAuction=_canBuyInAuction,\n        canClaimInStabPool=_canClaimInStabPool,\n        specialStabPoolId=_specialStabPoolId,\n        customAuctionParams=customAuctionParams,\n        whitelist=_whitelist,\n        isNft=_isNft,\n    )\n    assert self._isValidAssetConfig(_asset, config) # dev: invalid asset\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.ASSET_ADD_NEW\n    self.pendingAssetConfig[aid] = AssetUpdate(\n        asset=_asset,\n        config=config,\n    )\n\n    log NewAssetPending(\n        asset=_asset,\n        numVaults=len(config.vaultIds),\n        stakersPointsAlloc=config.stakersPointsAlloc,\n        voterPointsAlloc=config.voterPointsAlloc,\n        perUserDepositLimit=config.perUserDepositLimit,\n        globalDepositLimit=config.globalDepositLimit,\n        minDepositBalance=config.minDepositBalance,\n        debtTermsLtv=config.debtTerms.ltv,\n        debtTermsRedemptionThreshold=config.debtTerms.redemptionThreshold,\n        debtTermsLiqThreshold=config.debtTerms.liqThreshold,\n        debtTermsLiqFee=config.debtTerms.liqFee,\n        debtTermsBorrowRate=config.debtTerms.borrowRate,\n        debtTermsDaowry=config.debtTerms.daowry,\n        shouldBurnAsPayment=config.shouldBurnAsPayment,\n        shouldTransferToEndaoment=config.shouldTransferToEndaoment,\n        shouldSwapInStabPools=config.shouldSwapInStabPools,\n        shouldAuctionInstantly=config.shouldAuctionInstantly,\n        canDeposit=config.canDeposit,\n        canWithdraw=config.canWithdraw,\n        canRedeemCollateral=config.canRedeemCollateral,\n        canRedeemInStabPool=config.canRedeemInStabPool,\n        canBuyInAuction=config.canBuyInAuction,\n        canClaimInStabPool=config.canClaimInStabPool,\n        specialStabPoolId=config.specialStabPoolId,\n        auctionStartDiscount=config.customAuctionParams.startDiscount,\n        auctionMaxDiscount=config.customAuctionParams.maxDiscount,\n        auctionDelay=config.customAuctionParams.delay,\n        auctionDuration=config.customAuctionParams.duration,\n        whitelist=config.whitelist,\n        isNft=config.isNft,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidAssetConfig(_asset: address, _config: cs.AssetConfig) -> bool:\n    if _asset == empty(address):\n        return False\n    if not self._isValidDebtTerms(_config.debtTerms):\n        return False\n    if not self._isValidAssetDepositParams(_asset, _config.vaultIds, _config.stakersPointsAlloc, _config.voterPointsAlloc, _config.perUserDepositLimit, _config.globalDepositLimit, _config.minDepositBalance):\n        return False\n    if not self._isValidAssetLiqConfig(_asset, _config.shouldBurnAsPayment, _config.shouldTransferToEndaoment, _config.shouldSwapInStabPools, _config.shouldAuctionInstantly, _config.specialStabPoolId, _config.isNft, _config.whitelist, _config.debtTerms.ltv):\n        return False\n    if not self._isValidRedeemCollateralConfig(_asset, _config.canRedeemCollateral, _config.isNft, _config.debtTerms.ltv, _config.shouldTransferToEndaoment):\n        return False\n    if not self._isValidWhitelist(_config.whitelist):\n        return False\n    if _config.customAuctionParams.hasParams and not self._areValidAuctionParams(_config.customAuctionParams):\n        return False\n    return True\n\n\n##########################\n# Asset - Deposit Params #\n##########################\n\n\n@external\ndef setAssetDepositParams(\n    _asset: address,\n    _vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET],\n    _stakersPointsAlloc: uint256,\n    _voterPointsAlloc: uint256,\n    _perUserDepositLimit: uint256,\n    _globalDepositLimit: uint256,\n    _minDepositBalance: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert staticcall MissionControl(self._getMissionControlAddr()).isSupportedAsset(_asset) # dev: invalid asset\n    assert self._isValidAssetDepositParams(_asset, _vaultIds, _stakersPointsAlloc, _voterPointsAlloc, _perUserDepositLimit, _globalDepositLimit, _minDepositBalance) # dev: invalid asset deposit params\n    return self._setPendingAssetConfig(ActionType.ASSET_DEPOSIT_PARAMS, _asset, _vaultIds, _stakersPointsAlloc, _voterPointsAlloc, _perUserDepositLimit, _globalDepositLimit, _minDepositBalance)\n\n\n@view\n@internal\ndef _isValidAssetDepositParams(\n    _asset: address,\n    _vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET],\n    _stakersPointsAlloc: uint256,\n    _voterPointsAlloc: uint256,\n    _perUserDepositLimit: uint256,\n    _globalDepositLimit: uint256,\n    _minDepositBalance: uint256,\n) -> bool:\n    vaultBook: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(VAULT_BOOK_ID)\n    if 0 in [_perUserDepositLimit, _globalDepositLimit]:\n        return False\n    if max_value(uint256) in [_perUserDepositLimit, _globalDepositLimit, _stakersPointsAlloc, _voterPointsAlloc]:\n        return False\n    if _stakersPointsAlloc + _voterPointsAlloc > HUNDRED_PERCENT:\n        return False\n    if _perUserDepositLimit > _globalDepositLimit:\n        return False\n    if _minDepositBalance > _perUserDepositLimit:\n        return False\n    for vaultId: uint256 in _vaultIds:\n        if not staticcall VaultBook(vaultBook).isValidRegId(vaultId):\n            return False\n\n    # staker allocs must be with staker vaults\n    if _stakersPointsAlloc != 0:\n        hasStakerVault: bool = False\n        for sid: uint256 in [1, 2]:\n            if sid in _vaultIds:\n                hasStakerVault = True\n                break\n        if not hasStakerVault:\n            return False\n\n    return True\n\n\n######################\n# Asset - Liq Config #\n######################\n\n\n@external\ndef setAssetLiqConfig(\n    _asset: address,\n    _shouldBurnAsPayment: bool,\n    _shouldTransferToEndaoment: bool,\n    _shouldSwapInStabPools: bool,\n    _shouldAuctionInstantly: bool,\n    _specialStabPoolId: uint256 = 0,\n    _customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams),\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams)\n    if _customAuctionParams.hasParams:\n        assert self._areValidAuctionParams(_customAuctionParams) # dev: invalid auction params\n        customAuctionParams = _customAuctionParams\n\n    mc: address = self._getMissionControlAddr()\n    assert staticcall MissionControl(mc).isSupportedAsset(_asset) # dev: invalid asset\n    assetConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n    assert self._isValidAssetLiqConfig(_asset, _shouldBurnAsPayment, _shouldTransferToEndaoment, _shouldSwapInStabPools, _shouldAuctionInstantly, _specialStabPoolId, assetConfig.isNft, assetConfig.whitelist, assetConfig.debtTerms.ltv) # dev: invalid asset liq config\n    return self._setPendingAssetConfig(ActionType.ASSET_LIQ_CONFIG, _asset, [], 0, 0, 0, 0, 0, empty(cs.DebtTerms), _shouldBurnAsPayment, _shouldTransferToEndaoment, _shouldSwapInStabPools, _shouldAuctionInstantly, _specialStabPoolId, customAuctionParams)\n\n\n@view\n@internal\ndef _isValidAssetLiqConfig(\n    _asset: address,\n    _shouldBurnAsPayment: bool,\n    _shouldTransferToEndaoment: bool,\n    _shouldSwapInStabPools: bool,\n    _shouldAuctionInstantly: bool,\n    _specialStabPoolId: uint256,\n    _isNft: bool,\n    _whitelist: address,\n    _debtTermsLtv: uint256,\n) -> bool:\n    greenToken: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(GREEN_TOKEN_ID)\n    savingsGreen: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(SAVINGS_GREEN_ID)\n    vaultBook: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(VAULT_BOOK_ID)\n\n    if _shouldBurnAsPayment:\n\n        # can only burn if green or savings green\n        if _asset not in [greenToken, savingsGreen]:\n            return False\n\n    if _shouldTransferToEndaoment:\n\n        # cannot transfer to endaoment if green or savings green\n        if _asset in [greenToken, savingsGreen]:\n            return False\n\n    if _shouldSwapInStabPools:\n\n        # cannot be nft\n        if _isNft:\n            return False\n\n        # cannot have whitelist if no special stab pool\n        if _whitelist != empty(address) and _specialStabPoolId == 0:\n            if _whitelist != staticcall MissionControl(self._getMissionControlAddr()).trainingWheels():\n                return False\n\n        # must have ltv\n        if _debtTermsLtv == 0:\n            return False\n\n    # make sure special stab pool is valid\n    if _specialStabPoolId != 0 and not staticcall VaultBook(vaultBook).isValidRegId(_specialStabPoolId):\n        return False\n\n    return True\n\n\n@view\n@internal\ndef _areValidAuctionParams(_params: cs.AuctionParams) -> bool:\n    switchboard: address = staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(SWITCHBOARD_ID)\n    switchboardAlpha: address = staticcall Switchboard(switchboard).getAddr(SWITCHBOARD_ALPHA_ID)\n    return staticcall SwitchboardAlpha(switchboardAlpha).areValidAuctionParams(_params)\n\n\n######################\n# Asset - Debt Terms #\n######################\n\n\n@external\ndef setAssetDebtTerms(\n    _asset: address,\n    _ltv: uint256,\n    _redemptionThreshold: uint256,\n    _liqThreshold: uint256,\n    _liqFee: uint256,\n    _borrowRate: uint256,\n    _daowry: uint256,\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    mc: address = self._getMissionControlAddr()\n    assert staticcall MissionControl(mc).isSupportedAsset(_asset) # dev: invalid asset\n    assetConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n    assert self._isLtvWithinMaxDeviation(_ltv, assetConfig.debtTerms.ltv, staticcall MissionControl(mc).maxLtvDeviation()) # dev: ltv is outside max deviation\n\n    debtTerms: cs.DebtTerms = cs.DebtTerms(\n        ltv=_ltv,\n        redemptionThreshold=_redemptionThreshold,\n        liqThreshold=_liqThreshold,\n        liqFee=_liqFee,\n        borrowRate=_borrowRate,\n        daowry=_daowry,\n    )\n    assert self._isValidDebtTerms(debtTerms) # dev: invalid debt terms\n    return self._setPendingAssetConfig(ActionType.ASSET_DEBT_TERMS, _asset, [], 0, 0, 0, 0, 0, debtTerms)\n\n\n@view\n@internal\ndef _isValidDebtTerms(_debtTerms: cs.DebtTerms) -> bool:\n    if _debtTerms.liqThreshold > HUNDRED_PERCENT:\n        return False\n    if _debtTerms.redemptionThreshold > _debtTerms.liqThreshold:\n        return False\n    if _debtTerms.ltv > _debtTerms.redemptionThreshold:\n        return False\n    if _debtTerms.liqFee > HUNDRED_PERCENT or _debtTerms.borrowRate > HUNDRED_PERCENT or _debtTerms.daowry > HUNDRED_PERCENT:\n        return False\n    if _debtTerms.ltv != 0 and 0 in [_debtTerms.liqFee, _debtTerms.borrowRate]:\n        return False\n\n    # if ltv > 0, liq threshold and redemption threshold must be > 0\n    if _debtTerms.ltv != 0 and (_debtTerms.liqThreshold == 0 or _debtTerms.redemptionThreshold == 0):\n        return False\n\n    # make liq threshold and liq bonus work together\n    liqSum: uint256 = _debtTerms.liqThreshold + (_debtTerms.liqThreshold * _debtTerms.liqFee // HUNDRED_PERCENT)\n    return liqSum <= HUNDRED_PERCENT\n\n\n@view\n@internal\ndef _isLtvWithinMaxDeviation(_newLtv: uint256, _prevLtv: uint256, _maxDeviation: uint256) -> bool:\n\n    # cannot set ltv to 0 after already non-zero\n    if _prevLtv != 0 and _newLtv == 0:\n        return False\n\n    if _prevLtv == 0 or _maxDeviation == 0:\n        return True\n\n    lowerBound: uint256 = _prevLtv - min(_maxDeviation, _prevLtv)\n    return HUNDRED_PERCENT > _newLtv and _newLtv >= lowerBound\n\n\n#####################\n# Asset - Whitelist #\n#####################\n\n\n@external\ndef setWhitelistForAsset(_asset: address, _whitelist: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    assert staticcall MissionControl(self._getMissionControlAddr()).isSupportedAsset(_asset) # dev: invalid asset\n    assert self._isValidWhitelist(_whitelist) # dev: invalid whitelist\n    return self._setPendingAssetConfig(ActionType.ASSET_WHITELIST, _asset, [], 0, 0, 0, 0, 0, empty(cs.DebtTerms), False, False, False, False, 0, empty(cs.AuctionParams), _whitelist)\n\n\n@view\n@internal\ndef _isValidWhitelist(_whitelist: address) -> bool:\n    # make sure has interface\n    if _whitelist != empty(address):\n        assert not staticcall Whitelist(_whitelist).isUserAllowed(empty(address), empty(address)) # dev: invalid whitelist\n    return True\n\n\n##########################\n# Asset - Pending Config #\n##########################\n\n\n@internal\ndef _setPendingAssetConfig(\n    _actionType: ActionType,\n    _asset: address,\n    _vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET] = [],\n    _stakersPointsAlloc: uint256 = 0,\n    _voterPointsAlloc: uint256 = 0,\n    _perUserDepositLimit: uint256 = 0,\n    _globalDepositLimit: uint256 = 0,\n    _minDepositBalance: uint256 = 0,\n    _debtTerms: cs.DebtTerms = empty(cs.DebtTerms),\n    _shouldBurnAsPayment: bool = False,\n    _shouldTransferToEndaoment: bool = False,\n    _shouldSwapInStabPools: bool = False,\n    _shouldAuctionInstantly: bool = False,\n    _specialStabPoolId: uint256 = 0,\n    _customAuctionParams: cs.AuctionParams = empty(cs.AuctionParams),\n    _whitelist: address = empty(address),\n) -> uint256:\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = _actionType\n    config: cs.AssetConfig = cs.AssetConfig(\n        vaultIds=_vaultIds,\n        stakersPointsAlloc=_stakersPointsAlloc,\n        voterPointsAlloc=_voterPointsAlloc,\n        perUserDepositLimit=_perUserDepositLimit,\n        globalDepositLimit=_globalDepositLimit,\n        minDepositBalance=_minDepositBalance,\n        debtTerms=_debtTerms,\n        shouldBurnAsPayment=_shouldBurnAsPayment,\n        shouldTransferToEndaoment=_shouldTransferToEndaoment,\n        shouldSwapInStabPools=_shouldSwapInStabPools,\n        shouldAuctionInstantly=_shouldAuctionInstantly,\n        canDeposit=False,\n        canWithdraw=False,\n        canRedeemCollateral=False,\n        canRedeemInStabPool=False,\n        canBuyInAuction=False,\n        canClaimInStabPool=False,\n        specialStabPoolId=_specialStabPoolId,\n        customAuctionParams=_customAuctionParams,\n        whitelist=_whitelist,\n        isNft=False,\n    )\n    self.pendingAssetConfig[aid] = AssetUpdate(\n        asset=_asset,\n        config=config,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.ASSET_DEPOSIT_PARAMS:\n        log PendingAssetDepositParamsChange(\n            asset=_asset,\n            numVaultIds=len(_vaultIds),\n            stakersPointsAlloc=_stakersPointsAlloc,\n            voterPointsAlloc=_voterPointsAlloc,\n            perUserDepositLimit=_perUserDepositLimit,\n            globalDepositLimit=_globalDepositLimit,\n            minDepositBalance=_minDepositBalance,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.ASSET_LIQ_CONFIG:\n        log PendingAssetLiqConfigChange(\n            asset=_asset,\n            shouldBurnAsPayment=_shouldBurnAsPayment,\n            shouldTransferToEndaoment=_shouldTransferToEndaoment,\n            shouldSwapInStabPools=_shouldSwapInStabPools,\n            shouldAuctionInstantly=_shouldAuctionInstantly,\n            specialStabPoolId=_specialStabPoolId,\n            auctionStartDiscount=_customAuctionParams.startDiscount,\n            auctionMaxDiscount=_customAuctionParams.maxDiscount,\n            auctionDelay=_customAuctionParams.delay,\n            auctionDuration=_customAuctionParams.duration,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.ASSET_DEBT_TERMS:\n        log PendingAssetDebtTermsChange(\n            asset=_asset,\n            ltv=_debtTerms.ltv,\n            redemptionThreshold=_debtTerms.redemptionThreshold,\n            liqThreshold=_debtTerms.liqThreshold,\n            liqFee=_debtTerms.liqFee,\n            borrowRate=_debtTerms.borrowRate,\n            daowry=_debtTerms.daowry,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.ASSET_WHITELIST:\n        log PendingAssetWhitelistChange(\n            asset=_asset,\n            whitelist=_whitelist,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n############################\n# Asset - Enable / Disable #\n############################\n\n\n@external\ndef setCanDepositAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_DEPOSIT, _shouldEnable)\n\n\n@external\ndef setCanWithdrawAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_WITHDRAW, _shouldEnable)\n\n\n@external\ndef setCanRedeemInStabPoolAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_REDEEM_IN_STAB_POOL, _shouldEnable)\n\n\n@external\ndef setCanBuyInAuctionAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_BUY_IN_AUCTION, _shouldEnable)\n\n\n@external\ndef setCanClaimInStabPoolAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_CLAIM_IN_STAB_POOL, _shouldEnable)\n\n\n@external\ndef setCanRedeemCollateralAsset(_asset: address, _shouldEnable: bool) -> bool:\n    return self._setAssetFlag(_asset, AssetFlag.CAN_REDEEM_COLLATERAL, _shouldEnable)\n\n\n@internal\ndef _setAssetFlag(_asset: address, _flag: AssetFlag, _shouldEnable: bool) -> bool:\n    assert self._hasPermsToEnable(msg.sender, _shouldEnable) # dev: no perms\n\n    mc: address = self._getMissionControlAddr()\n    assert staticcall MissionControl(mc).isSupportedAsset(_asset) # dev: invalid asset\n    assetConfig: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(_asset)\n\n    # get current value and validate\n    if _flag == AssetFlag.CAN_DEPOSIT:\n        assert assetConfig.canDeposit != _shouldEnable # dev: already set\n        assetConfig.canDeposit = _shouldEnable\n        log CanDepositAssetSet(asset=_asset, canDeposit=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_WITHDRAW:\n        assert assetConfig.canWithdraw != _shouldEnable # dev: already set\n        assetConfig.canWithdraw = _shouldEnable\n        log CanWithdrawAssetSet(asset=_asset, canWithdraw=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_REDEEM_IN_STAB_POOL:\n        assert assetConfig.canRedeemInStabPool != _shouldEnable # dev: already set\n        assetConfig.canRedeemInStabPool = _shouldEnable\n        log CanRedeemInStabPoolAssetSet(asset=_asset, canRedeemInStabPool=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_BUY_IN_AUCTION:\n        assert assetConfig.canBuyInAuction != _shouldEnable # dev: already set\n        assetConfig.canBuyInAuction = _shouldEnable\n        log CanBuyInAuctionAssetSet(asset=_asset, canBuyInAuction=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_CLAIM_IN_STAB_POOL:\n        assert assetConfig.canClaimInStabPool != _shouldEnable # dev: already set\n        assetConfig.canClaimInStabPool = _shouldEnable\n        log CanClaimInStabPoolAssetSet(asset=_asset, canClaimInStabPool=_shouldEnable, caller=msg.sender)\n\n    elif _flag == AssetFlag.CAN_REDEEM_COLLATERAL:\n        assert assetConfig.canRedeemCollateral != _shouldEnable # dev: already set\n        assert self._isValidRedeemCollateralConfig(_asset, _shouldEnable, assetConfig.isNft, assetConfig.debtTerms.ltv, assetConfig.shouldTransferToEndaoment) # dev: invalid redeem collateral config\n        assetConfig.canRedeemCollateral = _shouldEnable\n        log CanRedeemCollateralAssetSet(asset=_asset, canRedeemCollateral=_shouldEnable, caller=msg.sender)\n\n    extcall MissionControl(mc).setAssetConfig(_asset, assetConfig)\n    return True\n\n\n# validation on collateral redemption\n\n\n@view\n@internal\ndef _isValidRedeemCollateralConfig(\n    _asset: address,\n    _shouldEnable: bool,\n    _isNft: bool,\n    _debtTermsLtv: uint256,\n    _shouldTransferToEndaoment: bool,\n) -> bool:\n    if not _shouldEnable:\n        return True\n\n    # cannot redeem collateral if nft\n    if _isNft:\n        return False\n\n    # must have ltv\n    if _debtTermsLtv == 0:\n        return False\n\n    # any stable-ish assets cannot be redeemed\n    if _shouldTransferToEndaoment:\n        return False\n\n    return True\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n    mc: address = self._getMissionControlAddr()\n\n    if actionType == ActionType.ASSET_ADD_NEW:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        assert self._isValidAssetConfig(p.asset, p.config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, p.config)\n        log AssetAdded(asset=p.asset)\n\n    elif actionType == ActionType.ASSET_DEPOSIT_PARAMS:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.vaultIds = p.config.vaultIds\n        config.stakersPointsAlloc = p.config.stakersPointsAlloc\n        config.voterPointsAlloc = p.config.voterPointsAlloc\n        config.perUserDepositLimit = p.config.perUserDepositLimit\n        config.globalDepositLimit = p.config.globalDepositLimit\n        config.minDepositBalance = p.config.minDepositBalance\n        assert self._isValidAssetConfig(p.asset, config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetDepositParamsSet(asset=p.asset, numVaultIds=len(p.config.vaultIds), stakersPointsAlloc=p.config.stakersPointsAlloc, voterPointsAlloc=p.config.voterPointsAlloc, perUserDepositLimit=p.config.perUserDepositLimit, globalDepositLimit=p.config.globalDepositLimit, minDepositBalance=p.config.minDepositBalance)\n\n    elif actionType == ActionType.ASSET_LIQ_CONFIG:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.shouldBurnAsPayment = p.config.shouldBurnAsPayment\n        config.shouldTransferToEndaoment = p.config.shouldTransferToEndaoment\n        config.shouldSwapInStabPools = p.config.shouldSwapInStabPools\n        config.shouldAuctionInstantly = p.config.shouldAuctionInstantly\n        config.specialStabPoolId = p.config.specialStabPoolId\n        config.customAuctionParams = p.config.customAuctionParams\n        assert self._isValidAssetConfig(p.asset, config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetLiqConfigSet(asset=p.asset, shouldBurnAsPayment=p.config.shouldBurnAsPayment, shouldTransferToEndaoment=p.config.shouldTransferToEndaoment, shouldSwapInStabPools=p.config.shouldSwapInStabPools, shouldAuctionInstantly=p.config.shouldAuctionInstantly, specialStabPoolId=p.config.specialStabPoolId, auctionStartDiscount=p.config.customAuctionParams.startDiscount, auctionMaxDiscount=p.config.customAuctionParams.maxDiscount, auctionDelay=p.config.customAuctionParams.delay, auctionDuration=p.config.customAuctionParams.duration)\n\n    elif actionType == ActionType.ASSET_DEBT_TERMS:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.debtTerms = p.config.debtTerms\n        assert self._isValidAssetConfig(p.asset, config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log AssetDebtTermsSet(asset=p.asset, ltv=p.config.debtTerms.ltv, redemptionThreshold=p.config.debtTerms.redemptionThreshold, liqThreshold=p.config.debtTerms.liqThreshold, liqFee=p.config.debtTerms.liqFee, borrowRate=p.config.debtTerms.borrowRate, daowry=p.config.debtTerms.daowry)\n\n    elif actionType == ActionType.ASSET_WHITELIST:\n        p: AssetUpdate = self.pendingAssetConfig[_aid]\n        config: cs.AssetConfig = staticcall MissionControl(mc).assetConfig(p.asset)\n        config.whitelist = p.config.whitelist\n        assert self._isValidAssetConfig(p.asset, config) # dev: invalid asset config\n        extcall MissionControl(mc).setAssetConfig(p.asset, config)\n        log WhitelistAssetSet(asset=p.asset, whitelist=p.config.whitelist)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n# cancel action\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n",
      "sha256sum": "d1cf6e80308b5d7235c8313c794908bc5f946f29f4aaf148946ef99f733645e0"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/config/SwitchboardBravo.vy": [
        "*"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.3+commit.bff19ea2",
  "integrity": "459a468b582185148721e57186d99602df8ec5b78e8f9b12deb65125a1a2eeda"
}