{
  "contracts": {
    "Deleverage": {
      "address": "0x936186F8b9120AEE134Fc1E27FbB3b47d1792964",
      "abi": [
        {
          "name": "DeleverageUser",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            },
            {
              "name": "targetRepayAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "repaidAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "StabAssetBurntDuringDeleverage",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "stabAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountBurned",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "EndaomentTransferDuringDeleverage",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "vaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountSent",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "isDepleted",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CollateralSwapped",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "caller",
              "type": "address",
              "indexed": true
            },
            {
              "name": "withdrawVaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "withdrawAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "withdrawAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "depositVaultId",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "depositAsset",
              "type": "address",
              "indexed": false
            },
            {
              "name": "depositAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "usdValue",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DeleverageUserWithVolatileAssets",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "repaidAmount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "hasGoodDebtHealth",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MinDeleverageBpsSet",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DeleverageBufferSet",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DeleverageCooldownSet",
          "inputs": [
            {
              "name": "blocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UnderscoreSafeSpreadBpsSet",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentPauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DepartmentFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintGreen",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canMintRipe",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_targetRepayAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_targetRepayAmount",
              "type": "uint256"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageWithSpecificAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_caller",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageWithSpecificAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_caller",
              "type": "address"
            },
            {
              "name": "_a",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageWithVolAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_withdrawVaultId",
              "type": "uint256"
            },
            {
              "name": "_withdrawAsset",
              "type": "address"
            },
            {
              "name": "_depositVaultId",
              "type": "uint256"
            },
            {
              "name": "_depositAsset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "swapCollateral",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_withdrawVaultId",
              "type": "uint256"
            },
            {
              "name": "_withdrawAsset",
              "type": "address"
            },
            {
              "name": "_depositVaultId",
              "type": "uint256"
            },
            {
              "name": "_depositAsset",
              "type": "address"
            },
            {
              "name": "_withdrawAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageForWithdrawal",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_vaultId",
              "type": "uint256"
            },
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getDeleverageInfo",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getMaxDeleverageAmount",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMinDeleverageBps",
          "inputs": [
            {
              "name": "_bps",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDeleverageBuffer",
          "inputs": [
            {
              "name": "_bps",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDeleverageCooldown",
          "inputs": [
            {
              "name": "_blocks",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUnderscoreSafeSpreadBps",
          "inputs": [
            {
              "name": "_bps",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minDeleverageBps",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "deleverageBuffer",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "deleverageCooldown",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "underscoreSafeSpreadBps",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "lastDeleverageBlock",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/Addys.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\ninterface RipeHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\nDELEVERAGE_ID: constant(uint256) = 18\nCREDIT_REDEEM_ID: constant(uint256) = 19\nTELLER_UTILS_ID: constant(uint256) = 20\nENDAOMENT_FUNDS_ID: constant(uint256) = 21\nENDAOMENT_PSM_ID: constant(uint256) = 22\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# deleverage\n\n\n@view\n@internal\ndef _getDeleverageId() -> uint256:\n    return DELEVERAGE_ID\n\n\n@view\n@internal\ndef _getDeleverageAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(DELEVERAGE_ID)\n\n\n# creditRedeem\n\n\n@view\n@internal\ndef _getCreditRedeemId() -> uint256:\n    return CREDIT_REDEEM_ID\n\n\n@view\n@internal\ndef _getCreditRedeemAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_REDEEM_ID)\n\n\n# teller utils\n\n\n@view\n@internal\ndef _getTellerUtilsId() -> uint256:\n    return TELLER_UTILS_ID\n\n\n@view\n@internal\ndef _getTellerUtilsAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_UTILS_ID)\n\n\n# endaoment funds\n\n\n@view\n@internal\ndef _getEndaomentFundsId() -> uint256:\n    return ENDAOMENT_FUNDS_ID\n\n\n@view\n@internal\ndef _getEndaomentFundsAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_FUNDS_ID)\n\n\n# endaoment psm\n\n\n@view\n@internal\ndef _getEndaomentPsmId() -> uint256:\n    return ENDAOMENT_PSM_ID\n\n\n@view\n@internal\ndef _getEndaomentPsmAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_PSM_ID)",
            "sha256sum": "2a46a2fbb26fed9ed5d59414833fb6c2f85a7ddf72e82ffc2d6e122296e1d4e6"
          },
          "interfaces/Department.vyi": {
            "content": "# @version 0.4.3\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    # used in RipeHq.vy\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "4022e08f4321cf2a061b4e6b15820958c96ff499d4fa72fcf789ed97dc234ed8"
          },
          "contracts/modules/DeptBasics.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nuses: addys\nimplements: dept\n\nimport contracts.modules.Addys as addys\nimport interfaces.Department as dept\nfrom ethereum.ercs import IERC20\n\nevent DepartmentPauseModified:\n    isPaused: bool\n\nevent DepartmentFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\nCAN_MINT_GREEN: immutable(bool)\nCAN_MINT_RIPE: immutable(bool)\n\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool, _canMintGreen: bool, _canMintRipe: bool):\n    self.isPaused = _shouldPause\n\n    CAN_MINT_GREEN = _canMintGreen\n    CAN_MINT_RIPE = _canMintRipe\n\n\n###########\n# Minting #\n###########\n\n\n@view\n@external\ndef canMintGreen() -> bool:\n    return CAN_MINT_GREEN\n\n\n@view\n@external\ndef canMintRipe() -> bool:\n    return CAN_MINT_RIPE\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log DepartmentPauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log DepartmentFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)\n",
            "sha256sum": "9a59ebe09a5c42dc943976e0cd48bc28ca56b7209a516514f11bf9162114043f"
          },
          "interfaces/Vault.vyi": {
            "content": "# @version 0.4.3\n\nimport contracts.modules.Addys as addys\n\nstruct VaultDataOnDeposit:\n    hasPosition: bool\n    numAssets: uint256\n    userBalance: uint256\n    totalBalance: uint256\n\n\n########\n# Core #\n########\n\n\n@external\ndef depositTokensInVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> uint256:\n    ...\n\n\n@external\ndef withdrawTokensFromVault(\n    _user: address,\n    _asset: address,\n    _amount: uint256,\n    _recipient: address,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n@external\ndef transferBalanceWithinVault(\n    _asset: address,\n    _fromUser: address,\n    _toUser: address,\n    _transferAmount: uint256,\n    _a: addys.Addys = empty(addys.Addys),\n) -> (uint256, bool):\n    ...\n\n\n####################\n# Needs For Others #\n####################\n\n\n@view\n@external\ndef numUserAssets(_user: address) -> uint256:\n    # used in AuctionHouse.vy\n    ...\n\n\n@view\n@external\ndef userAssets(_user: address, _index: uint256) -> address:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getVaultDataOnDeposit(_user: address, _asset: address) -> VaultDataOnDeposit:\n    # used in Teller.vy\n    ...\n\n\n@view\n@external\ndef getUserLootBoxShare(_user: address, _asset: address) -> uint256:\n    # used in Lootbox.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAndAmountAtIndex(_user: address, _index: uint256) -> (address, uint256):\n    # used in CreditEngine.vy\n    ...\n\n\n@view\n@external\ndef getUserAssetAtIndexAndHasBalance(_user: address, _index: uint256) -> (address, bool):\n    # used in Lootbox.vy and AuctionHouse.vy\n    ...\n\n\n###############\n# Other Utils #\n###############\n\n\n@view\n@external\ndef getTotalAmountForUser(_user: address, _asset: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getTotalAmountForVault(_asset: address) -> uint256:\n    ...\n\n\n########\n# Data #\n########\n\n\n@view\n@external\ndef isUserInVaultAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef doesUserHaveBalance(_user: address, _asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef isSupportedVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# remove data\n\n\n@external\ndef deregisterUserAsset(_user: address, _asset: address) -> bool:\n    ...\n\n\n@external\ndef deregisterVaultAsset(_asset: address) -> bool:\n    ...\n\n\n# utils\n\n\n@view\n@external\ndef getNumUserAssets(_user: address) -> uint256:\n    ...\n\n\n@view\n@external\ndef getNumVaultAssets() -> uint256:\n    ...\n\n\n@view\n@external\ndef doesVaultHaveAnyFunds() -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "6769283fa780a63e1b2e2fc56b8ef51f3ff9b5883f4f1c4af8905fd0b20ffde7"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n    stabPoolRipePerDollarClaimed: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address\n\nstruct AssetConfigEntry:\n    asset: address\n    config: AssetConfig\n\nstruct RipeGovVaultConfigEntry:\n    asset: address\n    config: RipeGovVaultConfig",
            "sha256sum": "def6208cd81de43d0d33656f9d05b5394d3a74c695fdc27ffe3c9711ccd67c2c"
          },
          "contracts/core/Deleverage.vy": {
            "content": "#     Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n#     Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nimplements: Department\n\nexports: addys.__interface__\nexports: deptBasics.__interface__\n\ninitializes: addys\ninitializes: deptBasics[addys := addys]\n\nimport contracts.modules.Addys as addys\nimport contracts.modules.DeptBasics as deptBasics\nfrom interfaces import Department\nfrom interfaces import Vault\nimport interfaces.ConfigStructs as cs\n\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\nfrom ethereum.ercs import IERC20Detailed\n\ninterface MissionControl:\n    def userDelegation(_user: address, _caller: address) -> cs.ActionDelegation: view\n    def getAssetLiqConfig(_asset: address) -> AssetLiqConfig: view\n    def getFirstVaultIdForAsset(_asset: address) -> uint256: view\n    def getDebtTerms(_asset: address) -> cs.DebtTerms: view\n    def getGenLiqConfig() -> GenLiqConfig: view\n    def getLtvPaybackBuffer() -> uint256: view\n    def underscoreRegistry() -> address: view\n\ninterface CreditEngine:\n    def repayFromDept(_user: address, _userDebt: UserDebt, _repayValue: uint256, _newInterest: uint256, _numUserVaults: uint256, _a: addys.Addys = empty(addys.Addys)) -> bool: nonpayable\n    def getLatestUserDebtAndTerms(_user: address, _shouldRaise: bool, _a: addys.Addys = empty(addys.Addys)) -> (UserDebt, UserBorrowTerms, uint256): view\n    def getUserBorrowTerms(_user: address, _shouldRaise: bool, _skipVaultId: uint256 = 0, _skipAsset: address = empty(address), _a: addys.Addys = empty(addys.Addys)) -> UserBorrowTerms: view\n\ninterface Ledger:\n    def isParticipatingInVault(_user: address, _vaultId: uint256) -> bool: view\n    def userVaults(_user: address, _index: uint256) -> uint256: view\n    def numUserVaults(_user: address) -> uint256: view\n\ninterface Teller:\n    def depositFromTrusted(_user: address, _vaultId: uint256, _asset: address, _amount: uint256, _lockDuration: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256: nonpayable\n    def performHousekeeping(_isHigherRisk: bool, _user: address, _shouldUpdateDebt: bool, _a: addys.Addys = empty(addys.Addys)): nonpayable\n\ninterface PriceDesk:\n    def getAssetAmount(_asset: address, _usdValue: uint256, _shouldRaise: bool = False) -> uint256: view\n    def getUsdValue(_asset: address, _amount: uint256, _shouldRaise: bool = False) -> uint256: view\n\ninterface VaultRegistry:\n    def isBasicEarnVault(_vaultAddr: address) -> bool: view\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface Registry:\n    def getAddr(_vaultId: uint256) -> address: view\n    def isValidAddr(_addr: address) -> bool: view\n\ninterface AuctionHouse:\n    def withdrawTokensFromVault(_user: address, _asset: address, _amount: uint256, _recipient: address, _vaultAddr: address, _a: addys.Addys) -> (uint256, bool): nonpayable\n\ninterface UnderscoreVault:\n    def convertToAssetsSafe(_shares: uint256) -> uint256: view\n\ninterface EndaomentPSM:\n    def getUsdcYieldPositionVaultToken() -> address: view\n\ninterface GreenToken:\n    def burn(_amount: uint256) -> bool: nonpayable\n\ninterface RipeHq:\n    def governance() -> address: view\n\nstruct DeleverageUserRequest:\n    user: address\n    targetRepayAmount: uint256\n\nstruct DeleverageAsset:\n    vaultId: uint256\n    asset: address\n    targetRepayAmount: uint256\n\nstruct GenLiqConfig:\n    canLiquidate: bool\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    ltvPaybackBuffer: uint256\n    genAuctionParams: cs.AuctionParams\n    priorityLiqAssetVaults: DynArray[VaultData, PRIORITY_LIQ_VAULT_DATA]\n    priorityStabVaults: DynArray[VaultData, MAX_STAB_VAULT_DATA]\n\nstruct AssetLiqConfig:\n    hasConfig: bool\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    customAuctionParams: cs.AuctionParams\n    specialStabPool: VaultData\n\nstruct VaultData:\n    vaultId: uint256\n    vaultAddr: address\n    asset: address\n\nstruct UserBorrowTerms:\n    collateralVal: uint256\n    totalMaxDebt: uint256\n    debtTerms: cs.DebtTerms\n    lowestLtv: uint256\n    highestLtv: uint256\n\nstruct UserDebt:\n    amount: uint256\n    principal: uint256\n    debtTerms: cs.DebtTerms\n    lastTimestamp: uint256\n    inLiquidation: bool\n\nevent DeleverageUser:\n    user: indexed(address)\n    caller: indexed(address)\n    targetRepayAmount: uint256\n    repaidAmount: uint256\n    hasGoodDebtHealth: bool\n\nevent StabAssetBurntDuringDeleverage:\n    user: indexed(address)\n    vaultId: uint256\n    stabAsset: indexed(address)\n    amountBurned: uint256\n    usdValue: uint256\n    isDepleted: bool\n\nevent EndaomentTransferDuringDeleverage:\n    user: indexed(address)\n    vaultId: uint256\n    asset: indexed(address)\n    amountSent: uint256\n    usdValue: uint256\n    isDepleted: bool\n\nevent CollateralSwapped:\n    user: indexed(address)\n    caller: indexed(address)\n    withdrawVaultId: uint256\n    withdrawAsset: indexed(address)\n    withdrawAmount: uint256\n    depositVaultId: uint256\n    depositAsset: address\n    depositAmount: uint256\n    usdValue: uint256\n\nevent DeleverageUserWithVolatileAssets:\n    user: indexed(address)\n    repaidAmount: uint256\n    hasGoodDebtHealth: bool\n\nevent MinDeleverageBpsSet:\n    bps: uint256\n\nevent DeleverageBufferSet:\n    bps: uint256\n\nevent DeleverageCooldownSet:\n    blocks: uint256\n\nevent UnderscoreSafeSpreadBpsSet:\n    bps: uint256\n\n# deleverage params\nminDeleverageBps: public(uint256)\ndeleverageBuffer: public(uint256)\ndeleverageCooldown: public(uint256)\nunderscoreSafeSpreadBps: public(uint256)\n\nlastDeleverageBlock: public(HashMap[address, uint256]) # user -> block number\n\n# cache\nvaultAddrs: transient(HashMap[uint256, address]) # vaultId -> vaultAddr\nassetLiqConfig: transient(HashMap[address, AssetLiqConfig]) # asset -> config\ndidHandleAsset: transient(HashMap[address, HashMap[uint256, HashMap[address, bool]]]) # user -> vaultId -> asset -> did handle\ndidHandleVaultId: transient(HashMap[address, HashMap[uint256, bool]]) # user -> vaultId -> did handle\n\nUNDERSCORE_LEGOBOOK_ID: constant(uint256) = 3\nUNDERSCORE_VAULT_REGISTRY_ID: constant(uint256) = 10\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100.00%\nONE_PERCENT: constant(uint256) = 1_00 # 1.00%\nPRIORITY_LIQ_VAULT_DATA: constant(uint256) = 20\nMAX_STAB_VAULT_DATA: constant(uint256) = 10\nMAX_DELEVERAGE_USERS: constant(uint256) = 25\nMAX_DELEVERAGE_ASSETS: constant(uint256) = 25\nMAX_UNDERSCORE_SAFE_SPREAD_BPS: constant(uint256) = 500 # 5% hard ceiling\nMAX_COOLDOWN_BLOCKS: constant(uint256) = 7_200 # ~1 day at 12s/block\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    addys.__init__(_ripeHq)\n    deptBasics.__init__(False, False, False) # no special permissions needed\n    self.underscoreSafeSpreadBps = 100 # 1%\n\n\n###################\n# Main Deleverage #\n###################\n\n\n# single user\n\n\n@external\ndef deleverageUser(_user: address, _caller: address, _targetRepayAmount: uint256, _a: addys.Addys = empty(addys.Addys)) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n    isTrusted: bool = addys._isValidRipeAddr(_caller) or self._isUnderscoreAddr(_caller, a.missionControl)\n    endaomentPsm: address = addys._getEndaomentPsmAddr()\n    psmYieldPositionToken: address = staticcall EndaomentPSM(endaomentPsm).getUsdcYieldPositionVaultToken()\n    repaidAmount: uint256 = self._deleverageUser(_user, _caller, isTrusted, _targetRepayAmount, config, addys._getEndaomentFundsAddr(), endaomentPsm, psmYieldPositionToken, a)\n    assert repaidAmount != 0 # dev: cannot deleverage\n    return repaidAmount\n\n\n# many users\n\n\n@external\ndef deleverageManyUsers(_users: DynArray[DeleverageUserRequest, MAX_DELEVERAGE_USERS], _caller: address, _a: addys.Addys = empty(addys.Addys)) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n    isTrusted: bool = addys._isValidRipeAddr(_caller) or self._isUnderscoreAddr(_caller, a.missionControl)\n\n    endaoFunds: address = addys._getEndaomentFundsAddr()\n    endaomentPsm: address = addys._getEndaomentPsmAddr()\n    psmYieldPositionToken: address = staticcall EndaomentPSM(endaomentPsm).getUsdcYieldPositionVaultToken()\n\n    totalRepaidAmount: uint256 = 0\n    numUsers: uint256 = 0\n    for u: DeleverageUserRequest in _users:\n        repaidAmount: uint256 = self._deleverageUser(u.user, _caller, isTrusted, u.targetRepayAmount, config, endaoFunds, endaomentPsm, psmYieldPositionToken, a)\n        if repaidAmount != 0:\n            totalRepaidAmount += repaidAmount\n            numUsers += 1\n\n    assert numUsers != 0 # dev: nobody deleveraged\n    return totalRepaidAmount\n\n\n# specific assets in order\n\n\n@external\ndef deleverageWithSpecificAssets(_user: address, _assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS], _caller: address, _a: addys.Addys = empty(addys.Addys)) -> uint256:\n    assert msg.sender == addys._getTellerAddr() # dev: only teller allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys(_a)\n    isTrusted: bool = _user == _caller or addys._isValidRipeAddr(_caller) or self._isUnderscoreAddr(_caller, a.missionControl)\n\n    endaoFunds: address = addys._getEndaomentFundsAddr()\n    endaomentPsm: address = addys._getEndaomentPsmAddr()\n    psmYieldPositionToken: address = staticcall EndaomentPSM(endaomentPsm).getUsdcYieldPositionVaultToken()\n\n    # check perms -- must also be able to borrow\n    if not isTrusted:\n        delegation: cs.ActionDelegation = staticcall MissionControl(a.missionControl).userDelegation(_user, _caller)\n        isTrusted = delegation.canBorrow\n\n    # must be trusted to deleverage with specific asset order\n    assert isTrusted # dev: not allowed\n\n    # get latest user debt\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    newInterest: uint256 = 0\n    userDebt, bt, newInterest = staticcall CreditEngine(a.creditEngine).getLatestUserDebtAndTerms(_user, True, a)\n    if userDebt.amount == 0:\n        return 0\n\n    maxTargetRepayAmount: uint256 = userDebt.amount\n    trueTargetRepayAmount: uint256 = 0\n\n    # process each asset in the specified order\n    for data: DeleverageAsset in _assets:\n        if maxTargetRepayAmount == 0:\n            break\n        if data.targetRepayAmount == 0:\n            continue\n\n        # get vault address\n        vaultAddr: address = empty(address)\n        isVaultAddrCached: bool = False\n        vaultAddr, isVaultAddrCached = self._getVaultAddr(data.vaultId, a.vaultBook)\n        if vaultAddr == empty(address):\n            continue\n\n        # cache vault addr\n        if not isVaultAddrCached:\n            self.vaultAddrs[data.vaultId] = vaultAddr\n\n        # handle this specific asset\n        repayForAsset: uint256 = min(maxTargetRepayAmount, data.targetRepayAmount)\n        trueTargetRepayAmount += repayForAsset\n        remainingToRepayForAsset: uint256 = self._handleSpecificAsset(_user, data.vaultId, vaultAddr, data.asset, repayForAsset, False, endaoFunds, endaomentPsm, psmYieldPositionToken, a)\n        paidAmountForAsset: uint256 = repayForAsset - remainingToRepayForAsset\n        maxTargetRepayAmount -= paidAmountForAsset\n\n    # calculate how much we actually repaid\n    totalRepaidAmount: uint256 = userDebt.amount - maxTargetRepayAmount\n    assert totalRepaidAmount != 0 # dev: no assets processed\n\n    # repay debt\n    hasGoodDebtHealth: bool = extcall CreditEngine(a.creditEngine).repayFromDept(_user, userDebt, min(totalRepaidAmount, userDebt.amount), newInterest, 0, a)\n\n    log DeleverageUser(\n        user=_user,\n        caller=_caller,\n        targetRepayAmount=trueTargetRepayAmount,\n        repaidAmount=totalRepaidAmount,\n        hasGoodDebtHealth=hasGoodDebtHealth,\n    )\n    return totalRepaidAmount\n\n\n######################\n# Special Deleverage #\n######################\n\n\n# volatile collateral assets\n\n\n@external\ndef deleverageWithVolAssets(_user: address, _assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS]) -> uint256:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n    if not addys._isValidRipeAddr(msg.sender):\n        assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n\n    # get latest user debt\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    newInterest: uint256 = 0\n    userDebt, bt, newInterest = staticcall CreditEngine(a.creditEngine).getLatestUserDebtAndTerms(_user, True, a)\n    if userDebt.amount == 0:\n        return 0\n\n    maxTargetRepayAmount: uint256 = userDebt.amount\n    endaoFunds: address = addys._getEndaomentFundsAddr()\n    endaomentPsm: address = addys._getEndaomentPsmAddr()\n    psmYieldPositionToken: address = staticcall EndaomentPSM(endaomentPsm).getUsdcYieldPositionVaultToken()\n\n    # process each volatile asset in the specified order\n    for data: DeleverageAsset in _assets:\n        if maxTargetRepayAmount == 0:\n            break\n        if data.targetRepayAmount == 0:\n            continue\n\n        # get vault address\n        vaultAddr: address = empty(address)\n        isVaultAddrCached: bool = False\n        vaultAddr, isVaultAddrCached = self._getVaultAddr(data.vaultId, a.vaultBook)\n        if vaultAddr == empty(address):\n            continue\n\n        # cache vault addr\n        if not isVaultAddrCached:\n            self.vaultAddrs[data.vaultId] = vaultAddr\n\n        # handle this volatile asset (skip stability pool & shouldTransferToEndaoment assets)\n        repayForAsset: uint256 = min(maxTargetRepayAmount, data.targetRepayAmount)\n        remainingToRepayForAsset: uint256 = self._handleSpecificAsset(_user, data.vaultId, vaultAddr, data.asset, repayForAsset, True, endaoFunds, endaomentPsm, psmYieldPositionToken, a)\n        paidAmountForAsset: uint256 = repayForAsset - remainingToRepayForAsset\n        maxTargetRepayAmount -= paidAmountForAsset\n\n    # calculate how much we actually repaid\n    totalRepaidAmount: uint256 = userDebt.amount - maxTargetRepayAmount\n    assert totalRepaidAmount != 0 # dev: no volatile assets processed\n\n    # repay debt\n    hasGoodDebtHealth: bool = extcall CreditEngine(a.creditEngine).repayFromDept(_user, userDebt, min(totalRepaidAmount, userDebt.amount), newInterest, 0, a)\n\n    log DeleverageUserWithVolatileAssets(\n        user=_user,\n        repaidAmount=totalRepaidAmount,\n        hasGoodDebtHealth=hasGoodDebtHealth,\n    )\n    return totalRepaidAmount\n\n\n# collateral swap\n\n\n@external\ndef swapCollateral(\n    _user: address,\n    _withdrawVaultId: uint256,\n    _withdrawAsset: address,\n    _depositVaultId: uint256,\n    _depositAsset: address,\n    _withdrawAmount: uint256 = max_value(uint256),\n) -> (uint256, uint256):\n    assert not deptBasics.isPaused # dev: contract paused\n    assert empty(address) not in [_user, _withdrawAsset, _depositAsset] # dev: invalid assets\n    assert 0 not in [_withdrawVaultId, _depositVaultId] # dev: invalid vault ids\n\n    a: addys.Addys = addys._getAddys()\n    if not addys._isValidRipeAddr(msg.sender):\n        assert msg.sender == staticcall RipeHq(a.hq).governance() # dev: governance only\n\n    # get vault addresses\n    withdrawVaultAddr: address = staticcall Registry(a.vaultBook).getAddr(_withdrawVaultId)\n    assert withdrawVaultAddr != empty(address) # dev: invalid withdraw vault\n\n    depositVaultAddr: address = staticcall Registry(a.vaultBook).getAddr(_depositVaultId)\n    assert depositVaultAddr != empty(address) # dev: invalid deposit vault\n\n    # get debt terms for both assets\n    withdrawAssetTerms: cs.DebtTerms = staticcall MissionControl(a.missionControl).getDebtTerms(_withdrawAsset)\n    depositAssetTerms: cs.DebtTerms = staticcall MissionControl(a.missionControl).getDebtTerms(_depositAsset)\n\n    # validate LTV: deposit asset must have >= LTV as withdraw asset\n    assert depositAssetTerms.ltv >= withdrawAssetTerms.ltv # dev: deposit asset LTV too low\n\n    # withdraw collateral from user's vault, transfer to governance (msg.sender)\n    withdrawnAmount: uint256 = 0\n    isPositionDepleted: bool = False\n    withdrawnAmount, isPositionDepleted = extcall AuctionHouse(a.auctionHouse).withdrawTokensFromVault(\n        _user,\n        _withdrawAsset,\n        _withdrawAmount,\n        msg.sender, # recipient is governance\n        withdrawVaultAddr,\n        a,\n    )\n    assert withdrawnAmount != 0 # dev: no collateral withdrawn\n\n    # calculate USD value of withdrawn amount\n    usdValue: uint256 = staticcall PriceDesk(a.priceDesk).getUsdValue(_withdrawAsset, withdrawnAmount, True)\n    assert usdValue != 0 # dev: invalid USD value\n\n    # calculate deposit amount based on USD value\n    depositAmount: uint256 = staticcall PriceDesk(a.priceDesk).getAssetAmount(_depositAsset, usdValue, True)\n    assert depositAmount != 0 # dev: invalid deposit amount\n\n    # transfer new collateral from governance to this contract\n    assert extcall IERC20(_depositAsset).transferFrom(msg.sender, self, depositAmount) # dev: transferFrom failed\n\n    # approve Teller to spend tokens and deposit into user's vault\n    assert extcall IERC20(_depositAsset).approve(a.teller, depositAmount) # dev: approve failed\n    extcall Teller(a.teller).depositFromTrusted(_user, _depositVaultId, _depositAsset, depositAmount, 0, a)\n    assert extcall IERC20(_depositAsset).approve(a.teller, 0) # dev: approve failed\n\n    # perform house keeping\n    extcall Teller(a.teller).performHousekeeping(False, _user, True, a)\n\n    log CollateralSwapped(\n        user=_user,\n        caller=msg.sender,\n        withdrawVaultId=_withdrawVaultId,\n        withdrawAsset=_withdrawAsset,\n        withdrawAmount=withdrawnAmount,\n        depositVaultId=_depositVaultId,\n        depositAsset=_depositAsset,\n        depositAmount=depositAmount,\n        usdValue=usdValue,\n    )\n    return withdrawnAmount, depositAmount\n\n\n# underscore leverage vaults\n\n\n@external\ndef deleverageForWithdrawal(_user: address, _vaultId: uint256, _asset: address, _amount: uint256) -> bool:\n    assert not deptBasics.isPaused # dev: contract paused\n    a: addys.Addys = addys._getAddys()\n\n    if not self._isUnderscoreAddr(msg.sender, a.missionControl):\n        assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n\n    # get current user state\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = staticcall CreditEngine(a.creditEngine).getLatestUserDebtAndTerms(_user, True, a)\n    if userDebt.amount == 0:\n        return False\n\n    vaultId: uint256 = _vaultId\n    if _vaultId == 0:\n        vaultId = staticcall MissionControl(a.missionControl).getFirstVaultIdForAsset(_asset)\n\n    # asset information\n    vaultAddr: address = staticcall Registry(a.vaultBook).getAddr(vaultId)\n    userBalance: uint256 = staticcall Vault(vaultAddr).getTotalAmountForUser(_user, _asset)\n    userUsdValue: uint256 = staticcall PriceDesk(a.priceDesk).getUsdValue(_asset, userBalance, True)\n\n    # calculate withdraw usd value\n    withdrawUsdValue: uint256 = userUsdValue\n    if _amount < userBalance:\n        withdrawUsdValue = userUsdValue * _amount // userBalance\n\n    # projected collateral after withdrawal (lazy-cached for near-redemption bypass checks)\n    projectedCollateralVal: uint256 = bt.collateralVal - withdrawUsdValue if bt.collateralVal > withdrawUsdValue else 0\n    didCheckNearRedemption: bool = False\n    isNearRedemption: bool = False\n\n    # cooldown: skip if recently deleveraged, unless near redemption after withdrawal\n    # NOTE: uses strict `>` (not `>=`) so same-block calls are allowed -- this is intentional\n    # to support multi-asset withdrawals that trigger multiple deleverages in a single tx.\n    # tradeoff: same-block spam (e.g. bundled txs) also bypasses cooldown.\n    cooldown: uint256 = self.deleverageCooldown\n    lastBlock: uint256 = self.lastDeleverageBlock[_user]\n    if cooldown != 0 and lastBlock != 0 and block.number > lastBlock and block.number < lastBlock + cooldown:\n        if not didCheckNearRedemption:\n            isNearRedemption = self._canDeleverageUserDebtPosition(userDebt.amount, projectedCollateralVal, bt.debtTerms.redemptionThreshold)\n            didCheckNearRedemption = True\n        if not isNearRedemption:\n            return False\n\n    # asset debt terms\n    assetDebtTerms: cs.DebtTerms = staticcall MissionControl(a.missionControl).getDebtTerms(_asset)\n    if assetDebtTerms.ltv == 0:\n        return False # 0% LTV means asset doesn't affect borrowing capacity\n\n    # calculate lost capacity from withdrawal\n    lostCapacity: uint256 = withdrawUsdValue * assetDebtTerms.ltv // HUNDRED_PERCENT\n    if lostCapacity == 0:\n        return False # if no capacity lost, no need to deleverage\n\n    # get deleverage info (maxDeleveragable amount and effective weighted LTV)\n    maxDeleveragable: uint256 = 0\n    effectiveLtv: uint256 = 0\n    maxDeleveragable, effectiveLtv = self._getDeleverageInfo(_user, a)\n    if maxDeleveragable == 0:\n        return False # no deleveragable assets\n\n    # calculate required repayment to maintain utilization ratio\n    # Formula: requiredRepayment = (debt \u00d7 lostCapacity) / (capacity - debt \u00d7 effectiveLtv)\n    numerator: uint256 = userDebt.amount * lostCapacity\n    debtTimesEffectiveLtv: uint256 = userDebt.amount * effectiveLtv // HUNDRED_PERCENT\n    if bt.totalMaxDebt <= debtTimesEffectiveLtv:\n        return False\n    denominator: uint256 = bt.totalMaxDebt - debtTimesEffectiveLtv\n\n    requiredRepayment: uint256 = numerator // denominator\n    if requiredRepayment == 0:\n        return False\n\n    # apply configurable buffer to be more conservative\n    bufferBps: uint256 = self.deleverageBuffer\n    if bufferBps != 0:\n        requiredRepayment = requiredRepayment * (HUNDRED_PERCENT + bufferBps) // HUNDRED_PERCENT\n\n    # cap at max deleveragable amount\n    requiredRepayment = min(maxDeleveragable, requiredRepayment)\n\n    # final cap at total debt\n    requiredRepayment = min(userDebt.amount, requiredRepayment)\n\n    # skip if effective repayment is below minimum threshold (% of total debt)\n    # unless position would be near redemption after withdrawal\n    minBps: uint256 = self.minDeleverageBps\n    if minBps != 0 and requiredRepayment * HUNDRED_PERCENT < userDebt.amount * minBps:\n        if not didCheckNearRedemption:\n            isNearRedemption = self._canDeleverageUserDebtPosition(userDebt.amount, projectedCollateralVal, bt.debtTerms.redemptionThreshold)\n            didCheckNearRedemption = True\n        if not isNearRedemption:\n            return False\n\n    # execute deleveraging\n    config: GenLiqConfig = staticcall MissionControl(a.missionControl).getGenLiqConfig()\n    endaomentPsm: address = addys._getEndaomentPsmAddr()\n    psmYieldPositionToken: address = staticcall EndaomentPSM(endaomentPsm).getUsdcYieldPositionVaultToken()\n    repaidAmount: uint256 = self._deleverageUser(_user, msg.sender, True, requiredRepayment, config, addys._getEndaomentFundsAddr(), endaomentPsm, psmYieldPositionToken, a)\n    if repaidAmount != 0:\n        self.lastDeleverageBlock[_user] = block.number\n    return repaidAmount != 0\n\n\n#######################\n# Internal Deleverage #\n#######################\n\n\n@internal\ndef _deleverageUser(\n    _user: address,\n    _caller: address,\n    _isTrusted: bool,\n    _targetRepayAmount: uint256,\n    _config: GenLiqConfig,\n    _endaoFunds: address,\n    _endaomentPsm: address,\n    _psmYieldPositionToken: address,\n    _a: addys.Addys,\n) -> uint256:\n    isTrusted: bool = _isTrusted\n\n    # check perms -- must also be able to borrow\n    if not isTrusted and _user != _caller:\n        delegation: cs.ActionDelegation = staticcall MissionControl(_a.missionControl).userDelegation(_user, _caller)\n        isTrusted = delegation.canBorrow\n\n    # get latest user debt\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    newInterest: uint256 = 0\n    userDebt, bt, newInterest = staticcall CreditEngine(_a.creditEngine).getLatestUserDebtAndTerms(_user, True, _a)\n    if userDebt.amount == 0:\n        return 0\n\n    # finalize target repay amount\n    targetRepayAmount: uint256 = min(_targetRepayAmount, userDebt.amount)\n    if targetRepayAmount == 0:\n        targetRepayAmount = userDebt.amount # maximum possible\n\n    # have cap when not trusted (treat similar to redemption)\n    if not isTrusted:\n        if not self._canDeleverageUserDebtPosition(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold):\n            return 0\n        targetLtv: uint256 = bt.lowestLtv\n        ltvPaybackBuffer: uint256 = staticcall MissionControl(_a.missionControl).getLtvPaybackBuffer()\n        if ltvPaybackBuffer != 0:\n            targetLtv = targetLtv * (HUNDRED_PERCENT - ltvPaybackBuffer) // HUNDRED_PERCENT\n        maxRepayableAmount: uint256 = self._calcAmountToPay(userDebt.amount, bt.collateralVal, targetLtv)\n        if maxRepayableAmount == 0:\n            return 0\n        targetRepayAmount = min(targetRepayAmount, maxRepayableAmount)\n\n    # perform deleverage phases\n    repaidAmount: uint256 = self._performDeleveragePhases(_user, targetRepayAmount, _config.priorityStabVaults, _config.priorityLiqAssetVaults, _endaoFunds, _endaomentPsm, _psmYieldPositionToken, _a)\n    if repaidAmount == 0:\n        return 0\n\n    # repay debt\n    repaidAmount = min(repaidAmount, userDebt.amount)\n    hasGoodDebtHealth: bool = extcall CreditEngine(_a.creditEngine).repayFromDept(_user, userDebt, repaidAmount, newInterest, 0, _a)\n\n    log DeleverageUser(\n        user=_user,\n        caller=_caller,\n        targetRepayAmount=targetRepayAmount,\n        repaidAmount=repaidAmount,\n        hasGoodDebtHealth=hasGoodDebtHealth,\n    )\n    return repaidAmount\n\n\n# deleverage phases\n\n\n@internal\ndef _performDeleveragePhases(\n    _user: address,\n    _targetRepayAmount: uint256,\n    _priorityStabVaults: DynArray[VaultData, MAX_STAB_VAULT_DATA],\n    _priorityLiqAssetVaults: DynArray[VaultData, PRIORITY_LIQ_VAULT_DATA],\n    _endaoFunds: address,\n    _endaomentPsm: address,\n    _psmYieldPositionToken: address,\n    _a: addys.Addys,\n) -> uint256:\n    remainingToRepay: uint256 = _targetRepayAmount\n\n    # PHASE 1 -- look at stability pool assets first\n\n    if len(_priorityStabVaults) != 0:\n        for stabPool: VaultData in _priorityStabVaults:\n            if remainingToRepay == 0:\n                break\n\n            if not staticcall Ledger(_a.ledger).isParticipatingInVault(_user, stabPool.vaultId):\n                continue\n\n            remainingToRepay = self._iterateThruAssetsWithinVault(_user, stabPool.vaultId, stabPool.vaultAddr, remainingToRepay, _endaoFunds, _endaomentPsm, _psmYieldPositionToken, _a)\n            if self.vaultAddrs[stabPool.vaultId] == empty(address):\n                self.vaultAddrs[stabPool.vaultId] = stabPool.vaultAddr # cache\n\n    # PHASE 2 -- Go thru priority liq assets (set in mission control)\n\n    if len(_priorityLiqAssetVaults) != 0 and remainingToRepay != 0:\n        for pData: VaultData in _priorityLiqAssetVaults:\n            if remainingToRepay == 0:\n                break\n\n            if not staticcall Vault(pData.vaultAddr).doesUserHaveBalance(_user, pData.asset):\n                continue\n\n            remainingToRepay = self._handleSpecificAsset(_user, pData.vaultId, pData.vaultAddr, pData.asset, remainingToRepay, False, _endaoFunds, _endaomentPsm, _psmYieldPositionToken, _a)\n            if self.vaultAddrs[pData.vaultId] == empty(address):\n                self.vaultAddrs[pData.vaultId] = pData.vaultAddr # cache\n\n    # PHASE 3 -- Go thru user's vaults (top to bottom as saved in ledger / vaults)\n\n    if remainingToRepay != 0:\n        remainingToRepay = self._iterateThruAllUserVaults(_user, remainingToRepay, _endaoFunds, _endaomentPsm, _psmYieldPositionToken, _a)\n\n    return _targetRepayAmount - remainingToRepay\n\n\n# all user vaults\n\n\n@internal\ndef _iterateThruAllUserVaults(\n    _user: address,\n    _remainingToRepay: uint256,\n    _endaoFunds: address,\n    _endaomentPsm: address,\n    _psmYieldPositionToken: address,\n    _a: addys.Addys,\n) -> uint256:\n    numUserVaults: uint256 = staticcall Ledger(_a.ledger).numUserVaults(_user)\n    if numUserVaults == 0:\n        return _remainingToRepay\n\n    remainingToRepay: uint256 = _remainingToRepay\n    for i: uint256 in range(1, numUserVaults, bound=max_value(uint256)):\n        if remainingToRepay == 0:\n            break\n\n        vaultId: uint256 = staticcall Ledger(_a.ledger).userVaults(_user, i)\n\n        # get vault address\n        vaultAddr: address = empty(address)\n        isVaultAddrCached: bool = False\n        vaultAddr, isVaultAddrCached = self._getVaultAddr(vaultId, _a.vaultBook)\n        if vaultAddr == empty(address):\n            continue\n\n        # cache vault addr\n        if not isVaultAddrCached:\n            self.vaultAddrs[vaultId] = vaultAddr\n\n        remainingToRepay = self._iterateThruAssetsWithinVault(_user, vaultId, vaultAddr, remainingToRepay, _endaoFunds, _endaomentPsm, _psmYieldPositionToken, _a)\n\n    return remainingToRepay\n\n\n# all assets within vault\n\n\n@internal\ndef _iterateThruAssetsWithinVault(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _remainingToRepay: uint256,\n    _endaoFunds: address,\n    _endaomentPsm: address,\n    _psmYieldPositionToken: address,\n    _a: addys.Addys,\n) -> uint256:\n\n    # check if we've already handled this vault\n    if self.didHandleVaultId[_user][_vaultId]:\n        return _remainingToRepay\n    self.didHandleVaultId[_user][_vaultId] = True\n\n    # no assets in vault, skip\n    numUserAssets: uint256 = staticcall Vault(_vaultAddr).numUserAssets(_user)\n    if numUserAssets == 0:\n        return _remainingToRepay\n\n    # totals\n    remainingToRepay: uint256 = _remainingToRepay\n    for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n        if remainingToRepay == 0:\n            break\n\n        # check if user still has balance in this asset\n        asset: address = empty(address)\n        hasBalance: bool = False\n        asset, hasBalance = staticcall Vault(_vaultAddr).getUserAssetAtIndexAndHasBalance(_user, y)\n        if asset == empty(address) or not hasBalance:\n            continue\n\n        # handle specific liq asset\n        remainingToRepay = self._handleSpecificAsset(_user, _vaultId, _vaultAddr, asset, remainingToRepay, False, _endaoFunds, _endaomentPsm, _psmYieldPositionToken, _a)\n\n    return remainingToRepay\n\n\n# specific asset\n\n\n@internal\ndef _handleSpecificAsset(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _remainingToRepay: uint256,\n    _volatilesOnly: bool,\n    _endaoFunds: address,\n    _endaomentPsm: address,\n    _psmYieldPositionToken: address,\n    _a: addys.Addys,\n) -> uint256:\n\n    # check if we've already handled this liq asset (cache for next time)\n    if self.didHandleAsset[_user][_vaultId][_asset]:\n        return _remainingToRepay\n    self.didHandleAsset[_user][_vaultId][_asset] = True\n\n    # asset liq config\n    config: AssetLiqConfig = empty(AssetLiqConfig)\n    isConfigCached: bool = False\n    config, isConfigCached = self._getAssetLiqConfig(_asset, _a.missionControl)\n    if not isConfigCached:\n        self.assetLiqConfig[_asset] = config\n\n    # transfer to endaoment funds or psm\n    recipient: address = _endaoFunds\n    if _psmYieldPositionToken != empty(address) and _asset == _psmYieldPositionToken:\n        recipient = _endaomentPsm\n\n    # handle volatile assets only - skip normal deleverage assets (shouldBurnAsPayment or shouldTransferToEndaoment)\n    if _volatilesOnly:\n        if config.shouldBurnAsPayment or config.shouldTransferToEndaoment:\n            return _remainingToRepay\n        return self._transferToEndaoment(_user, _vaultId, _vaultAddr, _asset, _remainingToRepay, recipient, _a)\n\n    # burn stability pool assets (GREEN, sGREEN)\n    if config.shouldBurnAsPayment and _asset in [_a.greenToken, _a.savingsGreen]:\n        return self._burnStabPoolAsset(_user, _vaultId, _vaultAddr, _asset, _remainingToRepay, _a)\n\n    # transfer to endaoment (other stablecoins)\n    if config.shouldTransferToEndaoment:\n        return self._transferToEndaoment(_user, _vaultId, _vaultAddr, _asset, _remainingToRepay, recipient, _a)\n\n    return _remainingToRepay\n\n\n# burn stability pool assets\n\n\n@internal\ndef _burnStabPoolAsset(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _stabAsset: address,\n    _remainingToRepay: uint256,\n    _a: addys.Addys,\n) -> uint256:\n    usdValue: uint256 = 0\n    amountReceived: uint256 = 0\n    isPositionDepleted: bool = False\n    usdValue, amountReceived, isPositionDepleted = self._transferCollateral(_user, self, _vaultAddr, _stabAsset, _remainingToRepay, _a)\n    if usdValue == 0:\n        return _remainingToRepay\n\n    # burn stab asset\n    if _stabAsset == _a.savingsGreen:\n        greenAmount: uint256 = extcall IERC4626(_a.savingsGreen).redeem(amountReceived, self, self) # dev: savings green redeem failed\n        assert extcall GreenToken(_a.greenToken).burn(greenAmount) # dev: failed to burn green\n    else:\n        assert extcall GreenToken(_a.greenToken).burn(amountReceived) # dev: failed to burn green\n\n    log StabAssetBurntDuringDeleverage(\n        user=_user,\n        vaultId=_vaultId,\n        stabAsset=_stabAsset,\n        amountBurned=amountReceived,\n        usdValue=usdValue,\n        isDepleted=isPositionDepleted,\n    )\n    return _remainingToRepay - min(usdValue, _remainingToRepay)\n\n\n# transfer to endaoment\n\n\n@internal\ndef _transferToEndaoment(\n    _user: address,\n    _vaultId: uint256,\n    _vaultAddr: address,\n    _asset: address,\n    _remainingToRepay: uint256,\n    _recipient: address,\n    _a: addys.Addys,\n) -> uint256:\n    collateralUsdValueSent: uint256 = 0\n    collateralAmountSent: uint256 = 0\n    isPositionDepleted: bool = False\n    collateralUsdValueSent, collateralAmountSent, isPositionDepleted = self._transferCollateral(_user, _recipient, _vaultAddr, _asset, _remainingToRepay, _a)\n    if collateralUsdValueSent == 0:\n        return _remainingToRepay\n\n    log EndaomentTransferDuringDeleverage(\n        user=_user,\n        vaultId=_vaultId,\n        asset=_asset,\n        amountSent=collateralAmountSent,\n        usdValue=collateralUsdValueSent,\n        isDepleted=isPositionDepleted\n    )\n    return _remainingToRepay - min(collateralUsdValueSent, _remainingToRepay)\n\n\n#############\n# Utilities #\n#############\n\n\n# deleverage info\n\n\n@view\n@external\ndef getDeleverageInfo(_user: address) -> (uint256, uint256):\n    return self._getDeleverageInfo(_user, addys._getAddys())\n\n\n@view\n@internal\ndef _getDeleverageInfo(_user: address, _a: addys.Addys) -> (uint256, uint256):\n    maxDeleveragableUsd: uint256 = 0\n    ltvSum: uint256 = 0 \n\n    # number of user vaults\n    numUserVaults: uint256 = staticcall Ledger(_a.ledger).numUserVaults(_user)\n    if numUserVaults == 0:\n        return 0, 0\n\n    # iterate through user vaults\n    for i: uint256 in range(1, numUserVaults, bound=max_value(uint256)):\n        vaultId: uint256 = staticcall Ledger(_a.ledger).userVaults(_user, i)\n        vaultAddr: address = staticcall Registry(_a.vaultBook).getAddr(vaultId)\n        if vaultAddr == empty(address):\n            continue\n\n        # number of assets in vault\n        numUserAssets: uint256 = staticcall Vault(vaultAddr).numUserAssets(_user)\n        if numUserAssets == 0:\n            continue\n\n        # iterate through assets\n        for y: uint256 in range(1, numUserAssets, bound=max_value(uint256)):\n            asset: address = empty(address)\n            hasBalance: bool = False\n            asset, hasBalance = staticcall Vault(vaultAddr).getUserAssetAtIndexAndHasBalance(_user, y)\n            if asset == empty(address) or not hasBalance:\n                continue\n\n            # get actual amount from vault\n            amount: uint256 = staticcall Vault(vaultAddr).getTotalAmountForUser(_user, asset)\n            if amount == 0:\n                continue\n\n            # check if asset is deleveragable\n            assetLiqConfig: AssetLiqConfig = staticcall MissionControl(_a.missionControl).getAssetLiqConfig(asset)\n            if not assetLiqConfig.shouldBurnAsPayment and not assetLiqConfig.shouldTransferToEndaoment:\n                continue\n\n            # usd value\n            usdValue: uint256 = staticcall PriceDesk(_a.priceDesk).getUsdValue(asset, amount, True)\n            if usdValue == 0:\n                continue\n\n            maxDeleveragableUsd += usdValue\n\n            # get asset LTV for weighted calculation\n            debtTerms: cs.DebtTerms = staticcall MissionControl(_a.missionControl).getDebtTerms(asset)\n            ltvSum += usdValue * debtTerms.ltv\n\n    # calculate effective weighted LTV\n    effectiveWeightedLtv: uint256 = 0\n    if maxDeleveragableUsd != 0:\n        effectiveWeightedLtv = ltvSum // maxDeleveragableUsd\n\n    return maxDeleveragableUsd, effectiveWeightedLtv\n\n\n# max deleverage amount (when untrusted caller)\n\n\n@view\n@external\ndef getMaxDeleverageAmount(_user: address) -> uint256:\n    a: addys.Addys = addys._getAddys()\n\n    # get latest user debt and terms\n    userDebt: UserDebt = empty(UserDebt)\n    bt: UserBorrowTerms = empty(UserBorrowTerms)\n    na: uint256 = 0\n    userDebt, bt, na = staticcall CreditEngine(a.creditEngine).getLatestUserDebtAndTerms(_user, False, a)\n    if userDebt.amount == 0 or userDebt.inLiquidation or bt.collateralVal == 0:\n        return 0\n\n    if not self._canDeleverageUserDebtPosition(userDebt.amount, bt.collateralVal, bt.debtTerms.redemptionThreshold):\n        return 0\n\n    ltvPaybackBuffer: uint256 = staticcall MissionControl(a.missionControl).getLtvPaybackBuffer()\n\n    # target ltv\n    targetLtv: uint256 = bt.lowestLtv\n    if ltvPaybackBuffer != 0:\n        targetLtv = targetLtv * (HUNDRED_PERCENT - ltvPaybackBuffer) // HUNDRED_PERCENT\n\n    return self._calcAmountToPay(userDebt.amount, bt.collateralVal, targetLtv)\n\n\n@view\n@internal\ndef _calcAmountToPay(_debtAmount: uint256, _collateralValue: uint256, _targetLtv: uint256) -> uint256:\n    # goal here is to only reduce the debt necessary to get LTV back to safe position\n    # it will never be perfectly precise because depending on what assets are taken\n    # to ensure maximum protocol solvency, we will target the user's lowest LTV\n    collValueAdjusted: uint256 =_collateralValue * _targetLtv // HUNDRED_PERCENT\n\n    # collateral value too low\n    if _debtAmount <= collValueAdjusted:\n        return _debtAmount\n\n    debtToRepay: uint256 = (_debtAmount - collValueAdjusted) * HUNDRED_PERCENT // (HUNDRED_PERCENT - _targetLtv)\n    return min(debtToRepay, _debtAmount)\n\n\n@view\n@internal\ndef _canDeleverageUserDebtPosition(_userDebtAmount: uint256, _collateralVal: uint256, _redemptionThreshold: uint256) -> bool:\n    if _redemptionThreshold == 0:\n        return False\n\n    # check if collateral value is below (or equal) to redemption threshold\n    redemptionThreshold: uint256 = _userDebtAmount * HUNDRED_PERCENT // _redemptionThreshold\n    return _collateralVal <= redemptionThreshold\n\n\n# transfer collateral\n\n\n@internal\ndef _transferCollateral(\n    _fromUser: address,\n    _toUser: address,\n    _vaultAddr: address,\n    _asset: address,\n    _targetUsdValue: uint256,\n    _a: addys.Addys,\n) -> (uint256, uint256, bool):\n    isUnderscoreEarnVault: bool = self._isUnderscoreEarnVault(_asset, _a.missionControl)\n    underlyingAsset: address = empty(address)\n    if isUnderscoreEarnVault:\n        underlyingAsset = staticcall IERC4626(_asset).asset()\n\n    # calculate max asset amount\n    maxAssetAmount: uint256 = self._getMaxAssetAmount(_asset, _targetUsdValue, isUnderscoreEarnVault, underlyingAsset, _a.greenToken, _a.savingsGreen, _a.priceDesk)\n    if maxAssetAmount == 0:\n        return 0, 0, False\n\n    # withdraw and transfer to recipient -- AuctionHouse has permissions to perform this\n    amountSent: uint256 = 0\n    isPositionDepleted: bool = False\n    amountSent, isPositionDepleted = extcall AuctionHouse(_a.auctionHouse).withdrawTokensFromVault(_fromUser, _asset, maxAssetAmount, _toUser, _vaultAddr, _a)\n\n    usdValue: uint256 = _targetUsdValue * amountSent // maxAssetAmount\n\n    # For underscore basic earn vault assets, cap max conversion at\n    # convertToAssetsSafe + configured spread so crediting remains bounded.\n    if isUnderscoreEarnVault and amountSent != 0 and underlyingAsset != empty(address):\n        na: uint256 = 0\n        cappedUnderlying: uint256 = 0\n        na, cappedUnderlying = self._getMaxAndCappedUnderlyingForShares(_asset, amountSent)\n        if cappedUnderlying != 0:\n            usdValue = staticcall PriceDesk(_a.priceDesk).getUsdValue(underlyingAsset, cappedUnderlying, True)\n\n    return usdValue, amountSent, isPositionDepleted\n\n\n# underscore address\n\n\n@view\n@internal\ndef _isUnderscoreAddr(_addr: address, _mc: address) -> bool:\n    underscore: address = staticcall MissionControl(_mc).underscoreRegistry()\n    if underscore == empty(address):\n        return False\n\n    # trust underscore earn vaults\n    if self._isUnderscoreEarnVaultWithRegistry(_addr, underscore):\n        return True\n\n    # check if underscore lego\n    undyLegoBook: address = staticcall Registry(underscore).getAddr(UNDERSCORE_LEGOBOOK_ID)\n    if undyLegoBook == empty(address):\n        return False\n    return staticcall Registry(undyLegoBook).isValidAddr(_addr)\n\n\n@view\n@internal\ndef _isUnderscoreEarnVault(_asset: address, _mc: address) -> bool:\n    underscore: address = staticcall MissionControl(_mc).underscoreRegistry()\n    return self._isUnderscoreEarnVaultWithRegistry(_asset, underscore)\n\n\n@view\n@internal\ndef _isUnderscoreEarnVaultWithRegistry(_asset: address, _underscore: address) -> bool:\n    if _underscore == empty(address):\n        return False\n\n    # check if underscore vault\n    vaultRegistry: address = staticcall Registry(_underscore).getAddr(UNDERSCORE_VAULT_REGISTRY_ID)\n    if vaultRegistry == empty(address):\n        return False\n    return staticcall VaultRegistry(vaultRegistry).isBasicEarnVault(_asset)\n\n\n@view\n@internal\ndef _getMaxAndCappedUnderlyingForShares(_asset: address, _shares: uint256) -> (uint256, uint256):\n    maxUnderlying: uint256 = staticcall IERC4626(_asset).convertToAssets(_shares)\n    if maxUnderlying == 0:\n        return 0, 0\n\n    safeUnderlying: uint256 = staticcall UnderscoreVault(_asset).convertToAssetsSafe(_shares)\n    if safeUnderlying == 0:\n        return 0, 0\n\n    maxAllowedUnderlying: uint256 = safeUnderlying * (HUNDRED_PERCENT + self.underscoreSafeSpreadBps) // HUNDRED_PERCENT\n    return maxUnderlying, min(maxUnderlying, maxAllowedUnderlying)\n\n\n# get asset amount\n\n\n@view\n@internal\ndef _getMaxAssetAmount(\n    _asset: address,\n    _targetUsdValue: uint256,\n    _isUnderscoreEarnVault: bool,\n    _underlyingAsset: address,\n    _greenToken: address,\n    _savingsGreen: address,\n    _priceDesk: address,\n) -> uint256:\n    amount: uint256 = 0\n    if _asset == _greenToken:\n        amount = _targetUsdValue\n    elif _asset == _savingsGreen:\n        amount = staticcall IERC4626(_savingsGreen).convertToShares(_targetUsdValue)\n    elif _isUnderscoreEarnVault:\n\n        if _underlyingAsset == empty(address):\n            return 0\n        underlyingAmount: uint256 = staticcall PriceDesk(_priceDesk).getAssetAmount(_underlyingAsset, _targetUsdValue, True)\n        adjustedUnderlyingAmount: uint256 = underlyingAmount\n\n        # Compare max vs capped value for one whole-share unit.\n        # Using a fixed share unit avoids noisy tiny-amount rounding.\n        sampleShareUnit: uint256 = 10 ** convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n        maxSampleUnderlying: uint256 = 0\n        cappedSampleUnderlying: uint256 = 0\n        maxSampleUnderlying, cappedSampleUnderlying = self._getMaxAndCappedUnderlyingForShares(_asset, sampleShareUnit)\n        if maxSampleUnderlying > cappedSampleUnderlying and cappedSampleUnderlying != 0:\n            # ceil(a / b) = (a + b - 1) // b\n            adjustedUnderlyingAmount = (underlyingAmount * maxSampleUnderlying + cappedSampleUnderlying - 1) // cappedSampleUnderlying\n\n        amount = staticcall IERC4626(_asset).convertToShares(adjustedUnderlyingAmount)\n    else:\n        amount = staticcall PriceDesk(_priceDesk).getAssetAmount(_asset, _targetUsdValue, True)\n    return amount\n\n\n# cache tools\n\n\n@view\n@internal\ndef _getAssetLiqConfig(_asset: address, _missionControl: address) -> (AssetLiqConfig, bool):\n    config: AssetLiqConfig = self.assetLiqConfig[_asset]\n    if config.hasConfig:\n        return config, True\n    return staticcall MissionControl(_missionControl).getAssetLiqConfig(_asset), False\n\n\n@view\n@internal\ndef _getVaultAddr(_vaultId: uint256, _vaultBook: address) -> (address, bool):\n    vaultAddr: address = self.vaultAddrs[_vaultId]\n    if vaultAddr != empty(address):\n        return vaultAddr, True\n    return staticcall Registry(_vaultBook).getAddr(_vaultId), False\n\n\n# deleverage params\n\n\n@external\ndef setMinDeleverageBps(_bps: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: only switchboard allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    assert _bps <= HUNDRED_PERCENT # dev: invalid bps\n    self.minDeleverageBps = _bps\n    log MinDeleverageBpsSet(bps=_bps)\n\n\n@external\ndef setDeleverageBuffer(_bps: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: only switchboard allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    assert _bps <= HUNDRED_PERCENT # dev: invalid bps\n    self.deleverageBuffer = _bps\n    log DeleverageBufferSet(bps=_bps)\n\n\n@external\ndef setDeleverageCooldown(_blocks: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: only switchboard allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    assert _blocks <= MAX_COOLDOWN_BLOCKS # dev: cooldown too large\n    self.deleverageCooldown = _blocks\n    log DeleverageCooldownSet(blocks=_blocks)\n\n\n@external\ndef setUnderscoreSafeSpreadBps(_bps: uint256):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: only switchboard allowed\n    assert not deptBasics.isPaused # dev: contract paused\n    assert _bps <= MAX_UNDERSCORE_SAFE_SPREAD_BPS # dev: exceeds hard ceiling\n    self.underscoreSafeSpreadBps = _bps\n    log UnderscoreSafeSpreadBpsSet(bps=_bps)\n",
            "sha256sum": "378068a1243ce48936c23f0301c5a700aef020e87f22e0a8010388629b5c591d"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/core/Deleverage.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "1840a44769e857afb0ccbf2a4380a174de76ae27bfc91a8f4afbf769055b76aa"
      },
      "args": "0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b",
      "file": "contracts/core/Deleverage.vy"
    },
    "SwitchboardDelta": {
      "address": "0x028c32A2075406157f2778eAC94a705aE7d01Fea",
      "abi": [
        {
          "name": "PendingHrContribTemplateChange",
          "inputs": [
            {
              "name": "contribTemplate",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingHrMaxCompensationChange",
          "inputs": [
            {
              "name": "maxCompensation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingHrMinCliffLengthChange",
          "inputs": [
            {
              "name": "minCliffLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingHrMaxStartDelayChange",
          "inputs": [
            {
              "name": "maxStartDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingHrVestingLengthBoundariesChange",
          "inputs": [
            {
              "name": "minVestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxVestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingManagerSet",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "manager",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingCancelPaycheckSet",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeCheckCashedFromSwitchboard",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cashedBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeTransferCancelledFromSwitchboard",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "OwnershipChangeCancelledFromSwitchboard",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "cancelledBy",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ContributorFrozenFromSwitchboard",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "frozenBy",
              "type": "address",
              "indexed": true
            },
            {
              "name": "shouldFreeze",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeBondConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountPerEpoch",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxRipePerUnitLockBonus",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shouldAutoRestart",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "restartDelayBlocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeBondEpochLengthSet",
          "inputs": [
            {
              "name": "epochLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "CanPurchaseRipeBondModified",
          "inputs": [
            {
              "name": "canPurchaseRipeBond",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "modifier",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingBadDebtSet",
          "inputs": [
            {
              "name": "badDebt",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingBondBoosterSet",
          "inputs": [
            {
              "name": "bondBooster",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingBoosterBoundariesSet",
          "inputs": [
            {
              "name": "maxBoostRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUnits",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BoosterMinLockDurationSet",
          "inputs": [
            {
              "name": "minLockDuration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingBoosterConfigsSet",
          "inputs": [
            {
              "name": "numBoosters",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ManyBondBoostersRemoved",
          "inputs": [
            {
              "name": "numUsers",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BondBoosterRemoved",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingBoosterConfigSet",
          "inputs": [
            {
              "name": "user",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrContribTemplateSet",
          "inputs": [
            {
              "name": "contribTemplate",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrMaxCompensationSet",
          "inputs": [
            {
              "name": "maxCompensation",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrMinCliffLengthSet",
          "inputs": [
            {
              "name": "minCliffLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrMaxStartDelaySet",
          "inputs": [
            {
              "name": "maxStartDelay",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrVestingLengthBoundariesSet",
          "inputs": [
            {
              "name": "minVestingLength",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxVestingLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrContributorManagerSet",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            },
            {
              "name": "manager",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "HrContributorCancelPaycheckSet",
          "inputs": [
            {
              "name": "contributor",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBondConfigSet",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "amountPerEpoch",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "minRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxRipePerUnit",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxRipePerUnitLockBonus",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "shouldAutoRestart",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBondEpochLengthSet",
          "inputs": [
            {
              "name": "epochLength",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBondStartEpochAtBlockSet",
          "inputs": [
            {
              "name": "startBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BadDebtSet",
          "inputs": [
            {
              "name": "badDebt",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeBondBoosterSet",
          "inputs": [
            {
              "name": "bondBooster",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ManyBondBoostersSet",
          "inputs": [
            {
              "name": "numBoosters",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "BoosterBoundariesSet",
          "inputs": [
            {
              "name": "maxBoostRatio",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUnits",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingUserBalanceResetSet",
          "inputs": [
            {
              "name": "numResets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingAssetResetSet",
          "inputs": [
            {
              "name": "numResets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserBalanceResetExecuted",
          "inputs": [
            {
              "name": "numResets",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "AssetResetExecuted",
          "inputs": [
            {
              "name": "numResets",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingUserBorrowResetSet",
          "inputs": [
            {
              "name": "numResets",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UserBorrowResetExecuted",
          "inputs": [
            {
              "name": "numResets",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeAvailableForRewardsChange",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeAvailableForHrChange",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingRipeAvailableForBondsChange",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeAvailableForRewardsSet",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeAvailableForHrSet",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeAvailableForBondsSet",
          "inputs": [
            {
              "name": "amount",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingUnderscoreRegistryChange",
          "inputs": [
            {
              "name": "underscoreRegistry",
              "type": "address",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingShouldCheckLastTouchChange",
          "inputs": [
            {
              "name": "shouldCheck",
              "type": "bool",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UnderscoreRegistrySet",
          "inputs": [
            {
              "name": "addr",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ShouldCheckLastTouchSet",
          "inputs": [
            {
              "name": "shouldCheck",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingMinDeleverageBpsChange",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "MinDeleverageBpsSet",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingDeleverageBufferChange",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DeleverageBufferSet",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingDeleverageCooldownChange",
          "inputs": [
            {
              "name": "blocks",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DeleverageCooldownSet",
          "inputs": [
            {
              "name": "blocks",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PendingUnderscoreSafeSpreadBpsChange",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "UnderscoreSafeSpreadBpsSet",
          "inputs": [
            {
              "name": "bps",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageUser",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_targetRepayAmount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageManyUsers",
          "inputs": [
            {
              "name": "_users",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageWithSpecificAssets",
          "inputs": [
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            },
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "deleverageWithVolAssets",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "vaultId",
                  "type": "uint256"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "targetRepayAmount",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMinDeleverageBps",
          "inputs": [
            {
              "name": "_bps",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDeleverageBuffer",
          "inputs": [
            {
              "name": "_bps",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setDeleverageCooldown",
          "inputs": [
            {
              "name": "_blocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUnderscoreSafeSpreadBps",
          "inputs": [
            {
              "name": "_bps",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setContributorTemplate",
          "inputs": [
            {
              "name": "_contribTemplate",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setContributorTemplate",
          "inputs": [
            {
              "name": "_contribTemplate",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxCompensation",
          "inputs": [
            {
              "name": "_maxComp",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxCompensation",
          "inputs": [
            {
              "name": "_maxComp",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMinCliffLength",
          "inputs": [
            {
              "name": "_minCliffLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMinCliffLength",
          "inputs": [
            {
              "name": "_minCliffLength",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxStartDelay",
          "inputs": [
            {
              "name": "_maxStartDelay",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setMaxStartDelay",
          "inputs": [
            {
              "name": "_maxStartDelay",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setVestingLengthBoundaries",
          "inputs": [
            {
              "name": "_minVestingLength",
              "type": "uint256"
            },
            {
              "name": "_maxVestingLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setVestingLengthBoundaries",
          "inputs": [
            {
              "name": "_minVestingLength",
              "type": "uint256"
            },
            {
              "name": "_maxVestingLength",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPaycheckForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManagerForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            },
            {
              "name": "_manager",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cashRipeCheckForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelRipeTransferForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelOwnershipChangeForContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "freezeContributor",
          "inputs": [
            {
              "name": "_contributor",
              "type": "address"
            },
            {
              "name": "_shouldFreeze",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeBondConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amountPerEpoch",
              "type": "uint256"
            },
            {
              "name": "_minRipePerUnit",
              "type": "uint256"
            },
            {
              "name": "_maxRipePerUnit",
              "type": "uint256"
            },
            {
              "name": "_maxRipePerUnitLockBonus",
              "type": "uint256"
            },
            {
              "name": "_shouldAutoRestart",
              "type": "bool"
            },
            {
              "name": "_restartDelayBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeBondConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_amountPerEpoch",
              "type": "uint256"
            },
            {
              "name": "_minRipePerUnit",
              "type": "uint256"
            },
            {
              "name": "_maxRipePerUnit",
              "type": "uint256"
            },
            {
              "name": "_maxRipePerUnitLockBonus",
              "type": "uint256"
            },
            {
              "name": "_shouldAutoRestart",
              "type": "bool"
            },
            {
              "name": "_restartDelayBlocks",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeBondEpochLength",
          "inputs": [
            {
              "name": "_epochLength",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeBondEpochLength",
          "inputs": [
            {
              "name": "_epochLength",
              "type": "uint256"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStartEpochAtBlock",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setStartEpochAtBlock",
          "inputs": [
            {
              "name": "_block",
              "type": "uint256"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPurchaseRipeBond",
          "inputs": [
            {
              "name": "_canBond",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setCanPurchaseRipeBond",
          "inputs": [
            {
              "name": "_canBond",
              "type": "bool"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBadDebt",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeAvailableForRewards",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeAvailableForHr",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeAvailableForBonds",
          "inputs": [
            {
              "name": "_amount",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUnderscoreRegistry",
          "inputs": [
            {
              "name": "_underscoreRegistry",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setUnderscoreRegistry",
          "inputs": [
            {
              "name": "_underscoreRegistry",
              "type": "address"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldCheckLastTouch",
          "inputs": [
            {
              "name": "_shouldCheck",
              "type": "bool"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setShouldCheckLastTouch",
          "inputs": [
            {
              "name": "_shouldCheck",
              "type": "bool"
            },
            {
              "name": "_missionControl",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setRipeBondBooster",
          "inputs": [
            {
              "name": "_bondBooster",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setManyBondBoosters",
          "inputs": [
            {
              "name": "_boosters",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "boostRatio",
                  "type": "uint256"
                },
                {
                  "name": "maxUnitsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "expireBlock",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBondBooster",
          "inputs": [
            {
              "name": "_config",
              "type": "tuple",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "boostRatio",
                  "type": "uint256"
                },
                {
                  "name": "maxUnitsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "expireBlock",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeManyBondBoosters",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "removeBondBooster",
          "inputs": [
            {
              "name": "_user",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBoosterBoundaries",
          "inputs": [
            {
              "name": "_maxBoostRatio",
              "type": "uint256"
            },
            {
              "name": "_maxUnits",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setBoosterMinLockDuration",
          "inputs": [
            {
              "name": "_minLockDuration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "resetManyUserBalancePoints",
          "inputs": [
            {
              "name": "_users",
              "type": "tuple[]",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "resetManyAssetPoints",
          "inputs": [
            {
              "name": "_assets",
              "type": "tuple[]",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                }
              ]
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "resetManyUserBorrowPoints",
          "inputs": [
            {
              "name": "_users",
              "type": "address[]"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "executePendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPendingAction",
          "inputs": [
            {
              "name": "_aid",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionType",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingHrConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contribTemplate",
                  "type": "address"
                },
                {
                  "name": "maxCompensation",
                  "type": "uint256"
                },
                {
                  "name": "minCliffLength",
                  "type": "uint256"
                },
                {
                  "name": "maxStartDelay",
                  "type": "uint256"
                },
                {
                  "name": "minVestingLength",
                  "type": "uint256"
                },
                {
                  "name": "maxVestingLength",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingManager",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "contributor",
                  "type": "address"
                },
                {
                  "name": "pendingManager",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingCancelPaycheck",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRipeBondConfig",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "amountPerEpoch",
                  "type": "uint256"
                },
                {
                  "name": "canBond",
                  "type": "bool"
                },
                {
                  "name": "minRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnit",
                  "type": "uint256"
                },
                {
                  "name": "maxRipePerUnitLockBonus",
                  "type": "uint256"
                },
                {
                  "name": "epochLength",
                  "type": "uint256"
                },
                {
                  "name": "shouldAutoRestart",
                  "type": "bool"
                },
                {
                  "name": "restartDelayBlocks",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRipeBondConfigValue",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingBondBooster",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingBoosterConfigs",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "boostRatio",
                  "type": "uint256"
                },
                {
                  "name": "maxUnitsAllowed",
                  "type": "uint256"
                },
                {
                  "name": "expireBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingBoosterBoundaries",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "maxBoostRatio",
                  "type": "uint256"
                },
                {
                  "name": "maxUnits",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUserBalanceReset",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "user",
                  "type": "address"
                },
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingAssetReset",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "asset",
                  "type": "address"
                },
                {
                  "name": "vaultId",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUserBorrowReset",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingRipeAvailable",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUnderscoreRegistry",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingShouldCheckLastTouch",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingMinDeleverageBps",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingDeleverageBuffer",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingDeleverageCooldown",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingUnderscoreSafeSpreadBps",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingMissionControl",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_tempGov",
              "type": "address"
            },
            {
              "name": "_minConfigTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxConfigTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isRipeHqGov() # dev: ripe hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "4ffcc0fe78019515e484beb8bd5d700dce92d785b6bf26af25f52ea1289a5950"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "2c45da650f92c6891ed37a165a365934d31ed144b03e13c79f4f4fc68f2b7851"
          },
          "interfaces/ConfigStructs.vyi": {
            "content": "# @version 0.4.3\n\nMAX_VAULTS_PER_ASSET: constant(uint256) = 10\n\nstruct GenConfig:\n    perUserMaxVaults: uint256\n    perUserMaxAssetsPerVault: uint256\n    priceStaleTime: uint256\n    canDeposit: bool\n    canWithdraw: bool\n    canBorrow: bool\n    canRepay: bool\n    canClaimLoot: bool\n    canLiquidate: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n\nstruct GenDebtConfig:\n    perUserDebtLimit: uint256\n    globalDebtLimit: uint256\n    minDebtAmount: uint256\n    numAllowedBorrowers: uint256\n    maxBorrowPerInterval: uint256\n    numBlocksPerInterval: uint256\n    minDynamicRateBoost: uint256\n    maxDynamicRateBoost: uint256\n    increasePerDangerBlock: uint256\n    maxBorrowRate: uint256\n    maxLtvDeviation: uint256\n    keeperFeeRatio: uint256\n    minKeeperFee: uint256\n    maxKeeperFee: uint256\n    isDaowryEnabled: bool\n    ltvPaybackBuffer: uint256\n    genAuctionParams: AuctionParams\n\nstruct HrConfig:\n    contribTemplate: address\n    maxCompensation: uint256\n    minCliffLength: uint256\n    maxStartDelay: uint256\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nstruct RipeBondConfig:\n    asset: address\n    amountPerEpoch: uint256\n    canBond: bool\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    epochLength: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n\nstruct RipeRewardsConfig:\n    arePointsEnabled: bool\n    ripePerBlock: uint256\n    borrowersAlloc: uint256\n    stakersAlloc: uint256\n    votersAlloc: uint256\n    genDepositorsAlloc: uint256\n    autoStakeRatio: uint256\n    autoStakeDurationRatio: uint256\n    stabPoolRipePerDollarClaimed: uint256\n\nstruct RipeGovVaultConfig:\n    lockTerms: LockTerms\n    assetWeight: uint256\n    shouldFreezeWhenBadDebt: bool\n\nstruct LockTerms:\n    minLockDuration: uint256\n    maxLockDuration: uint256\n    maxLockBoost: uint256\n    canExit: bool\n    exitFee: uint256\n\nstruct AuctionParams:\n    hasParams: bool\n    startDiscount: uint256\n    maxDiscount: uint256\n    delay: uint256\n    duration: uint256\n\nstruct AssetConfig:\n    vaultIds: DynArray[uint256, MAX_VAULTS_PER_ASSET]\n    stakersPointsAlloc: uint256\n    voterPointsAlloc: uint256\n    perUserDepositLimit: uint256\n    globalDepositLimit: uint256\n    minDepositBalance: uint256\n    debtTerms: DebtTerms\n    shouldBurnAsPayment: bool\n    shouldTransferToEndaoment: bool\n    shouldSwapInStabPools: bool\n    shouldAuctionInstantly: bool\n    canDeposit: bool\n    canWithdraw: bool\n    canRedeemCollateral: bool\n    canRedeemInStabPool: bool\n    canBuyInAuction: bool\n    canClaimInStabPool: bool\n    specialStabPoolId: uint256\n    customAuctionParams: AuctionParams\n    whitelist: address\n    isNft: bool\n\nstruct DebtTerms:\n    ltv: uint256\n    redemptionThreshold: uint256\n    liqThreshold: uint256\n    liqFee: uint256\n    borrowRate: uint256\n    daowry: uint256\n\nstruct UserConfig:\n    canAnyoneDeposit: bool\n    canAnyoneRepayDebt: bool\n    canAnyoneBondForUser: bool\n\nstruct ActionDelegation:\n    canWithdraw: bool\n    canBorrow: bool\n    canClaimFromStabPool: bool\n    canClaimLoot: bool\n\nstruct VaultLite:\n    vaultId: uint256\n    asset: address\n\nstruct AssetConfigEntry:\n    asset: address\n    config: AssetConfig\n\nstruct RipeGovVaultConfigEntry:\n    asset: address\n    config: RipeGovVaultConfig",
            "sha256sum": "def6208cd81de43d0d33656f9d05b5394d3a74c695fdc27ffe3c9711ccd67c2c"
          },
          "contracts/config/SwitchboardDelta.vy": {
            "content": "#        ______   __     __   __   ______  ______   __  __   ______   ______   ______   ______   _____    \n#       /\\  ___\\ /\\ \\  _ \\ \\ /\\ \\ /\\__  _\\/\\  ___\\ /\\ \\_\\ \\ /\\  == \\ /\\  __ \\ /\\  __ \\ /\\  == \\ /\\  __-.  \n#       \\ \\___  \\\\ \\ \\/ \".\\ \\\\ \\ \\\\/_/\\ \\/\\ \\ \\____\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\\\ \\  __ \\\\ \\  __< \\ \\ \\/\\ \\ \n#        \\/\\_____\\\\ \\__/\".~\\_\\\\ \\_\\  \\ \\_\\ \\ \\_____\\\\ \\_\\ \\_\\\\ \\_____\\\\ \\_____\\\\ \\_\\ \\_\\\\ \\_\\ \\_\\\\ \\____- \n#         \\/_____/ \\/_/   \\/_/ \\/_/   \\/_/  \\/_____/ \\/_/\\/_/ \\/_____/ \\/_____/ \\/_/\\/_/ \\/_/ /_/ \\/____/ \n#                                                      \u2513  \u2513   \n#                                                     \u250f\u252b\u250f\u2513\u2503\u254b\u250f\u2513\n#                                                     \u2517\u253b\u2517 \u2517\u2517\u2517\u253b\n#\n#      Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n#      Ripe Foundation (C) 2025 \n\n# @version 0.4.3\n# pragma optimize codesize\n\nexports: gov.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.TimeLock as timeLock\nimport interfaces.ConfigStructs as cs\n\ninterface MissionControl:\n    def setUnderscoreRegistry(_underscoreRegistry: address): nonpayable\n    def setRipeBondConfig(_config: cs.RipeBondConfig): nonpayable\n    def setShouldCheckLastTouch(_shouldCheck: bool): nonpayable\n    def canPerformLiteAction(_user: address) -> bool: view\n    def setHrConfig(_config: cs.HrConfig): nonpayable\n    def ripeBondConfig() -> cs.RipeBondConfig: view\n    def underscoreRegistry() -> address: view\n    def shouldCheckLastTouch() -> bool: view\n    def hrConfig() -> cs.HrConfig: view\n\ninterface BondBooster:\n    def setManyBondBoosters(_boosters: DynArray[BoosterConfig, MAX_BOOSTERS]): nonpayable\n    def setMaxBoostAndMaxUnits(_maxBoostRatio: uint256, _maxUnits: uint256): nonpayable\n    def removeManyBondBoosters(_users: DynArray[address, MAX_BOOSTERS]): nonpayable\n    def getBoostRatio(_user: address, _units: uint256) -> uint256: view\n    def setMinLockDuration(_minLockDuration: uint256): nonpayable\n    def setBondBooster(_config: BoosterConfig): nonpayable\n    def removeBondBooster(_user: address): nonpayable\n\ninterface HrContributor:\n    def setIsFrozen(_shouldFreeze: bool) -> bool: nonpayable\n    def setManager(_manager: address): nonpayable\n    def cashRipeCheck() -> uint256: nonpayable\n    def cancelOwnershipChange(): nonpayable\n    def cancelRipeTransfer(): nonpayable\n    def cancelPaycheck(): nonpayable\n\ninterface Deleverage:\n    def deleverageWithVolAssets(_user: address, _assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS]) -> uint256: nonpayable\n    def setUnderscoreSafeSpreadBps(_bps: uint256): nonpayable\n    def setDeleverageCooldown(_blocks: uint256): nonpayable\n    def setMinDeleverageBps(_bps: uint256): nonpayable\n    def setDeleverageBuffer(_bps: uint256): nonpayable\n\ninterface Ledger:\n    def isHrContributor(_contributor: address) -> bool: view\n    def setRipeAvailForRewards(_amount: uint256): nonpayable\n    def setRipeAvailForBonds(_amount: uint256): nonpayable\n    def setRipeAvailForHr(_amount: uint256): nonpayable\n    def setBadDebt(_amount: uint256): nonpayable\n\ninterface Teller:\n    def deleverageWithSpecificAssets(_assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS], _user: address = msg.sender) -> uint256: nonpayable\n    def deleverageUser(_user: address = msg.sender, _targetRepayAmount: uint256 = max_value(uint256)) -> uint256: nonpayable\n    def deleverageManyUsers(_users: DynArray[DeleverageUserRequest, MAX_DELEVERAGE_USERS]) -> uint256: nonpayable\n\ninterface Lootbox:\n    def resetUserBalancePoints(_user: address, _asset: address, _vaultId: uint256): nonpayable\n    def resetAssetPoints(_asset: address, _vaultId: uint256): nonpayable\n    def resetUserBorrowPoints(_user: address): nonpayable\n\ninterface BondRoom:\n    def startBondEpochAtBlock(_block: uint256): nonpayable\n    def setBondBooster(_bondBooster: address): nonpayable\n    def bondBooster() -> address: view\n\ninterface UnderscoreLedger:\n    def isUserWallet(_addr: address) -> bool: view\n\ninterface UnderscoreRegistry:\n    def getAddr(_addyId: uint256) -> address: view\n\ninterface RipeHq:\n    def getAddr(_regId: uint256) -> address: view\n\nflag ActionType:\n    HR_CONFIG_TEMPLATE\n    HR_CONFIG_MAX_COMP\n    HR_CONFIG_MIN_CLIFF\n    HR_CONFIG_MAX_START_DELAY\n    HR_CONFIG_VESTING\n    HR_MANAGER\n    HR_CANCEL_PAYCHECK\n    RIPE_BOND_CONFIG\n    RIPE_BOND_EPOCH_LENGTH\n    RIPE_BAD_DEBT\n    RIPE_BOND_BOOSTER\n    BOND_BOOSTER_ADD\n    BOND_BOOSTER_BOUNDARIES\n    LOOT_USER_BALANCE_RESET\n    LOOT_ASSET_RESET\n    LOOT_USER_BORROW_RESET\n    RIPE_AVAIL_REWARDS\n    RIPE_AVAIL_HR\n    RIPE_AVAIL_BONDS\n    OTHER_UNDERSCORE_REGISTRY\n    OTHER_SHOULD_CHECK_LAST_TOUCH\n    DELEVERAGE_MIN_BPS\n    DELEVERAGE_BUFFER\n    DELEVERAGE_COOLDOWN\n    DELEVERAGE_UNDERSCORE_SAFE_SPREAD\n\nstruct DeleverageUserRequest:\n    user: address\n    targetRepayAmount: uint256\n\nstruct DeleverageAsset:\n    vaultId: uint256\n    asset: address\n    targetRepayAmount: uint256\n\nstruct PendingManager:\n    contributor: address\n    pendingManager: address\n\nstruct PendingCancelPaycheck:\n    contributor: address\n    pendingShouldCancel: bool\n\nstruct BoosterConfig:\n    user: address\n    boostRatio: uint256\n    maxUnitsAllowed: uint256\n    expireBlock: uint256\n\nstruct UserBalanceReset:\n    user: address\n    asset: address\n    vaultId: uint256\n\nstruct AssetReset:\n    asset: address\n    vaultId: uint256\n\nstruct BoosterBoundaries:\n    maxBoostRatio: uint256\n    maxUnits: uint256\n\nevent PendingHrContribTemplateChange:\n    contribTemplate: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingHrMaxCompensationChange:\n    maxCompensation: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingHrMinCliffLengthChange:\n    minCliffLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingHrMaxStartDelayChange:\n    maxStartDelay: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingHrVestingLengthBoundariesChange:\n    minVestingLength: uint256\n    maxVestingLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingManagerSet:\n    contributor: indexed(address)\n    manager: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingCancelPaycheckSet:\n    contributor: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent RipeCheckCashedFromSwitchboard:\n    contributor: indexed(address)\n    cashedBy: indexed(address)\n    amount: uint256\n\nevent RipeTransferCancelledFromSwitchboard:\n    contributor: indexed(address)\n    cancelledBy: indexed(address)\n\nevent OwnershipChangeCancelledFromSwitchboard:\n    contributor: indexed(address)\n    cancelledBy: indexed(address)\n\nevent ContributorFrozenFromSwitchboard:\n    contributor: indexed(address)\n    frozenBy: indexed(address)\n    shouldFreeze: bool\n\nevent PendingRipeBondConfigSet:\n    asset: indexed(address)\n    amountPerEpoch: uint256\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    shouldAutoRestart: bool\n    restartDelayBlocks: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRipeBondEpochLengthSet:\n    epochLength: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent CanPurchaseRipeBondModified:\n    canPurchaseRipeBond: bool\n    modifier: indexed(address)\n\nevent PendingBadDebtSet:\n    badDebt: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingBondBoosterSet:\n    bondBooster: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingBoosterBoundariesSet:\n    maxBoostRatio: uint256\n    maxUnits: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent BoosterMinLockDurationSet:\n    minLockDuration: uint256\n\nevent PendingBoosterConfigsSet:\n    numBoosters: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent ManyBondBoostersRemoved:\n    numUsers: uint256\n\nevent BondBoosterRemoved:\n    user: indexed(address)\n\nevent PendingBoosterConfigSet:\n    user: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent HrContribTemplateSet:\n    contribTemplate: indexed(address)\n\nevent HrMaxCompensationSet:\n    maxCompensation: uint256\n\nevent HrMinCliffLengthSet:\n    minCliffLength: uint256\n\nevent HrMaxStartDelaySet:\n    maxStartDelay: uint256\n\nevent HrVestingLengthBoundariesSet:\n    minVestingLength: uint256\n    maxVestingLength: uint256\n\nevent HrContributorManagerSet:\n    contributor: indexed(address)\n    manager: indexed(address)\n\nevent HrContributorCancelPaycheckSet:\n    contributor: indexed(address)\n\nevent RipeBondConfigSet:\n    asset: indexed(address)\n    amountPerEpoch: uint256\n    minRipePerUnit: uint256\n    maxRipePerUnit: uint256\n    maxRipePerUnitLockBonus: uint256\n    shouldAutoRestart: bool\n\nevent RipeBondEpochLengthSet:\n    epochLength: uint256\n\nevent RipeBondStartEpochAtBlockSet:\n    startBlock: uint256\n\nevent BadDebtSet:\n    badDebt: uint256\n\nevent RipeBondBoosterSet:\n    bondBooster: indexed(address)\n\nevent ManyBondBoostersSet:\n    numBoosters: uint256\n\nevent BoosterBoundariesSet:\n    maxBoostRatio: uint256\n    maxUnits: uint256\n\nevent PendingUserBalanceResetSet:\n    numResets: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingAssetResetSet:\n    numResets: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent UserBalanceResetExecuted:\n    numResets: uint256\n\nevent AssetResetExecuted:\n    numResets: uint256\n\nevent PendingUserBorrowResetSet:\n    numResets: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent UserBorrowResetExecuted:\n    numResets: uint256\n\nevent PendingRipeAvailableForRewardsChange:\n    amount: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRipeAvailableForHrChange:\n    amount: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingRipeAvailableForBondsChange:\n    amount: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent RipeAvailableForRewardsSet:\n    amount: uint256\n\nevent RipeAvailableForHrSet:\n    amount: uint256\n\nevent RipeAvailableForBondsSet:\n    amount: uint256\n\nevent PendingUnderscoreRegistryChange:\n    underscoreRegistry: address\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PendingShouldCheckLastTouchChange:\n    shouldCheck: bool\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent UnderscoreRegistrySet:\n    addr: indexed(address)\n\nevent ShouldCheckLastTouchSet:\n    shouldCheck: bool\n\nevent PendingMinDeleverageBpsChange:\n    bps: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent MinDeleverageBpsSet:\n    bps: uint256\n\nevent PendingDeleverageBufferChange:\n    bps: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent DeleverageBufferSet:\n    bps: uint256\n\nevent PendingDeleverageCooldownChange:\n    blocks: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent DeleverageCooldownSet:\n    blocks: uint256\n\nevent PendingUnderscoreSafeSpreadBpsChange:\n    bps: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent UnderscoreSafeSpreadBpsSet:\n    bps: uint256\n\n# pending config changes\nactionType: public(HashMap[uint256, ActionType]) # aid -> type\npendingHrConfig: public(HashMap[uint256, cs.HrConfig]) # aid -> config\npendingManager: public(HashMap[uint256, PendingManager]) # aid -> pending manager\npendingCancelPaycheck: public(HashMap[uint256, address]) # aid -> contributor\npendingRipeBondConfig: public(HashMap[uint256, cs.RipeBondConfig]) # aid -> config\npendingRipeBondConfigValue: public(HashMap[uint256, uint256]) # aid -> block\npendingBondBooster: public(HashMap[uint256, address]) # aid -> bond booster\npendingBoosterConfigs: public(HashMap[uint256, DynArray[BoosterConfig, MAX_BOOSTERS]]) # aid -> configs\npendingBoosterBoundaries: public(HashMap[uint256, BoosterBoundaries]) # aid -> boundaries\npendingUserBalanceReset: public(HashMap[uint256, DynArray[UserBalanceReset, MAX_USERS]]) # aid -> users\npendingAssetReset: public(HashMap[uint256, DynArray[AssetReset, MAX_ASSETS]]) # aid -> assets\npendingUserBorrowReset: public(HashMap[uint256, DynArray[address, MAX_USERS]]) # aid -> users\npendingRipeAvailable: public(HashMap[uint256, uint256]) # aid -> amount\npendingUnderscoreRegistry: public(HashMap[uint256, address])\npendingShouldCheckLastTouch: public(HashMap[uint256, bool])\npendingMinDeleverageBps: public(HashMap[uint256, uint256]) # aid -> bps\npendingDeleverageBuffer: public(HashMap[uint256, uint256]) # aid -> bps\npendingDeleverageCooldown: public(HashMap[uint256, uint256]) # aid -> blocks\npendingUnderscoreSafeSpreadBps: public(HashMap[uint256, uint256]) # aid -> bps\npendingMissionControl: public(HashMap[uint256, address]) # aid -> target mission control\n\nTELLER_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nUNDERSCORE_LEDGER_ID: constant(uint256) = 1\nBOND_ROOM_ID: constant(uint256) = 12\nLOOTBOX_ID: constant(uint256) = 16\nDELEVERAGE_ID: constant(uint256) = 18\nEIGHTEEN_DECIMALS: constant(uint256) = 10 ** 18\nMAX_BOOSTERS: constant(uint256) = 50\nHUNDRED_PERCENT: constant(uint256) = 100_00\nMAX_USERS: constant(uint256) = 40\nMAX_ASSETS: constant(uint256) = 20\nMAX_DELEVERAGE_USERS: constant(uint256) = 25\nMAX_DELEVERAGE_ASSETS: constant(uint256) = 25\nMAX_COOLDOWN_BLOCKS: constant(uint256) = 7_200 # ~1 day at 12s/block\nMAX_UNDERSCORE_SAFE_SPREAD_BPS: constant(uint256) = 500 # 5% hard ceiling\n\n# timestamp units (not blocks!)\nDAY_IN_SECONDS: constant(uint256) = 60 * 60 * 24\nWEEK_IN_SECONDS: constant(uint256) = 7 * DAY_IN_SECONDS\nMONTH_IN_SECONDS: constant(uint256) = 30 * DAY_IN_SECONDS\nYEAR_IN_SECONDS: constant(uint256) = 365 * DAY_IN_SECONDS\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _tempGov: address,\n    _minConfigTimeLock: uint256,\n    _maxConfigTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, _tempGov, 0, 0, 0)\n    timeLock.__init__(_minConfigTimeLock, _maxConfigTimeLock, 0, _maxConfigTimeLock)\n\n\n# access control\n\n\n@view\n@internal\ndef _hasPermsToEnable(_caller: address, _isLite: bool) -> bool:\n    if gov._canGovern(_caller):\n        return True\n    if _isLite:\n        return staticcall MissionControl(self._getMissionControlAddr()).canPerformLiteAction(_caller)\n    return False\n\n\n# addys lite\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(MISSION_CONTROL_ID)\n\n\n@view\n@internal\ndef _resolveMissionControl(_missionControl: address) -> address:\n    mc: address = self._getMissionControlAddr()\n    if _missionControl == empty(address):\n        return mc\n    assert _missionControl != mc # dev: use empty for current mission control\n    return _missionControl\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(LEDGER_ID)\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(TELLER_ID)\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(BOND_ROOM_ID)\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(LOOTBOX_ID)\n\n\n@view\n@internal\ndef _getDeleverageAddr() -> address:\n    return staticcall RipeHq(gov._getRipeHqFromGov()).getAddr(DELEVERAGE_ID)\n\n\n##############\n# Deleverage #\n##############\n\n\n@external\ndef deleverageUser(_user: address, _targetRepayAmount: uint256 = max_value(uint256)) -> uint256:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    return extcall Teller(self._getTellerAddr()).deleverageUser(_user, _targetRepayAmount)\n\n\n@external\ndef deleverageManyUsers(_users: DynArray[DeleverageUserRequest, MAX_DELEVERAGE_USERS]) -> uint256:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    return extcall Teller(self._getTellerAddr()).deleverageManyUsers(_users)\n\n\n@external\ndef deleverageWithSpecificAssets(_assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS], _user: address) -> uint256:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    return extcall Teller(self._getTellerAddr()).deleverageWithSpecificAssets(_assets, _user)\n\n\n@external\ndef deleverageWithVolAssets(_user: address, _assets: DynArray[DeleverageAsset, MAX_DELEVERAGE_ASSETS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return extcall Deleverage(self._getDeleverageAddr()).deleverageWithVolAssets(_user, _assets)\n\n\n# set min deleverage bps\n\n\n@external\ndef setMinDeleverageBps(_bps: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _bps <= HUNDRED_PERCENT # dev: invalid bps\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.DELEVERAGE_MIN_BPS\n    self.pendingMinDeleverageBps[aid] = _bps\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingMinDeleverageBpsChange(\n        bps=_bps,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n# set deleverage buffer\n\n\n@external\ndef setDeleverageBuffer(_bps: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _bps <= HUNDRED_PERCENT # dev: invalid bps\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.DELEVERAGE_BUFFER\n    self.pendingDeleverageBuffer[aid] = _bps\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingDeleverageBufferChange(\n        bps=_bps,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n# set deleverage cooldown\n\n\n@external\ndef setDeleverageCooldown(_blocks: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _blocks <= MAX_COOLDOWN_BLOCKS # dev: cooldown too large\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.DELEVERAGE_COOLDOWN\n    self.pendingDeleverageCooldown[aid] = _blocks\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingDeleverageCooldownChange(\n        blocks=_blocks,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n# set underscore safe spread bps\n\n\n@external\ndef setUnderscoreSafeSpreadBps(_bps: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _bps <= MAX_UNDERSCORE_SAFE_SPREAD_BPS # dev: exceeds hard ceiling\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.DELEVERAGE_UNDERSCORE_SAFE_SPREAD\n    self.pendingUnderscoreSafeSpreadBps[aid] = _bps\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingUnderscoreSafeSpreadBpsChange(\n        bps=_bps,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n#############\n# HR Config #\n#############\n\n\n# contrib template\n\n\n@external\ndef setContributorTemplate(_contribTemplate: address, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _contribTemplate.is_contract and _contribTemplate != empty(address) # dev: invalid contrib template\n    aid: uint256 = self._setPendingHrConfig(ActionType.HR_CONFIG_TEMPLATE, _contribTemplate)\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    return aid\n\n\n# max compensation\n\n\n@external\ndef setMaxCompensation(_maxComp: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _maxComp != 0 and _maxComp <= 20_000_000 * EIGHTEEN_DECIMALS # dev: invalid max compensation\n    aid: uint256 = self._setPendingHrConfig(ActionType.HR_CONFIG_MAX_COMP, empty(address), _maxComp)\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    return aid\n\n\n# min cliff length\n\n\n@external\ndef setMinCliffLength(_minCliffLength: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _minCliffLength > WEEK_IN_SECONDS # dev: invalid min cliff length\n    aid: uint256 = self._setPendingHrConfig(ActionType.HR_CONFIG_MIN_CLIFF, empty(address), 0, _minCliffLength)\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    return aid\n\n\n# max start delay\n\n\n@external\ndef setMaxStartDelay(_maxStartDelay: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _maxStartDelay <= 3 * MONTH_IN_SECONDS # dev: invalid max start delay\n    aid: uint256 = self._setPendingHrConfig(ActionType.HR_CONFIG_MAX_START_DELAY, empty(address), 0, 0, _maxStartDelay)\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    return aid\n\n\n# min vesting length\n\n\n@external\ndef setVestingLengthBoundaries(_minVestingLength: uint256, _maxVestingLength: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _minVestingLength < _maxVestingLength # dev: invalid vesting length boundaries\n    assert _minVestingLength > MONTH_IN_SECONDS # dev: invalid min vesting length\n    assert _maxVestingLength <= 5 * YEAR_IN_SECONDS # dev: invalid max vesting length\n    aid: uint256 = self._setPendingHrConfig(ActionType.HR_CONFIG_VESTING, empty(address), 0, 0, 0, _minVestingLength, _maxVestingLength)\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    return aid\n\n\n# set pending hr config\n\n\n@internal\ndef _setPendingHrConfig(\n    _actionType: ActionType,\n    _contribTemplate: address = empty(address),\n    _maxCompensation: uint256 = 0,\n    _minCliffLength: uint256 = 0,\n    _maxStartDelay: uint256 = 0,\n    _minVestingLength: uint256 = 0,\n    _maxVestingLength: uint256 = 0,\n) -> uint256:\n    aid: uint256 = timeLock._initiateAction()\n\n    self.actionType[aid] = _actionType\n    self.pendingHrConfig[aid] = cs.HrConfig(\n        contribTemplate=_contribTemplate,\n        maxCompensation=_maxCompensation,\n        minCliffLength=_minCliffLength,\n        maxStartDelay=_maxStartDelay,\n        minVestingLength=_minVestingLength,\n        maxVestingLength=_maxVestingLength,\n    )\n\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    if _actionType == ActionType.HR_CONFIG_TEMPLATE:\n        log PendingHrContribTemplateChange(\n            contribTemplate=_contribTemplate,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.HR_CONFIG_MAX_COMP:\n        log PendingHrMaxCompensationChange(\n            maxCompensation=_maxCompensation,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.HR_CONFIG_MIN_CLIFF:\n        log PendingHrMinCliffLengthChange(\n            minCliffLength=_minCliffLength,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.HR_CONFIG_MAX_START_DELAY:\n        log PendingHrMaxStartDelayChange(\n            maxStartDelay=_maxStartDelay,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    elif _actionType == ActionType.HR_CONFIG_VESTING:\n        log PendingHrVestingLengthBoundariesChange(\n            minVestingLength=_minVestingLength,\n            maxVestingLength=_maxVestingLength,\n            confirmationBlock=confirmationBlock,\n            actionId=aid,\n        )\n    return aid\n\n\n#######################\n# Contributor Options #\n#######################\n\n\n# cancel paycheck\n\n\n@external\ndef cancelPaycheckForContributor(_contributor: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert staticcall Ledger(self._getLedgerAddr()).isHrContributor(_contributor) # dev: not a contributor\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.HR_CANCEL_PAYCHECK\n    self.pendingCancelPaycheck[aid] = _contributor\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingCancelPaycheckSet(contributor=_contributor, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# set manager\n\n\n@external\ndef setManagerForContributor(_contributor: address, _manager: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _manager != empty(address) # dev: invalid manager\n    assert staticcall Ledger(self._getLedgerAddr()).isHrContributor(_contributor) # dev: not a contributor\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.HR_MANAGER\n    self.pendingManager[aid] = PendingManager(contributor=_contributor, pendingManager=_manager)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingManagerSet(contributor=_contributor, manager=_manager, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# lite actions\n\n\n@external\ndef cashRipeCheckForContributor(_contributor: address) -> bool:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    amount: uint256 = extcall HrContributor(_contributor).cashRipeCheck()\n    log RipeCheckCashedFromSwitchboard(contributor=_contributor, cashedBy=msg.sender, amount=amount)\n    return True\n\n\n@external\ndef cancelRipeTransferForContributor(_contributor: address) -> bool:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    extcall HrContributor(_contributor).cancelRipeTransfer()\n    log RipeTransferCancelledFromSwitchboard(contributor=_contributor, cancelledBy=msg.sender)\n    return True\n\n\n@external\ndef cancelOwnershipChangeForContributor(_contributor: address) -> bool:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    extcall HrContributor(_contributor).cancelOwnershipChange()\n    log OwnershipChangeCancelledFromSwitchboard(contributor=_contributor, cancelledBy=msg.sender)\n    return True\n\n\n@external\ndef freezeContributor(_contributor: address, _shouldFreeze: bool) -> bool:\n    assert self._hasPermsToEnable(msg.sender, _shouldFreeze) # dev: no perms\n    assert extcall HrContributor(_contributor).setIsFrozen(_shouldFreeze) # dev: could not freeze\n    log ContributorFrozenFromSwitchboard(contributor=_contributor, frozenBy=msg.sender, shouldFreeze=_shouldFreeze)\n    return True\n\n\n####################\n# Ripe Bond Config #\n####################\n\n\n# main config\n\n\n@external\ndef setRipeBondConfig(\n    _asset: address,\n    _amountPerEpoch: uint256,\n    _minRipePerUnit: uint256,\n    _maxRipePerUnit: uint256,\n    _maxRipePerUnitLockBonus: uint256,\n    _shouldAutoRestart: bool,\n    _restartDelayBlocks: uint256,\n    _missionControl: address = empty(address),\n) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_BOND_CONFIG\n\n    assert _asset != empty(address) # dev: invalid asset\n    assert 0 not in [_amountPerEpoch, _maxRipePerUnit] # dev: invalid config\n    assert _minRipePerUnit < _maxRipePerUnit # dev: invalid min/max ripe per unit\n    assert _maxRipePerUnitLockBonus <= (10 * HUNDRED_PERCENT) # dev: max is 1000%\n\n    self.pendingRipeBondConfig[aid] = cs.RipeBondConfig(\n        asset=_asset,\n        amountPerEpoch=_amountPerEpoch,\n        canBond=False,\n        minRipePerUnit=_minRipePerUnit,\n        maxRipePerUnit=_maxRipePerUnit,\n        maxRipePerUnitLockBonus=_maxRipePerUnitLockBonus,\n        epochLength=0,\n        shouldAutoRestart=_shouldAutoRestart,\n        restartDelayBlocks=_restartDelayBlocks,\n    )\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRipeBondConfigSet(\n        asset=_asset,\n        amountPerEpoch=_amountPerEpoch,\n        minRipePerUnit=_minRipePerUnit,\n        maxRipePerUnit=_maxRipePerUnit,\n        maxRipePerUnitLockBonus=_maxRipePerUnitLockBonus,\n        shouldAutoRestart=_shouldAutoRestart,\n        restartDelayBlocks=_restartDelayBlocks,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n# epoch length\n\n\n@external\ndef setRipeBondEpochLength(_epochLength: uint256, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert _epochLength != 0 # dev: invalid epoch length\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_BOND_EPOCH_LENGTH\n    self.pendingRipeBondConfigValue[aid] = _epochLength\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRipeBondEpochLengthSet(epochLength=_epochLength, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# start epoch at block\n\n\n@external\ndef setStartEpochAtBlock(_block: uint256 = 0):\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    blockNum: uint256 = max(_block, block.number)\n    bondRoom: address = self._getBondRoomAddr()\n    extcall BondRoom(bondRoom).startBondEpochAtBlock(blockNum)\n    log RipeBondStartEpochAtBlockSet(startBlock=blockNum)\n\n\n# disable / enable bonding\n\n\n@external\ndef setCanPurchaseRipeBond(_canBond: bool, _missionControl: address = empty(address)) -> bool:\n    assert self._hasPermsToEnable(msg.sender, not _canBond) # dev: no perms\n    mc: address = self._resolveMissionControl(_missionControl)\n    config: cs.RipeBondConfig = staticcall MissionControl(mc).ripeBondConfig()\n    assert config.canBond != _canBond # dev: no change\n    config.canBond = _canBond\n    extcall MissionControl(mc).setRipeBondConfig(config)\n    log CanPurchaseRipeBondModified(canPurchaseRipeBond=_canBond, modifier=msg.sender)\n    return True\n\n\n# set bad debt\n\n\n@external\ndef setBadDebt(_amount: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_BAD_DEBT\n    self.pendingRipeBondConfigValue[aid] = _amount\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingBadDebtSet(badDebt=_amount, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n##################\n# Ripe Available #\n##################\n\n\n@external\ndef setRipeAvailableForRewards(_amount: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_AVAIL_REWARDS\n    self.pendingRipeAvailable[aid] = _amount\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRipeAvailableForRewardsChange(\n        amount=_amount,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@external\ndef setRipeAvailableForHr(_amount: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_AVAIL_HR\n    self.pendingRipeAvailable[aid] = _amount\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRipeAvailableForHrChange(\n        amount=_amount,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@external\ndef setRipeAvailableForBonds(_amount: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_AVAIL_BONDS\n    self.pendingRipeAvailable[aid] = _amount\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingRipeAvailableForBondsChange(\n        amount=_amount,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n#######################\n# Underscore Registry #\n#######################\n\n\n@external\ndef setUnderscoreRegistry(_underscoreRegistry: address, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self._isValidUnderscoreAddr(_underscoreRegistry) # dev: invalid underscore registry\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.OTHER_UNDERSCORE_REGISTRY\n    self.pendingUnderscoreRegistry[aid] = _underscoreRegistry\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingUnderscoreRegistryChange(\n        underscoreRegistry=_underscoreRegistry,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidUnderscoreAddr(_addr: address) -> bool:\n    if _addr == empty(address):\n        return True # allowing setting to empty address\n\n    undyLedger: address = staticcall UnderscoreRegistry(_addr).getAddr(UNDERSCORE_LEDGER_ID)\n    if undyLedger == empty(address):\n        return False\n\n    # make sure has interface\n    return not staticcall UnderscoreLedger(undyLedger).isUserWallet(empty(address))\n\n\n###########################\n# Should Check Last Touch #\n###########################\n\n\n@external\ndef setShouldCheckLastTouch(_shouldCheck: bool, _missionControl: address = empty(address)) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.OTHER_SHOULD_CHECK_LAST_TOUCH\n    self.pendingShouldCheckLastTouch[aid] = _shouldCheck\n    self.pendingMissionControl[aid] = self._resolveMissionControl(_missionControl)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingShouldCheckLastTouchChange(shouldCheck=_shouldCheck, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n################\n# Bond Booster #\n################\n\n\n# setting bond booster contract\n\n\n@external\ndef setRipeBondBooster(_bondBooster: address) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert self._isValidRipeBondBoosterAddr(_bondBooster) # dev: invalid bond booster\n\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.RIPE_BOND_BOOSTER\n    self.pendingBondBooster[aid] = _bondBooster\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingBondBoosterSet(\n        bondBooster=_bondBooster,\n        confirmationBlock=confirmationBlock,\n        actionId=aid,\n    )\n    return aid\n\n\n@view\n@internal\ndef _isValidRipeBondBoosterAddr(_addr: address) -> bool:\n    # make sure has interface\n    if _addr != empty(address):\n        na: uint256 = staticcall BondBooster(_addr).getBoostRatio(empty(address), 10)\n    return True\n\n\n# add booster configs\n\n\n@external\ndef setManyBondBoosters(_boosters: DynArray[BoosterConfig, MAX_BOOSTERS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert len(_boosters) != 0 # dev: no boosters\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.BOND_BOOSTER_ADD\n    self.pendingBoosterConfigs[aid] = _boosters\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingBoosterConfigsSet(numBoosters=len(_boosters), confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# add single booster config\n\n\n@external\ndef setBondBooster(_config: BoosterConfig) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.BOND_BOOSTER_ADD\n    self.pendingBoosterConfigs[aid] = [_config]\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingBoosterConfigSet(user=_config.user, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# remove boosted users\n\n\n@external\ndef removeManyBondBoosters(_users: DynArray[address, MAX_BOOSTERS]) -> bool:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    bondBooster: address = staticcall BondRoom(self._getBondRoomAddr()).bondBooster()\n    extcall BondBooster(bondBooster).removeManyBondBoosters(_users)\n    log ManyBondBoostersRemoved(numUsers=len(_users))\n    return True\n\n\n# remove single boosted user\n\n\n@external\ndef removeBondBooster(_user: address) -> bool:\n    assert self._hasPermsToEnable(msg.sender, True) # dev: no perms\n    bondBooster: address = staticcall BondRoom(self._getBondRoomAddr()).bondBooster()\n    extcall BondBooster(bondBooster).removeBondBooster(_user)\n    log BondBoosterRemoved(user=_user)\n    return True\n\n\n# set booster boundaries\n\n\n@external\ndef setBoosterBoundaries(_maxBoostRatio: uint256, _maxUnits: uint256) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.BOND_BOOSTER_BOUNDARIES\n    self.pendingBoosterBoundaries[aid] = BoosterBoundaries(maxBoostRatio=_maxBoostRatio, maxUnits=_maxUnits)\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingBoosterBoundariesSet(maxBoostRatio=_maxBoostRatio, maxUnits=_maxUnits, confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n# set booster min lock duration\n\n\n@external\ndef setBoosterMinLockDuration(_minLockDuration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    bondBooster: address = staticcall BondRoom(self._getBondRoomAddr()).bondBooster()\n    extcall BondBooster(bondBooster).setMinLockDuration(_minLockDuration)\n    log BoosterMinLockDurationSet(minLockDuration=_minLockDuration)\n    return True\n\n\n################\n# Loot Cleanup #\n################\n\n\n@external\ndef resetManyUserBalancePoints(_users: DynArray[UserBalanceReset, MAX_USERS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert len(_users) != 0 # dev: no users\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.LOOT_USER_BALANCE_RESET\n    self.pendingUserBalanceReset[aid] = _users\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingUserBalanceResetSet(numResets=len(_users), confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n@external\ndef resetManyAssetPoints(_assets: DynArray[AssetReset, MAX_ASSETS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert len(_assets) != 0 # dev: no assets\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.LOOT_ASSET_RESET\n    self.pendingAssetReset[aid] = _assets\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingAssetResetSet(numResets=len(_assets), confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n@external\ndef resetManyUserBorrowPoints(_users: DynArray[address, MAX_USERS]) -> uint256:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert len(_users) != 0 # dev: no users\n    aid: uint256 = timeLock._initiateAction()\n    self.actionType[aid] = ActionType.LOOT_USER_BORROW_RESET\n    self.pendingUserBorrowReset[aid] = _users\n    confirmationBlock: uint256 = timeLock._getActionConfirmationBlock(aid)\n    log PendingUserBorrowResetSet(numResets=len(_users), confirmationBlock=confirmationBlock, actionId=aid)\n    return aid\n\n\n#############\n# Execution #\n#############\n\n\n@external\ndef executePendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    # check time lock\n    if not timeLock._confirmAction(_aid):\n        if timeLock._isExpired(_aid):\n            self._cancelPendingAction(_aid)\n        return False\n\n    actionType: ActionType = self.actionType[_aid]\n\n    # use stored MC if set, otherwise fallback to current (for backwards compat)\n    mc: address = self.pendingMissionControl[_aid]\n    if mc == empty(address):\n        mc = self._getMissionControlAddr()\n\n    if actionType == ActionType.HR_CONFIG_TEMPLATE:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        config.contribTemplate = self.pendingHrConfig[_aid].contribTemplate\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrContribTemplateSet(contribTemplate=config.contribTemplate)\n\n    elif actionType == ActionType.HR_CONFIG_MAX_COMP:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        p: cs.HrConfig = self.pendingHrConfig[_aid]\n        config.maxCompensation = p.maxCompensation\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrMaxCompensationSet(maxCompensation=p.maxCompensation)\n\n    elif actionType == ActionType.HR_CONFIG_MIN_CLIFF:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        p: cs.HrConfig = self.pendingHrConfig[_aid]\n        config.minCliffLength = p.minCliffLength\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrMinCliffLengthSet(minCliffLength=p.minCliffLength)\n\n    elif actionType == ActionType.HR_CONFIG_MAX_START_DELAY:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        p: cs.HrConfig = self.pendingHrConfig[_aid]\n        config.maxStartDelay = p.maxStartDelay\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrMaxStartDelaySet(maxStartDelay=p.maxStartDelay)\n\n    elif actionType == ActionType.HR_CONFIG_VESTING:\n        config: cs.HrConfig = staticcall MissionControl(mc).hrConfig()\n        p: cs.HrConfig = self.pendingHrConfig[_aid]\n        config.minVestingLength = p.minVestingLength\n        config.maxVestingLength = p.maxVestingLength\n        extcall MissionControl(mc).setHrConfig(config)\n        log HrVestingLengthBoundariesSet(minVestingLength=p.minVestingLength, maxVestingLength=p.maxVestingLength)\n\n    elif actionType == ActionType.HR_MANAGER:\n        p: PendingManager = self.pendingManager[_aid]\n        extcall HrContributor(p.contributor).setManager(p.pendingManager)\n        log HrContributorManagerSet(contributor=p.contributor, manager=p.pendingManager)\n\n    elif actionType == ActionType.HR_CANCEL_PAYCHECK:\n        p: address = self.pendingCancelPaycheck[_aid]\n        extcall HrContributor(p).cancelPaycheck()\n        log HrContributorCancelPaycheckSet(contributor=p)\n\n    elif actionType == ActionType.RIPE_BOND_CONFIG:\n        p: cs.RipeBondConfig = self.pendingRipeBondConfig[_aid]\n        config: cs.RipeBondConfig = staticcall MissionControl(mc).ripeBondConfig()\n        config.asset = p.asset\n        config.amountPerEpoch = p.amountPerEpoch\n        config.minRipePerUnit = p.minRipePerUnit\n        config.maxRipePerUnit = p.maxRipePerUnit\n        config.maxRipePerUnitLockBonus = p.maxRipePerUnitLockBonus\n        config.shouldAutoRestart = p.shouldAutoRestart\n        config.restartDelayBlocks = p.restartDelayBlocks\n        extcall MissionControl(mc).setRipeBondConfig(config)\n        log RipeBondConfigSet(asset=p.asset, amountPerEpoch=p.amountPerEpoch, minRipePerUnit=p.minRipePerUnit, maxRipePerUnit=p.maxRipePerUnit, maxRipePerUnitLockBonus=p.maxRipePerUnitLockBonus, shouldAutoRestart=p.shouldAutoRestart)\n\n    elif actionType == ActionType.RIPE_BOND_EPOCH_LENGTH:\n        config: cs.RipeBondConfig = staticcall MissionControl(mc).ripeBondConfig()\n        config.epochLength = self.pendingRipeBondConfigValue[_aid]\n        extcall MissionControl(mc).setRipeBondConfig(config)\n        log RipeBondEpochLengthSet(epochLength=config.epochLength)\n\n    elif actionType == ActionType.RIPE_BAD_DEBT:\n        amount: uint256 = self.pendingRipeBondConfigValue[_aid]\n        extcall Ledger(self._getLedgerAddr()).setBadDebt(amount)\n        log BadDebtSet(badDebt=amount)\n\n    elif actionType == ActionType.RIPE_BOND_BOOSTER:\n        bondBooster: address = self.pendingBondBooster[_aid]\n        extcall BondRoom(self._getBondRoomAddr()).setBondBooster(bondBooster)\n        log RipeBondBoosterSet(bondBooster=bondBooster)\n\n    elif actionType == ActionType.BOND_BOOSTER_ADD:\n        boosters: DynArray[BoosterConfig, MAX_BOOSTERS] = self.pendingBoosterConfigs[_aid]\n        bondBooster: address = staticcall BondRoom(self._getBondRoomAddr()).bondBooster()\n        extcall BondBooster(bondBooster).setManyBondBoosters(boosters)\n        log ManyBondBoostersSet(numBoosters=len(boosters))\n\n    elif actionType == ActionType.BOND_BOOSTER_BOUNDARIES:\n        boundaries: BoosterBoundaries = self.pendingBoosterBoundaries[_aid]\n        bondBooster: address = staticcall BondRoom(self._getBondRoomAddr()).bondBooster()\n        extcall BondBooster(bondBooster).setMaxBoostAndMaxUnits(boundaries.maxBoostRatio, boundaries.maxUnits)\n        log BoosterBoundariesSet(maxBoostRatio=boundaries.maxBoostRatio, maxUnits=boundaries.maxUnits)\n\n    elif actionType == ActionType.LOOT_USER_BALANCE_RESET:\n        resets: DynArray[UserBalanceReset, MAX_USERS] = self.pendingUserBalanceReset[_aid]\n        lootbox: address = self._getLootboxAddr()\n        for reset: UserBalanceReset in resets:\n            extcall Lootbox(lootbox).resetUserBalancePoints(reset.user, reset.asset, reset.vaultId)\n        log UserBalanceResetExecuted(numResets=len(resets))\n\n    elif actionType == ActionType.LOOT_ASSET_RESET:\n        resets: DynArray[AssetReset, MAX_ASSETS] = self.pendingAssetReset[_aid]\n        lootbox: address = self._getLootboxAddr()\n        for reset: AssetReset in resets:\n            extcall Lootbox(lootbox).resetAssetPoints(reset.asset, reset.vaultId)\n        log AssetResetExecuted(numResets=len(resets))\n\n    elif actionType == ActionType.LOOT_USER_BORROW_RESET:\n        users: DynArray[address, MAX_USERS] = self.pendingUserBorrowReset[_aid]\n        lootbox: address = self._getLootboxAddr()\n        for user: address in users:\n            extcall Lootbox(lootbox).resetUserBorrowPoints(user)\n        log UserBorrowResetExecuted(numResets=len(users))\n\n    elif actionType == ActionType.RIPE_AVAIL_REWARDS:\n        amount: uint256 = self.pendingRipeAvailable[_aid]\n        extcall Ledger(self._getLedgerAddr()).setRipeAvailForRewards(amount)\n        log RipeAvailableForRewardsSet(amount=amount)\n\n    elif actionType == ActionType.RIPE_AVAIL_HR:\n        amount: uint256 = self.pendingRipeAvailable[_aid]\n        extcall Ledger(self._getLedgerAddr()).setRipeAvailForHr(amount)\n        log RipeAvailableForHrSet(amount=amount)\n\n    elif actionType == ActionType.RIPE_AVAIL_BONDS:\n        amount: uint256 = self.pendingRipeAvailable[_aid]\n        extcall Ledger(self._getLedgerAddr()).setRipeAvailForBonds(amount)\n        log RipeAvailableForBondsSet(amount=amount)\n\n    elif actionType == ActionType.OTHER_UNDERSCORE_REGISTRY:\n        underscoreRegistry: address = self.pendingUnderscoreRegistry[_aid]\n        extcall MissionControl(mc).setUnderscoreRegistry(underscoreRegistry)\n        log UnderscoreRegistrySet(addr=underscoreRegistry)\n\n    elif actionType == ActionType.OTHER_SHOULD_CHECK_LAST_TOUCH:\n        shouldCheck: bool = self.pendingShouldCheckLastTouch[_aid]\n        extcall MissionControl(mc).setShouldCheckLastTouch(shouldCheck)\n        log ShouldCheckLastTouchSet(shouldCheck=shouldCheck)\n\n    elif actionType == ActionType.DELEVERAGE_MIN_BPS:\n        bps: uint256 = self.pendingMinDeleverageBps[_aid]\n        extcall Deleverage(self._getDeleverageAddr()).setMinDeleverageBps(bps)\n        log MinDeleverageBpsSet(bps=bps)\n\n    elif actionType == ActionType.DELEVERAGE_BUFFER:\n        bps: uint256 = self.pendingDeleverageBuffer[_aid]\n        extcall Deleverage(self._getDeleverageAddr()).setDeleverageBuffer(bps)\n        log DeleverageBufferSet(bps=bps)\n\n    elif actionType == ActionType.DELEVERAGE_COOLDOWN:\n        blocks: uint256 = self.pendingDeleverageCooldown[_aid]\n        extcall Deleverage(self._getDeleverageAddr()).setDeleverageCooldown(blocks)\n        log DeleverageCooldownSet(blocks=blocks)\n\n    elif actionType == ActionType.DELEVERAGE_UNDERSCORE_SAFE_SPREAD:\n        bps: uint256 = self.pendingUnderscoreSafeSpreadBps[_aid]\n        extcall Deleverage(self._getDeleverageAddr()).setUnderscoreSafeSpreadBps(bps)\n        log UnderscoreSafeSpreadBpsSet(bps=bps)\n\n    self.actionType[_aid] = empty(ActionType)\n    return True\n\n\n# cancel action\n\n\n@external\ndef cancelPendingAction(_aid: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    self._cancelPendingAction(_aid)\n    return True\n\n\n@internal\ndef _cancelPendingAction(_aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.actionType[_aid] = empty(ActionType)\n",
            "sha256sum": "072dd4ab5334b2303bb9fd123c9652c021fa75a2586f634bb0d163abc30e15b5"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/config/SwitchboardDelta.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "6808b747bf34dc52a2abb6d0c048926a22277b95794fb8d80df402552c45773c"
      },
      "args": "0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/config/SwitchboardDelta.vy"
    },
    "UndyVaultPrices": {
      "address": "0x64D0F785c3D4bf4675f4b8432D765175F014A8Ac",
      "abi": [
        {
          "name": "NewPriceConfigPending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewPriceConfigAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "NewPriceConfigCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceConfigUpdatePending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceConfigUpdated",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "minSnapshotDelay",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxNumSnapshots",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "maxUpsideDeviation",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "staleTime",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceConfigUpdateCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisablePriceConfigPending",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmationBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "actionId",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisablePriceConfigConfirmed",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "DisablePriceConfigCancelled",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PricePerShareSnapshotAdded",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "underlyingAsset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "totalSupply",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "pricePerShare",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeTimeLockModified",
          "inputs": [
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ExpirationSet",
          "inputs": [
            {
              "name": "expiration",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "ActionTimeLockSet",
          "inputs": [
            {
              "name": "newTimeLock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "prevTimeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeStarted",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeConfirmed",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovChangeCancelled",
          "inputs": [
            {
              "name": "cancelledGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "initiatedBlock",
              "type": "uint256",
              "indexed": false
            },
            {
              "name": "confirmBlock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "GovRelinquished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "RipeHqSetupFinished",
          "inputs": [
            {
              "name": "prevGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "newGov",
              "type": "address",
              "indexed": true
            },
            {
              "name": "timeLock",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourcePauseModified",
          "inputs": [
            {
              "name": "isPaused",
              "type": "bool",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "name": "PriceSourceFundsRecovered",
          "inputs": [
            {
              "name": "asset",
              "type": "address",
              "indexed": true
            },
            {
              "name": "recipient",
              "type": "address",
              "indexed": true
            },
            {
              "name": "balance",
              "type": "uint256",
              "indexed": false
            }
          ],
          "anonymous": false,
          "type": "event"
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHqFromGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canGovern",
          "inputs": [
            {
              "name": "_addr",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getGovernors",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingGovChange",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "startGovernanceChange",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelGovernanceChange",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "relinquishGov",
          "inputs": [],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setGovTimeLock",
          "inputs": [
            {
              "name": "_numBlocks",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidGovTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxGovChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "finishRipeHqSetup",
          "inputs": [
            {
              "name": "_newGov",
              "type": "address"
            },
            {
              "name": "_timeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "governance",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingGov",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "newGov",
                  "type": "address"
                },
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numGovChanges",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "govChangeTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getAddys",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "hq",
                  "type": "address"
                },
                {
                  "name": "greenToken",
                  "type": "address"
                },
                {
                  "name": "savingsGreen",
                  "type": "address"
                },
                {
                  "name": "ripeToken",
                  "type": "address"
                },
                {
                  "name": "ledger",
                  "type": "address"
                },
                {
                  "name": "missionControl",
                  "type": "address"
                },
                {
                  "name": "switchboard",
                  "type": "address"
                },
                {
                  "name": "priceDesk",
                  "type": "address"
                },
                {
                  "name": "vaultBook",
                  "type": "address"
                },
                {
                  "name": "auctionHouse",
                  "type": "address"
                },
                {
                  "name": "auctionHouseNft",
                  "type": "address"
                },
                {
                  "name": "boardroom",
                  "type": "address"
                },
                {
                  "name": "bondRoom",
                  "type": "address"
                },
                {
                  "name": "creditEngine",
                  "type": "address"
                },
                {
                  "name": "endaoment",
                  "type": "address"
                },
                {
                  "name": "humanResources",
                  "type": "address"
                },
                {
                  "name": "lootbox",
                  "type": "address"
                },
                {
                  "name": "teller",
                  "type": "address"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getRipeHq",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPricedAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "address[]"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "pause",
          "inputs": [
            {
              "name": "_shouldPause",
              "type": "bool"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFunds",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "recoverFundsMany",
          "inputs": [
            {
              "name": "_recipient",
              "type": "address"
            },
            {
              "name": "_assets",
              "type": "address[]"
            }
          ],
          "outputs": []
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isPaused",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "assets",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "address"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "indexOfAsset",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "numAssets",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "canConfirmAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isExpired",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingAction",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getActionConfirmationBlock",
          "inputs": [
            {
              "name": "_actionId",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidActionTimeLock",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "minActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "maxActionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setExpiration",
          "inputs": [
            {
              "name": "_expiration",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "setActionTimeLockAfterSetup",
          "inputs": [
            {
              "name": "_newTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingActions",
          "inputs": [
            {
              "name": "arg0",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "initiatedBlock",
                  "type": "uint256"
                },
                {
                  "name": "confirmBlock",
                  "type": "uint256"
                },
                {
                  "name": "expiration",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionId",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "actionTimeLock",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "expiration",
          "inputs": [],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getPriceAndHasFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            },
            {
              "name": "_priceDesk",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            },
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "hasPendingPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            },
            {
              "name": "_maxUpsideDeviation",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            },
            {
              "name": "_maxUpsideDeviation",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmNewPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelNewPendingPriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidNewFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            },
            {
              "name": "_maxUpsideDeviation",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            },
            {
              "name": "_maxUpsideDeviation",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "updatePriceConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_minSnapshotDelay",
              "type": "uint256"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            },
            {
              "name": "_maxUpsideDeviation",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelPriceFeedUpdate",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidUpdateConfig",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            },
            {
              "name": "_maxNumSnapshots",
              "type": "uint256"
            },
            {
              "name": "_staleTime",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "disablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "confirmDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "cancelDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "isValidDisablePriceFeed",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getWeightedPrice",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "uint256"
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "function",
          "name": "addPriceSnapshot",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "bool"
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "getLatestSnapshot",
          "inputs": [
            {
              "name": "_asset",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "priceConfigs",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "underlyingAsset",
                  "type": "address"
                },
                {
                  "name": "underlyingDecimals",
                  "type": "uint256"
                },
                {
                  "name": "vaultTokenDecimals",
                  "type": "uint256"
                },
                {
                  "name": "minSnapshotDelay",
                  "type": "uint256"
                },
                {
                  "name": "maxNumSnapshots",
                  "type": "uint256"
                },
                {
                  "name": "maxUpsideDeviation",
                  "type": "uint256"
                },
                {
                  "name": "staleTime",
                  "type": "uint256"
                },
                {
                  "name": "lastSnapshot",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "totalSupply",
                      "type": "uint256"
                    },
                    {
                      "name": "pricePerShare",
                      "type": "uint256"
                    },
                    {
                      "name": "lastUpdate",
                      "type": "uint256"
                    }
                  ]
                },
                {
                  "name": "nextIndex",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "snapShots",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            },
            {
              "name": "arg1",
              "type": "uint256"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "name": "pricePerShare",
                  "type": "uint256"
                },
                {
                  "name": "lastUpdate",
                  "type": "uint256"
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "view",
          "type": "function",
          "name": "pendingPriceConfigs",
          "inputs": [
            {
              "name": "arg0",
              "type": "address"
            }
          ],
          "outputs": [
            {
              "name": "",
              "type": "tuple",
              "components": [
                {
                  "name": "actionId",
                  "type": "uint256"
                },
                {
                  "name": "config",
                  "type": "tuple",
                  "components": [
                    {
                      "name": "underlyingAsset",
                      "type": "address"
                    },
                    {
                      "name": "underlyingDecimals",
                      "type": "uint256"
                    },
                    {
                      "name": "vaultTokenDecimals",
                      "type": "uint256"
                    },
                    {
                      "name": "minSnapshotDelay",
                      "type": "uint256"
                    },
                    {
                      "name": "maxNumSnapshots",
                      "type": "uint256"
                    },
                    {
                      "name": "maxUpsideDeviation",
                      "type": "uint256"
                    },
                    {
                      "name": "staleTime",
                      "type": "uint256"
                    },
                    {
                      "name": "lastSnapshot",
                      "type": "tuple",
                      "components": [
                        {
                          "name": "totalSupply",
                          "type": "uint256"
                        },
                        {
                          "name": "pricePerShare",
                          "type": "uint256"
                        },
                        {
                          "name": "lastUpdate",
                          "type": "uint256"
                        }
                      ]
                    },
                    {
                      "name": "nextIndex",
                      "type": "uint256"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "stateMutability": "nonpayable",
          "type": "constructor",
          "inputs": [
            {
              "name": "_ripeHq",
              "type": "address"
            },
            {
              "name": "_tempGov",
              "type": "address"
            },
            {
              "name": "_minPriceChangeTimeLock",
              "type": "uint256"
            },
            {
              "name": "_maxPriceChangeTimeLock",
              "type": "uint256"
            }
          ],
          "outputs": []
        }
      ],
      "solc_json": {
        "language": "Vyper",
        "sources": {
          "contracts/modules/LocalGov.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\ninterface RipeHq:\n    def minGovChangeTimeLock() -> uint256: view\n    def maxGovChangeTimeLock() -> uint256: view\n    def governance() -> address: view\n\nstruct PendingGovernance:\n    newGov: address\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeStarted:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    confirmBlock: uint256\n\nevent GovChangeConfirmed:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovChangeCancelled:\n    cancelledGov: indexed(address)\n    initiatedBlock: uint256\n    confirmBlock: uint256\n\nevent GovRelinquished:\n    prevGov: indexed(address)\n\nevent GovChangeTimeLockModified:\n    prevTimeLock: uint256\n    newTimeLock: uint256\n\nevent RipeHqSetupFinished:\n    prevGov: indexed(address)\n    newGov: indexed(address)\n    timeLock: uint256\n\n# governance\ngovernance: public(address)\npendingGov: public(PendingGovernance)\nnumGovChanges: public(uint256)\n\n# time lock\ngovChangeTimeLock: public(uint256)\n\n# config\nRIPE_HQ_FOR_GOV: immutable(address)\nMIN_GOV_TIME_LOCK: immutable(uint256)\nMAX_GOV_TIME_LOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _initialGov: address,\n    _minTimeLock: uint256,\n    _maxTimeLock: uint256,\n    _initialTimeLock: uint256,\n):\n    RIPE_HQ_FOR_GOV = _ripeHq\n    self.governance = _initialGov\n\n    # ripe hq\n    if _ripeHq == empty(address):\n        assert _initialGov != empty(address) # dev: ripe hq must have gov\n\n    # local gov (department, other smart contracts)\n    else:\n        hqGov: address = staticcall RipeHq(_ripeHq).governance()\n        assert hqGov != empty(address) # dev: ripe hq must have gov\n        assert _initialGov != hqGov # dev: ripe hq cannot set same gov\n\n    # time locks\n    minTimeLock: uint256 = _minTimeLock\n    maxTimeLock: uint256 = _maxTimeLock\n    if minTimeLock == 0 or maxTimeLock == 0:\n        assert _ripeHq != empty(address) # dev: need ripe hq if no time locks\n        minTimeLock = staticcall RipeHq(_ripeHq).minGovChangeTimeLock()\n        maxTimeLock = staticcall RipeHq(_ripeHq).maxGovChangeTimeLock()\n\n    # set min and max time locks\n    assert minTimeLock < maxTimeLock # dev: invalid time lock\n    assert minTimeLock != 0 and maxTimeLock != max_value(uint256) # dev: invalid time lock\n    MIN_GOV_TIME_LOCK = minTimeLock\n    MAX_GOV_TIME_LOCK = maxTimeLock\n\n    # this contract is top level governance from Ripe HQ -- not setting initial time lock during setup\n    if _ripeHq == empty(address):\n        return\n\n    # set initial time lock (for local gov)\n    initialTimeLock: uint256 = max(minTimeLock, _initialTimeLock)\n    assert self._setGovTimeLock(initialTimeLock) # dev: invalid time lock\n\n\n@view\n@external\ndef getRipeHqFromGov() -> address:\n    return self._getRipeHqFromGov()\n\n\n@view\n@internal\ndef _getRipeHqFromGov() -> address:\n    return RIPE_HQ_FOR_GOV\n\n\n##############\n# Gov Access #\n##############\n\n\n@view\n@external\ndef canGovern(_addr: address) -> bool:\n    return self._canGovern(_addr)\n\n\n@view\n@internal\ndef _canGovern(_addr: address) -> bool:\n    if _addr == empty(address):\n        return False\n    return _addr in self._getGovernors()\n\n\n@view\n@external\ndef getGovernors() -> DynArray[address, 2]:\n    return self._getGovernors()\n\n\n@view\n@internal\ndef _getGovernors() -> DynArray[address, 2]:\n    governors: DynArray[address, 2] = []\n\n    # local governance\n    localGov: address = self.governance\n    if localGov != empty(address):\n        governors.append(localGov)\n\n    # ripe hq governance\n    ripeHq: address = RIPE_HQ_FOR_GOV\n    if ripeHq == empty(address):\n        return governors\n\n    hqGov: address = staticcall RipeHq(ripeHq).governance()\n    if hqGov != empty(address):\n        governors.append(hqGov)\n\n    return governors\n\n\n######################\n# Governance Changes #\n######################\n\n\n@view\n@external\ndef hasPendingGovChange() -> bool:\n    return self.pendingGov.confirmBlock != 0\n\n\n@view\n@internal\ndef _isRipeHqGov() -> bool:\n    return RIPE_HQ_FOR_GOV == empty(address)\n\n\n# start gov change\n\n\n@external\ndef startGovernanceChange(_newGov: address):\n    governors: DynArray[address, 2] = self._getGovernors()\n    assert msg.sender in governors # dev: no perms\n\n    # validation\n    if _newGov != empty(address):\n        assert _newGov not in governors # dev: invalid _newGov\n        assert _newGov.is_contract # dev: _newGov must be a contract\n    else:\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    confirmBlock: uint256 = block.number + self.govChangeTimeLock\n    self.pendingGov = PendingGovernance(\n        newGov= _newGov,\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n    )\n    log GovChangeStarted(prevGov=self.governance, newGov=_newGov, confirmBlock=confirmBlock)\n\n\n# confirm gov change\n\n\n@external\ndef confirmGovernanceChange():\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 and block.number >= data.confirmBlock # dev: time lock not reached\n\n    # check permissions\n    if data.newGov != empty(address):\n        assert msg.sender == data.newGov # dev: only new gov can confirm\n    else:\n        assert self._canGovern(msg.sender) # dev: no perms\n        assert not self._isRipeHqGov() # dev: ripe hq cannot set 0x0\n\n    # set new governance\n    prevGov: address = self.governance\n    self.governance = data.newGov\n    self.numGovChanges += 1\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeConfirmed(prevGov=prevGov, newGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# cancel gov change\n\n\n@external\ndef cancelGovernanceChange():\n    assert self._canGovern(msg.sender) # dev: no perms\n    data: PendingGovernance = self.pendingGov\n    assert data.confirmBlock != 0 # dev: no pending change\n    self.pendingGov = empty(PendingGovernance)\n    log GovChangeCancelled(cancelledGov=data.newGov, initiatedBlock=data.initiatedBlock, confirmBlock=data.confirmBlock)\n\n\n# relinquish gov (only for local gov)\n\n\n@external\ndef relinquishGov():\n    assert msg.sender == self.governance # dev: no perms\n    assert not self._isRipeHqGov() # dev: ripe hq cannot relinquish gov\n\n    self.governance = empty(address)\n    self.numGovChanges += 1\n    log GovRelinquished(prevGov=msg.sender)\n\n\n####################\n# Time Lock Config #\n####################\n\n\n# set time lock\n\n\n@external\ndef setGovTimeLock(_numBlocks: uint256) -> bool:\n    assert self._canGovern(msg.sender) # dev: no perms\n    return self._setGovTimeLock(_numBlocks)\n\n\n@internal\ndef _setGovTimeLock(_numBlocks: uint256) -> bool:\n    prevTimeLock: uint256 = self.govChangeTimeLock\n    assert self._isValidGovTimeLock(_numBlocks, prevTimeLock) # dev: invalid time lock\n    self.govChangeTimeLock = _numBlocks\n    log GovChangeTimeLockModified(prevTimeLock=prevTimeLock, newTimeLock=_numBlocks)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidGovTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidGovTimeLock(_newTimeLock, self.govChangeTimeLock)\n\n\n@view\n@internal\ndef _isValidGovTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    if self.pendingGov.confirmBlock != 0:\n        return False # cannot change while pending gov change\n    return _newTimeLock >= MIN_GOV_TIME_LOCK and _newTimeLock <= MAX_GOV_TIME_LOCK\n\n\n# utils\n\n\n@view\n@external\ndef minGovChangeTimeLock() -> uint256:\n    return MIN_GOV_TIME_LOCK\n\n\n@view\n@external\ndef maxGovChangeTimeLock() -> uint256:\n    return MAX_GOV_TIME_LOCK\n\n\n#################\n# Ripe Hq Setup #\n#################\n\n\n@external\ndef finishRipeHqSetup(_newGov: address, _timeLock: uint256 = 0) -> bool:\n    assert self._isRipeHqGov() # dev: only ripe hq\n    assert msg.sender == self.governance # dev: no perms\n    assert self.numGovChanges == 0 # dev: already changed gov\n\n    # validation\n    assert _newGov != empty(address) and _newGov.is_contract # dev: invalid _newGov\n    prevGov: address = self.governance\n\n    # set new gov\n    self.governance = _newGov\n    self.numGovChanges += 1\n\n    # set time lock\n    timeLock: uint256 = _timeLock\n    if timeLock == 0:\n        timeLock = MIN_GOV_TIME_LOCK\n    assert self._setGovTimeLock(timeLock) # dev: invalid time lock\n\n    log RipeHqSetupFinished(prevGov=prevGov, newGov=_newGov, timeLock=timeLock)\n    return True",
            "sha256sum": "4ffcc0fe78019515e484beb8bd5d700dce92d785b6bf26af25f52ea1289a5950"
          },
          "contracts/modules/Addys.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\ninterface RipeHq:\n    def isValidAddr(_addr: address) -> bool: view\n    def getAddr(_regId: uint256) -> address: view\n\ninterface Switchboard:\n    def isSwitchboardAddr(_addr: address) -> bool: view\n\ninterface VaultBook:\n    def isVaultBookAddr(_addr: address) -> bool: view\n\nstruct Addys:\n    hq: address\n    greenToken: address\n    savingsGreen: address\n    ripeToken: address\n    ledger: address\n    missionControl: address\n    switchboard: address\n    priceDesk: address\n    vaultBook: address\n    auctionHouse: address\n    auctionHouseNft: address\n    boardroom: address\n    bondRoom: address\n    creditEngine: address\n    endaoment: address\n    humanResources: address\n    lootbox: address\n    teller: address\n\n# hq\nRIPE_HQ_FOR_ADDYS: immutable(address)\n\n# core addys\nGREEN_TOKEN_ID: constant(uint256) = 1\nSAVINGS_GREEN_ID: constant(uint256) = 2\nRIPE_TOKEN_ID: constant(uint256) = 3\nLEDGER_ID: constant(uint256) = 4\nMISSION_CONTROL_ID: constant(uint256) = 5\nSWITCHBOARD_ID: constant(uint256) = 6\nPRICE_DESK_ID: constant(uint256) = 7\nVAULT_BOOK_ID: constant(uint256) = 8\nAUCTION_HOUSE_ID: constant(uint256) = 9\nAUCTION_HOUSE_NFT_ID: constant(uint256) = 10\nBOARDROOM_ID: constant(uint256) = 11\nBOND_ROOM_ID: constant(uint256) = 12\nCREDIT_ENGINE_ID: constant(uint256) = 13\nENDAOMENT_ID: constant(uint256) = 14\nHUMAN_RESOURCES_ID: constant(uint256) = 15\nLOOTBOX_ID: constant(uint256) = 16\nTELLER_ID: constant(uint256) = 17\nDELEVERAGE_ID: constant(uint256) = 18\nCREDIT_REDEEM_ID: constant(uint256) = 19\nTELLER_UTILS_ID: constant(uint256) = 20\nENDAOMENT_FUNDS_ID: constant(uint256) = 21\nENDAOMENT_PSM_ID: constant(uint256) = 22\n\n\n@deploy\ndef __init__(_ripeHq: address):\n    assert _ripeHq != empty(address) # dev: invalid ripe hq\n    RIPE_HQ_FOR_ADDYS = _ripeHq\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getAddys() -> Addys:\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _getAddys(_addys: Addys = empty(Addys)) -> Addys:\n    if _addys.hq != empty(address):\n        return _addys\n    return self._generateAddys()\n\n\n@view\n@internal\ndef _generateAddys() -> Addys:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    return Addys(\n        hq=hq,\n        greenToken=staticcall RipeHq(hq).getAddr(GREEN_TOKEN_ID),\n        savingsGreen=staticcall RipeHq(hq).getAddr(SAVINGS_GREEN_ID),\n        ripeToken=staticcall RipeHq(hq).getAddr(RIPE_TOKEN_ID),\n        ledger=staticcall RipeHq(hq).getAddr(LEDGER_ID),\n        missionControl=staticcall RipeHq(hq).getAddr(MISSION_CONTROL_ID),\n        switchboard=staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID),\n        priceDesk=staticcall RipeHq(hq).getAddr(PRICE_DESK_ID),\n        vaultBook=staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID),\n        auctionHouse=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_ID),\n        auctionHouseNft=staticcall RipeHq(hq).getAddr(AUCTION_HOUSE_NFT_ID),\n        boardroom=staticcall RipeHq(hq).getAddr(BOARDROOM_ID),\n        bondRoom=staticcall RipeHq(hq).getAddr(BOND_ROOM_ID),\n        creditEngine=staticcall RipeHq(hq).getAddr(CREDIT_ENGINE_ID),\n        endaoment=staticcall RipeHq(hq).getAddr(ENDAOMENT_ID),\n        humanResources=staticcall RipeHq(hq).getAddr(HUMAN_RESOURCES_ID),\n        lootbox=staticcall RipeHq(hq).getAddr(LOOTBOX_ID),\n        teller=staticcall RipeHq(hq).getAddr(TELLER_ID),\n    )\n\n\n##########\n# Tokens #\n##########\n\n\n@view\n@internal\ndef _getGreenToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(GREEN_TOKEN_ID)\n\n\n@view\n@internal\ndef _getSavingsGreen() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SAVINGS_GREEN_ID)\n\n\n@view\n@internal\ndef _getRipeToken() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(RIPE_TOKEN_ID)\n\n\n###########\n# Helpers #\n###########\n\n\n# ripe hq\n\n\n@view\n@external\ndef getRipeHq() -> address:\n    return self._getRipeHq()\n\n\n@view\n@internal\ndef _getRipeHq() -> address:\n    return RIPE_HQ_FOR_ADDYS\n\n\n# utils\n\n\n@view\n@internal\ndef _isValidRipeAddr(_addr: address) -> bool:\n    hq: address = RIPE_HQ_FOR_ADDYS\n    \n    # core departments\n    if staticcall RipeHq(hq).isValidAddr(_addr):\n        return True\n\n    # vault book\n    vaultBook: address = staticcall RipeHq(hq).getAddr(VAULT_BOOK_ID)\n    if vaultBook != empty(address) and staticcall VaultBook(vaultBook).isVaultBookAddr(_addr):\n        return True\n\n    # switchboard config\n    switchboard: address = staticcall RipeHq(hq).getAddr(SWITCHBOARD_ID)\n    if switchboard != empty(address) and staticcall Switchboard(switchboard).isSwitchboardAddr(_addr):\n        return True\n\n    return False\n\n\n@view\n@internal\ndef _isSwitchboardAddr(_addr: address) -> bool:\n    switchboard: address = staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n    if switchboard == empty(address):\n        return False\n    return staticcall Switchboard(switchboard).isSwitchboardAddr(_addr)\n\n\n###############\n# Departments #\n###############\n\n\n# ledger\n\n\n@view\n@internal\ndef _getLedgerId() -> uint256:\n    return LEDGER_ID\n\n\n@view\n@internal\ndef _getLedgerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LEDGER_ID)\n\n\n# mission control\n\n\n@view\n@internal\ndef _getMissionControlId() -> uint256:\n    return MISSION_CONTROL_ID\n\n\n@view\n@internal\ndef _getMissionControlAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(MISSION_CONTROL_ID)\n\n\n# switchboard\n\n\n@view\n@internal\ndef _getSwitchboardId() -> uint256:\n    return SWITCHBOARD_ID\n\n\n@view\n@internal\ndef _getSwitchboardAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(SWITCHBOARD_ID)\n\n\n# price desk\n\n\n@view\n@internal\ndef _getPriceDeskId() -> uint256:\n    return PRICE_DESK_ID\n\n\n@view\n@internal\ndef _getPriceDeskAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(PRICE_DESK_ID)\n\n\n# vault book\n\n\n@view\n@internal\ndef _getVaultBookId() -> uint256:\n    return VAULT_BOOK_ID\n\n\n@view\n@internal\ndef _getVaultBookAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(VAULT_BOOK_ID)\n\n\n# auction house\n\n\n@view\n@internal\ndef _getAuctionHouseId() -> uint256:\n    return AUCTION_HOUSE_ID\n\n\n@view\n@internal\ndef _getAuctionHouseAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_ID)\n\n\n# auction house nft\n\n\n@view\n@internal\ndef _getAuctionHouseNftId() -> uint256:\n    return AUCTION_HOUSE_NFT_ID\n\n\n@view\n@internal\ndef _getAuctionHouseNftAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(AUCTION_HOUSE_NFT_ID)\n\n\n# boardroom\n\n\n@view\n@internal\ndef _getBoardroomId() -> uint256:\n    return BOARDROOM_ID\n\n\n@view\n@internal\ndef _getBoardroomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOARDROOM_ID)\n\n\n# bond room\n\n\n@view\n@internal\ndef _getBondRoomId() -> uint256:\n    return BOND_ROOM_ID\n\n\n@view\n@internal\ndef _getBondRoomAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(BOND_ROOM_ID)\n\n\n# credit engine\n\n\n@view\n@internal\ndef _getCreditEngineId() -> uint256:\n    return CREDIT_ENGINE_ID\n\n\n@view\n@internal\ndef _getCreditEngineAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_ENGINE_ID)\n\n\n# endaoment\n\n\n@view\n@internal\ndef _getEndaomentId() -> uint256:\n    return ENDAOMENT_ID\n\n\n@view\n@internal\ndef _getEndaomentAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_ID)\n\n\n# human resources\n\n\n@view\n@internal\ndef _getHumanResourcesId() -> uint256:\n    return HUMAN_RESOURCES_ID\n\n\n@view\n@internal\ndef _getHumanResourcesAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(HUMAN_RESOURCES_ID)\n\n\n# lootbox\n\n\n@view\n@internal\ndef _getLootboxId() -> uint256:\n    return LOOTBOX_ID\n\n\n@view\n@internal\ndef _getLootboxAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(LOOTBOX_ID)\n\n\n# teller\n\n\n@view\n@internal\ndef _getTellerId() -> uint256:\n    return TELLER_ID\n\n\n@view\n@internal\ndef _getTellerAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_ID)\n\n\n# deleverage\n\n\n@view\n@internal\ndef _getDeleverageId() -> uint256:\n    return DELEVERAGE_ID\n\n\n@view\n@internal\ndef _getDeleverageAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(DELEVERAGE_ID)\n\n\n# creditRedeem\n\n\n@view\n@internal\ndef _getCreditRedeemId() -> uint256:\n    return CREDIT_REDEEM_ID\n\n\n@view\n@internal\ndef _getCreditRedeemAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(CREDIT_REDEEM_ID)\n\n\n# teller utils\n\n\n@view\n@internal\ndef _getTellerUtilsId() -> uint256:\n    return TELLER_UTILS_ID\n\n\n@view\n@internal\ndef _getTellerUtilsAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(TELLER_UTILS_ID)\n\n\n# endaoment funds\n\n\n@view\n@internal\ndef _getEndaomentFundsId() -> uint256:\n    return ENDAOMENT_FUNDS_ID\n\n\n@view\n@internal\ndef _getEndaomentFundsAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_FUNDS_ID)\n\n\n# endaoment psm\n\n\n@view\n@internal\ndef _getEndaomentPsmId() -> uint256:\n    return ENDAOMENT_PSM_ID\n\n\n@view\n@internal\ndef _getEndaomentPsmAddr() -> address:\n    return staticcall RipeHq(RIPE_HQ_FOR_ADDYS).getAddr(ENDAOMENT_PSM_ID)",
            "sha256sum": "2a46a2fbb26fed9ed5d59414833fb6c2f85a7ddf72e82ffc2d6e122296e1d4e6"
          },
          "contracts/priceSources/modules/PriceSourceData.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nuses: addys\n\nimport contracts.modules.Addys as addys\nfrom ethereum.ercs import IERC20\n\nevent PriceSourcePauseModified:\n    isPaused: bool\n\nevent PriceSourceFundsRecovered:\n    asset: indexed(address)\n    recipient: indexed(address)\n    balance: uint256\n\n# config\nisPaused: public(bool)\n\n# priced assets\nassets: public(HashMap[uint256, address]) # index -> asset\nindexOfAsset: public(HashMap[address, uint256]) # asset -> index\nnumAssets: public(uint256) # number of assets\n\nMAX_ASSETS: constant(uint256) = 50\nMAX_RECOVER_ASSETS: constant(uint256) = 20\n\n\n@deploy\ndef __init__(_shouldPause: bool):\n    self.isPaused = _shouldPause\n\n\n##############\n# Asset Data #\n##############\n\n\n# add priced asset\n\n\n@internal\ndef _addPricedAsset(_asset: address):\n    aid: uint256 = self.numAssets\n    if aid == 0:\n        aid = 1 # not using 0 index\n    self.assets[aid] = _asset\n    self.indexOfAsset[_asset] = aid\n    self.numAssets = aid + 1\n\n\n# remove priced asset\n\n\n@internal\ndef _removePricedAsset(_asset: address):\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return\n\n    targetIndex: uint256 = self.indexOfAsset[_asset]\n    if targetIndex == 0:\n        return\n\n    # update data\n    lastIndex: uint256 = numAssets - 1\n    self.numAssets = lastIndex\n    self.indexOfAsset[_asset] = 0\n\n    # get last item, replace the removed item\n    if targetIndex != lastIndex:\n        lastItem: address = self.assets[lastIndex]\n        self.assets[targetIndex] = lastItem\n        self.indexOfAsset[lastItem] = targetIndex\n\n\n# get priced assets\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, MAX_ASSETS]:\n    numAssets: uint256 = self.numAssets\n    if numAssets == 0:\n        return []\n    assets: DynArray[address, MAX_ASSETS] = []\n    for i: uint256 in range(1, numAssets, bound=MAX_ASSETS):\n        assets.append(self.assets[i])\n    return assets\n\n\n########\n# Ripe #\n########\n\n\n# activate\n\n\n@external\ndef pause(_shouldPause: bool):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    assert _shouldPause != self.isPaused # dev: no change\n    self.isPaused = _shouldPause\n    log PriceSourcePauseModified(isPaused=_shouldPause)\n\n\n# recover funds\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    self._recoverFunds(_recipient, _asset)\n\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, MAX_RECOVER_ASSETS]):\n    assert addys._isSwitchboardAddr(msg.sender) # dev: no perms\n    for a: address in _assets:\n        self._recoverFunds(_recipient, a)\n\n\n@internal\ndef _recoverFunds(_recipient: address, _asset: address):\n    assert empty(address) not in [_recipient, _asset] # dev: invalid recipient or asset\n    balance: uint256 = staticcall IERC20(_asset).balanceOf(self)\n    assert balance != 0 # dev: nothing to recover\n\n    assert extcall IERC20(_asset).transfer(_recipient, balance, default_return_value=True) # dev: recovery failed\n    log PriceSourceFundsRecovered(asset=_asset, recipient=_recipient, balance=balance)",
            "sha256sum": "7732f16d278cd2e105af1a91b79329b724972fcc14e686533c5ac5eeedd1852c"
          },
          "contracts/modules/TimeLock.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nuses: gov\nimport contracts.modules.LocalGov as gov\n\nstruct PendingAction:\n    initiatedBlock: uint256\n    confirmBlock: uint256\n    expiration: uint256\n\nevent ActionTimeLockSet:\n    newTimeLock: uint256\n    prevTimeLock: uint256\n\nevent ExpirationSet:\n    expiration: uint256\n\n# core data\npendingActions: public(HashMap[uint256, PendingAction])\nactionId: public(uint256)\n\n# config\nactionTimeLock: public(uint256)\nexpiration: public(uint256)\n\nMIN_ACTION_TIMELOCK: immutable(uint256)\nMAX_ACTION_TIMELOCK: immutable(uint256)\n\n\n@deploy\ndef __init__(\n    _minActionTimeLock: uint256,\n    _maxActionTimeLock: uint256,\n    _initialTimeLock: uint256,\n    _expiration: uint256,\n):\n    # start at 1 index\n    self.actionId = 1\n\n    # set time lock boundaries\n    assert _minActionTimeLock < _maxActionTimeLock # dev: invalid time lock boundaries\n    assert _minActionTimeLock != 0 and _maxActionTimeLock != max_value(uint256) # dev: invalid time lock boundaries\n    MIN_ACTION_TIMELOCK = _minActionTimeLock\n    MAX_ACTION_TIMELOCK = _maxActionTimeLock\n\n    # set expiration time\n    self._setExpiration(_expiration, _initialTimeLock)\n\n    # set initial time lock\n    if _initialTimeLock != 0:\n        assert self._setActionTimeLock(_initialTimeLock, 0) # dev: failed to set initial time lock\n\n\n########\n# Core #\n########\n\n\n# initiate\n\n\n@internal\ndef _initiateAction() -> uint256:\n    actionId: uint256 = self.actionId\n    confirmBlock: uint256 = block.number + self.actionTimeLock\n    self.pendingActions[actionId] = PendingAction(\n        initiatedBlock= block.number,\n        confirmBlock= confirmBlock,\n        expiration= confirmBlock + self.expiration,\n    )\n    self.actionId += 1\n    return actionId\n\n\n# confirm\n\n\n@internal\ndef _confirmAction(_actionId: uint256) -> bool:\n    if not self._canConfirmAction(_actionId):\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n# cancel\n\n\n@internal\ndef _cancelAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    self.pendingActions[_actionId] = empty(PendingAction)\n    return True\n\n\n#########\n# Utils #\n#########\n\n\n# can confirm\n\n\n@view\n@external\ndef canConfirmAction(_actionId: uint256) -> bool:\n    return self._canConfirmAction(_actionId)\n\n\n@view\n@internal\ndef _canConfirmAction(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0 or block.number < data.confirmBlock:\n        return False\n    if block.number >= data.expiration:\n        return False\n    return True\n\n\n# is expired\n\n\n@view\n@external\ndef isExpired(_actionId: uint256) -> bool:\n    return self._isExpired(_actionId)\n\n\n@view\n@internal\ndef _isExpired(_actionId: uint256) -> bool:\n    data: PendingAction = self.pendingActions[_actionId]\n    if data.confirmBlock == 0:\n        return False\n    return block.number >= data.expiration\n\n\n# pending action\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    return self._hasPendingAction(_actionId)\n\n\n@view\n@internal\ndef _hasPendingAction(_actionId: uint256) -> bool:\n    return self.pendingActions[_actionId].confirmBlock != 0\n\n\n# confirmation block\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self._getActionConfirmationBlock(_actionId)\n\n\n@view\n@internal\ndef _getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    return self.pendingActions[_actionId].confirmBlock\n\n\n######################\n# Config - Time Lock #\n######################\n\n\n@external\ndef setActionTimeLock(_newTimeLock: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@internal\ndef _setActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    assert self._isValidActionTimeLock(_newTimeLock, _prevTimeLock) # dev: invalid time lock\n    self.actionTimeLock = _newTimeLock\n    log ActionTimeLockSet(newTimeLock=_newTimeLock, prevTimeLock=_prevTimeLock)\n    return True\n\n\n# validation\n\n\n@view\n@external\ndef isValidActionTimeLock(_newTimeLock: uint256) -> bool:\n    return self._isValidActionTimeLock(_newTimeLock, self.actionTimeLock)\n\n\n@view\n@internal\ndef _isValidActionTimeLock(_newTimeLock: uint256, _prevTimeLock: uint256) -> bool:\n    if _newTimeLock == _prevTimeLock:\n        return False # no change\n    return _newTimeLock >= MIN_ACTION_TIMELOCK and _newTimeLock <= MAX_ACTION_TIMELOCK\n\n\n# utils\n\n\n@view\n@external\ndef minActionTimeLock() -> uint256:\n    return MIN_ACTION_TIMELOCK\n\n\n@view\n@external\ndef maxActionTimeLock() -> uint256:\n    return MAX_ACTION_TIMELOCK\n\n\n#######################\n# Config - Expiration #\n#######################\n\n\n@external\ndef setExpiration(_expiration: uint256) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    return self._setExpiration(_expiration, self.actionTimeLock)\n\n\n@internal\ndef _setExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    assert self._isValidExpiration(_expiration, _timeLock) # dev: invalid expiration\n    self.expiration = _expiration\n    log ExpirationSet(expiration=_expiration)\n    return True\n\n\n# validation\n\n\n@view\n@internal\ndef _isValidExpiration(_expiration: uint256, _timeLock: uint256) -> bool:\n    if _expiration == 0 or _expiration == max_value(uint256):\n        return False\n    if _expiration < _timeLock:\n        return False\n    return True\n\n\n################\n# Finish Setup #\n################\n\n\n@external\ndef setActionTimeLockAfterSetup(_newTimeLock: uint256 = 0) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n\n    prevTimeLock: uint256 = self.actionTimeLock\n    assert prevTimeLock == 0 # dev: already set\n\n    timeLock: uint256 = _newTimeLock\n    if timeLock == 0:\n        timeLock = MIN_ACTION_TIMELOCK\n    return self._setActionTimeLock(timeLock, prevTimeLock)",
            "sha256sum": "2c45da650f92c6891ed37a165a365934d31ed144b03e13c79f4f4fc68f2b7851"
          },
          "interfaces/PriceSource.vyi": {
            "content": "# @version 0.4.3\n\n\n########\n# Core #\n########\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> uint256:\n    ...\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _oracleRegistry: address = empty(address)) -> (uint256, bool):\n    ...\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@view\n@external\ndef getPricedAssets() -> DynArray[address, 50]:\n    ...\n\n\n@external \ndef addPriceSnapshot(_asset: address) -> bool:\n    ...\n\n\n################\n# Feed Changes #\n################\n\n\n# new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    ...\n\n\n# update feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    ...\n\n\n# disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    ...\n\n\n#############\n# Time Lock #\n#############\n\n\n@view\n@external\ndef actionTimeLock() -> uint256:\n    ...\n\n\n@view\n@external\ndef hasPendingAction(_actionId: uint256) -> bool:\n    ...\n\n\n@view\n@external\ndef getActionConfirmationBlock(_actionId: uint256) -> uint256:\n    ...\n\n\n@external\ndef setActionTimeLock(_numBlocks: uint256) -> bool:\n    ...\n\n\n@external\ndef setActionTimeLockAfterSetup(_numBlocks: uint256 = 0) -> bool:\n    ...\n\n\n########\n# Ripe #\n########\n\n\n@view\n@external\ndef isPaused() -> bool:\n    ...\n\n\n@external\ndef pause(_shouldPause: bool):\n    ...\n\n\n@external\ndef recoverFunds(_recipient: address, _asset: address):\n    ...\n\n@external\ndef recoverFundsMany(_recipient: address, _assets: DynArray[address, 20]):\n    ...",
            "sha256sum": "7530b4cb747dc9b6fab3207ac23a05050bf93bccdbbc65d018089f644ef06c77"
          },
          "contracts/priceSources/UndyVaultPrices.vy": {
            "content": "# Ripe Protocol License: https://github.com/ripe-foundation/ripe-protocol/blob/master/LICENSE.md\n# Ripe Foundation (C) 2025\n\n# @version 0.4.3\n\nimplements: PriceSource\n\nexports: gov.__interface__\nexports: addys.__interface__\nexports: priceData.__interface__\nexports: timeLock.__interface__\n\ninitializes: gov\ninitializes: addys\ninitializes: priceData[addys := addys]\ninitializes: timeLock[gov := gov]\n\nimport contracts.modules.LocalGov as gov\nimport contracts.modules.Addys as addys\nimport contracts.priceSources.modules.PriceSourceData as priceData\nimport contracts.modules.TimeLock as timeLock\n\nimport interfaces.PriceSource as PriceSource\nfrom ethereum.ercs import IERC20Detailed\nfrom ethereum.ercs import IERC4626\nfrom ethereum.ercs import IERC20\n\ninterface PriceDesk:\n    def getPrice(_asset: address, _shouldRaise: bool = False) -> uint256: view\n\ninterface UnderscoreVault:\n    def convertToAssets(_shareAmount: uint256) -> uint256: view\n\ninterface VaultRegistry:\n    def isEarnVault(_vaultAddr: address) -> bool: view\n\ninterface UndyRegistry:\n    def getAddr(_regId: uint256) -> address: view\n\ninterface MissionControl:\n    def underscoreRegistry() -> address: view\n\nstruct PriceConfig:\n    underlyingAsset: address\n    underlyingDecimals: uint256\n    vaultTokenDecimals: uint256\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n    lastSnapshot: PriceSnapshot\n    nextIndex: uint256\n\nstruct PriceSnapshot:\n    totalSupply: uint256\n    pricePerShare: uint256\n    lastUpdate: uint256\n\nstruct PendingPriceConfig:\n    actionId: uint256\n    config: PriceConfig\n\nevent NewPriceConfigPending:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent NewPriceConfigAdded:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nevent NewPriceConfigCancelled:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n\nevent PriceConfigUpdatePending:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent PriceConfigUpdated:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n    minSnapshotDelay: uint256\n    maxNumSnapshots: uint256\n    maxUpsideDeviation: uint256\n    staleTime: uint256\n\nevent PriceConfigUpdateCancelled:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n\nevent DisablePriceConfigPending:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n    confirmationBlock: uint256\n    actionId: uint256\n\nevent DisablePriceConfigConfirmed:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n\nevent DisablePriceConfigCancelled:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n\nevent PricePerShareSnapshotAdded:\n    asset: indexed(address)\n    underlyingAsset: indexed(address)\n    totalSupply: uint256\n    pricePerShare: uint256\n\n# data \npriceConfigs: public(HashMap[address, PriceConfig]) # asset -> config\nsnapShots: public(HashMap[address, HashMap[uint256, PriceSnapshot]]) # asset -> index -> snapshot\npendingPriceConfigs: public(HashMap[address, PendingPriceConfig]) # asset -> pending config\n\nHUNDRED_PERCENT: constant(uint256) = 100_00 # 100%\nUNDERSCORE_VAULT_REGISTRY_ID: constant(uint256) = 10\n\n\n@deploy\ndef __init__(\n    _ripeHq: address,\n    _tempGov: address,\n    _minPriceChangeTimeLock: uint256,\n    _maxPriceChangeTimeLock: uint256,\n):\n    gov.__init__(_ripeHq, _tempGov, 0, 0, 0)\n    addys.__init__(_ripeHq)\n    priceData.__init__(False)\n    timeLock.__init__(_minPriceChangeTimeLock, _maxPriceChangeTimeLock, 0, _maxPriceChangeTimeLock)\n\n\n###############\n# Core Prices #\n###############\n\n\n# get price\n\n\n@view\n@external\ndef getPrice(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> uint256:\n    config: PriceConfig = self.priceConfigs[_asset]\n    if config.underlyingAsset == empty(address):\n        return 0\n    return self._getPrice(_asset, config, _priceDesk)\n\n\n@view\n@external\ndef getPriceAndHasFeed(_asset: address, _staleTime: uint256 = 0, _priceDesk: address = empty(address)) -> (uint256, bool):\n    config: PriceConfig = self.priceConfigs[_asset]\n    if config.underlyingAsset == empty(address):\n        return 0, False\n    return self._getPrice(_asset, config, _priceDesk), True\n\n\n@view\n@internal\ndef _getPrice(\n    _asset: address,\n    _config: PriceConfig,\n    _priceDesk: address,\n) -> uint256:\n    # NOTE: not using Mission Control `_staleTime` in this contract.\n    # These vault tokens are different/unique. Each config has its own stale time.\n\n    priceDesk: address = _priceDesk\n    if priceDesk == empty(address):\n        priceDesk = addys._getPriceDeskAddr()\n\n    # get price\n    weightedPricePerShare: uint256 = self._getWeightedPrice(_asset, _config)\n    underlyingPrice: uint256 = staticcall PriceDesk(priceDesk).getPrice(_config.underlyingAsset, False)\n    return self._getUnderscoreVaultPrice(_asset, _config, weightedPricePerShare, underlyingPrice)\n\n\n# utilities\n\n\n@view\n@external\ndef hasPriceFeed(_asset: address) -> bool:\n    return self.priceConfigs[_asset].underlyingAsset != empty(address)\n\n\n@view\n@external\ndef hasPendingPriceFeedUpdate(_asset: address) -> bool:\n    return timeLock._hasPendingAction(self.pendingPriceConfigs[_asset].actionId)\n\n\n################\n# Add New Feed #\n################\n\n\n# initiate new feed\n\n\n@external\ndef addNewPriceFeed(\n    _asset: address,\n    _minSnapshotDelay: uint256 = 60 * 5, # 5 minutes\n    _maxNumSnapshots: uint256 = 20,\n    _maxUpsideDeviation: uint256 = 10_00, # 10%\n    _staleTime: uint256 = 60 * 60 * 24, # 1 day\n) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    p: PriceConfig = self._getPriceConfig(_asset, _minSnapshotDelay, _maxNumSnapshots, _maxUpsideDeviation, _staleTime)\n    assert self._isValidNewPriceConfig(_asset, p) # dev: invalid feed\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingPriceConfigs[_asset] = PendingPriceConfig(actionId=aid, config=p)\n    log NewPriceConfigPending(\n        asset=_asset,\n        underlyingAsset=p.underlyingAsset,\n        minSnapshotDelay=p.minSnapshotDelay,\n        maxNumSnapshots=p.maxNumSnapshots,\n        maxUpsideDeviation=p.maxUpsideDeviation,\n        staleTime=p.staleTime,\n        confirmationBlock=timeLock._getActionConfirmationBlock(aid),\n        actionId=aid,\n    )\n    return True\n\n\n# confirm new feed\n\n\n@external\ndef confirmNewPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: PendingPriceConfig = self.pendingPriceConfigs[_asset]\n    assert d.config.underlyingAsset != empty(address) # dev: no pending config\n    if not self._isValidNewPriceConfig(_asset, d.config):\n        self._cancelNewPendingPriceFeed(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # save new feed config\n    self.priceConfigs[_asset] = d.config\n    self.pendingPriceConfigs[_asset] = empty(PendingPriceConfig)\n    priceData._addPricedAsset(_asset)\n\n    # add snapshot\n    self._addPriceSnapshot(_asset, d.config)\n\n    log NewPriceConfigAdded(\n        asset=_asset,\n        underlyingAsset=d.config.underlyingAsset,\n        minSnapshotDelay=d.config.minSnapshotDelay,\n        maxNumSnapshots=d.config.maxNumSnapshots,\n        maxUpsideDeviation=d.config.maxUpsideDeviation,\n        staleTime=d.config.staleTime,\n    )\n    return True\n\n\n# cancel new feed\n\n\n@external\ndef cancelNewPendingPriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: PendingPriceConfig = self.pendingPriceConfigs[_asset]\n    self._cancelNewPendingPriceFeed(_asset, d.actionId)\n    log NewPriceConfigCancelled(\n        asset=_asset,\n        underlyingAsset=d.config.underlyingAsset,\n    )\n    return True\n\n\n@internal\ndef _cancelNewPendingPriceFeed(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingPriceConfigs[_asset] = empty(PendingPriceConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidNewFeed(\n    _asset: address,\n    _minSnapshotDelay: uint256,\n    _maxNumSnapshots: uint256,\n    _maxUpsideDeviation: uint256,\n    _staleTime: uint256,\n) -> bool:\n    config: PriceConfig = self._getPriceConfig(_asset, _minSnapshotDelay, _maxNumSnapshots, _maxUpsideDeviation, _staleTime)\n    return self._isValidNewPriceConfig(_asset, config)\n\n\n@view\n@internal\ndef _isValidNewPriceConfig(_asset: address, _config: PriceConfig) -> bool:\n    if priceData.indexOfAsset[_asset] != 0 or self.priceConfigs[_asset].underlyingAsset != empty(address): # use the `updatePriceConfig` function instead\n        return False\n    return self._isValidFeedConfig(_asset, _config)\n\n\n@view\n@internal\ndef _isValidFeedConfig(_asset: address, _config: PriceConfig) -> bool:\n    if empty(address) in [_asset, _config.underlyingAsset]:\n        return False\n\n    # verify the vault is an earn vault\n    underscore: address = staticcall MissionControl(addys._getMissionControlAddr()).underscoreRegistry()\n    if underscore == empty(address):\n        return False\n    vaultRegistry: address = staticcall UndyRegistry(underscore).getAddr(UNDERSCORE_VAULT_REGISTRY_ID)\n    if not staticcall VaultRegistry(vaultRegistry).isEarnVault(_asset):\n        return False\n\n    if _config.minSnapshotDelay > (60 * 60 * 24 * 7): # 1 week\n        return False\n    if _config.maxNumSnapshots == 0 or _config.maxNumSnapshots > 25:\n        return False\n    if _config.maxUpsideDeviation > HUNDRED_PERCENT:\n        return False\n    if 0 in [_config.underlyingDecimals, _config.vaultTokenDecimals]:\n        return False\n\n    # verify underlying asset has a price feed\n    if staticcall PriceDesk(addys._getPriceDeskAddr()).getPrice(_config.underlyingAsset, False) == 0:\n        return False\n\n    # verify the vault implements convertToAssets and returns a valid price\n    pricePerShare: uint256 = staticcall UnderscoreVault(_asset).convertToAssets(10 ** _config.vaultTokenDecimals)\n    return pricePerShare != 0\n\n\n# create price config\n\n\n@view\n@internal\ndef _getPriceConfig(\n    _asset: address,\n    _minSnapshotDelay: uint256,\n    _maxNumSnapshots: uint256,\n    _maxUpsideDeviation: uint256,\n    _staleTime: uint256,\n) -> PriceConfig:\n    underlyingAsset: address = staticcall IERC4626(_asset).asset()\n\n    underlyingDecimals: uint256 = 0\n    if underlyingAsset != empty(address):\n        underlyingDecimals = convert(staticcall IERC20Detailed(underlyingAsset).decimals(), uint256)\n\n    # vault token decimals\n    vaultTokenDecimals: uint256 = 0\n    if _asset != empty(address):\n        vaultTokenDecimals = convert(staticcall IERC20Detailed(_asset).decimals(), uint256)\n\n    return PriceConfig(\n        underlyingAsset=underlyingAsset,\n        underlyingDecimals=underlyingDecimals,\n        vaultTokenDecimals=vaultTokenDecimals,\n        minSnapshotDelay=_minSnapshotDelay,\n        maxNumSnapshots=_maxNumSnapshots,\n        maxUpsideDeviation=_maxUpsideDeviation,\n        staleTime=_staleTime,\n        lastSnapshot=empty(PriceSnapshot),\n        nextIndex=0,\n    )\n\n\n#################\n# Update Config #\n#################\n\n\n@external\ndef updatePriceConfig(\n    _asset: address,\n    _minSnapshotDelay: uint256 = 60 * 5, # 5 minutes\n    _maxNumSnapshots: uint256 = 20,\n    _maxUpsideDeviation: uint256 = 10_00, # 10%\n    _staleTime: uint256 = 60 * 60 * 24, # 1 day\n) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    p: PriceConfig = self.priceConfigs[_asset]\n    p.minSnapshotDelay = _minSnapshotDelay\n    p.maxNumSnapshots = _maxNumSnapshots\n    p.maxUpsideDeviation = _maxUpsideDeviation\n    p.staleTime = _staleTime\n    assert self._isValidUpdateConfig(_asset, p) # dev: invalid config\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingPriceConfigs[_asset] = PendingPriceConfig(actionId=aid, config=p)\n    log PriceConfigUpdatePending(\n        asset=_asset,\n        underlyingAsset=p.underlyingAsset,\n        minSnapshotDelay=p.minSnapshotDelay,\n        maxNumSnapshots=p.maxNumSnapshots,\n        maxUpsideDeviation=p.maxUpsideDeviation,\n        staleTime=p.staleTime,\n        confirmationBlock=timeLock._getActionConfirmationBlock(aid),\n        actionId=aid,\n    )\n    return True\n\n\n# confirm new feed\n\n\n@external\ndef confirmPriceFeedUpdate(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    d: PendingPriceConfig = self.pendingPriceConfigs[_asset]\n    assert d.config.underlyingAsset != empty(address) # dev: no pending config\n    if not self._isValidUpdateConfig(_asset, d.config):\n        self._cancelPriceFeedUpdate(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # save new feed config\n    self.priceConfigs[_asset] = d.config\n    self.pendingPriceConfigs[_asset] = empty(PendingPriceConfig)\n\n    # add snapshot\n    self._addPriceSnapshot(_asset, d.config)\n\n    log PriceConfigUpdated(\n        asset=_asset,\n        underlyingAsset=d.config.underlyingAsset,\n        minSnapshotDelay=d.config.minSnapshotDelay,\n        maxNumSnapshots=d.config.maxNumSnapshots,\n        maxUpsideDeviation=d.config.maxUpsideDeviation,\n        staleTime=d.config.staleTime,\n    )\n    return True\n\n\n# cancel new feed\n\n\n@external\ndef cancelPriceFeedUpdate(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    d: PendingPriceConfig = self.pendingPriceConfigs[_asset]\n    self._cancelPriceFeedUpdate(_asset, d.actionId)\n    log PriceConfigUpdateCancelled(\n        asset=_asset,\n        underlyingAsset=d.config.underlyingAsset,\n    )\n    return True\n\n\n@internal\ndef _cancelPriceFeedUpdate(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingPriceConfigs[_asset] = empty(PendingPriceConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidUpdateConfig(_asset: address, _maxNumSnapshots: uint256, _staleTime: uint256) -> bool:\n    p: PriceConfig = self.priceConfigs[_asset]\n    p.maxNumSnapshots = _maxNumSnapshots\n    p.staleTime = _staleTime\n    return self._isValidUpdateConfig(_asset, p)\n\n\n@view\n@internal\ndef _isValidUpdateConfig(_asset: address, _config: PriceConfig) -> bool:\n    if priceData.indexOfAsset[_asset] == 0 or _config.underlyingAsset == empty(address): # must add new feed first\n        return False\n    return self._isValidFeedConfig(_asset, _config)\n\n\n################\n# Disable Feed #\n################\n\n\n# initiate disable feed\n\n\n@external\ndef disablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validation\n    prevConfig: PriceConfig = self.priceConfigs[_asset]\n    assert self._isValidDisablePriceFeed(_asset, prevConfig.underlyingAsset) # dev: invalid asset\n\n    # set to pending state\n    aid: uint256 = timeLock._initiateAction()\n    self.pendingPriceConfigs[_asset] = PendingPriceConfig(actionId=aid, config=empty(PriceConfig))\n\n    log DisablePriceConfigPending(\n        asset=_asset,\n        underlyingAsset=prevConfig.underlyingAsset,\n        confirmationBlock=timeLock._getActionConfirmationBlock(aid),\n        actionId=aid,\n    )\n    return True\n\n\n# confirm disable feed\n\n\n@external\ndef confirmDisablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    # validate again\n    prevConfig: PriceConfig = self.priceConfigs[_asset]\n    d: PendingPriceConfig = self.pendingPriceConfigs[_asset]\n    assert d.actionId != 0 # dev: no pending disable feed\n    if not self._isValidDisablePriceFeed(_asset, prevConfig.underlyingAsset):\n        self._cancelDisablePriceFeed(_asset, d.actionId)\n        return False\n\n    # check time lock\n    assert timeLock._confirmAction(d.actionId) # dev: time lock not reached\n\n    # disable feed\n    self.priceConfigs[_asset] = empty(PriceConfig)\n    self.pendingPriceConfigs[_asset] = empty(PendingPriceConfig)\n    priceData._removePricedAsset(_asset)\n\n    log DisablePriceConfigConfirmed(\n        asset=_asset,\n        underlyingAsset=prevConfig.underlyingAsset,\n    )\n    return True\n\n\n# cancel disable feed\n\n\n@external\ndef cancelDisablePriceFeed(_asset: address) -> bool:\n    assert gov._canGovern(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n\n    self._cancelDisablePriceFeed(_asset, self.pendingPriceConfigs[_asset].actionId)\n    prevConfig: PriceConfig = self.priceConfigs[_asset]\n    log DisablePriceConfigCancelled(\n        asset=_asset,\n        underlyingAsset=prevConfig.underlyingAsset,\n    )\n    return True\n\n\n@internal\ndef _cancelDisablePriceFeed(_asset: address, _aid: uint256):\n    assert timeLock._cancelAction(_aid) # dev: cannot cancel action\n    self.pendingPriceConfigs[_asset] = empty(PendingPriceConfig)\n\n\n# validation\n\n\n@view\n@external\ndef isValidDisablePriceFeed(_asset: address) -> bool:\n    return self._isValidDisablePriceFeed(_asset, self.priceConfigs[_asset].underlyingAsset)\n\n\n@view\n@internal\ndef _isValidDisablePriceFeed(_asset: address, _underlyingAsset: address) -> bool:\n    if priceData.indexOfAsset[_asset] == 0:\n        return False\n    return _underlyingAsset != empty(address)\n\n\n###################\n# Price Snapshots #\n###################\n\n\n# get weighted price\n\n\n@view\n@external\ndef getWeightedPrice(_asset: address) -> uint256:\n    config: PriceConfig = self.priceConfigs[_asset]\n    return self._getWeightedPrice(_asset, config)\n\n\n@view\n@internal\ndef _getWeightedPrice(_asset: address, _config: PriceConfig) -> uint256:\n    if _config.underlyingAsset == empty(address) or _config.maxNumSnapshots == 0:\n        return 0\n\n    # calculate weighted average price using all valid snapshots\n    numerator: uint256 = 0\n    denominator: uint256 = 0\n    for i: uint256 in range(_config.maxNumSnapshots, bound=max_value(uint256)):\n\n        snapShot: PriceSnapshot = self.snapShots[_asset][i]\n        if snapShot.pricePerShare == 0 or snapShot.totalSupply == 0 or snapShot.lastUpdate == 0:\n            continue\n\n        # too stale, skip\n        if _config.staleTime != 0 and block.timestamp > snapShot.lastUpdate + _config.staleTime:\n            continue\n\n        numerator += (snapShot.totalSupply * snapShot.pricePerShare)\n        denominator += snapShot.totalSupply\n\n    # weighted price per share\n    weightedPricePerShare: uint256 = 0\n    if numerator != 0:\n        weightedPricePerShare = numerator // denominator\n    else:\n        weightedPricePerShare = _config.lastSnapshot.pricePerShare\n\n    return weightedPricePerShare\n\n\n# add price snapshot\n\n\n@external \ndef addPriceSnapshot(_asset: address) -> bool:\n    config: PriceConfig = self.priceConfigs[_asset]\n    if config.underlyingAsset == empty(address):\n        return False\n    assert addys._isValidRipeAddr(msg.sender) # dev: no perms\n    assert not priceData.isPaused # dev: contract paused\n    return self._addPriceSnapshot(_asset, config)\n\n\n@internal \ndef _addPriceSnapshot(_asset: address, _config: PriceConfig) -> bool:\n    config: PriceConfig = _config\n    if config.underlyingAsset == empty(address):\n        return False\n\n    # already have snapshot for this time\n    if config.lastSnapshot.lastUpdate == block.timestamp:\n        return False\n\n    # check if snapshot is too recent\n    if config.lastSnapshot.lastUpdate + config.minSnapshotDelay > block.timestamp:\n        return False\n\n    # create and store new snapshot\n    newSnapshot: PriceSnapshot = self._getLatestSnapshot(_asset, config)\n    config.lastSnapshot = newSnapshot\n    self.snapShots[_asset][config.nextIndex] = newSnapshot\n\n    # update index\n    config.nextIndex += 1\n    if config.nextIndex >= config.maxNumSnapshots:\n        config.nextIndex = 0\n\n    # save config data\n    self.priceConfigs[_asset] = config\n\n    log PricePerShareSnapshotAdded(\n        asset=_asset,\n        underlyingAsset=config.underlyingAsset,\n        totalSupply=newSnapshot.totalSupply,\n        pricePerShare=newSnapshot.pricePerShare,\n    )\n    return True\n\n\n# latest snapshot\n\n\n@view\n@external\ndef getLatestSnapshot(_asset: address) -> PriceSnapshot:\n    return self._getLatestSnapshot(_asset, self.priceConfigs[_asset])\n\n\n@view\n@internal\ndef _getLatestSnapshot(_asset: address, _config: PriceConfig) -> PriceSnapshot:\n    totalSupply: uint256 = staticcall IERC20(_asset).totalSupply() // (10 ** _config.vaultTokenDecimals)\n    pricePerShare: uint256 = self._getCurrentVaultPricePerShare(_asset, _config.vaultTokenDecimals)\n    pricePerShare = self._throttleUpside(pricePerShare, _config.lastSnapshot.pricePerShare, _config.maxUpsideDeviation)\n    return PriceSnapshot(\n        totalSupply=totalSupply,\n        pricePerShare=pricePerShare,\n        lastUpdate=block.timestamp,\n    )\n\n\n@view\n@internal\ndef _throttleUpside(_newValue: uint256, _prevValue: uint256, _maxUpside: uint256) -> uint256:\n    if _maxUpside == 0 or _prevValue == 0 or _newValue == 0:\n        return _newValue\n    maxPricePerShare: uint256 = _prevValue + (_prevValue * _maxUpside // HUNDRED_PERCENT)\n    return min(_newValue, maxPricePerShare)\n\n\n#####################\n# Underscore Vaults #\n#####################\n\n\n@view\n@internal\ndef _getUnderscoreVaultPrice(\n    _asset: address,\n    _config: PriceConfig,\n    _weightedPricePerShare: uint256,\n    _underlyingPrice: uint256,\n) -> uint256:\n    pricePerShare: uint256 = _weightedPricePerShare\n    if pricePerShare == 0 or _underlyingPrice == 0:\n        return 0\n\n    # allow downside if current price per share is lower\n    currentPricePerShare: uint256 = self._getCurrentVaultPricePerShare(_asset, _config.vaultTokenDecimals)\n    if currentPricePerShare != 0:\n        pricePerShare = min(pricePerShare, currentPricePerShare)\n\n    return _underlyingPrice * pricePerShare // (10 ** _config.underlyingDecimals)\n\n\n@view\n@internal\ndef _getCurrentVaultPricePerShare(_asset: address, _decimals: uint256) -> uint256:\n    return staticcall UnderscoreVault(_asset).convertToAssets(10 ** _decimals)\n",
            "sha256sum": "63b9ddaaa9798e6e55c6b3856913cc6614ee4c12376403728eb11acefc591b2f"
          }
        },
        "settings": {
          "outputSelection": {
            "contracts/priceSources/UndyVaultPrices.vy": [
              "*"
            ]
          },
          "search_paths": [
            "."
          ]
        },
        "compiler_version": "v0.4.3+commit.bff19ea2",
        "integrity": "acdee855723bd473a941fc77d5683a9067e3947f157bcb26097e6c924fb8b1b6"
      },
      "args": "0000000000000000000000006162df1b329e157479f8f1407e888260e0ec3d2b000000000000000000000000ef3cb7750ff6158d9f9b27651bbba2299096483b0000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000049d40",
      "file": "contracts/priceSources/UndyVaultPrices.vy"
    }
  }
}